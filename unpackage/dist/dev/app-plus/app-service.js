var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
if (typeof Promise !== "undefined" && !Promise.prototype.finally) {
  Promise.prototype.finally = function(callback) {
    const promise = this.constructor;
    return this.then(
      (value) => promise.resolve(callback()).then(() => value),
      (reason) => promise.resolve(callback()).then(() => {
        throw reason;
      })
    );
  };
}
;
if (typeof uni !== "undefined" && uni && uni.requireGlobal) {
  const global2 = uni.requireGlobal();
  ArrayBuffer = global2.ArrayBuffer;
  Int8Array = global2.Int8Array;
  Uint8Array = global2.Uint8Array;
  Uint8ClampedArray = global2.Uint8ClampedArray;
  Int16Array = global2.Int16Array;
  Uint16Array = global2.Uint16Array;
  Int32Array = global2.Int32Array;
  Uint32Array = global2.Uint32Array;
  Float32Array = global2.Float32Array;
  Float64Array = global2.Float64Array;
  BigInt64Array = global2.BigInt64Array;
  BigUint64Array = global2.BigUint64Array;
}
;
if (uni.restoreGlobal) {
  uni.restoreGlobal(Vue, weex, plus, setTimeout, clearTimeout, setInterval, clearInterval);
}
(function(vue) {
  "use strict";
  const _export_sfc = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
      target[key] = val;
    }
    return target;
  };
  const _sfc_main$5 = {};
  function _sfc_render$4(_ctx, _cache) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createCommentVNode("HEADER SEARCH"),
      vue.createCommentVNode('<van-search v-model="value" shape="round" class="vant-search" />'),
      vue.createElementVNode("view", { class: "header-search" }, [
        vue.createElementVNode("view", { class: "header-search-main" }, [
          vue.createElementVNode("img", {
            alt: "search-icon",
            class: "search-icon",
            referrerpolicy: "no-referrer",
            src: "https://lanhu-oss.lanhuapp.com/FigmaDDSSlicePNG7c679e922bb0e925338b25532a16b343.png"
          })
        ]),
        vue.createElementVNode("view", { class: "chat-icon" }, [
          vue.createElementVNode("img", {
            alt: "chat-icon",
            class: "label_2",
            referrerpolicy: "no-referrer",
            src: "https://lanhu-oss.lanhuapp.com/FigmaDDSSlicePNG829afc409ee34527795e3fd8cfe58e46.png"
          })
        ])
      ])
    ]);
  }
  const Header = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$4], ["__scopeId", "data-v-a3105577"], ["__file", "/Users/violet/Documents/HBuilderProjects/MENU Education/components/common/Header.vue"]]);
  const _sfc_main$4 = {};
  function _sfc_render$3(_ctx, _cache) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" });
  }
  const Recommend = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$3], ["__file", "/Users/violet/Documents/HBuilderProjects/MENU Education/pages/index/recommend/recommend.vue"]]);
  const _sfc_main$3 = {};
  function _sfc_render$2(_ctx, _cache) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" });
  }
  const Free = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$2], ["__file", "/Users/violet/Documents/HBuilderProjects/MENU Education/pages/index/free/Free.vue"]]);
  const _sfc_main$2 = {};
  function _sfc_render$1(_ctx, _cache) {
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" });
  }
  const Practice = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$1], ["__file", "/Users/violet/Documents/HBuilderProjects/MENU Education/pages/index/practice/Practice.vue"]]);
  const _sfc_main$1 = /* @__PURE__ */ vue.defineComponent({
    __name: "index",
    setup(__props, { expose: __expose }) {
      __expose();
      const __returned__ = { Header, Recommend, Free, Practice };
      Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
      return __returned__;
    }
  });
  function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_n_tab_pane = vue.resolveComponent("n-tab-pane");
    const _component_n_tabs = vue.resolveComponent("n-tabs");
    return vue.openBlock(), vue.createElementBlock("view", { class: "content" }, [
      vue.createVNode($setup["Header"]),
      vue.createCommentVNode("TAB"),
      vue.createElementVNode("view", { class: "tab" }, [
        vue.createVNode(_component_n_tabs, {
          type: "segment",
          animated: ""
        }, {
          default: vue.withCtx(() => [
            vue.createVNode(_component_n_tab_pane, {
              class: "single-tab",
              name: "chap1",
              tab: "Recommend"
            }, {
              default: vue.withCtx(() => [
                vue.createTextVNode(" Recommend "),
                vue.createVNode($setup["Recommend"])
              ]),
              _: 1
              /* STABLE */
            }),
            vue.createVNode(_component_n_tab_pane, {
              class: "single-tab",
              name: "chap2",
              tab: "Free"
            }, {
              default: vue.withCtx(() => [
                vue.createTextVNode(" Free "),
                vue.createVNode($setup["Free"])
              ]),
              _: 1
              /* STABLE */
            }),
            vue.createVNode(_component_n_tab_pane, {
              class: "single-tab",
              name: "chap3",
              tab: "Practice"
            }, {
              default: vue.withCtx(() => [
                vue.createTextVNode(" Practice "),
                vue.createVNode($setup["Practice"])
              ]),
              _: 1
              /* STABLE */
            })
          ]),
          _: 1
          /* STABLE */
        })
      ])
    ]);
  }
  const PagesIndexIndex = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render], ["__file", "/Users/violet/Documents/HBuilderProjects/MENU Education/pages/index/index.vue"]]);
  __definePage("pages/index/index", PagesIndexIndex);
  function formatAppLog(type, filename, ...args) {
    if (uni.__log__) {
      uni.__log__(type, filename, ...args);
    } else {
      console[type].apply(console, [...args, filename]);
    }
  }
  const _sfc_main = {
    onLaunch: function() {
      formatAppLog("log", "at App.vue:4", "App Launch");
    },
    onShow: function() {
      formatAppLog("log", "at App.vue:7", "App Show");
    },
    onHide: function() {
      formatAppLog("log", "at App.vue:10", "App Hide");
    }
  };
  const App = /* @__PURE__ */ _export_sfc(_sfc_main, [["__file", "/Users/violet/Documents/HBuilderProjects/MENU Education/App.vue"]]);
  let onceCbs = [];
  const paramsMap = /* @__PURE__ */ new WeakMap();
  function flushOnceCallbacks() {
    onceCbs.forEach((cb) => cb(...paramsMap.get(cb)));
    onceCbs = [];
  }
  function beforeNextFrameOnce(cb, ...params) {
    paramsMap.set(cb, params);
    if (onceCbs.includes(cb))
      return;
    onceCbs.push(cb) === 1 && requestAnimationFrame(flushOnceCallbacks);
  }
  function getParentNode$1(node) {
    if (node.nodeType === 9) {
      return null;
    }
    return node.parentNode;
  }
  function getScrollParent$1(node) {
    if (node === null)
      return null;
    const parentNode = getParentNode$1(node);
    if (parentNode === null) {
      return null;
    }
    if (parentNode.nodeType === 9) {
      return document.documentElement;
    }
    if (parentNode.nodeType === 1) {
      const { overflow, overflowX, overflowY } = getComputedStyle(parentNode);
      if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
        return parentNode;
      }
    }
    return getScrollParent$1(parentNode);
  }
  function unwrapElement(target) {
    if (typeof target === "string")
      return document.querySelector(target);
    if (typeof target === "function")
      return target();
    return target;
  }
  function happensIn(e, dataSetPropName) {
    let { target } = e;
    while (target) {
      if (target.dataset) {
        if (target.dataset[dataSetPropName] !== void 0)
          return true;
      }
      target = target.parentElement;
    }
    return false;
  }
  function getPreciseEventTarget(event) {
    return event.composedPath()[0] || null;
  }
  function parseResponsiveProp(reponsiveProp) {
    if (typeof reponsiveProp === "number") {
      return {
        "": reponsiveProp.toString()
      };
    }
    const params = {};
    reponsiveProp.split(/ +/).forEach((pairLiteral) => {
      if (pairLiteral === "")
        return;
      const [prefix2, value] = pairLiteral.split(":");
      if (value === void 0) {
        params[""] = prefix2;
      } else {
        params[prefix2] = value;
      }
    });
    return params;
  }
  function parseResponsivePropValue(reponsiveProp, activeKeyOrSize) {
    var _a;
    if (reponsiveProp === void 0 || reponsiveProp === null)
      return void 0;
    const classObj = parseResponsiveProp(reponsiveProp);
    if (activeKeyOrSize === void 0)
      return classObj[""];
    if (typeof activeKeyOrSize === "string") {
      return (_a = classObj[activeKeyOrSize]) !== null && _a !== void 0 ? _a : classObj[""];
    } else if (Array.isArray(activeKeyOrSize)) {
      for (let i = activeKeyOrSize.length - 1; i >= 0; --i) {
        const key = activeKeyOrSize[i];
        if (key in classObj)
          return classObj[key];
      }
      return classObj[""];
    } else {
      let activeValue = void 0;
      let activeKey = -1;
      Object.keys(classObj).forEach((key) => {
        const keyAsNum = Number(key);
        if (!Number.isNaN(keyAsNum) && activeKeyOrSize >= keyAsNum && keyAsNum >= activeKey) {
          activeKey = keyAsNum;
          activeValue = classObj[key];
        }
      });
      return activeValue;
    }
  }
  function depx(value) {
    if (typeof value === "string") {
      if (value.endsWith("px")) {
        return Number(value.slice(0, value.length - 2));
      }
      return Number(value);
    }
    return value;
  }
  function pxfy(value) {
    if (value === void 0 || value === null)
      return void 0;
    if (typeof value === "number")
      return `${value}px`;
    if (value.endsWith("px"))
      return value;
    return `${value}px`;
  }
  function getMargin(value, position) {
    const parts = value.trim().split(/\s+/g);
    const margin = {
      top: parts[0]
    };
    switch (parts.length) {
      case 1:
        margin.right = parts[0];
        margin.bottom = parts[0];
        margin.left = parts[0];
        break;
      case 2:
        margin.right = parts[1];
        margin.left = parts[1];
        margin.bottom = parts[0];
        break;
      case 3:
        margin.right = parts[1];
        margin.bottom = parts[2];
        margin.left = parts[1];
        break;
      case 4:
        margin.right = parts[1];
        margin.bottom = parts[2];
        margin.left = parts[3];
        break;
      default:
        throw new Error("[seemly/getMargin]:" + value + " is not a valid value.");
    }
    if (position === void 0)
      return margin;
    return margin[position];
  }
  function getGap(value, orient) {
    const [rowGap, colGap] = value.split(" ");
    if (!orient)
      return {
        row: rowGap,
        col: colGap || rowGap
      };
    return orient === "row" ? rowGap : colGap;
  }
  const colors = {
    black: "#000",
    silver: "#C0C0C0",
    gray: "#808080",
    white: "#FFF",
    maroon: "#800000",
    red: "#F00",
    purple: "#800080",
    fuchsia: "#F0F",
    green: "#008000",
    lime: "#0F0",
    olive: "#808000",
    yellow: "#FF0",
    navy: "#000080",
    blue: "#00F",
    teal: "#008080",
    aqua: "#0FF",
    transparent: "#0000"
  };
  function hsl2hsv(h, s, l) {
    s /= 100;
    l /= 100;
    const v = s * Math.min(l, 1 - l) + l;
    return [h, v ? (2 - 2 * l / v) * 100 : 0, v * 100];
  }
  function hsv2hsl(h, s, v) {
    s /= 100;
    v /= 100;
    const l = v - v * s / 2;
    const m = Math.min(l, 1 - l);
    return [h, m ? (v - l) / m * 100 : 0, l * 100];
  }
  function hsv2rgb(h, s, v) {
    s /= 100;
    v /= 100;
    let f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
    return [f(5) * 255, f(3) * 255, f(1) * 255];
  }
  function rgb2hsv(r, g, b) {
    r /= 255;
    g /= 255;
    b /= 255;
    let v = Math.max(r, g, b), c2 = v - Math.min(r, g, b);
    let h = c2 && (v == r ? (g - b) / c2 : v == g ? 2 + (b - r) / c2 : 4 + (r - g) / c2);
    return [60 * (h < 0 ? h + 6 : h), v && c2 / v * 100, v * 100];
  }
  function rgb2hsl(r, g, b) {
    r /= 255;
    g /= 255;
    b /= 255;
    let v = Math.max(r, g, b), c2 = v - Math.min(r, g, b), f = 1 - Math.abs(v + v - c2 - 1);
    let h = c2 && (v == r ? (g - b) / c2 : v == g ? 2 + (b - r) / c2 : 4 + (r - g) / c2);
    return [60 * (h < 0 ? h + 6 : h), f ? c2 / f * 100 : 0, (v + v - c2) * 50];
  }
  function hsl2rgb(h, s, l) {
    s /= 100;
    l /= 100;
    let a2 = s * Math.min(l, 1 - l);
    let f = (n, k = (n + h / 30) % 12) => l - a2 * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return [f(0) * 255, f(8) * 255, f(4) * 255];
  }
  const prefix$1 = "^\\s*";
  const suffix = "\\s*$";
  const percent = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))%\\s*";
  const float = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))\\s*";
  const hex = "([0-9A-Fa-f])";
  const dhex = "([0-9A-Fa-f]{2})";
  const hslRegex = new RegExp(`${prefix$1}hsl\\s*\\(${float},${percent},${percent}\\)${suffix}`);
  const hsvRegex = new RegExp(`${prefix$1}hsv\\s*\\(${float},${percent},${percent}\\)${suffix}`);
  const hslaRegex = new RegExp(`${prefix$1}hsla\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
  const hsvaRegex = new RegExp(`${prefix$1}hsva\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
  const rgbRegex = new RegExp(`${prefix$1}rgb\\s*\\(${float},${float},${float}\\)${suffix}`);
  const rgbaRegex = new RegExp(`${prefix$1}rgba\\s*\\(${float},${float},${float},${float}\\)${suffix}`);
  const sHexRegex = new RegExp(`${prefix$1}#${hex}${hex}${hex}${suffix}`);
  const hexRegex = new RegExp(`${prefix$1}#${dhex}${dhex}${dhex}${suffix}`);
  const sHexaRegex = new RegExp(`${prefix$1}#${hex}${hex}${hex}${hex}${suffix}`);
  const hexaRegex = new RegExp(`${prefix$1}#${dhex}${dhex}${dhex}${dhex}${suffix}`);
  function parseHex(value) {
    return parseInt(value, 16);
  }
  function hsla(color) {
    try {
      let i;
      if (i = hslaRegex.exec(color)) {
        return [
          roundDeg(i[1]),
          roundPercent(i[5]),
          roundPercent(i[9]),
          roundAlpha(i[13])
        ];
      } else if (i = hslRegex.exec(color)) {
        return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];
      }
      throw new Error(`[seemly/hsla]: Invalid color value ${color}.`);
    } catch (e) {
      throw e;
    }
  }
  function hsva(color) {
    try {
      let i;
      if (i = hsvaRegex.exec(color)) {
        return [
          roundDeg(i[1]),
          roundPercent(i[5]),
          roundPercent(i[9]),
          roundAlpha(i[13])
        ];
      } else if (i = hsvRegex.exec(color)) {
        return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];
      }
      throw new Error(`[seemly/hsva]: Invalid color value ${color}.`);
    } catch (e) {
      throw e;
    }
  }
  function rgba(color) {
    try {
      let i;
      if (i = hexRegex.exec(color)) {
        return [parseHex(i[1]), parseHex(i[2]), parseHex(i[3]), 1];
      } else if (i = rgbRegex.exec(color)) {
        return [roundChannel(i[1]), roundChannel(i[5]), roundChannel(i[9]), 1];
      } else if (i = rgbaRegex.exec(color)) {
        return [
          roundChannel(i[1]),
          roundChannel(i[5]),
          roundChannel(i[9]),
          roundAlpha(i[13])
        ];
      } else if (i = sHexRegex.exec(color)) {
        return [
          parseHex(i[1] + i[1]),
          parseHex(i[2] + i[2]),
          parseHex(i[3] + i[3]),
          1
        ];
      } else if (i = hexaRegex.exec(color)) {
        return [
          parseHex(i[1]),
          parseHex(i[2]),
          parseHex(i[3]),
          roundAlpha(parseHex(i[4]) / 255)
        ];
      } else if (i = sHexaRegex.exec(color)) {
        return [
          parseHex(i[1] + i[1]),
          parseHex(i[2] + i[2]),
          parseHex(i[3] + i[3]),
          roundAlpha(parseHex(i[4] + i[4]) / 255)
        ];
      } else if (color in colors) {
        return rgba(colors[color]);
      }
      throw new Error(`[seemly/rgba]: Invalid color value ${color}.`);
    } catch (e) {
      throw e;
    }
  }
  function normalizeAlpha$1(alphaValue) {
    return alphaValue > 1 ? 1 : alphaValue < 0 ? 0 : alphaValue;
  }
  function stringifyRgb(r, g, b) {
    return `rgb(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)})`;
  }
  function stringifyRgba(r, g, b, a2) {
    return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${normalizeAlpha$1(a2)})`;
  }
  function compositeChannel(v1, a1, v2, a2, a3) {
    return roundChannel((v1 * a1 * (1 - a2) + v2 * a2) / a3);
  }
  function composite(background, overlay2) {
    if (!Array.isArray(background))
      background = rgba(background);
    if (!Array.isArray(overlay2))
      overlay2 = rgba(overlay2);
    const a1 = background[3];
    const a2 = overlay2[3];
    const alpha = roundAlpha(a1 + a2 - a1 * a2);
    return stringifyRgba(compositeChannel(background[0], a1, overlay2[0], a2, alpha), compositeChannel(background[1], a1, overlay2[1], a2, alpha), compositeChannel(background[2], a1, overlay2[2], a2, alpha), alpha);
  }
  function changeColor(base2, options) {
    const [r, g, b, a2 = 1] = Array.isArray(base2) ? base2 : rgba(base2);
    if (options.alpha) {
      return stringifyRgba(r, g, b, options.alpha);
    }
    return stringifyRgba(r, g, b, a2);
  }
  function scaleColor(base2, options) {
    const [r, g, b, a2 = 1] = Array.isArray(base2) ? base2 : rgba(base2);
    const { lightness = 1, alpha = 1 } = options;
    return toRgbaString([r * lightness, g * lightness, b * lightness, a2 * alpha]);
  }
  function roundAlpha(value) {
    const v = Math.round(Number(value) * 100) / 100;
    if (v > 1)
      return 1;
    if (v < 0)
      return 0;
    return v;
  }
  function roundDeg(value) {
    const v = Math.round(Number(value));
    if (v >= 360)
      return 0;
    if (v < 0)
      return 0;
    return v;
  }
  function roundChannel(value) {
    const v = Math.round(Number(value));
    if (v > 255)
      return 255;
    if (v < 0)
      return 0;
    return v;
  }
  function roundPercent(value) {
    const v = Math.round(Number(value));
    if (v > 100)
      return 100;
    if (v < 0)
      return 0;
    return v;
  }
  function toRgbString(base2) {
    const [r, g, b] = Array.isArray(base2) ? base2 : rgba(base2);
    return stringifyRgb(r, g, b);
  }
  function toRgbaString(base2) {
    const [r, g, b] = base2;
    if (3 in base2) {
      return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${roundAlpha(base2[3])})`;
    }
    return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, 1)`;
  }
  function toHsvString(base2) {
    return `hsv(${roundDeg(base2[0])}, ${roundPercent(base2[1])}%, ${roundPercent(base2[2])}%)`;
  }
  function toHsvaString(base2) {
    const [h, s, v] = base2;
    if (3 in base2) {
      return `hsva(${roundDeg(h)}, ${roundPercent(s)}%, ${roundPercent(v)}%, ${roundAlpha(base2[3])})`;
    }
    return `hsva(${roundDeg(h)}, ${roundPercent(s)}%, ${roundPercent(v)}%, 1)`;
  }
  function toHslString(base2) {
    return `hsl(${roundDeg(base2[0])}, ${roundPercent(base2[1])}%, ${roundPercent(base2[2])}%)`;
  }
  function toHslaString(base2) {
    const [h, s, l] = base2;
    if (3 in base2) {
      return `hsla(${roundDeg(h)}, ${roundPercent(s)}%, ${roundPercent(l)}%, ${roundAlpha(base2[3])})`;
    }
    return `hsla(${roundDeg(h)}, ${roundPercent(s)}%, ${roundPercent(l)}%, 1)`;
  }
  function toHexaString(base2) {
    if (typeof base2 === "string") {
      let i;
      if (i = hexRegex.exec(base2)) {
        return `${i[0]}FF`;
      } else if (i = hexaRegex.exec(base2)) {
        return i[0];
      } else if (i = sHexRegex.exec(base2)) {
        return `#${i[1]}${i[1]}${i[2]}${i[2]}${i[3]}${i[3]}FF`;
      } else if (i = sHexaRegex.exec(base2)) {
        return `#${i[1]}${i[1]}${i[2]}${i[2]}${i[3]}${i[3]}${i[4]}${i[4]}`;
      }
      throw new Error(`[seemly/toHexString]: Invalid hex value ${base2}.`);
    }
    const hex2 = `#${base2.slice(0, 3).map((unit) => roundChannel(unit).toString(16).toUpperCase().padStart(2, "0")).join("")}`;
    const a2 = base2.length === 3 ? "FF" : roundChannel(base2[3] * 255).toString(16).padStart(2, "0").toUpperCase();
    return hex2 + a2;
  }
  function toHexString(base2) {
    if (typeof base2 === "string") {
      let i;
      if (i = hexRegex.exec(base2)) {
        return i[0];
      } else if (i = hexaRegex.exec(base2)) {
        return i[0].slice(0, 7);
      } else if (i = sHexRegex.exec(base2) || sHexaRegex.exec(base2)) {
        return `#${i[1]}${i[1]}${i[2]}${i[2]}${i[3]}${i[3]}`;
      }
      throw new Error(`[seemly/toHexString]: Invalid hex value ${base2}.`);
    }
    return `#${base2.slice(0, 3).map((unit) => roundChannel(unit).toString(16).toUpperCase().padStart(2, "0")).join("")}`;
  }
  function createId(length = 8) {
    return Math.random().toString(16).slice(2, 2 + length);
  }
  function repeat(count, v) {
    const ret = [];
    for (let i = 0; i < count; ++i) {
      ret.push(v);
    }
    return ret;
  }
  function indexMap(count, createValue) {
    const ret = [];
    if (!createValue) {
      for (let i = 0; i < count; ++i) {
        ret.push(i);
      }
      return ret;
    }
    for (let i = 0; i < count; ++i) {
      ret.push(createValue(i));
    }
    return ret;
  }
  function getSlot$1(instance, slotName = "default", fallback = []) {
    const slots = instance.$slots;
    const slot = slots[slotName];
    if (slot === void 0)
      return fallback;
    return slot();
  }
  function getVNodeChildren(vNode, slotName = "default", fallback = []) {
    const {
      children
    } = vNode;
    if (children !== null && typeof children === "object" && !Array.isArray(children)) {
      const slot = children[slotName];
      if (typeof slot === "function") {
        return slot();
      }
    }
    return fallback;
  }
  function keep(object, keys2 = [], rest) {
    const keepedObject = {};
    keys2.forEach((key) => {
      keepedObject[key] = object[key];
    });
    return Object.assign(keepedObject, rest);
  }
  function omit(object, keys2 = [], rest) {
    const omitedObject = {};
    const originalKeys = Object.getOwnPropertyNames(object);
    originalKeys.forEach((originalKey) => {
      if (!keys2.includes(originalKey)) {
        omitedObject[originalKey] = object[originalKey];
      }
    });
    return Object.assign(omitedObject, rest);
  }
  function flatten$3(vNodes, filterCommentNode = true, result = []) {
    vNodes.forEach((vNode) => {
      if (vNode === null)
        return;
      if (typeof vNode !== "object") {
        if (typeof vNode === "string" || typeof vNode === "number") {
          result.push(vue.createTextVNode(String(vNode)));
        }
        return;
      }
      if (Array.isArray(vNode)) {
        flatten$3(vNode, filterCommentNode, result);
        return;
      }
      if (vNode.type === vue.Fragment) {
        if (vNode.children === null)
          return;
        if (Array.isArray(vNode.children)) {
          flatten$3(vNode.children, filterCommentNode, result);
        }
      } else {
        if (vNode.type === vue.Comment && filterCommentNode)
          return;
        result.push(vNode);
      }
    });
    return result;
  }
  function call(funcs, ...args) {
    if (Array.isArray(funcs)) {
      funcs.forEach((func) => call(func, ...args));
    } else {
      return funcs(...args);
    }
  }
  function keysOf(obj) {
    return Object.keys(obj);
  }
  function render$1(r, ...args) {
    if (typeof r === "function") {
      return r(...args);
    } else if (typeof r === "string") {
      return vue.createTextVNode(r);
    } else if (typeof r === "number") {
      return vue.createTextVNode(String(r));
    } else {
      return null;
    }
  }
  const warnedMessages = /* @__PURE__ */ new Set();
  function warnOnce(location, message2) {
    const mergedMessage = `[naive/${location}]: ${message2}`;
    if (warnedMessages.has(mergedMessage))
      return;
    warnedMessages.add(mergedMessage);
    console.error(mergedMessage);
  }
  function warn$2(location, message2) {
    console.error(`[naive/${location}]: ${message2}`);
  }
  function error(location, message2, error2) {
    console.error(`[naive/${location}]: ${message2}`, error2);
  }
  function throwError(location, message2) {
    throw new Error(`[naive/${location}]: ${message2}`);
  }
  function smallerSize(size2) {
    switch (size2) {
      case "tiny":
        return "mini";
      case "small":
        return "tiny";
      case "medium":
        return "small";
      case "large":
        return "medium";
      case "huge":
        return "large";
    }
    throw new Error(`${size2} has no smaller size.`);
  }
  function getTitleAttribute(value) {
    switch (typeof value) {
      case "string":
        return value || void 0;
      case "number":
        return String(value);
      default:
        return void 0;
    }
  }
  function getFirstSlotVNode(slots, slotName = "default", props = void 0) {
    const slot = slots[slotName];
    if (!slot) {
      warn$2("getFirstSlotVNode", `slot[${slotName}] is empty`);
      return null;
    }
    const slotContent = flatten$3(slot(props));
    if (slotContent.length === 1) {
      return slotContent[0];
    } else {
      warn$2("getFirstSlotVNode", `slot[${slotName}] should have exactly one child`);
      return null;
    }
  }
  function createDataKey(key) {
    return typeof key === "string" ? `s-${key}` : `n-${key}`;
  }
  function createRefSetter(ref) {
    return (inst) => {
      if (inst) {
        ref.value = inst.$el;
      } else {
        ref.value = null;
      }
    };
  }
  function createInjectionKey(key) {
    return key;
  }
  function ensureValidVNode(vnodes) {
    return vnodes.some((child) => {
      if (!vue.isVNode(child)) {
        return true;
      }
      if (child.type === vue.Comment) {
        return false;
      }
      if (child.type === vue.Fragment && !ensureValidVNode(child.children)) {
        return false;
      }
      return true;
    }) ? vnodes : null;
  }
  function resolveSlot(slot, fallback) {
    return slot && ensureValidVNode(slot()) || fallback();
  }
  function resolveSlotWithProps(slot, props, fallback) {
    return slot && ensureValidVNode(slot(props)) || fallback(props);
  }
  function resolveWrappedSlot(slot, wrapper) {
    const children = slot && ensureValidVNode(slot());
    return wrapper(children || null);
  }
  function resolveWrappedSlotWithProps(slot, props, wrapper) {
    const children = slot && ensureValidVNode(slot(props));
    return wrapper(children || null);
  }
  function isSlotEmpty(slot) {
    return !(slot && ensureValidVNode(slot()));
  }
  function mergeEventHandlers(handlers) {
    const filteredHandlers = handlers.filter((handler) => handler !== void 0);
    if (filteredHandlers.length === 0)
      return void 0;
    if (filteredHandlers.length === 1)
      return filteredHandlers[0];
    return (e) => {
      handlers.forEach((handler) => {
        if (handler) {
          handler(e);
        }
      });
    };
  }
  function isNodeVShowFalse(vNode) {
    var _a;
    const showDir = (_a = vNode.dirs) === null || _a === void 0 ? void 0 : _a.find(({
      dir
    }) => dir === vue.vShow);
    return !!(showDir && showDir.value === false);
  }
  const Wrapper = vue.defineComponent({
    render() {
      var _a, _b;
      return (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
  });
  const pureNumberRegex = /^(\d|\.)+$/;
  const numberRegex = /(\d|\.)+/;
  function formatLength(length, {
    c: c2 = 1,
    offset = 0,
    attachPx = true
  } = {}) {
    if (typeof length === "number") {
      const result = (length + offset) * c2;
      if (result === 0)
        return "0";
      return `${result}px`;
    } else if (typeof length === "string") {
      if (pureNumberRegex.test(length)) {
        const result = (Number(length) + offset) * c2;
        if (attachPx) {
          if (result === 0)
            return "0";
          return `${result}px`;
        } else {
          return `${result}`;
        }
      } else {
        const result = numberRegex.exec(length);
        if (!result)
          return length;
        return length.replace(numberRegex, String((Number(result[0]) + offset) * c2));
      }
    }
    return length;
  }
  function color2Class(color) {
    return color.replace(/#|\(|\)|,|\s|\./g, "_");
  }
  function rtlInset(inset) {
    const {
      left,
      right,
      top,
      bottom
    } = getMargin(inset);
    return `${top} ${right} ${bottom} ${left}`;
  }
  function ampCount(selector) {
    let cnt = 0;
    for (let i = 0; i < selector.length; ++i) {
      if (selector[i] === "&")
        ++cnt;
    }
    return cnt;
  }
  const separatorRegex = /\s*,(?![^(]*\))\s*/g;
  const extraSpaceRegex = /\s+/g;
  function resolveSelectorWithAmp(amp, selector) {
    const nextAmp = [];
    selector.split(separatorRegex).forEach((partialSelector) => {
      let round2 = ampCount(partialSelector);
      if (!round2) {
        amp.forEach((partialAmp) => {
          nextAmp.push(
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            (partialAmp && partialAmp + " ") + partialSelector
          );
        });
        return;
      } else if (round2 === 1) {
        amp.forEach((partialAmp) => {
          nextAmp.push(partialSelector.replace("&", partialAmp));
        });
        return;
      }
      let partialNextAmp = [
        partialSelector
      ];
      while (round2--) {
        const nextPartialNextAmp = [];
        partialNextAmp.forEach((selectorItr) => {
          amp.forEach((partialAmp) => {
            nextPartialNextAmp.push(selectorItr.replace("&", partialAmp));
          });
        });
        partialNextAmp = nextPartialNextAmp;
      }
      partialNextAmp.forEach((part) => nextAmp.push(part));
    });
    return nextAmp;
  }
  function resolveSelector(amp, selector) {
    const nextAmp = [];
    selector.split(separatorRegex).forEach((partialSelector) => {
      amp.forEach((partialAmp) => {
        nextAmp.push((partialAmp && partialAmp + " ") + partialSelector);
      });
    });
    return nextAmp;
  }
  function parseSelectorPath(selectorPaths) {
    let amp = [""];
    selectorPaths.forEach((selector) => {
      selector = selector && selector.trim();
      if (
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        !selector
      ) {
        return;
      }
      if (selector.includes("&")) {
        amp = resolveSelectorWithAmp(amp, selector);
      } else {
        amp = resolveSelector(amp, selector);
      }
    });
    return amp.join(", ").replace(extraSpaceRegex, " ");
  }
  function removeElement(el) {
    if (!el)
      return;
    const parentElement = el.parentElement;
    if (parentElement)
      parentElement.removeChild(el);
  }
  function queryElement(id, parent) {
    return (parent !== null && parent !== void 0 ? parent : document.head).querySelector(`style[cssr-id="${id}"]`);
  }
  function createElement(id) {
    const el = document.createElement("style");
    el.setAttribute("cssr-id", id);
    return el;
  }
  function isMediaOrSupports(selector) {
    if (!selector)
      return false;
    return /^\s*@(s|m)/.test(selector);
  }
  const kebabRegex = /[A-Z]/g;
  function kebabCase$1(pattern) {
    return pattern.replace(kebabRegex, (match2) => "-" + match2.toLowerCase());
  }
  function unwrapProperty(prop, indent = "  ") {
    if (typeof prop === "object" && prop !== null) {
      return " {\n" + Object.entries(prop).map((v) => {
        return indent + `  ${kebabCase$1(v[0])}: ${v[1]};`;
      }).join("\n") + "\n" + indent + "}";
    }
    return `: ${prop};`;
  }
  function unwrapProperties(props, instance, params) {
    if (typeof props === "function") {
      return props({
        context: instance.context,
        props: params
      });
    }
    return props;
  }
  function createStyle(selector, props, instance, params) {
    if (!props)
      return "";
    const unwrappedProps = unwrapProperties(props, instance, params);
    if (!unwrappedProps)
      return "";
    if (typeof unwrappedProps === "string") {
      return `${selector} {
${unwrappedProps}
}`;
    }
    const propertyNames = Object.keys(unwrappedProps);
    if (propertyNames.length === 0) {
      if (instance.config.keepEmptyBlock)
        return selector + " {\n}";
      return "";
    }
    const statements = selector ? [
      selector + " {"
    ] : [];
    propertyNames.forEach((propertyName) => {
      const property2 = unwrappedProps[propertyName];
      if (propertyName === "raw") {
        statements.push("\n" + property2 + "\n");
        return;
      }
      propertyName = kebabCase$1(propertyName);
      if (property2 !== null && property2 !== void 0) {
        statements.push(`  ${propertyName}${unwrapProperty(property2)}`);
      }
    });
    if (selector) {
      statements.push("}");
    }
    return statements.join("\n");
  }
  function loopCNodeListWithCallback(children, options, callback) {
    if (!children)
      return;
    children.forEach((child) => {
      if (Array.isArray(child)) {
        loopCNodeListWithCallback(child, options, callback);
      } else if (typeof child === "function") {
        const grandChildren = child(options);
        if (Array.isArray(grandChildren)) {
          loopCNodeListWithCallback(grandChildren, options, callback);
        } else if (grandChildren) {
          callback(grandChildren);
        }
      } else if (child) {
        callback(child);
      }
    });
  }
  function traverseCNode(node, selectorPaths, styles2, instance, params) {
    const $ = node.$;
    let blockSelector = "";
    if (!$ || typeof $ === "string") {
      if (isMediaOrSupports($)) {
        blockSelector = $;
      } else {
        selectorPaths.push($);
      }
    } else if (typeof $ === "function") {
      const selector2 = $({
        context: instance.context,
        props: params
      });
      if (isMediaOrSupports(selector2)) {
        blockSelector = selector2;
      } else {
        selectorPaths.push(selector2);
      }
    } else {
      if ($.before)
        $.before(instance.context);
      if (!$.$ || typeof $.$ === "string") {
        if (isMediaOrSupports($.$)) {
          blockSelector = $.$;
        } else {
          selectorPaths.push($.$);
        }
      } else if ($.$) {
        const selector2 = $.$({
          context: instance.context,
          props: params
        });
        if (isMediaOrSupports(selector2)) {
          blockSelector = selector2;
        } else {
          selectorPaths.push(selector2);
        }
      }
    }
    const selector = parseSelectorPath(selectorPaths);
    const style2 = createStyle(selector, node.props, instance, params);
    if (blockSelector) {
      styles2.push(`${blockSelector} {`);
    } else if (style2.length) {
      styles2.push(style2);
    }
    if (node.children) {
      loopCNodeListWithCallback(node.children, {
        context: instance.context,
        props: params
      }, (childNode) => {
        if (typeof childNode === "string") {
          const style3 = createStyle(selector, { raw: childNode }, instance, params);
          styles2.push(style3);
        } else {
          traverseCNode(childNode, selectorPaths, styles2, instance, params);
        }
      });
    }
    selectorPaths.pop();
    if (blockSelector) {
      styles2.push("}");
    }
    if ($ && $.after)
      $.after(instance.context);
  }
  function render(node, instance, props) {
    const styles2 = [];
    traverseCNode(node, [], styles2, instance, props);
    return styles2.join("\n\n");
  }
  function murmur2(str) {
    var h = 0;
    var k, i = 0, len2 = str.length;
    for (; len2 >= 4; ++i, len2 -= 4) {
      k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
      k = /* Math.imul(k, m): */
      (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
      k ^= /* k >>> r: */
      k >>> 24;
      h = /* Math.imul(k, m): */
      (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    }
    switch (len2) {
      case 3:
        h ^= (str.charCodeAt(i + 2) & 255) << 16;
      case 2:
        h ^= (str.charCodeAt(i + 1) & 255) << 8;
      case 1:
        h ^= str.charCodeAt(i) & 255;
        h = /* Math.imul(h, m): */
        (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    }
    h ^= h >>> 13;
    h = /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    return ((h ^ h >>> 15) >>> 0).toString(36);
  }
  if (typeof window !== "undefined") {
    window.__cssrContext = {};
  }
  function unmount(instance, node, id, parent) {
    const { els } = node;
    if (id === void 0) {
      els.forEach(removeElement);
      node.els = [];
    } else {
      const target = queryElement(id, parent);
      if (target && els.includes(target)) {
        removeElement(target);
        node.els = els.filter((el) => el !== target);
      }
    }
  }
  function addElementToList(els, target) {
    els.push(target);
  }
  function mount(instance, node, id, props, head, force, anchorMetaName, parent, ssrAdapter2) {
    let style2;
    if (id === void 0) {
      style2 = node.render(props);
      id = murmur2(style2);
    }
    if (ssrAdapter2) {
      ssrAdapter2.adapter(id, style2 !== null && style2 !== void 0 ? style2 : node.render(props));
      return;
    }
    if (parent === void 0) {
      parent = document.head;
    }
    const queriedTarget = queryElement(id, parent);
    if (queriedTarget !== null && !force) {
      return queriedTarget;
    }
    const target = queriedTarget !== null && queriedTarget !== void 0 ? queriedTarget : createElement(id);
    if (style2 === void 0)
      style2 = node.render(props);
    target.textContent = style2;
    if (queriedTarget !== null)
      return queriedTarget;
    if (anchorMetaName) {
      const anchorMetaEl = parent.querySelector(`meta[name="${anchorMetaName}"]`);
      if (anchorMetaEl) {
        parent.insertBefore(target, anchorMetaEl);
        addElementToList(node.els, target);
        return target;
      }
    }
    if (head) {
      parent.insertBefore(target, parent.querySelector("style, link"));
    } else {
      parent.appendChild(target);
    }
    addElementToList(node.els, target);
    return target;
  }
  function wrappedRender(props) {
    return render(this, this.instance, props);
  }
  function wrappedMount(options = {}) {
    const { id, ssr, props, head = false, force = false, anchorMetaName, parent } = options;
    const targetElement = mount(this.instance, this, id, props, head, force, anchorMetaName, parent, ssr);
    return targetElement;
  }
  function wrappedUnmount(options = {}) {
    const { id, parent } = options;
    unmount(this.instance, this, id, parent);
  }
  const createCNode = function(instance, $, props, children) {
    return {
      instance,
      $,
      props,
      children,
      els: [],
      render: wrappedRender,
      mount: wrappedMount,
      unmount: wrappedUnmount
    };
  };
  const c$2 = function(instance, $, props, children) {
    if (Array.isArray($)) {
      return createCNode(instance, { $: null }, null, $);
    } else if (Array.isArray(props)) {
      return createCNode(instance, $, null, props);
    } else if (Array.isArray(children)) {
      return createCNode(instance, $, props, children);
    } else {
      return createCNode(instance, $, props, null);
    }
  };
  function CssRender(config = {}) {
    const cssr2 = {
      c: (...args) => c$2(cssr2, ...args),
      use: (plugin2, ...args) => plugin2.install(cssr2, ...args),
      find: queryElement,
      context: {},
      config
    };
    return cssr2;
  }
  function exists(id, ssr) {
    if (id === void 0)
      return false;
    if (ssr) {
      const { context: { ids } } = ssr;
      return ids.has(id);
    }
    return queryElement(id) !== null;
  }
  function plugin$1(options) {
    let _bPrefix = ".";
    let _ePrefix = "__";
    let _mPrefix = "--";
    let c2;
    if (options) {
      let t = options.blockPrefix;
      if (t) {
        _bPrefix = t;
      }
      t = options.elementPrefix;
      if (t) {
        _ePrefix = t;
      }
      t = options.modifierPrefix;
      if (t) {
        _mPrefix = t;
      }
    }
    const _plugin = {
      install(instance) {
        c2 = instance.c;
        const ctx2 = instance.context;
        ctx2.bem = {};
        ctx2.bem.b = null;
        ctx2.bem.els = null;
      }
    };
    function b(arg) {
      let memorizedB;
      let memorizedE;
      return {
        before(ctx2) {
          memorizedB = ctx2.bem.b;
          memorizedE = ctx2.bem.els;
          ctx2.bem.els = null;
        },
        after(ctx2) {
          ctx2.bem.b = memorizedB;
          ctx2.bem.els = memorizedE;
        },
        $({ context, props }) {
          arg = typeof arg === "string" ? arg : arg({ context, props });
          context.bem.b = arg;
          return `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}`;
        }
      };
    }
    function e(arg) {
      let memorizedE;
      return {
        before(ctx2) {
          memorizedE = ctx2.bem.els;
        },
        after(ctx2) {
          ctx2.bem.els = memorizedE;
        },
        $({ context, props }) {
          arg = typeof arg === "string" ? arg : arg({ context, props });
          context.bem.els = arg.split(",").map((v) => v.trim());
          return context.bem.els.map((el) => `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${_ePrefix}${el}`).join(", ");
        }
      };
    }
    function m(arg) {
      return {
        $({ context, props }) {
          arg = typeof arg === "string" ? arg : arg({ context, props });
          const modifiers = arg.split(",").map((v) => v.trim());
          function elementToSelector(el) {
            return modifiers.map((modifier) => `&${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${el !== void 0 ? `${_ePrefix}${el}` : ""}${_mPrefix}${modifier}`).join(", ");
          }
          const els = context.bem.els;
          if (els !== null) {
            if (els.length >= 2) {
              throw Error(`[css-render/plugin-bem]: m(${arg}) is invalid, using modifier inside multiple elements is not allowed`);
            }
            return elementToSelector(els[0]);
          } else {
            return elementToSelector();
          }
        }
      };
    }
    function notM(arg) {
      return {
        $({ context, props }) {
          arg = typeof arg === "string" ? arg : arg({ context, props });
          const els = context.bem.els;
          if (els !== null && els.length >= 2) {
            throw Error(`[css-render/plugin-bem]: notM(${arg}) is invalid, using modifier inside multiple elements is not allowed`);
          }
          return `&:not(${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${els !== null && els.length > 0 ? `${_ePrefix}${els[0]}` : ""}${_mPrefix}${arg})`;
        }
      };
    }
    const cB2 = (...args) => c2(b(args[0]), args[1], args[2]);
    const cE2 = (...args) => c2(e(args[0]), args[1], args[2]);
    const cM2 = (...args) => c2(m(args[0]), args[1], args[2]);
    const cNotM2 = (...args) => c2(notM(args[0]), args[1], args[2]);
    Object.assign(_plugin, {
      cB: cB2,
      cE: cE2,
      cM: cM2,
      cNotM: cNotM2
    });
    return _plugin;
  }
  const namespace = "n";
  const prefix = `.${namespace}-`;
  const elementPrefix = "__";
  const modifierPrefix = "--";
  const cssr = CssRender();
  const plugin = plugin$1({
    blockPrefix: prefix,
    elementPrefix,
    modifierPrefix
  });
  cssr.use(plugin);
  const {
    c: c$1,
    find
  } = cssr;
  const {
    cB,
    cE,
    cM,
    cNotM
  } = plugin;
  function insideModal(style2) {
    return c$1(({
      props: {
        bPrefix
      }
    }) => `${bPrefix || prefix}modal, ${bPrefix || prefix}drawer`, [style2]);
  }
  function insidePopover(style2) {
    return c$1(({
      props: {
        bPrefix
      }
    }) => `${bPrefix || prefix}popover`, [style2]);
  }
  function asModal(style2) {
    return c$1(({
      props: {
        bPrefix
      }
    }) => `&${bPrefix || prefix}modal`, style2);
  }
  const cCB = (...args) => {
    return c$1(">", [cB(...args)]);
  };
  function createKey(prefix2, suffix2) {
    return prefix2 + (suffix2 === "default" ? "" : suffix2.replace(/^[a-z]/, (startChar) => startChar.toUpperCase()));
  }
  let _isJsdom;
  function isJsdom() {
    if (_isJsdom === void 0) {
      _isJsdom = navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom");
    }
    return _isJsdom;
  }
  const isBrowser$2 = typeof document !== "undefined" && typeof window !== "undefined";
  const eventSet = /* @__PURE__ */ new WeakSet();
  function markEventEffectPerformed(event) {
    eventSet.add(event);
  }
  function eventEffectNotPerformed(event) {
    return !eventSet.has(event);
  }
  function useInjectionInstanceCollection(injectionName, collectionKey, registerKeyRef) {
    var _a;
    const injection = vue.inject(injectionName, null);
    if (injection === null)
      return;
    const vm = (_a = vue.getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy;
    vue.watch(registerKeyRef, registerInstance);
    registerInstance(registerKeyRef.value);
    vue.onBeforeUnmount(() => {
      registerInstance(void 0, registerKeyRef.value);
    });
    function registerInstance(key, oldKey) {
      if (!injection)
        return;
      const collection = injection[collectionKey];
      if (oldKey !== void 0)
        removeInstance(collection, oldKey);
      if (key !== void 0)
        addInstance(collection, key);
    }
    function removeInstance(collection, key) {
      if (!collection[key])
        collection[key] = [];
      collection[key].splice(collection[key].findIndex((instance) => instance === vm), 1);
    }
    function addInstance(collection, key) {
      if (!collection[key])
        collection[key] = [];
      if (!~collection[key].findIndex((instance) => instance === vm)) {
        collection[key].push(vm);
      }
    }
  }
  function useInjectionCollection(injectionName, collectionKey, valueRef) {
    const injection = vue.inject(injectionName, null);
    if (injection === null)
      return;
    if (!(collectionKey in injection)) {
      injection[collectionKey] = [];
    }
    injection[collectionKey].push(valueRef.value);
    vue.watch(valueRef, (value, prevValue) => {
      const collectionArray = injection[collectionKey];
      const index = collectionArray.findIndex((collectionValue) => collectionValue === prevValue);
      if (~index)
        collectionArray.splice(index, 1);
      collectionArray.push(value);
    });
    vue.onBeforeUnmount(() => {
      const collectionArray = injection[collectionKey];
      const index = collectionArray.findIndex((collectionValue) => collectionValue === valueRef.value);
      if (~index)
        collectionArray.splice(index, 1);
    });
  }
  function useInjectionElementCollection(injectionName, collectionKey, getElement) {
    const injection = vue.inject(injectionName, null);
    if (injection === null)
      return;
    if (!(collectionKey in injection)) {
      injection[collectionKey] = [];
    }
    vue.onMounted(() => {
      const el = getElement();
      if (!el)
        return;
      injection[collectionKey].push(el);
    });
    vue.onBeforeUnmount(() => {
      const collectionArray = injection[collectionKey];
      const element = getElement();
      const index = collectionArray.findIndex((collectionElement) => collectionElement === element);
      if (~index)
        collectionArray.splice(index, 1);
    });
  }
  function useDeferredTrue(valueRef, delay, shouldDelayRef) {
    if (!delay)
      return valueRef;
    const delayedRef = vue.ref(valueRef.value);
    let timerId = null;
    vue.watch(valueRef, (value) => {
      if (timerId !== null)
        window.clearTimeout(timerId);
      if (value === true) {
        if (shouldDelayRef && !shouldDelayRef.value) {
          delayedRef.value = true;
        } else {
          timerId = window.setTimeout(() => {
            delayedRef.value = true;
          }, delay);
        }
      } else {
        delayedRef.value = false;
      }
    });
    return delayedRef;
  }
  function useFalseUntilTruthy(originalRef) {
    const currentRef = vue.ref(!!originalRef.value);
    if (currentRef.value)
      return vue.readonly(currentRef);
    const stop = vue.watch(originalRef, (value) => {
      if (value) {
        currentRef.value = true;
        stop();
      }
    });
    return vue.readonly(currentRef);
  }
  function useMemo(getterOrOptions) {
    const computedValueRef = vue.computed(getterOrOptions);
    const valueRef = vue.ref(computedValueRef.value);
    vue.watch(computedValueRef, (value) => {
      valueRef.value = value;
    });
    if (typeof getterOrOptions === "function") {
      return valueRef;
    } else {
      return {
        __v_isRef: true,
        get value() {
          return valueRef.value;
        },
        set value(v) {
          getterOrOptions.set(v);
        }
      };
    }
  }
  function hasInstance() {
    return vue.getCurrentInstance() !== null;
  }
  const isBrowser$1 = typeof window !== "undefined";
  let fontsReady;
  let isFontReady;
  const init = () => {
    var _a, _b;
    fontsReady = isBrowser$1 ? (_b = (_a = document) === null || _a === void 0 ? void 0 : _a.fonts) === null || _b === void 0 ? void 0 : _b.ready : void 0;
    isFontReady = false;
    if (fontsReady !== void 0) {
      void fontsReady.then(() => {
        isFontReady = true;
      });
    } else {
      isFontReady = true;
    }
  };
  init();
  function onFontsReady(cb) {
    if (isFontReady)
      return;
    let deactivated = false;
    vue.onMounted(() => {
      if (!isFontReady) {
        fontsReady === null || fontsReady === void 0 ? void 0 : fontsReady.then(() => {
          if (deactivated)
            return;
          cb();
        });
      }
    });
    vue.onBeforeUnmount(() => {
      deactivated = true;
    });
  }
  function getEventTarget(e) {
    const path = e.composedPath();
    return path[0];
  }
  const traps = {
    mousemoveoutside: /* @__PURE__ */ new WeakMap(),
    clickoutside: /* @__PURE__ */ new WeakMap()
  };
  function createTrapHandler(name, el, originalHandler) {
    if (name === "mousemoveoutside") {
      const moveHandler = (e) => {
        if (el.contains(getEventTarget(e)))
          return;
        originalHandler(e);
      };
      return {
        mousemove: moveHandler,
        touchstart: moveHandler
      };
    } else if (name === "clickoutside") {
      let mouseDownOutside = false;
      const downHandler = (e) => {
        mouseDownOutside = !el.contains(getEventTarget(e));
      };
      const upHanlder = (e) => {
        if (!mouseDownOutside)
          return;
        if (el.contains(getEventTarget(e)))
          return;
        originalHandler(e);
      };
      return {
        mousedown: downHandler,
        mouseup: upHanlder,
        touchstart: downHandler,
        touchend: upHanlder
      };
    }
    console.error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      `[evtd/create-trap-handler]: name \`${name}\` is invalid. This could be a bug of evtd.`
    );
    return {};
  }
  function ensureTrapHandlers(name, el, handler) {
    const handlers = traps[name];
    let elHandlers = handlers.get(el);
    if (elHandlers === void 0) {
      handlers.set(el, elHandlers = /* @__PURE__ */ new WeakMap());
    }
    let trapHandler = elHandlers.get(handler);
    if (trapHandler === void 0) {
      elHandlers.set(handler, trapHandler = createTrapHandler(name, el, handler));
    }
    return trapHandler;
  }
  function trapOn(name, el, handler, options) {
    if (name === "mousemoveoutside" || name === "clickoutside") {
      const trapHandlers = ensureTrapHandlers(name, el, handler);
      Object.keys(trapHandlers).forEach((key) => {
        on(key, document, trapHandlers[key], options);
      });
      return true;
    }
    return false;
  }
  function trapOff(name, el, handler, options) {
    if (name === "mousemoveoutside" || name === "clickoutside") {
      const trapHandlers = ensureTrapHandlers(name, el, handler);
      Object.keys(trapHandlers).forEach((key) => {
        off(key, document, trapHandlers[key], options);
      });
      return true;
    }
    return false;
  }
  function createDelegate() {
    if (typeof window === "undefined") {
      return {
        on: () => {
        },
        off: () => {
        }
      };
    }
    const propagationStopped = /* @__PURE__ */ new WeakMap();
    const immediatePropagationStopped = /* @__PURE__ */ new WeakMap();
    function trackPropagation() {
      propagationStopped.set(this, true);
    }
    function trackImmediate() {
      propagationStopped.set(this, true);
      immediatePropagationStopped.set(this, true);
    }
    function spy(event, propName, fn) {
      const source = event[propName];
      event[propName] = function() {
        fn.apply(event, arguments);
        return source.apply(event, arguments);
      };
      return event;
    }
    function unspy(event, propName) {
      event[propName] = Event.prototype[propName];
    }
    const currentTargets = /* @__PURE__ */ new WeakMap();
    const currentTargetDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, "currentTarget");
    function getCurrentTarget() {
      var _a;
      return (_a = currentTargets.get(this)) !== null && _a !== void 0 ? _a : null;
    }
    function defineCurrentTarget(event, getter) {
      if (currentTargetDescriptor === void 0)
        return;
      Object.defineProperty(event, "currentTarget", {
        configurable: true,
        enumerable: true,
        get: getter !== null && getter !== void 0 ? getter : currentTargetDescriptor.get
      });
    }
    const phaseToTypeToElToHandlers = {
      bubble: {},
      capture: {}
    };
    const typeToWindowEventHandlers = {};
    function createUnifiedHandler() {
      const delegeteHandler = function(e) {
        const { type, eventPhase, bubbles } = e;
        const target = getEventTarget(e);
        if (eventPhase === 2)
          return;
        const phase = eventPhase === 1 ? "capture" : "bubble";
        let cursor = target;
        const path = [];
        while (true) {
          if (cursor === null)
            cursor = window;
          path.push(cursor);
          if (cursor === window) {
            break;
          }
          cursor = cursor.parentNode || null;
        }
        const captureElToHandlers = phaseToTypeToElToHandlers.capture[type];
        const bubbleElToHandlers = phaseToTypeToElToHandlers.bubble[type];
        spy(e, "stopPropagation", trackPropagation);
        spy(e, "stopImmediatePropagation", trackImmediate);
        defineCurrentTarget(e, getCurrentTarget);
        if (phase === "capture") {
          if (captureElToHandlers === void 0)
            return;
          for (let i = path.length - 1; i >= 0; --i) {
            if (propagationStopped.has(e))
              break;
            const target2 = path[i];
            const handlers = captureElToHandlers.get(target2);
            if (handlers !== void 0) {
              currentTargets.set(e, target2);
              for (const handler of handlers) {
                if (immediatePropagationStopped.has(e))
                  break;
                handler(e);
              }
            }
            if (i === 0 && !bubbles && bubbleElToHandlers !== void 0) {
              const bubbleHandlers = bubbleElToHandlers.get(target2);
              if (bubbleHandlers !== void 0) {
                for (const handler of bubbleHandlers) {
                  if (immediatePropagationStopped.has(e))
                    break;
                  handler(e);
                }
              }
            }
          }
        } else if (phase === "bubble") {
          if (bubbleElToHandlers === void 0)
            return;
          for (let i = 0; i < path.length; ++i) {
            if (propagationStopped.has(e))
              break;
            const target2 = path[i];
            const handlers = bubbleElToHandlers.get(target2);
            if (handlers !== void 0) {
              currentTargets.set(e, target2);
              for (const handler of handlers) {
                if (immediatePropagationStopped.has(e))
                  break;
                handler(e);
              }
            }
          }
        }
        unspy(e, "stopPropagation");
        unspy(e, "stopImmediatePropagation");
        defineCurrentTarget(e);
      };
      delegeteHandler.displayName = "evtdUnifiedHandler";
      return delegeteHandler;
    }
    function createUnifiedWindowEventHandler() {
      const delegateHandler = function(e) {
        const { type, eventPhase } = e;
        if (eventPhase !== 2)
          return;
        const handlers = typeToWindowEventHandlers[type];
        if (handlers === void 0)
          return;
        handlers.forEach((handler) => handler(e));
      };
      delegateHandler.displayName = "evtdUnifiedWindowEventHandler";
      return delegateHandler;
    }
    const unifiedHandler = createUnifiedHandler();
    const unfiendWindowEventHandler = createUnifiedWindowEventHandler();
    function ensureElToHandlers(phase, type) {
      const phaseHandlers = phaseToTypeToElToHandlers[phase];
      if (phaseHandlers[type] === void 0) {
        phaseHandlers[type] = /* @__PURE__ */ new Map();
        window.addEventListener(type, unifiedHandler, phase === "capture");
      }
      return phaseHandlers[type];
    }
    function ensureWindowEventHandlers(type) {
      const windowEventHandlers = typeToWindowEventHandlers[type];
      if (windowEventHandlers === void 0) {
        typeToWindowEventHandlers[type] = /* @__PURE__ */ new Set();
        window.addEventListener(type, unfiendWindowEventHandler);
      }
      return typeToWindowEventHandlers[type];
    }
    function ensureHandlers(elToHandlers, el) {
      let elHandlers = elToHandlers.get(el);
      if (elHandlers === void 0) {
        elToHandlers.set(el, elHandlers = /* @__PURE__ */ new Set());
      }
      return elHandlers;
    }
    function handlerExist(el, phase, type, handler) {
      const elToHandlers = phaseToTypeToElToHandlers[phase][type];
      if (elToHandlers !== void 0) {
        const handlers = elToHandlers.get(el);
        if (handlers !== void 0) {
          if (handlers.has(handler))
            return true;
        }
      }
      return false;
    }
    function windowEventHandlerExist(type, handler) {
      const handlers = typeToWindowEventHandlers[type];
      if (handlers !== void 0) {
        if (handlers.has(handler)) {
          return true;
        }
      }
      return false;
    }
    function on2(type, el, handler, options) {
      let mergedHandler;
      if (typeof options === "object" && options.once === true) {
        mergedHandler = (e) => {
          off2(type, el, mergedHandler, options);
          handler(e);
        };
      } else {
        mergedHandler = handler;
      }
      const trapped = trapOn(type, el, mergedHandler, options);
      if (trapped)
        return;
      const phase = options === true || typeof options === "object" && options.capture === true ? "capture" : "bubble";
      const elToHandlers = ensureElToHandlers(phase, type);
      const handlers = ensureHandlers(elToHandlers, el);
      if (!handlers.has(mergedHandler))
        handlers.add(mergedHandler);
      if (el === window) {
        const windowEventHandlers = ensureWindowEventHandlers(type);
        if (!windowEventHandlers.has(mergedHandler)) {
          windowEventHandlers.add(mergedHandler);
        }
      }
    }
    function off2(type, el, handler, options) {
      const trapped = trapOff(type, el, handler, options);
      if (trapped)
        return;
      const capture = options === true || typeof options === "object" && options.capture === true;
      const phase = capture ? "capture" : "bubble";
      const elToHandlers = ensureElToHandlers(phase, type);
      const handlers = ensureHandlers(elToHandlers, el);
      if (el === window) {
        const mirrorPhase = capture ? "bubble" : "capture";
        if (!handlerExist(el, mirrorPhase, type, handler) && windowEventHandlerExist(type, handler)) {
          const windowEventHandlers = typeToWindowEventHandlers[type];
          windowEventHandlers.delete(handler);
          if (windowEventHandlers.size === 0) {
            window.removeEventListener(type, unfiendWindowEventHandler);
            typeToWindowEventHandlers[type] = void 0;
          }
        }
      }
      if (handlers.has(handler))
        handlers.delete(handler);
      if (handlers.size === 0) {
        elToHandlers.delete(el);
      }
      if (elToHandlers.size === 0) {
        window.removeEventListener(type, unifiedHandler, phase === "capture");
        phaseToTypeToElToHandlers[phase][type] = void 0;
      }
    }
    return {
      on: on2,
      off: off2
    };
  }
  const { on, off } = createDelegate();
  const mousePositionRef = vue.ref(null);
  function clickHandler(e) {
    if (e.clientX > 0 || e.clientY > 0) {
      mousePositionRef.value = {
        x: e.clientX,
        y: e.clientY
      };
    } else {
      const { target } = e;
      if (target instanceof Element) {
        const { left, top, width, height } = target.getBoundingClientRect();
        if (left > 0 || top > 0) {
          mousePositionRef.value = {
            x: left + width / 2,
            y: top + height / 2
          };
        } else {
          mousePositionRef.value = { x: 0, y: 0 };
        }
      } else {
        mousePositionRef.value = null;
      }
    }
  }
  let usedCount$1 = 0;
  let managable$1 = true;
  function useClickPosition() {
    if (!isBrowser$1)
      return vue.readonly(vue.ref(null));
    if (usedCount$1 === 0)
      on("click", document, clickHandler, true);
    const setup2 = () => {
      usedCount$1 += 1;
    };
    if (managable$1 && (managable$1 = hasInstance())) {
      vue.onBeforeMount(setup2);
      vue.onBeforeUnmount(() => {
        usedCount$1 -= 1;
        if (usedCount$1 === 0)
          off("click", document, clickHandler, true);
      });
    } else {
      setup2();
    }
    return vue.readonly(mousePositionRef);
  }
  const clickedTimeRef = vue.ref(void 0);
  let usedCount = 0;
  function handleClick() {
    clickedTimeRef.value = Date.now();
  }
  let managable = true;
  function useClicked(timeout) {
    if (!isBrowser$1)
      return vue.readonly(vue.ref(false));
    const clickedRef = vue.ref(false);
    let timerId = null;
    function clearTimer() {
      if (timerId !== null)
        window.clearTimeout(timerId);
    }
    function clickedHandler() {
      clearTimer();
      clickedRef.value = true;
      timerId = window.setTimeout(() => {
        clickedRef.value = false;
      }, timeout);
    }
    if (usedCount === 0) {
      on("click", window, handleClick, true);
    }
    const setup2 = () => {
      usedCount += 1;
      on("click", window, clickedHandler, true);
    };
    if (managable && (managable = hasInstance())) {
      vue.onBeforeMount(setup2);
      vue.onBeforeUnmount(() => {
        usedCount -= 1;
        if (usedCount === 0) {
          off("click", window, handleClick, true);
        }
        off("click", window, clickedHandler, true);
        clearTimer();
      });
    } else {
      setup2();
    }
    return vue.readonly(clickedRef);
  }
  function useMergedState(controlledStateRef, uncontrolledStateRef) {
    vue.watch(controlledStateRef, (value) => {
      if (value !== void 0) {
        uncontrolledStateRef.value = value;
      }
    });
    return vue.computed(() => {
      if (controlledStateRef.value === void 0) {
        return uncontrolledStateRef.value;
      }
      return controlledStateRef.value;
    });
  }
  function isMounted() {
    const isMounted2 = vue.ref(false);
    vue.onMounted(() => {
      isMounted2.value = true;
    });
    return vue.readonly(isMounted2);
  }
  function useCompitable(reactive, keys2) {
    return vue.computed(() => {
      for (const key of keys2) {
        if (reactive[key] !== void 0)
          return reactive[key];
      }
      return reactive[keys2[keys2.length - 1]];
    });
  }
  const isIos = (typeof window === "undefined" ? false : /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1) && // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
  !window.MSStream;
  function useIsIos() {
    return isIos;
  }
  const defaultBreakpointOptions = {
    // mobile
    // 0 ~ 640 doesn't mean it should display well in all the range,
    // but means you should treat it like a mobile phone.)
    xs: 0,
    s: 640,
    m: 1024,
    l: 1280,
    xl: 1536,
    "2xl": 1920
    // normal desktop display
  };
  function createMediaQuery(screenWidth) {
    return `(min-width: ${screenWidth}px)`;
  }
  const mqlMap = {};
  function useBreakpoints(screens = defaultBreakpointOptions) {
    if (!isBrowser$1)
      return vue.computed(() => []);
    if (typeof window.matchMedia !== "function")
      return vue.computed(() => []);
    const breakpointStatusRef = vue.ref({});
    const breakpoints = Object.keys(screens);
    const updateBreakpoints = (e, breakpointName) => {
      if (e.matches)
        breakpointStatusRef.value[breakpointName] = true;
      else
        breakpointStatusRef.value[breakpointName] = false;
    };
    breakpoints.forEach((key) => {
      const breakpointValue = screens[key];
      let mql;
      let cbs;
      if (mqlMap[breakpointValue] === void 0) {
        mql = window.matchMedia(createMediaQuery(breakpointValue));
        if (mql.addEventListener) {
          mql.addEventListener("change", (e) => {
            cbs.forEach((cb) => {
              cb(e, key);
            });
          });
        } else if (mql.addListener) {
          mql.addListener((e) => {
            cbs.forEach((cb) => {
              cb(e, key);
            });
          });
        }
        cbs = /* @__PURE__ */ new Set();
        mqlMap[breakpointValue] = {
          mql,
          cbs
        };
      } else {
        mql = mqlMap[breakpointValue].mql;
        cbs = mqlMap[breakpointValue].cbs;
      }
      cbs.add(updateBreakpoints);
      if (mql.matches) {
        cbs.forEach((cb) => {
          cb(mql, key);
        });
      }
    });
    vue.onBeforeUnmount(() => {
      breakpoints.forEach((breakpoint) => {
        const { cbs } = mqlMap[screens[breakpoint]];
        if (cbs.has(updateBreakpoints)) {
          cbs.delete(updateBreakpoints);
        }
      });
    });
    return vue.computed(() => {
      const { value } = breakpointStatusRef;
      return breakpoints.filter((key) => value[key]);
    });
  }
  function useKeyboard$1(options = {}, enabledRef) {
    const state = vue.reactive({
      ctrl: false,
      command: false,
      win: false,
      shift: false,
      tab: false
    });
    const { keydown, keyup } = options;
    const keydownHandler = (e) => {
      switch (e.key) {
        case "Control":
          state.ctrl = true;
          break;
        case "Meta":
          state.command = true;
          state.win = true;
          break;
        case "Shift":
          state.shift = true;
          break;
        case "Tab":
          state.tab = true;
          break;
      }
      if (keydown !== void 0) {
        Object.keys(keydown).forEach((key) => {
          if (key !== e.key)
            return;
          const handler = keydown[key];
          if (typeof handler === "function") {
            handler(e);
          } else {
            const { stop = false, prevent = false } = handler;
            if (stop)
              e.stopPropagation();
            if (prevent)
              e.preventDefault();
            handler.handler(e);
          }
        });
      }
    };
    const keyupHandler = (e) => {
      switch (e.key) {
        case "Control":
          state.ctrl = false;
          break;
        case "Meta":
          state.command = false;
          state.win = false;
          break;
        case "Shift":
          state.shift = false;
          break;
        case "Tab":
          state.tab = false;
          break;
      }
      if (keyup !== void 0) {
        Object.keys(keyup).forEach((key) => {
          if (key !== e.key)
            return;
          const handler = keyup[key];
          if (typeof handler === "function") {
            handler(e);
          } else {
            const { stop = false, prevent = false } = handler;
            if (stop)
              e.stopPropagation();
            if (prevent)
              e.preventDefault();
            handler.handler(e);
          }
        });
      }
    };
    const setup2 = () => {
      if (enabledRef === void 0 || enabledRef.value) {
        on("keydown", document, keydownHandler);
        on("keyup", document, keyupHandler);
      }
      if (enabledRef !== void 0) {
        vue.watch(enabledRef, (value) => {
          if (value) {
            on("keydown", document, keydownHandler);
            on("keyup", document, keyupHandler);
          } else {
            off("keydown", document, keydownHandler);
            off("keyup", document, keyupHandler);
          }
        });
      }
    };
    if (hasInstance()) {
      vue.onBeforeMount(setup2);
      vue.onBeforeUnmount(() => {
        if (enabledRef === void 0 || enabledRef.value) {
          off("keydown", document, keydownHandler);
          off("keyup", document, keyupHandler);
        }
      });
    } else {
      setup2();
    }
    return vue.readonly(state);
  }
  const internalSelectionMenuInjectionKey = createInjectionKey("n-internal-select-menu");
  const internalSelectionMenuBodyInjectionKey = createInjectionKey("n-internal-select-menu-body");
  const modalBodyInjectionKey = createInjectionKey("n-modal-body");
  const modalProviderInjectionKey$1 = createInjectionKey("n-modal-provider");
  const modalInjectionKey = createInjectionKey("n-modal");
  const drawerBodyInjectionKey = createInjectionKey("n-drawer-body");
  const drawerInjectionKey = createInjectionKey("n-drawer");
  const popoverBodyInjectionKey = createInjectionKey("n-popover-body");
  const teleportDisabled = "__disabled__";
  function useAdjustedTo(props) {
    const modal = vue.inject(modalBodyInjectionKey, null);
    const drawer = vue.inject(drawerBodyInjectionKey, null);
    const popover = vue.inject(popoverBodyInjectionKey, null);
    const selectMenu = vue.inject(internalSelectionMenuBodyInjectionKey, null);
    const fullscreenElementRef = vue.ref();
    if (typeof document !== "undefined") {
      fullscreenElementRef.value = document.fullscreenElement;
      const handleFullscreenChange = () => {
        fullscreenElementRef.value = document.fullscreenElement;
      };
      vue.onMounted(() => {
        on("fullscreenchange", document, handleFullscreenChange);
      });
      vue.onBeforeUnmount(() => {
        off("fullscreenchange", document, handleFullscreenChange);
      });
    }
    return useMemo(() => {
      var _a;
      const {
        to
      } = props;
      if (to !== void 0) {
        if (to === false)
          return teleportDisabled;
        if (to === true)
          return fullscreenElementRef.value || "body";
        return to;
      }
      if (modal === null || modal === void 0 ? void 0 : modal.value) {
        return (_a = modal.value.$el) !== null && _a !== void 0 ? _a : modal.value;
      }
      if (drawer === null || drawer === void 0 ? void 0 : drawer.value)
        return drawer.value;
      if (popover === null || popover === void 0 ? void 0 : popover.value)
        return popover.value;
      if (selectMenu === null || selectMenu === void 0 ? void 0 : selectMenu.value)
        return selectMenu.value;
      return to !== null && to !== void 0 ? to : fullscreenElementRef.value || "body";
    });
  }
  useAdjustedTo.tdkey = teleportDisabled;
  useAdjustedTo.propTo = {
    type: [String, Object, Boolean],
    default: void 0
  };
  let houdiniRegistered = false;
  function useHoudini() {
    if (!isBrowser$2)
      return;
    if (!window.CSS)
      return;
    if (!houdiniRegistered) {
      houdiniRegistered = true;
      if ("registerProperty" in (window === null || window === void 0 ? void 0 : window.CSS)) {
        try {
          ;
          CSS.registerProperty({
            name: "--n-color-start",
            syntax: "<color>",
            inherits: false,
            initialValue: "#0000"
          });
          CSS.registerProperty({
            name: "--n-color-end",
            syntax: "<color>",
            inherits: false,
            initialValue: "#0000"
          });
        } catch (_a) {
        }
      }
    }
  }
  function getSlot(scope, slots, slotName = "default") {
    const slot = slots[slotName];
    if (slot === void 0) {
      throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
    }
    return slot();
  }
  function flatten$2(vNodes, filterCommentNode = true, result = []) {
    vNodes.forEach((vNode) => {
      if (vNode === null)
        return;
      if (typeof vNode !== "object") {
        if (typeof vNode === "string" || typeof vNode === "number") {
          result.push(vue.createTextVNode(String(vNode)));
        }
        return;
      }
      if (Array.isArray(vNode)) {
        flatten$2(vNode, filterCommentNode, result);
        return;
      }
      if (vNode.type === vue.Fragment) {
        if (vNode.children === null)
          return;
        if (Array.isArray(vNode.children)) {
          flatten$2(vNode.children, filterCommentNode, result);
        }
      } else if (vNode.type !== vue.Comment) {
        result.push(vNode);
      }
    });
    return result;
  }
  function getFirstVNode(scope, slots, slotName = "default") {
    const slot = slots[slotName];
    if (slot === void 0) {
      throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
    }
    const content = flatten$2(slot());
    if (content.length === 1) {
      return content[0];
    } else {
      throw new Error(`[vueuc/${scope}]: slot[${slotName}] should have exactly one child.`);
    }
  }
  let viewMeasurer = null;
  function ensureViewBoundingRect() {
    if (viewMeasurer === null) {
      viewMeasurer = document.getElementById("v-binder-view-measurer");
      if (viewMeasurer === null) {
        viewMeasurer = document.createElement("div");
        viewMeasurer.id = "v-binder-view-measurer";
        const { style: style2 } = viewMeasurer;
        style2.position = "fixed";
        style2.left = "0";
        style2.right = "0";
        style2.top = "0";
        style2.bottom = "0";
        style2.pointerEvents = "none";
        style2.visibility = "hidden";
        document.body.appendChild(viewMeasurer);
      }
    }
    return viewMeasurer.getBoundingClientRect();
  }
  function getPointRect(x, y) {
    const viewRect = ensureViewBoundingRect();
    return {
      top: y,
      left: x,
      height: 0,
      width: 0,
      right: viewRect.width - x,
      bottom: viewRect.height - y
    };
  }
  function getRect$1(el) {
    const elRect = el.getBoundingClientRect();
    const viewRect = ensureViewBoundingRect();
    return {
      left: elRect.left - viewRect.left,
      top: elRect.top - viewRect.top,
      bottom: viewRect.height + viewRect.top - elRect.bottom,
      right: viewRect.width + viewRect.left - elRect.right,
      width: elRect.width,
      height: elRect.height
    };
  }
  function getParentNode(node) {
    if (node.nodeType === 9) {
      return null;
    }
    return node.parentNode;
  }
  function getScrollParent(node) {
    if (node === null)
      return null;
    const parentNode = getParentNode(node);
    if (parentNode === null) {
      return null;
    }
    if (parentNode.nodeType === 9) {
      return document;
    }
    if (parentNode.nodeType === 1) {
      const { overflow, overflowX, overflowY } = getComputedStyle(parentNode);
      if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
        return parentNode;
      }
    }
    return getScrollParent(parentNode);
  }
  const Binder = vue.defineComponent({
    name: "Binder",
    props: {
      syncTargetWithParent: Boolean,
      syncTarget: {
        type: Boolean,
        default: true
      }
    },
    setup(props) {
      var _a;
      vue.provide("VBinder", (_a = vue.getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy);
      const VBinder2 = vue.inject("VBinder", null);
      const targetRef = vue.ref(null);
      const setTargetRef = (el) => {
        targetRef.value = el;
        if (VBinder2 && props.syncTargetWithParent) {
          VBinder2.setTargetRef(el);
        }
      };
      let scrollableNodes = [];
      const ensureScrollListener = () => {
        let cursor = targetRef.value;
        while (true) {
          cursor = getScrollParent(cursor);
          if (cursor === null)
            break;
          scrollableNodes.push(cursor);
        }
        for (const el of scrollableNodes) {
          on("scroll", el, onScroll, true);
        }
      };
      const removeScrollListeners = () => {
        for (const el of scrollableNodes) {
          off("scroll", el, onScroll, true);
        }
        scrollableNodes = [];
      };
      const followerScrollListeners = /* @__PURE__ */ new Set();
      const addScrollListener = (listener) => {
        if (followerScrollListeners.size === 0) {
          ensureScrollListener();
        }
        if (!followerScrollListeners.has(listener)) {
          followerScrollListeners.add(listener);
        }
      };
      const removeScrollListener = (listener) => {
        if (followerScrollListeners.has(listener)) {
          followerScrollListeners.delete(listener);
        }
        if (followerScrollListeners.size === 0) {
          removeScrollListeners();
        }
      };
      const onScroll = () => {
        beforeNextFrameOnce(onScrollRaf);
      };
      const onScrollRaf = () => {
        followerScrollListeners.forEach((listener) => listener());
      };
      const followerResizeListeners = /* @__PURE__ */ new Set();
      const addResizeListener = (listener) => {
        if (followerResizeListeners.size === 0) {
          on("resize", window, onResize);
        }
        if (!followerResizeListeners.has(listener)) {
          followerResizeListeners.add(listener);
        }
      };
      const removeResizeListener = (listener) => {
        if (followerResizeListeners.has(listener)) {
          followerResizeListeners.delete(listener);
        }
        if (followerResizeListeners.size === 0) {
          off("resize", window, onResize);
        }
      };
      const onResize = () => {
        followerResizeListeners.forEach((listener) => listener());
      };
      vue.onBeforeUnmount(() => {
        off("resize", window, onResize);
        removeScrollListeners();
      });
      return {
        targetRef,
        setTargetRef,
        addScrollListener,
        removeScrollListener,
        addResizeListener,
        removeResizeListener
      };
    },
    render() {
      return getSlot("binder", this.$slots);
    }
  });
  const VBinder = Binder;
  const VTarget = vue.defineComponent({
    name: "Target",
    setup() {
      const { setTargetRef, syncTarget } = vue.inject("VBinder");
      const setTargetDirective = {
        mounted: setTargetRef,
        updated: setTargetRef
      };
      return {
        syncTarget,
        setTargetDirective
      };
    },
    render() {
      const { syncTarget, setTargetDirective } = this;
      if (syncTarget) {
        return vue.withDirectives(getFirstVNode("follower", this.$slots), [
          [setTargetDirective]
        ]);
      }
      return getFirstVNode("follower", this.$slots);
    }
  });
  const ctxKey$1 = "@@mmoContext";
  const mousemoveoutside = {
    mounted(el, { value }) {
      el[ctxKey$1] = {
        handler: void 0
      };
      if (typeof value === "function") {
        el[ctxKey$1].handler = value;
        on("mousemoveoutside", el, value);
      }
    },
    updated(el, { value }) {
      const ctx2 = el[ctxKey$1];
      if (typeof value === "function") {
        if (ctx2.handler) {
          if (ctx2.handler !== value) {
            off("mousemoveoutside", el, ctx2.handler);
            ctx2.handler = value;
            on("mousemoveoutside", el, value);
          }
        } else {
          el[ctxKey$1].handler = value;
          on("mousemoveoutside", el, value);
        }
      } else {
        if (ctx2.handler) {
          off("mousemoveoutside", el, ctx2.handler);
          ctx2.handler = void 0;
        }
      }
    },
    unmounted(el) {
      const { handler } = el[ctxKey$1];
      if (handler) {
        off("mousemoveoutside", el, handler);
      }
      el[ctxKey$1].handler = void 0;
    }
  };
  const mousemoveoutside$1 = mousemoveoutside;
  const ctxKey = "@@coContext";
  const clickoutside = {
    mounted(el, { value, modifiers }) {
      el[ctxKey] = {
        handler: void 0
      };
      if (typeof value === "function") {
        el[ctxKey].handler = value;
        on("clickoutside", el, value, {
          capture: modifiers.capture
        });
      }
    },
    updated(el, { value, modifiers }) {
      const ctx2 = el[ctxKey];
      if (typeof value === "function") {
        if (ctx2.handler) {
          if (ctx2.handler !== value) {
            off("clickoutside", el, ctx2.handler, {
              capture: modifiers.capture
            });
            ctx2.handler = value;
            on("clickoutside", el, value, {
              capture: modifiers.capture
            });
          }
        } else {
          el[ctxKey].handler = value;
          on("clickoutside", el, value, {
            capture: modifiers.capture
          });
        }
      } else {
        if (ctx2.handler) {
          off("clickoutside", el, ctx2.handler, {
            capture: modifiers.capture
          });
          ctx2.handler = void 0;
        }
      }
    },
    unmounted(el, { modifiers }) {
      const { handler } = el[ctxKey];
      if (handler) {
        off("clickoutside", el, handler, {
          capture: modifiers.capture
        });
      }
      el[ctxKey].handler = void 0;
    }
  };
  const clickoutside$1 = clickoutside;
  function warn$1(location, message2) {
    console.error(`[vdirs/${location}]: ${message2}`);
  }
  class ZIndexManager {
    constructor() {
      this.elementZIndex = /* @__PURE__ */ new Map();
      this.nextZIndex = 2e3;
    }
    get elementCount() {
      return this.elementZIndex.size;
    }
    ensureZIndex(el, zIndex) {
      const { elementZIndex } = this;
      if (zIndex !== void 0) {
        el.style.zIndex = `${zIndex}`;
        elementZIndex.delete(el);
        return;
      }
      const { nextZIndex } = this;
      if (elementZIndex.has(el)) {
        const currentZIndex = elementZIndex.get(el);
        if (currentZIndex + 1 === this.nextZIndex)
          return;
      }
      el.style.zIndex = `${nextZIndex}`;
      elementZIndex.set(el, nextZIndex);
      this.nextZIndex = nextZIndex + 1;
      this.squashState();
    }
    unregister(el, zIndex) {
      const { elementZIndex } = this;
      if (elementZIndex.has(el)) {
        elementZIndex.delete(el);
      } else if (zIndex === void 0) {
        warn$1("z-index-manager/unregister-element", "Element not found when unregistering.");
      }
      this.squashState();
    }
    squashState() {
      const { elementCount } = this;
      if (!elementCount) {
        this.nextZIndex = 2e3;
      }
      if (this.nextZIndex - elementCount > 2500)
        this.rearrange();
    }
    rearrange() {
      const elementZIndexPair = Array.from(this.elementZIndex.entries());
      elementZIndexPair.sort((pair1, pair2) => {
        return pair1[1] - pair2[1];
      });
      this.nextZIndex = 2e3;
      elementZIndexPair.forEach((pair) => {
        const el = pair[0];
        const zIndex = this.nextZIndex++;
        if (`${zIndex}` !== el.style.zIndex)
          el.style.zIndex = `${zIndex}`;
      });
    }
  }
  const zIndexManager = new ZIndexManager();
  const ctx = "@@ziContext";
  const zindexable = {
    mounted(el, bindings) {
      const { value = {} } = bindings;
      const { zIndex, enabled } = value;
      el[ctx] = {
        enabled: !!enabled,
        initialized: false
      };
      if (enabled) {
        zIndexManager.ensureZIndex(el, zIndex);
        el[ctx].initialized = true;
      }
    },
    updated(el, bindings) {
      const { value = {} } = bindings;
      const { zIndex, enabled } = value;
      const cachedEnabled = el[ctx].enabled;
      if (enabled && !cachedEnabled) {
        zIndexManager.ensureZIndex(el, zIndex);
        el[ctx].initialized = true;
      }
      el[ctx].enabled = !!enabled;
    },
    unmounted(el, bindings) {
      if (!el[ctx].initialized)
        return;
      const { value = {} } = bindings;
      const { zIndex } = value;
      zIndexManager.unregister(el, zIndex);
    }
  };
  const zindexable$1 = zindexable;
  const ssrContextKey = "@css-render/vue3-ssr";
  function createStyleString(id, style2) {
    return `<style cssr-id="${id}">
${style2}
</style>`;
  }
  function ssrAdapter(id, style2, ssrContext) {
    const { styles: styles2, ids } = ssrContext;
    if (ids.has(id))
      return;
    if (styles2 !== null) {
      ids.add(id);
      styles2.push(createStyleString(id, style2));
    }
  }
  const isBrowser = typeof document !== "undefined";
  function useSsrAdapter() {
    if (isBrowser)
      return void 0;
    const context = vue.inject(ssrContextKey, null);
    if (context === null)
      return void 0;
    return {
      adapter: (id, style2) => ssrAdapter(id, style2, context),
      context
    };
  }
  function warn(location, message2) {
    console.error(`[vueuc/${location}]: ${message2}`);
  }
  const { c } = CssRender();
  const cssrAnchorMetaName$1 = "vueuc-style";
  function lowBit(n) {
    return n & -n;
  }
  class FinweckTree {
    /**
     * @param l length of the array
     * @param min min value of the array
     */
    constructor(l, min) {
      this.l = l;
      this.min = min;
      const ft = new Array(l + 1);
      for (let i = 0; i < l + 1; ++i) {
        ft[i] = 0;
      }
      this.ft = ft;
    }
    /**
     * Add arr[i] by n, start from 0
     * @param i the index of the element to be added
     * @param n the value to be added
     */
    add(i, n) {
      if (n === 0)
        return;
      const { l, ft } = this;
      i += 1;
      while (i <= l) {
        ft[i] += n;
        i += lowBit(i);
      }
    }
    /**
     * Get the value of index i
     * @param i index
     * @returns value of the index
     */
    get(i) {
      return this.sum(i + 1) - this.sum(i);
    }
    /**
     * Get the sum of first i elements
     * @param i count of head elements to be added
     * @returns the sum of first i elements
     */
    sum(i) {
      if (i === void 0)
        i = this.l;
      if (i <= 0)
        return 0;
      const { ft, min, l } = this;
      if (i > l)
        throw new Error("[FinweckTree.sum]: `i` is larger than length.");
      let ret = i * min;
      while (i > 0) {
        ret += ft[i];
        i -= lowBit(i);
      }
      return ret;
    }
    /**
     * Get the largest count of head elements whose sum are <= threshold
     * @param threshold
     * @returns the largest count of head elements whose sum are <= threshold
     */
    getBound(threshold) {
      let l = 0;
      let r = this.l;
      while (r > l) {
        const m = Math.floor((l + r) / 2);
        const sumM = this.sum(m);
        if (sumM > threshold) {
          r = m;
          continue;
        } else if (sumM < threshold) {
          if (l === m) {
            if (this.sum(l + 1) <= threshold)
              return l + 1;
            return m;
          }
          l = m;
        } else {
          return m;
        }
      }
      return l;
    }
  }
  function resolveTo(selector) {
    if (typeof selector === "string") {
      return document.querySelector(selector);
    }
    return selector();
  }
  const LazyTeleport = vue.defineComponent({
    name: "LazyTeleport",
    props: {
      to: {
        type: [String, Object],
        default: void 0
      },
      disabled: Boolean,
      show: {
        type: Boolean,
        required: true
      }
    },
    setup(props) {
      return {
        showTeleport: useFalseUntilTruthy(vue.toRef(props, "show")),
        mergedTo: vue.computed(() => {
          const { to } = props;
          return to !== null && to !== void 0 ? to : "body";
        })
      };
    },
    render() {
      return this.showTeleport ? this.disabled ? getSlot("lazy-teleport", this.$slots) : vue.h(vue.Teleport, {
        disabled: this.disabled,
        to: this.mergedTo
      }, getSlot("lazy-teleport", this.$slots)) : null;
    }
  });
  const oppositionPositions = {
    top: "bottom",
    bottom: "top",
    left: "right",
    right: "left"
  };
  const oppositeAligns = {
    start: "end",
    center: "center",
    end: "start"
  };
  const propToCompare = {
    top: "height",
    bottom: "height",
    left: "width",
    right: "width"
  };
  const transformOrigins = {
    "bottom-start": "top left",
    bottom: "top center",
    "bottom-end": "top right",
    "top-start": "bottom left",
    top: "bottom center",
    "top-end": "bottom right",
    "right-start": "top left",
    right: "center left",
    "right-end": "bottom left",
    "left-start": "top right",
    left: "center right",
    "left-end": "bottom right"
  };
  const overlapTransformOrigin = {
    "bottom-start": "bottom left",
    bottom: "bottom center",
    "bottom-end": "bottom right",
    "top-start": "top left",
    top: "top center",
    "top-end": "top right",
    "right-start": "top right",
    right: "center right",
    "right-end": "bottom right",
    "left-start": "top left",
    left: "center left",
    "left-end": "bottom left"
  };
  const oppositeAlignCssPositionProps = {
    "bottom-start": "right",
    "bottom-end": "left",
    "top-start": "right",
    "top-end": "left",
    "right-start": "bottom",
    "right-end": "top",
    "left-start": "bottom",
    "left-end": "top"
  };
  const keepOffsetDirection = {
    top: true,
    bottom: false,
    left: true,
    right: false
    // left--
  };
  const cssPositionToOppositeAlign = {
    top: "end",
    bottom: "start",
    left: "end",
    right: "start"
  };
  function getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, shift, flip, overlap) {
    if (!flip || overlap) {
      return { placement, top: 0, left: 0 };
    }
    const [position, align] = placement.split("-");
    let properAlign = align !== null && align !== void 0 ? align : "center";
    let properOffset = {
      top: 0,
      left: 0
    };
    const deriveOffset = (oppositeAlignCssSizeProp, alignCssPositionProp, offsetVertically2) => {
      let left = 0;
      let top = 0;
      const diff = followerRect[oppositeAlignCssSizeProp] - targetRect[alignCssPositionProp] - targetRect[oppositeAlignCssSizeProp];
      if (diff > 0 && shift) {
        if (offsetVertically2) {
          top = keepOffsetDirection[alignCssPositionProp] ? diff : -diff;
        } else {
          left = keepOffsetDirection[alignCssPositionProp] ? diff : -diff;
        }
      }
      return {
        left,
        top
      };
    };
    const offsetVertically = position === "left" || position === "right";
    if (properAlign !== "center") {
      const oppositeAlignCssPositionProp = oppositeAlignCssPositionProps[placement];
      const currentAlignCssPositionProp = oppositionPositions[oppositeAlignCssPositionProp];
      const oppositeAlignCssSizeProp = propToCompare[oppositeAlignCssPositionProp];
      if (followerRect[oppositeAlignCssSizeProp] > targetRect[oppositeAlignCssSizeProp]) {
        if (
          // current space is not enough
          // ----------[ target ]---------|
          // -------[     follower        ]
          targetRect[oppositeAlignCssPositionProp] + targetRect[oppositeAlignCssSizeProp] < followerRect[oppositeAlignCssSizeProp]
        ) {
          const followerOverTargetSize = (followerRect[oppositeAlignCssSizeProp] - targetRect[oppositeAlignCssSizeProp]) / 2;
          if (targetRect[oppositeAlignCssPositionProp] < followerOverTargetSize || targetRect[currentAlignCssPositionProp] < followerOverTargetSize) {
            if (targetRect[oppositeAlignCssPositionProp] < targetRect[currentAlignCssPositionProp]) {
              properAlign = oppositeAligns[align];
              properOffset = deriveOffset(oppositeAlignCssSizeProp, currentAlignCssPositionProp, offsetVertically);
            } else {
              properOffset = deriveOffset(oppositeAlignCssSizeProp, oppositeAlignCssPositionProp, offsetVertically);
            }
          } else {
            properAlign = "center";
          }
        }
      } else if (followerRect[oppositeAlignCssSizeProp] < targetRect[oppositeAlignCssSizeProp]) {
        if (targetRect[currentAlignCssPositionProp] < 0 && // opposite align has larger space
        // ------------[   target   ]
        // ----------------[follower]
        targetRect[oppositeAlignCssPositionProp] > targetRect[currentAlignCssPositionProp]) {
          properAlign = oppositeAligns[align];
        }
      }
    } else {
      const possibleAlternativeAlignCssPositionProp1 = position === "bottom" || position === "top" ? "left" : "top";
      const possibleAlternativeAlignCssPositionProp2 = oppositionPositions[possibleAlternativeAlignCssPositionProp1];
      const alternativeAlignCssSizeProp = propToCompare[possibleAlternativeAlignCssPositionProp1];
      const followerOverTargetSize = (followerRect[alternativeAlignCssSizeProp] - targetRect[alternativeAlignCssSizeProp]) / 2;
      if (
        // center is not enough
        // ----------- [ target ]--|
        // -------[     follower     ]
        targetRect[possibleAlternativeAlignCssPositionProp1] < followerOverTargetSize || targetRect[possibleAlternativeAlignCssPositionProp2] < followerOverTargetSize
      ) {
        if (targetRect[possibleAlternativeAlignCssPositionProp1] > targetRect[possibleAlternativeAlignCssPositionProp2]) {
          properAlign = cssPositionToOppositeAlign[possibleAlternativeAlignCssPositionProp1];
          properOffset = deriveOffset(alternativeAlignCssSizeProp, possibleAlternativeAlignCssPositionProp1, offsetVertically);
        } else {
          properAlign = cssPositionToOppositeAlign[possibleAlternativeAlignCssPositionProp2];
          properOffset = deriveOffset(alternativeAlignCssSizeProp, possibleAlternativeAlignCssPositionProp2, offsetVertically);
        }
      }
    }
    let properPosition = position;
    if (
      // space is not enough
      targetRect[position] < followerRect[propToCompare[position]] && // opposite position's space is larger
      targetRect[position] < targetRect[oppositionPositions[position]]
    ) {
      properPosition = oppositionPositions[position];
    }
    return {
      placement: properAlign !== "center" ? `${properPosition}-${properAlign}` : properPosition,
      left: properOffset.left,
      top: properOffset.top
    };
  }
  function getProperTransformOrigin(placement, overlap) {
    if (overlap)
      return overlapTransformOrigin[placement];
    return transformOrigins[placement];
  }
  function getOffset$1(placement, offsetRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap) {
    if (overlap) {
      switch (placement) {
        case "bottom-start":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left)}px`,
            transform: "translateY(-100%)"
          };
        case "bottom-end":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
            transform: "translateX(-100%) translateY(-100%)"
          };
        case "top-start":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left)}px`,
            transform: ""
          };
        case "top-end":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
            transform: "translateX(-100%)"
          };
        case "right-start":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
            transform: "translateX(-100%)"
          };
        case "right-end":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
            transform: "translateX(-100%) translateY(-100%)"
          };
        case "left-start":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left)}px`,
            transform: ""
          };
        case "left-end":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left)}px`,
            transform: "translateY(-100%)"
          };
        case "top":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
            transform: "translateX(-50%)"
          };
        case "right":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
            transform: "translateX(-100%) translateY(-50%)"
          };
        case "left":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left)}px`,
            transform: "translateY(-50%)"
          };
        case "bottom":
        default:
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
            transform: "translateX(-50%) translateY(-100%)"
          };
      }
    }
    switch (placement) {
      case "bottom-start":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
          transform: ""
        };
      case "bottom-end":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
          transform: "translateX(-100%)"
        };
      case "top-start":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
          transform: "translateY(-100%)"
        };
      case "top-end":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
          transform: "translateX(-100%) translateY(-100%)"
        };
      case "right-start":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
          transform: ""
        };
      case "right-end":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
          transform: "translateY(-100%)"
        };
      case "left-start":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
          transform: "translateX(-100%)"
        };
      case "left-end":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
          transform: "translateX(-100%) translateY(-100%)"
        };
      case "top":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2 + offsetLeftToStandardPlacement)}px`,
          transform: "translateY(-100%) translateX(-50%)"
        };
      case "right":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2 + offsetTopToStandardPlacement)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
          transform: "translateY(-50%)"
        };
      case "left":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2 + offsetTopToStandardPlacement)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
          transform: "translateY(-50%) translateX(-100%)"
        };
      case "bottom":
      default:
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2 + offsetLeftToStandardPlacement)}px`,
          transform: "translateX(-50%)"
        };
    }
  }
  const style$1F = c([
    c(".v-binder-follower-container", {
      position: "absolute",
      left: "0",
      right: "0",
      top: "0",
      height: "0",
      pointerEvents: "none",
      zIndex: "auto"
    }),
    c(".v-binder-follower-content", {
      position: "absolute",
      zIndex: "auto"
    }, [
      c("> *", {
        pointerEvents: "all"
      })
    ])
  ]);
  const VFollower = vue.defineComponent({
    name: "Follower",
    inheritAttrs: false,
    props: {
      show: Boolean,
      enabled: {
        type: Boolean,
        default: void 0
      },
      placement: {
        type: String,
        default: "bottom"
      },
      syncTrigger: {
        type: Array,
        default: ["resize", "scroll"]
      },
      to: [String, Object],
      flip: {
        type: Boolean,
        default: true
      },
      internalShift: Boolean,
      x: Number,
      y: Number,
      width: String,
      minWidth: String,
      containerClass: String,
      teleportDisabled: Boolean,
      zindexable: {
        type: Boolean,
        default: true
      },
      zIndex: Number,
      overlap: Boolean
    },
    setup(props) {
      const VBinder2 = vue.inject("VBinder");
      const mergedEnabledRef = useMemo(() => {
        return props.enabled !== void 0 ? props.enabled : props.show;
      });
      const followerRef = vue.ref(null);
      const offsetContainerRef = vue.ref(null);
      const ensureListeners = () => {
        const { syncTrigger } = props;
        if (syncTrigger.includes("scroll")) {
          VBinder2.addScrollListener(syncPosition);
        }
        if (syncTrigger.includes("resize")) {
          VBinder2.addResizeListener(syncPosition);
        }
      };
      const removeListeners = () => {
        VBinder2.removeScrollListener(syncPosition);
        VBinder2.removeResizeListener(syncPosition);
      };
      vue.onMounted(() => {
        if (mergedEnabledRef.value) {
          syncPosition();
          ensureListeners();
        }
      });
      const ssrAdapter2 = useSsrAdapter();
      style$1F.mount({
        id: "vueuc/binder",
        head: true,
        anchorMetaName: cssrAnchorMetaName$1,
        ssr: ssrAdapter2
      });
      vue.onBeforeUnmount(() => {
        removeListeners();
      });
      onFontsReady(() => {
        if (mergedEnabledRef.value) {
          syncPosition();
        }
      });
      const syncPosition = () => {
        if (!mergedEnabledRef.value) {
          return;
        }
        const follower = followerRef.value;
        if (follower === null)
          return;
        const target = VBinder2.targetRef;
        const { x, y, overlap } = props;
        const targetRect = x !== void 0 && y !== void 0 ? getPointRect(x, y) : getRect$1(target);
        follower.style.setProperty("--v-target-width", `${Math.round(targetRect.width)}px`);
        follower.style.setProperty("--v-target-height", `${Math.round(targetRect.height)}px`);
        const { width, minWidth, placement, internalShift, flip } = props;
        follower.setAttribute("v-placement", placement);
        if (overlap) {
          follower.setAttribute("v-overlap", "");
        } else {
          follower.removeAttribute("v-overlap");
        }
        const { style: style2 } = follower;
        if (width === "target") {
          style2.width = `${targetRect.width}px`;
        } else if (width !== void 0) {
          style2.width = width;
        } else {
          style2.width = "";
        }
        if (minWidth === "target") {
          style2.minWidth = `${targetRect.width}px`;
        } else if (minWidth !== void 0) {
          style2.minWidth = minWidth;
        } else {
          style2.minWidth = "";
        }
        const followerRect = getRect$1(follower);
        const offsetContainerRect = getRect$1(offsetContainerRef.value);
        const { left: offsetLeftToStandardPlacement, top: offsetTopToStandardPlacement, placement: properPlacement } = getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, internalShift, flip, overlap);
        const properTransformOrigin = getProperTransformOrigin(properPlacement, overlap);
        const { left, top, transform } = getOffset$1(properPlacement, offsetContainerRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap);
        follower.setAttribute("v-placement", properPlacement);
        follower.style.setProperty("--v-offset-left", `${Math.round(offsetLeftToStandardPlacement)}px`);
        follower.style.setProperty("--v-offset-top", `${Math.round(offsetTopToStandardPlacement)}px`);
        follower.style.transform = `translateX(${left}) translateY(${top}) ${transform}`;
        follower.style.setProperty("--v-transform-origin", properTransformOrigin);
        follower.style.transformOrigin = properTransformOrigin;
      };
      vue.watch(mergedEnabledRef, (value) => {
        if (value) {
          ensureListeners();
          syncOnNextTick();
        } else {
          removeListeners();
        }
      });
      const syncOnNextTick = () => {
        vue.nextTick().then(syncPosition).catch((e) => console.error(e));
      };
      [
        "placement",
        "x",
        "y",
        "internalShift",
        "flip",
        "width",
        "overlap",
        "minWidth"
      ].forEach((prop) => {
        vue.watch(vue.toRef(props, prop), syncPosition);
      });
      ["teleportDisabled"].forEach((prop) => {
        vue.watch(vue.toRef(props, prop), syncOnNextTick);
      });
      vue.watch(vue.toRef(props, "syncTrigger"), (value) => {
        if (!value.includes("resize")) {
          VBinder2.removeResizeListener(syncPosition);
        } else {
          VBinder2.addResizeListener(syncPosition);
        }
        if (!value.includes("scroll")) {
          VBinder2.removeScrollListener(syncPosition);
        } else {
          VBinder2.addScrollListener(syncPosition);
        }
      });
      const isMountedRef = isMounted();
      const mergedToRef = useMemo(() => {
        const { to } = props;
        if (to !== void 0)
          return to;
        if (isMountedRef.value) {
          return void 0;
        }
        return void 0;
      });
      return {
        VBinder: VBinder2,
        mergedEnabled: mergedEnabledRef,
        offsetContainerRef,
        followerRef,
        mergedTo: mergedToRef,
        syncPosition
      };
    },
    render() {
      return vue.h(LazyTeleport, {
        show: this.show,
        to: this.mergedTo,
        disabled: this.teleportDisabled
      }, {
        default: () => {
          var _a, _b;
          const vNode = vue.h("div", {
            class: ["v-binder-follower-container", this.containerClass],
            ref: "offsetContainerRef"
          }, [
            vue.h("div", {
              class: "v-binder-follower-content",
              ref: "followerRef"
            }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a))
          ]);
          if (this.zindexable) {
            return vue.withDirectives(vNode, [
              [
                zindexable$1,
                {
                  enabled: this.mergedEnabled,
                  zIndex: this.zIndex
                }
              ]
            ]);
          }
          return vNode;
        }
      });
    }
  });
  var resizeObservers = [];
  var hasActiveObservations = function() {
    return resizeObservers.some(function(ro) {
      return ro.activeTargets.length > 0;
    });
  };
  var hasSkippedObservations = function() {
    return resizeObservers.some(function(ro) {
      return ro.skippedTargets.length > 0;
    });
  };
  var msg = "ResizeObserver loop completed with undelivered notifications.";
  var deliverResizeLoopError = function() {
    var event;
    if (typeof ErrorEvent === "function") {
      event = new ErrorEvent("error", {
        message: msg
      });
    } else {
      event = document.createEvent("Event");
      event.initEvent("error", false, false);
      event.message = msg;
    }
    window.dispatchEvent(event);
  };
  var ResizeObserverBoxOptions;
  (function(ResizeObserverBoxOptions2) {
    ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
    ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
    ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
  })(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
  var freeze = function(obj) {
    return Object.freeze(obj);
  };
  var ResizeObserverSize = /* @__PURE__ */ function() {
    function ResizeObserverSize2(inlineSize, blockSize) {
      this.inlineSize = inlineSize;
      this.blockSize = blockSize;
      freeze(this);
    }
    return ResizeObserverSize2;
  }();
  var DOMRectReadOnly = function() {
    function DOMRectReadOnly2(x, y, width, height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.top = this.y;
      this.left = this.x;
      this.bottom = this.top + this.height;
      this.right = this.left + this.width;
      return freeze(this);
    }
    DOMRectReadOnly2.prototype.toJSON = function() {
      var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;
      return { x, y, top, right, bottom, left, width, height };
    };
    DOMRectReadOnly2.fromRect = function(rectangle) {
      return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
    };
    return DOMRectReadOnly2;
  }();
  var isSVG = function(target) {
    return target instanceof SVGElement && "getBBox" in target;
  };
  var isHidden = function(target) {
    if (isSVG(target)) {
      var _a = target.getBBox(), width = _a.width, height = _a.height;
      return !width && !height;
    }
    var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
    return !(offsetWidth || offsetHeight || target.getClientRects().length);
  };
  var isElement = function(obj) {
    var _a;
    if (obj instanceof Element) {
      return true;
    }
    var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
    return !!(scope && obj instanceof scope.Element);
  };
  var isReplacedElement = function(target) {
    switch (target.tagName) {
      case "INPUT":
        if (target.type !== "image") {
          break;
        }
      case "VIDEO":
      case "AUDIO":
      case "EMBED":
      case "OBJECT":
      case "CANVAS":
      case "IFRAME":
      case "IMG":
        return true;
    }
    return false;
  };
  var global$1 = typeof window !== "undefined" ? window : {};
  var cache = /* @__PURE__ */ new WeakMap();
  var scrollRegexp = /auto|scroll/;
  var verticalRegexp = /^tb|vertical/;
  var IE = /msie|trident/i.test(global$1.navigator && global$1.navigator.userAgent);
  var parseDimension = function(pixel) {
    return parseFloat(pixel || "0");
  };
  var size = function(inlineSize, blockSize, switchSizes) {
    if (inlineSize === void 0) {
      inlineSize = 0;
    }
    if (blockSize === void 0) {
      blockSize = 0;
    }
    if (switchSizes === void 0) {
      switchSizes = false;
    }
    return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
  };
  var zeroBoxes = freeze({
    devicePixelContentBoxSize: size(),
    borderBoxSize: size(),
    contentBoxSize: size(),
    contentRect: new DOMRectReadOnly(0, 0, 0, 0)
  });
  var calculateBoxSizes = function(target, forceRecalculation) {
    if (forceRecalculation === void 0) {
      forceRecalculation = false;
    }
    if (cache.has(target) && !forceRecalculation) {
      return cache.get(target);
    }
    if (isHidden(target)) {
      cache.set(target, zeroBoxes);
      return zeroBoxes;
    }
    var cs = getComputedStyle(target);
    var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
    var removePadding = !IE && cs.boxSizing === "border-box";
    var switchSizes = verticalRegexp.test(cs.writingMode || "");
    var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || "");
    var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || "");
    var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
    var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
    var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
    var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
    var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
    var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
    var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
    var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
    var horizontalPadding = paddingLeft + paddingRight;
    var verticalPadding = paddingTop + paddingBottom;
    var horizontalBorderArea = borderLeft + borderRight;
    var verticalBorderArea = borderTop + borderBottom;
    var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
    var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
    var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
    var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
    var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
    var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
    var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
    var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
    var boxes = freeze({
      devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
      borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
      contentBoxSize: size(contentWidth, contentHeight, switchSizes),
      contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
    });
    cache.set(target, boxes);
    return boxes;
  };
  var calculateBoxSize = function(target, observedBox, forceRecalculation) {
    var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
    switch (observedBox) {
      case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
        return devicePixelContentBoxSize;
      case ResizeObserverBoxOptions.BORDER_BOX:
        return borderBoxSize;
      default:
        return contentBoxSize;
    }
  };
  var ResizeObserverEntry = /* @__PURE__ */ function() {
    function ResizeObserverEntry2(target) {
      var boxes = calculateBoxSizes(target);
      this.target = target;
      this.contentRect = boxes.contentRect;
      this.borderBoxSize = freeze([boxes.borderBoxSize]);
      this.contentBoxSize = freeze([boxes.contentBoxSize]);
      this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
    }
    return ResizeObserverEntry2;
  }();
  var calculateDepthForNode = function(node) {
    if (isHidden(node)) {
      return Infinity;
    }
    var depth = 0;
    var parent = node.parentNode;
    while (parent) {
      depth += 1;
      parent = parent.parentNode;
    }
    return depth;
  };
  var broadcastActiveObservations = function() {
    var shallowestDepth = Infinity;
    var callbacks2 = [];
    resizeObservers.forEach(function processObserver(ro) {
      if (ro.activeTargets.length === 0) {
        return;
      }
      var entries = [];
      ro.activeTargets.forEach(function processTarget(ot) {
        var entry = new ResizeObserverEntry(ot.target);
        var targetDepth = calculateDepthForNode(ot.target);
        entries.push(entry);
        ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
        if (targetDepth < shallowestDepth) {
          shallowestDepth = targetDepth;
        }
      });
      callbacks2.push(function resizeObserverCallback() {
        ro.callback.call(ro.observer, entries, ro.observer);
      });
      ro.activeTargets.splice(0, ro.activeTargets.length);
    });
    for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {
      var callback = callbacks_1[_i];
      callback();
    }
    return shallowestDepth;
  };
  var gatherActiveObservationsAtDepth = function(depth) {
    resizeObservers.forEach(function processObserver(ro) {
      ro.activeTargets.splice(0, ro.activeTargets.length);
      ro.skippedTargets.splice(0, ro.skippedTargets.length);
      ro.observationTargets.forEach(function processTarget(ot) {
        if (ot.isActive()) {
          if (calculateDepthForNode(ot.target) > depth) {
            ro.activeTargets.push(ot);
          } else {
            ro.skippedTargets.push(ot);
          }
        }
      });
    });
  };
  var process$1 = function() {
    var depth = 0;
    gatherActiveObservationsAtDepth(depth);
    while (hasActiveObservations()) {
      depth = broadcastActiveObservations();
      gatherActiveObservationsAtDepth(depth);
    }
    if (hasSkippedObservations()) {
      deliverResizeLoopError();
    }
    return depth > 0;
  };
  var trigger;
  var callbacks = [];
  var notify = function() {
    return callbacks.splice(0).forEach(function(cb) {
      return cb();
    });
  };
  var queueMicroTask = function(callback) {
    if (!trigger) {
      var toggle_1 = 0;
      var el_1 = document.createTextNode("");
      var config = { characterData: true };
      new MutationObserver(function() {
        return notify();
      }).observe(el_1, config);
      trigger = function() {
        el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
      };
    }
    callbacks.push(callback);
    trigger();
  };
  var queueResizeObserver = function(cb) {
    queueMicroTask(function ResizeObserver2() {
      requestAnimationFrame(cb);
    });
  };
  var watching = 0;
  var isWatching = function() {
    return !!watching;
  };
  var CATCH_PERIOD = 250;
  var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
  var events = [
    "resize",
    "load",
    "transitionend",
    "animationend",
    "animationstart",
    "animationiteration",
    "keyup",
    "keydown",
    "mouseup",
    "mousedown",
    "mouseover",
    "mouseout",
    "blur",
    "focus"
  ];
  var time$1 = function(timeout) {
    if (timeout === void 0) {
      timeout = 0;
    }
    return Date.now() + timeout;
  };
  var scheduled = false;
  var Scheduler = function() {
    function Scheduler2() {
      var _this = this;
      this.stopped = true;
      this.listener = function() {
        return _this.schedule();
      };
    }
    Scheduler2.prototype.run = function(timeout) {
      var _this = this;
      if (timeout === void 0) {
        timeout = CATCH_PERIOD;
      }
      if (scheduled) {
        return;
      }
      scheduled = true;
      var until = time$1(timeout);
      queueResizeObserver(function() {
        var elementsHaveResized = false;
        try {
          elementsHaveResized = process$1();
        } finally {
          scheduled = false;
          timeout = until - time$1();
          if (!isWatching()) {
            return;
          }
          if (elementsHaveResized) {
            _this.run(1e3);
          } else if (timeout > 0) {
            _this.run(timeout);
          } else {
            _this.start();
          }
        }
      });
    };
    Scheduler2.prototype.schedule = function() {
      this.stop();
      this.run();
    };
    Scheduler2.prototype.observe = function() {
      var _this = this;
      var cb = function() {
        return _this.observer && _this.observer.observe(document.body, observerConfig);
      };
      document.body ? cb() : global$1.addEventListener("DOMContentLoaded", cb);
    };
    Scheduler2.prototype.start = function() {
      var _this = this;
      if (this.stopped) {
        this.stopped = false;
        this.observer = new MutationObserver(this.listener);
        this.observe();
        events.forEach(function(name) {
          return global$1.addEventListener(name, _this.listener, true);
        });
      }
    };
    Scheduler2.prototype.stop = function() {
      var _this = this;
      if (!this.stopped) {
        this.observer && this.observer.disconnect();
        events.forEach(function(name) {
          return global$1.removeEventListener(name, _this.listener, true);
        });
        this.stopped = true;
      }
    };
    return Scheduler2;
  }();
  var scheduler = new Scheduler();
  var updateCount = function(n) {
    !watching && n > 0 && scheduler.start();
    watching += n;
    !watching && scheduler.stop();
  };
  var skipNotifyOnElement = function(target) {
    return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
  };
  var ResizeObservation = function() {
    function ResizeObservation2(target, observedBox) {
      this.target = target;
      this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
      this.lastReportedSize = {
        inlineSize: 0,
        blockSize: 0
      };
    }
    ResizeObservation2.prototype.isActive = function() {
      var size2 = calculateBoxSize(this.target, this.observedBox, true);
      if (skipNotifyOnElement(this.target)) {
        this.lastReportedSize = size2;
      }
      if (this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize) {
        return true;
      }
      return false;
    };
    return ResizeObservation2;
  }();
  var ResizeObserverDetail = /* @__PURE__ */ function() {
    function ResizeObserverDetail2(resizeObserver, callback) {
      this.activeTargets = [];
      this.skippedTargets = [];
      this.observationTargets = [];
      this.observer = resizeObserver;
      this.callback = callback;
    }
    return ResizeObserverDetail2;
  }();
  var observerMap = /* @__PURE__ */ new WeakMap();
  var getObservationIndex = function(observationTargets, target) {
    for (var i = 0; i < observationTargets.length; i += 1) {
      if (observationTargets[i].target === target) {
        return i;
      }
    }
    return -1;
  };
  var ResizeObserverController = function() {
    function ResizeObserverController2() {
    }
    ResizeObserverController2.connect = function(resizeObserver, callback) {
      var detail = new ResizeObserverDetail(resizeObserver, callback);
      observerMap.set(resizeObserver, detail);
    };
    ResizeObserverController2.observe = function(resizeObserver, target, options) {
      var detail = observerMap.get(resizeObserver);
      var firstObservation = detail.observationTargets.length === 0;
      if (getObservationIndex(detail.observationTargets, target) < 0) {
        firstObservation && resizeObservers.push(detail);
        detail.observationTargets.push(new ResizeObservation(target, options && options.box));
        updateCount(1);
        scheduler.schedule();
      }
    };
    ResizeObserverController2.unobserve = function(resizeObserver, target) {
      var detail = observerMap.get(resizeObserver);
      var index = getObservationIndex(detail.observationTargets, target);
      var lastObservation = detail.observationTargets.length === 1;
      if (index >= 0) {
        lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
        detail.observationTargets.splice(index, 1);
        updateCount(-1);
      }
    };
    ResizeObserverController2.disconnect = function(resizeObserver) {
      var _this = this;
      var detail = observerMap.get(resizeObserver);
      detail.observationTargets.slice().forEach(function(ot) {
        return _this.unobserve(resizeObserver, ot.target);
      });
      detail.activeTargets.splice(0, detail.activeTargets.length);
    };
    return ResizeObserverController2;
  }();
  var ResizeObserver = function() {
    function ResizeObserver2(callback) {
      if (arguments.length === 0) {
        throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
      }
      if (typeof callback !== "function") {
        throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
      }
      ResizeObserverController.connect(this, callback);
    }
    ResizeObserver2.prototype.observe = function(target, options) {
      if (arguments.length === 0) {
        throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
      }
      if (!isElement(target)) {
        throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
      }
      ResizeObserverController.observe(this, target, options);
    };
    ResizeObserver2.prototype.unobserve = function(target) {
      if (arguments.length === 0) {
        throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
      }
      if (!isElement(target)) {
        throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
      }
      ResizeObserverController.unobserve(this, target);
    };
    ResizeObserver2.prototype.disconnect = function() {
      ResizeObserverController.disconnect(this);
    };
    ResizeObserver2.toString = function() {
      return "function ResizeObserver () { [polyfill code] }";
    };
    return ResizeObserver2;
  }();
  class ResizeObserverDelegate {
    constructor() {
      this.handleResize = this.handleResize.bind(this);
      this.observer = new (typeof window !== "undefined" && window.ResizeObserver || ResizeObserver)(this.handleResize);
      this.elHandlersMap = /* @__PURE__ */ new Map();
    }
    handleResize(entries) {
      for (const entry of entries) {
        const handler = this.elHandlersMap.get(entry.target);
        if (handler !== void 0) {
          handler(entry);
        }
      }
    }
    registerHandler(el, handler) {
      this.elHandlersMap.set(el, handler);
      this.observer.observe(el);
    }
    unregisterHandler(el) {
      if (!this.elHandlersMap.has(el)) {
        return;
      }
      this.elHandlersMap.delete(el);
      this.observer.unobserve(el);
    }
  }
  const resizeObserverManager = new ResizeObserverDelegate();
  const VResizeObserver = vue.defineComponent({
    name: "ResizeObserver",
    props: {
      onResize: Function
    },
    setup(props) {
      let registered = false;
      const proxy = vue.getCurrentInstance().proxy;
      function handleResize(entry) {
        const { onResize } = props;
        if (onResize !== void 0)
          onResize(entry);
      }
      vue.onMounted(() => {
        const el = proxy.$el;
        if (el === void 0) {
          warn("resize-observer", "$el does not exist.");
          return;
        }
        if (el.nextElementSibling !== el.nextSibling) {
          if (el.nodeType === 3 && el.nodeValue !== "") {
            warn("resize-observer", "$el can not be observed (it may be a text node).");
            return;
          }
        }
        if (el.nextElementSibling !== null) {
          resizeObserverManager.registerHandler(el.nextElementSibling, handleResize);
          registered = true;
        }
      });
      vue.onBeforeUnmount(() => {
        if (registered) {
          resizeObserverManager.unregisterHandler(proxy.$el.nextElementSibling);
        }
      });
    },
    render() {
      return vue.renderSlot(this.$slots, "default");
    }
  });
  let maybeTouch;
  function ensureMaybeTouch() {
    if (typeof document === "undefined")
      return false;
    if (maybeTouch === void 0) {
      if ("matchMedia" in window) {
        maybeTouch = window.matchMedia("(pointer:coarse)").matches;
      } else {
        maybeTouch = false;
      }
    }
    return maybeTouch;
  }
  let wheelScale;
  function ensureWheelScale() {
    if (typeof document === "undefined")
      return 1;
    if (wheelScale === void 0) {
      wheelScale = "chrome" in window ? window.devicePixelRatio : 1;
    }
    return wheelScale;
  }
  const xScrollInjextionKey = "VVirtualListXScroll";
  function setupXScroll({ columnsRef, renderColRef, renderItemWithColsRef }) {
    const listWidthRef = vue.ref(0);
    const scrollLeftRef = vue.ref(0);
    const xFinweckTreeRef = vue.computed(() => {
      const columns = columnsRef.value;
      if (columns.length === 0) {
        return null;
      }
      const ft = new FinweckTree(columns.length, 0);
      columns.forEach((column, index) => {
        ft.add(index, column.width);
      });
      return ft;
    });
    const startIndexRef = useMemo(() => {
      const xFinweckTree = xFinweckTreeRef.value;
      if (xFinweckTree !== null) {
        return Math.max(xFinweckTree.getBound(scrollLeftRef.value) - 1, 0);
      } else {
        return 0;
      }
    });
    const getLeft = (index) => {
      const xFinweckTree = xFinweckTreeRef.value;
      if (xFinweckTree !== null) {
        return xFinweckTree.sum(index);
      } else {
        return 0;
      }
    };
    const endIndexRef = useMemo(() => {
      const xFinweckTree = xFinweckTreeRef.value;
      if (xFinweckTree !== null) {
        return Math.min(xFinweckTree.getBound(scrollLeftRef.value + listWidthRef.value) + 1, columnsRef.value.length - 1);
      } else {
        return 0;
      }
    });
    vue.provide(xScrollInjextionKey, {
      startIndexRef,
      endIndexRef,
      columnsRef,
      renderColRef,
      renderItemWithColsRef,
      getLeft
    });
    return {
      listWidthRef,
      scrollLeftRef
    };
  }
  const VirtualListRow = vue.defineComponent({
    name: "VirtualListRow",
    props: {
      index: { type: Number, required: true },
      item: {
        type: Object,
        required: true
      }
    },
    setup() {
      const { startIndexRef, endIndexRef, columnsRef, getLeft, renderColRef, renderItemWithColsRef } = (
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        vue.inject(xScrollInjextionKey)
      );
      return {
        startIndex: startIndexRef,
        endIndex: endIndexRef,
        columns: columnsRef,
        renderCol: renderColRef,
        renderItemWithCols: renderItemWithColsRef,
        getLeft
      };
    },
    render() {
      const { startIndex, endIndex, columns, renderCol, renderItemWithCols, getLeft, item } = this;
      if (renderItemWithCols != null) {
        return renderItemWithCols({
          itemIndex: this.index,
          startColIndex: startIndex,
          endColIndex: endIndex,
          allColumns: columns,
          item,
          getLeft
        });
      }
      if (renderCol != null) {
        const items = [];
        for (let i = startIndex; i <= endIndex; ++i) {
          const column = columns[i];
          items.push(renderCol({ column, left: getLeft(i), item }));
        }
        return items;
      }
      return null;
    }
  });
  const styles$1 = c(".v-vl", {
    maxHeight: "inherit",
    height: "100%",
    overflow: "auto",
    minWidth: "1px"
    // a zero width container won't be scrollable
  }, [
    c("&:not(.v-vl--show-scrollbar)", {
      scrollbarWidth: "none"
    }, [
      c("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", {
        width: 0,
        height: 0,
        display: "none"
      })
    ])
  ]);
  const VVirtualList = vue.defineComponent({
    name: "VirtualList",
    inheritAttrs: false,
    props: {
      showScrollbar: {
        type: Boolean,
        default: true
      },
      columns: {
        type: Array,
        default: () => []
      },
      renderCol: Function,
      renderItemWithCols: Function,
      items: {
        type: Array,
        default: () => []
      },
      // it is suppose to be the min height
      itemSize: {
        type: Number,
        required: true
      },
      itemResizable: Boolean,
      itemsStyle: [String, Object],
      visibleItemsTag: {
        type: [String, Object],
        default: "div"
      },
      visibleItemsProps: Object,
      ignoreItemResize: Boolean,
      onScroll: Function,
      onWheel: Function,
      onResize: Function,
      defaultScrollKey: [Number, String],
      defaultScrollIndex: Number,
      keyField: {
        type: String,
        default: "key"
      },
      // Whether it is a good API?
      // ResizeObserver + footer & header is not enough.
      // Too complex for simple case
      paddingTop: {
        type: [Number, String],
        default: 0
      },
      paddingBottom: {
        type: [Number, String],
        default: 0
      }
    },
    setup(props) {
      const ssrAdapter2 = useSsrAdapter();
      styles$1.mount({
        id: "vueuc/virtual-list",
        head: true,
        anchorMetaName: cssrAnchorMetaName$1,
        ssr: ssrAdapter2
      });
      vue.onMounted(() => {
        const { defaultScrollIndex, defaultScrollKey } = props;
        if (defaultScrollIndex !== void 0 && defaultScrollIndex !== null) {
          scrollTo({ index: defaultScrollIndex });
        } else if (defaultScrollKey !== void 0 && defaultScrollKey !== null) {
          scrollTo({ key: defaultScrollKey });
        }
      });
      let isDeactivated = false;
      let activateStateInitialized = false;
      vue.onActivated(() => {
        isDeactivated = false;
        if (!activateStateInitialized) {
          activateStateInitialized = true;
          return;
        }
        scrollTo({ top: scrollTopRef.value, left: scrollLeftRef.value });
      });
      vue.onDeactivated(() => {
        isDeactivated = true;
        if (!activateStateInitialized) {
          activateStateInitialized = true;
        }
      });
      const totalWidthRef = useMemo(() => {
        if (props.renderCol == null && props.renderItemWithCols == null) {
          return void 0;
        }
        if (props.columns.length === 0)
          return void 0;
        let width = 0;
        props.columns.forEach((column) => {
          width += column.width;
        });
        return width;
      });
      const keyIndexMapRef = vue.computed(() => {
        const map2 = /* @__PURE__ */ new Map();
        const { keyField } = props;
        props.items.forEach((item, index) => {
          map2.set(item[keyField], index);
        });
        return map2;
      });
      const { scrollLeftRef, listWidthRef } = setupXScroll({
        columnsRef: vue.toRef(props, "columns"),
        renderColRef: vue.toRef(props, "renderCol"),
        renderItemWithColsRef: vue.toRef(props, "renderItemWithCols")
      });
      const listElRef = vue.ref(null);
      const listHeightRef = vue.ref(void 0);
      const keyToHeightOffset = /* @__PURE__ */ new Map();
      const finweckTreeRef = vue.computed(() => {
        const { items, itemSize, keyField } = props;
        const ft = new FinweckTree(items.length, itemSize);
        items.forEach((item, index) => {
          const key = item[keyField];
          const heightOffset = keyToHeightOffset.get(key);
          if (heightOffset !== void 0) {
            ft.add(index, heightOffset);
          }
        });
        return ft;
      });
      const finweckTreeUpdateTrigger = vue.ref(0);
      const scrollTopRef = vue.ref(0);
      const startIndexRef = useMemo(() => {
        return Math.max(finweckTreeRef.value.getBound(scrollTopRef.value - depx(props.paddingTop)) - 1, 0);
      });
      const viewportItemsRef = vue.computed(() => {
        const { value: listHeight } = listHeightRef;
        if (listHeight === void 0)
          return [];
        const { items, itemSize } = props;
        const startIndex = startIndexRef.value;
        const endIndex = Math.min(startIndex + Math.ceil(listHeight / itemSize + 1), items.length - 1);
        const viewportItems = [];
        for (let i = startIndex; i <= endIndex; ++i) {
          viewportItems.push(items[i]);
        }
        return viewportItems;
      });
      const scrollTo = (options, y) => {
        if (typeof options === "number") {
          scrollToPosition(options, y, "auto");
          return;
        }
        const { left, top, index, key, position, behavior, debounce: debounce2 = true } = options;
        if (left !== void 0 || top !== void 0) {
          scrollToPosition(left, top, behavior);
        } else if (index !== void 0) {
          scrollToIndex(index, behavior, debounce2);
        } else if (key !== void 0) {
          const toIndex = keyIndexMapRef.value.get(key);
          if (toIndex !== void 0)
            scrollToIndex(toIndex, behavior, debounce2);
        } else if (position === "bottom") {
          scrollToPosition(0, Number.MAX_SAFE_INTEGER, behavior);
        } else if (position === "top") {
          scrollToPosition(0, 0, behavior);
        }
      };
      let anchorIndex;
      let anchorTimerId = null;
      function scrollToIndex(index, behavior, debounce2) {
        const { value: ft } = finweckTreeRef;
        const targetTop = ft.sum(index) + depx(props.paddingTop);
        if (!debounce2) {
          listElRef.value.scrollTo({
            left: 0,
            top: targetTop,
            behavior
          });
        } else {
          anchorIndex = index;
          if (anchorTimerId !== null) {
            window.clearTimeout(anchorTimerId);
          }
          anchorTimerId = window.setTimeout(() => {
            anchorIndex = void 0;
            anchorTimerId = null;
          }, 16);
          const { scrollTop, offsetHeight } = listElRef.value;
          if (targetTop > scrollTop) {
            const itemSize = ft.get(index);
            if (targetTop + itemSize <= scrollTop + offsetHeight)
              ;
            else {
              listElRef.value.scrollTo({
                left: 0,
                top: targetTop + itemSize - offsetHeight,
                behavior
              });
            }
          } else {
            listElRef.value.scrollTo({
              left: 0,
              top: targetTop,
              behavior
            });
          }
        }
      }
      function scrollToPosition(left, top, behavior) {
        listElRef.value.scrollTo({
          left,
          top,
          behavior
        });
      }
      function handleItemResize(key, entry) {
        var _a, _b, _c;
        if (isDeactivated)
          return;
        if (props.ignoreItemResize)
          return;
        if (isHideByVShow(entry.target))
          return;
        const { value: ft } = finweckTreeRef;
        const index = keyIndexMapRef.value.get(key);
        const previousHeight = ft.get(index);
        const height = (_c = (_b = (_a = entry.borderBoxSize) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.blockSize) !== null && _c !== void 0 ? _c : entry.contentRect.height;
        if (height === previousHeight)
          return;
        const offset = height - props.itemSize;
        if (offset === 0) {
          keyToHeightOffset.delete(key);
        } else {
          keyToHeightOffset.set(key, height - props.itemSize);
        }
        const delta = height - previousHeight;
        if (delta === 0)
          return;
        ft.add(index, delta);
        const listEl = listElRef.value;
        if (listEl != null) {
          if (anchorIndex === void 0) {
            const previousHeightSum = ft.sum(index);
            if (listEl.scrollTop > previousHeightSum) {
              listEl.scrollBy(0, delta);
            }
          } else {
            if (index < anchorIndex) {
              listEl.scrollBy(0, delta);
            } else if (index === anchorIndex) {
              const previousHeightSum = ft.sum(index);
              if (height + previousHeightSum > // Note, listEl shouldn't have border, nor offsetHeight won't be
              // correct
              listEl.scrollTop + listEl.offsetHeight) {
                listEl.scrollBy(0, delta);
              }
            }
          }
          syncViewport();
        }
        finweckTreeUpdateTrigger.value++;
      }
      const mayUseWheel = !ensureMaybeTouch();
      let wheelCatched = false;
      function handleListScroll(e) {
        var _a;
        (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);
        if (!mayUseWheel || !wheelCatched) {
          syncViewport();
        }
      }
      function handleListWheel(e) {
        var _a;
        (_a = props.onWheel) === null || _a === void 0 ? void 0 : _a.call(props, e);
        if (mayUseWheel) {
          const listEl = listElRef.value;
          if (listEl != null) {
            if (e.deltaX === 0) {
              if (listEl.scrollTop === 0 && e.deltaY <= 0) {
                return;
              }
              if (listEl.scrollTop + listEl.offsetHeight >= listEl.scrollHeight && e.deltaY >= 0) {
                return;
              }
            }
            e.preventDefault();
            listEl.scrollTop += e.deltaY / ensureWheelScale();
            listEl.scrollLeft += e.deltaX / ensureWheelScale();
            syncViewport();
            wheelCatched = true;
            beforeNextFrameOnce(() => {
              wheelCatched = false;
            });
          }
        }
      }
      function handleListResize(entry) {
        if (isDeactivated)
          return;
        if (isHideByVShow(entry.target))
          return;
        if (props.renderCol == null && props.renderItemWithCols == null) {
          if (entry.contentRect.height === listHeightRef.value)
            return;
        } else {
          if (entry.contentRect.height === listHeightRef.value && entry.contentRect.width === listWidthRef.value) {
            return;
          }
        }
        listHeightRef.value = entry.contentRect.height;
        listWidthRef.value = entry.contentRect.width;
        const { onResize } = props;
        if (onResize !== void 0)
          onResize(entry);
      }
      function syncViewport() {
        const { value: listEl } = listElRef;
        if (listEl == null)
          return;
        scrollTopRef.value = listEl.scrollTop;
        scrollLeftRef.value = listEl.scrollLeft;
      }
      function isHideByVShow(el) {
        let cursor = el;
        while (cursor !== null) {
          if (cursor.style.display === "none")
            return true;
          cursor = cursor.parentElement;
        }
        return false;
      }
      return {
        listHeight: listHeightRef,
        listStyle: {
          overflow: "auto"
        },
        keyToIndex: keyIndexMapRef,
        itemsStyle: vue.computed(() => {
          const { itemResizable } = props;
          const height = pxfy(finweckTreeRef.value.sum());
          finweckTreeUpdateTrigger.value;
          return [
            props.itemsStyle,
            {
              boxSizing: "content-box",
              width: pxfy(totalWidthRef.value),
              height: itemResizable ? "" : height,
              minHeight: itemResizable ? height : "",
              paddingTop: pxfy(props.paddingTop),
              paddingBottom: pxfy(props.paddingBottom)
            }
          ];
        }),
        visibleItemsStyle: vue.computed(() => {
          finweckTreeUpdateTrigger.value;
          return {
            transform: `translateY(${pxfy(finweckTreeRef.value.sum(startIndexRef.value))})`
          };
        }),
        viewportItems: viewportItemsRef,
        listElRef,
        itemsElRef: vue.ref(null),
        scrollTo,
        handleListResize,
        handleListScroll,
        handleListWheel,
        handleItemResize
      };
    },
    render() {
      const { itemResizable, keyField, keyToIndex, visibleItemsTag } = this;
      return vue.h(VResizeObserver, {
        onResize: this.handleListResize
      }, {
        default: () => {
          var _a, _b;
          return vue.h("div", vue.mergeProps(this.$attrs, {
            class: ["v-vl", this.showScrollbar && "v-vl--show-scrollbar"],
            onScroll: this.handleListScroll,
            onWheel: this.handleListWheel,
            ref: "listElRef"
          }), [
            this.items.length !== 0 ? vue.h("div", {
              ref: "itemsElRef",
              class: "v-vl-items",
              style: this.itemsStyle
            }, [
              vue.h(visibleItemsTag, Object.assign({
                class: "v-vl-visible-items",
                style: this.visibleItemsStyle
              }, this.visibleItemsProps), {
                default: () => {
                  const { renderCol, renderItemWithCols } = this;
                  return this.viewportItems.map((item) => {
                    const key = item[keyField];
                    const index = keyToIndex.get(key);
                    const renderedCols = renderCol != null ? vue.h(VirtualListRow, {
                      index,
                      item
                    }) : void 0;
                    const renderedItemWithCols = renderItemWithCols != null ? vue.h(VirtualListRow, {
                      index,
                      item
                    }) : void 0;
                    const itemVNode = this.$slots.default({
                      item,
                      renderedCols,
                      renderedItemWithCols,
                      index
                    })[0];
                    if (itemResizable) {
                      return vue.h(VResizeObserver, {
                        key,
                        onResize: (entry) => this.handleItemResize(key, entry)
                      }, {
                        default: () => itemVNode
                      });
                    }
                    itemVNode.key = key;
                    return itemVNode;
                  });
                }
              })
            ]) : (_b = (_a = this.$slots).empty) === null || _b === void 0 ? void 0 : _b.call(_a)
          ]);
        }
      });
    }
  });
  const styles = c(".v-x-scroll", {
    overflow: "auto",
    scrollbarWidth: "none"
  }, [
    c("&::-webkit-scrollbar", {
      width: 0,
      height: 0
    })
  ]);
  const VXScroll = vue.defineComponent({
    name: "XScroll",
    props: {
      disabled: Boolean,
      onScroll: Function
    },
    setup() {
      const selfRef = vue.ref(null);
      function handleWheel(e) {
        const preventYWheel = e.currentTarget.offsetWidth < e.currentTarget.scrollWidth;
        if (!preventYWheel || e.deltaY === 0)
          return;
        e.currentTarget.scrollLeft += e.deltaY + e.deltaX;
        e.preventDefault();
      }
      const ssrAdapter2 = useSsrAdapter();
      styles.mount({
        id: "vueuc/x-scroll",
        head: true,
        anchorMetaName: cssrAnchorMetaName$1,
        ssr: ssrAdapter2
      });
      const exposedMethods = {
        scrollTo(...args) {
          var _a;
          (_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(...args);
        }
      };
      return Object.assign({
        selfRef,
        handleWheel
      }, exposedMethods);
    },
    render() {
      return vue.h("div", {
        ref: "selfRef",
        onScroll: this.onScroll,
        onWheel: this.disabled ? void 0 : this.handleWheel,
        class: "v-x-scroll"
      }, this.$slots);
    }
  });
  const hiddenAttr = "v-hidden";
  const style$1E = c("[v-hidden]", {
    display: "none!important"
  });
  const VOverflow = vue.defineComponent({
    name: "Overflow",
    props: {
      getCounter: Function,
      getTail: Function,
      updateCounter: Function,
      onUpdateCount: Function,
      onUpdateOverflow: Function
    },
    setup(props, { slots }) {
      const selfRef = vue.ref(null);
      const counterRef = vue.ref(null);
      function deriveCounter(options) {
        const { value: self2 } = selfRef;
        const { getCounter, getTail } = props;
        let counter;
        if (getCounter !== void 0)
          counter = getCounter();
        else {
          counter = counterRef.value;
        }
        if (!self2 || !counter)
          return;
        if (counter.hasAttribute(hiddenAttr)) {
          counter.removeAttribute(hiddenAttr);
        }
        const { children } = self2;
        if (options.showAllItemsBeforeCalculate) {
          for (const child of children) {
            if (child.hasAttribute(hiddenAttr)) {
              child.removeAttribute(hiddenAttr);
            }
          }
        }
        const containerWidth = self2.offsetWidth;
        const childWidths = [];
        const tail = slots.tail ? getTail === null || getTail === void 0 ? void 0 : getTail() : null;
        let childWidthSum = tail ? tail.offsetWidth : 0;
        let overflow = false;
        const len2 = self2.children.length - (slots.tail ? 1 : 0);
        for (let i = 0; i < len2 - 1; ++i) {
          if (i < 0)
            continue;
          const child = children[i];
          if (overflow) {
            if (!child.hasAttribute(hiddenAttr)) {
              child.setAttribute(hiddenAttr, "");
            }
            continue;
          } else if (child.hasAttribute(hiddenAttr)) {
            child.removeAttribute(hiddenAttr);
          }
          const childWidth = child.offsetWidth;
          childWidthSum += childWidth;
          childWidths[i] = childWidth;
          if (childWidthSum > containerWidth) {
            const { updateCounter } = props;
            for (let j = i; j >= 0; --j) {
              const restCount = len2 - 1 - j;
              if (updateCounter !== void 0) {
                updateCounter(restCount);
              } else {
                counter.textContent = `${restCount}`;
              }
              const counterWidth = counter.offsetWidth;
              childWidthSum -= childWidths[j];
              if (childWidthSum + counterWidth <= containerWidth || j === 0) {
                overflow = true;
                i = j - 1;
                if (tail) {
                  if (i === -1) {
                    tail.style.maxWidth = `${containerWidth - counterWidth}px`;
                    tail.style.boxSizing = "border-box";
                  } else {
                    tail.style.maxWidth = "";
                  }
                }
                const { onUpdateCount } = props;
                if (onUpdateCount)
                  onUpdateCount(restCount);
                break;
              }
            }
          }
        }
        const { onUpdateOverflow } = props;
        if (!overflow) {
          if (onUpdateOverflow !== void 0) {
            onUpdateOverflow(false);
          }
          counter.setAttribute(hiddenAttr, "");
        } else {
          if (onUpdateOverflow !== void 0) {
            onUpdateOverflow(true);
          }
        }
      }
      const ssrAdapter2 = useSsrAdapter();
      style$1E.mount({
        id: "vueuc/overflow",
        head: true,
        anchorMetaName: cssrAnchorMetaName$1,
        ssr: ssrAdapter2
      });
      vue.onMounted(() => deriveCounter({
        showAllItemsBeforeCalculate: false
      }));
      return {
        selfRef,
        counterRef,
        sync: deriveCounter
      };
    },
    render() {
      const { $slots } = this;
      vue.nextTick(() => this.sync({
        showAllItemsBeforeCalculate: false
      }));
      return vue.h("div", {
        class: "v-overflow",
        ref: "selfRef"
      }, [
        vue.renderSlot($slots, "default"),
        // $slots.counter should only has 1 element
        $slots.counter ? $slots.counter() : vue.h("span", {
          style: {
            display: "inline-block"
          },
          ref: "counterRef"
        }),
        // $slots.tail should only has 1 element
        $slots.tail ? $slots.tail() : null
      ]);
    }
  });
  function isHTMLElement(node) {
    return node instanceof HTMLElement;
  }
  function focusFirstDescendant(node) {
    for (let i = 0; i < node.childNodes.length; i++) {
      const child = node.childNodes[i];
      if (isHTMLElement(child)) {
        if (attemptFocus(child) || focusFirstDescendant(child)) {
          return true;
        }
      }
    }
    return false;
  }
  function focusLastDescendant(element) {
    for (let i = element.childNodes.length - 1; i >= 0; i--) {
      const child = element.childNodes[i];
      if (isHTMLElement(child)) {
        if (attemptFocus(child) || focusLastDescendant(child)) {
          return true;
        }
      }
    }
    return false;
  }
  function attemptFocus(element) {
    if (!isFocusable(element)) {
      return false;
    }
    try {
      element.focus({ preventScroll: true });
    } catch (e) {
    }
    return document.activeElement === element;
  }
  function isFocusable(element) {
    if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
      return true;
    }
    if (element.getAttribute("disabled")) {
      return false;
    }
    switch (element.nodeName) {
      case "A":
        return !!element.href && element.rel !== "ignore";
      case "INPUT":
        return element.type !== "hidden" && element.type !== "file";
      case "BUTTON":
      case "SELECT":
      case "TEXTAREA":
        return true;
      default:
        return false;
    }
  }
  let stack = [];
  const FocusTrap = vue.defineComponent({
    name: "FocusTrap",
    props: {
      disabled: Boolean,
      active: Boolean,
      autoFocus: {
        type: Boolean,
        default: true
      },
      onEsc: Function,
      initialFocusTo: String,
      finalFocusTo: String,
      returnFocusOnDeactivated: {
        type: Boolean,
        default: true
      }
    },
    setup(props) {
      const id = createId();
      const focusableStartRef = vue.ref(null);
      const focusableEndRef = vue.ref(null);
      let activated = false;
      let ignoreInternalFocusChange = false;
      const lastFocusedElement = typeof document === "undefined" ? null : document.activeElement;
      function isCurrentActive() {
        const currentActiveId = stack[stack.length - 1];
        return currentActiveId === id;
      }
      function handleDocumentKeydown(e) {
        var _a;
        if (e.code === "Escape") {
          if (isCurrentActive()) {
            (_a = props.onEsc) === null || _a === void 0 ? void 0 : _a.call(props, e);
          }
        }
      }
      vue.onMounted(() => {
        vue.watch(() => props.active, (value) => {
          if (value) {
            activate();
            on("keydown", document, handleDocumentKeydown);
          } else {
            off("keydown", document, handleDocumentKeydown);
            if (activated) {
              deactivate();
            }
          }
        }, {
          immediate: true
        });
      });
      vue.onBeforeUnmount(() => {
        off("keydown", document, handleDocumentKeydown);
        if (activated)
          deactivate();
      });
      function handleDocumentFocus(e) {
        if (ignoreInternalFocusChange)
          return;
        if (isCurrentActive()) {
          const mainEl = getMainEl();
          if (mainEl === null)
            return;
          if (mainEl.contains(getPreciseEventTarget(e)))
            return;
          resetFocusTo("first");
        }
      }
      function getMainEl() {
        const focusableStartEl = focusableStartRef.value;
        if (focusableStartEl === null)
          return null;
        let mainEl = focusableStartEl;
        while (true) {
          mainEl = mainEl.nextSibling;
          if (mainEl === null)
            break;
          if (mainEl instanceof Element && mainEl.tagName === "DIV") {
            break;
          }
        }
        return mainEl;
      }
      function activate() {
        var _a;
        if (props.disabled)
          return;
        stack.push(id);
        if (props.autoFocus) {
          const { initialFocusTo } = props;
          if (initialFocusTo === void 0) {
            resetFocusTo("first");
          } else {
            (_a = resolveTo(initialFocusTo)) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
          }
        }
        activated = true;
        document.addEventListener("focus", handleDocumentFocus, true);
      }
      function deactivate() {
        var _a;
        if (props.disabled)
          return;
        document.removeEventListener("focus", handleDocumentFocus, true);
        stack = stack.filter((idInStack) => idInStack !== id);
        if (isCurrentActive())
          return;
        const { finalFocusTo } = props;
        if (finalFocusTo !== void 0) {
          (_a = resolveTo(finalFocusTo)) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
        } else if (props.returnFocusOnDeactivated) {
          if (lastFocusedElement instanceof HTMLElement) {
            ignoreInternalFocusChange = true;
            lastFocusedElement.focus({ preventScroll: true });
            ignoreInternalFocusChange = false;
          }
        }
      }
      function resetFocusTo(target) {
        if (!isCurrentActive())
          return;
        if (props.active) {
          const focusableStartEl = focusableStartRef.value;
          const focusableEndEl = focusableEndRef.value;
          if (focusableStartEl !== null && focusableEndEl !== null) {
            const mainEl = getMainEl();
            if (mainEl == null || mainEl === focusableEndEl) {
              ignoreInternalFocusChange = true;
              focusableStartEl.focus({ preventScroll: true });
              ignoreInternalFocusChange = false;
              return;
            }
            ignoreInternalFocusChange = true;
            const focused = target === "first" ? focusFirstDescendant(mainEl) : focusLastDescendant(mainEl);
            ignoreInternalFocusChange = false;
            if (!focused) {
              ignoreInternalFocusChange = true;
              focusableStartEl.focus({ preventScroll: true });
              ignoreInternalFocusChange = false;
            }
          }
        }
      }
      function handleStartFocus(e) {
        if (ignoreInternalFocusChange)
          return;
        const mainEl = getMainEl();
        if (mainEl === null)
          return;
        if (e.relatedTarget !== null && mainEl.contains(e.relatedTarget)) {
          resetFocusTo("last");
        } else {
          resetFocusTo("first");
        }
      }
      function handleEndFocus(e) {
        if (ignoreInternalFocusChange)
          return;
        if (e.relatedTarget !== null && e.relatedTarget === focusableStartRef.value) {
          resetFocusTo("last");
        } else {
          resetFocusTo("first");
        }
      }
      return {
        focusableStartRef,
        focusableEndRef,
        focusableStyle: "position: absolute; height: 0; width: 0;",
        handleStartFocus,
        handleEndFocus
      };
    },
    render() {
      const { default: defaultSlot } = this.$slots;
      if (defaultSlot === void 0)
        return null;
      if (this.disabled)
        return defaultSlot();
      const { active, focusableStyle } = this;
      return vue.h(vue.Fragment, null, [
        vue.h("div", {
          "aria-hidden": "true",
          tabindex: active ? "0" : "-1",
          ref: "focusableStartRef",
          style: focusableStyle,
          onFocus: this.handleStartFocus
        }),
        defaultSlot(),
        vue.h("div", {
          "aria-hidden": "true",
          style: focusableStyle,
          ref: "focusableEndRef",
          tabindex: active ? "0" : "-1",
          onFocus: this.handleEndFocus
        })
      ]);
    }
  });
  function useOnResize(elRef, onResize) {
    if (onResize) {
      vue.onMounted(() => {
        const {
          value: el
        } = elRef;
        if (el) {
          resizeObserverManager.registerHandler(el, onResize);
        }
      });
      vue.onBeforeUnmount(() => {
        const {
          value: el
        } = elRef;
        if (el) {
          resizeObserverManager.unregisterHandler(el);
        }
      });
    }
  }
  let lockCount = 0;
  let originalMarginRight = "";
  let originalOverflow = "";
  let originalOverflowX = "";
  let originalOverflowY = "";
  const lockHtmlScrollRightCompensationRef = vue.ref("0px");
  function useLockHtmlScroll(lockRef) {
    if (typeof document === "undefined")
      return;
    const el = document.documentElement;
    let watchStopHandle;
    let activated = false;
    const unlock = () => {
      el.style.marginRight = originalMarginRight;
      el.style.overflow = originalOverflow;
      el.style.overflowX = originalOverflowX;
      el.style.overflowY = originalOverflowY;
      lockHtmlScrollRightCompensationRef.value = "0px";
    };
    vue.onMounted(() => {
      watchStopHandle = vue.watch(lockRef, (value) => {
        if (value) {
          if (!lockCount) {
            const scrollbarWidth = window.innerWidth - el.offsetWidth;
            if (scrollbarWidth > 0) {
              originalMarginRight = el.style.marginRight;
              el.style.marginRight = `${scrollbarWidth}px`;
              lockHtmlScrollRightCompensationRef.value = `${scrollbarWidth}px`;
            }
            originalOverflow = el.style.overflow;
            originalOverflowX = el.style.overflowX;
            originalOverflowY = el.style.overflowY;
            el.style.overflow = "hidden";
            el.style.overflowX = "hidden";
            el.style.overflowY = "hidden";
          }
          activated = true;
          lockCount++;
        } else {
          lockCount--;
          if (!lockCount) {
            unlock();
          }
          activated = false;
        }
      }, {
        immediate: true
      });
    });
    vue.onBeforeUnmount(() => {
      watchStopHandle === null || watchStopHandle === void 0 ? void 0 : watchStopHandle();
      if (activated) {
        lockCount--;
        if (!lockCount) {
          unlock();
        }
        activated = false;
      }
    });
  }
  const isComposingRef = vue.ref(false);
  function compositionStartHandler() {
    isComposingRef.value = true;
  }
  function compositionEndHandler() {
    isComposingRef.value = false;
  }
  let mountedCount = 0;
  function useIsComposing() {
    if (isBrowser$2) {
      vue.onBeforeMount(() => {
        if (!mountedCount) {
          window.addEventListener("compositionstart", compositionStartHandler);
          window.addEventListener("compositionend", compositionEndHandler);
        }
        mountedCount++;
      });
      vue.onBeforeUnmount(() => {
        if (mountedCount <= 1) {
          window.removeEventListener("compositionstart", compositionStartHandler);
          window.removeEventListener("compositionend", compositionEndHandler);
          mountedCount = 0;
        } else {
          mountedCount--;
        }
      });
    }
    return isComposingRef;
  }
  function useReactivated(callback) {
    const isDeactivatedRef = {
      isDeactivated: false
    };
    let activateStateInitialized = false;
    vue.onActivated(() => {
      isDeactivatedRef.isDeactivated = false;
      if (!activateStateInitialized) {
        activateStateInitialized = true;
        return;
      }
      callback();
    });
    vue.onDeactivated(() => {
      isDeactivatedRef.isDeactivated = true;
      if (!activateStateInitialized) {
        activateStateInitialized = true;
      }
    });
    return isDeactivatedRef;
  }
  function isDocument(node) {
    return node.nodeName === "#document";
  }
  function download(url, name) {
    if (!url)
      return;
    const a2 = document.createElement("a");
    a2.href = url;
    if (name !== void 0) {
      a2.download = name;
    }
    document.body.appendChild(a2);
    a2.click();
    document.body.removeChild(a2);
  }
  const formItemInjectionKey = createInjectionKey("n-form-item");
  function useFormItem(props, {
    defaultSize = "medium",
    mergedSize,
    mergedDisabled
  } = {}) {
    const NFormItem2 = vue.inject(formItemInjectionKey, null);
    vue.provide(formItemInjectionKey, null);
    const mergedSizeRef = vue.computed(mergedSize ? () => mergedSize(NFormItem2) : () => {
      const {
        size: size2
      } = props;
      if (size2)
        return size2;
      if (NFormItem2) {
        const {
          mergedSize: mergedSize2
        } = NFormItem2;
        if (mergedSize2.value !== void 0) {
          return mergedSize2.value;
        }
      }
      return defaultSize;
    });
    const mergedDisabledRef = vue.computed(mergedDisabled ? () => mergedDisabled(NFormItem2) : () => {
      const {
        disabled
      } = props;
      if (disabled !== void 0) {
        return disabled;
      }
      if (NFormItem2) {
        return NFormItem2.disabled.value;
      }
      return false;
    });
    const mergedStatusRef = vue.computed(() => {
      const {
        status
      } = props;
      if (status)
        return status;
      return NFormItem2 === null || NFormItem2 === void 0 ? void 0 : NFormItem2.mergedValidationStatus.value;
    });
    vue.onBeforeUnmount(() => {
      if (NFormItem2) {
        NFormItem2.restoreValidation();
      }
    });
    return {
      mergedSizeRef,
      mergedDisabledRef,
      mergedStatusRef,
      nTriggerFormBlur() {
        if (NFormItem2) {
          NFormItem2.handleContentBlur();
        }
      },
      nTriggerFormChange() {
        if (NFormItem2) {
          NFormItem2.handleContentChange();
        }
      },
      nTriggerFormFocus() {
        if (NFormItem2) {
          NFormItem2.handleContentFocus();
        }
      },
      nTriggerFormInput() {
        if (NFormItem2) {
          NFormItem2.handleContentInput();
        }
      }
    };
  }
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var Symbol$1 = root.Symbol;
  var objectProto$e = Object.prototype;
  var hasOwnProperty$b = objectProto$e.hasOwnProperty;
  var nativeObjectToString$1 = objectProto$e.toString;
  var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
    try {
      value[symToStringTag$1] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }
  var objectProto$d = Object.prototype;
  var nativeObjectToString = objectProto$d.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  var symbolTag$1 = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$1;
  }
  function arrayMap(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }
  var isArray = Array.isArray;
  var INFINITY$2 = 1 / 0;
  var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY$2 ? "-0" : result;
  }
  var reWhitespace = /\s/;
  function trimmedEndIndex(string2) {
    var index = string2.length;
    while (index-- && reWhitespace.test(string2.charAt(index))) {
    }
    return index;
  }
  var reTrimStart = /^\s+/;
  function baseTrim(string2) {
    return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
  }
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  var INFINITY$1 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY$1 || value === -INFINITY$1) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  function identity(value) {
    return value;
  }
  var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  var funcProto$2 = Function.prototype;
  var funcToString$2 = funcProto$2.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString$2.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto$1 = Function.prototype, objectProto$c = Object.prototype;
  var funcToString$1 = funcProto$1.toString;
  var hasOwnProperty$a = objectProto$c.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function getValue$1(object, key) {
    return object == null ? void 0 : object[key];
  }
  function getNative(object, key) {
    var value = getValue$1(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  var WeakMap$1 = getNative(root, "WeakMap");
  var objectCreate = Object.create;
  var baseCreate = /* @__PURE__ */ function() {
    function object() {
    }
    return function(proto) {
      if (!isObject(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object();
      object.prototype = void 0;
      return result;
    };
  }();
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }
  var HOT_COUNT = 800, HOT_SPAN = 16;
  var nativeNow = Date.now;
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  function constant(value) {
    return function() {
      return value;
    };
  }
  var defineProperty = function() {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  }();
  var baseSetToString = !defineProperty ? identity : function(func, string2) {
    return defineProperty(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant(string2),
      "writable": true
    });
  };
  const baseSetToString$1 = baseSetToString;
  var setToString = shortOut(baseSetToString$1);
  var MAX_SAFE_INTEGER$1 = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER$1 : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function baseAssignValue(object, key, value) {
    if (key == "__proto__" && defineProperty) {
      defineProperty(object, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object[key] = value;
    }
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  var objectProto$b = Object.prototype;
  var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty$9.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
      if (newValue === void 0) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }
  var nativeMax$1 = Math.max;
  function overRest(func, start, transform) {
    start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index = -1, length = nativeMax$1(args.length - start, 0), array = Array(length);
      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity), func + "");
  }
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index;
    if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
      return eq(object[index], value);
    }
    return false;
  }
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? void 0 : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  }
  var objectProto$a = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$a;
    return value === proto;
  }
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  var argsTag$2 = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag$2;
  }
  var objectProto$9 = Object.prototype;
  var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
  var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
  var isArguments = baseIsArguments(/* @__PURE__ */ function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty$8.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
  };
  function stubFalse() {
    return false;
  }
  var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
  var Buffer$1 = moduleExports$2 ? root.Buffer : void 0;
  var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
  var isBuffer = nativeIsBuffer || stubFalse;
  var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]";
  var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
  var freeProcess = moduleExports$1 && freeGlobal.process;
  var nodeUtil = function() {
    try {
      var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  var objectProto$8 = Object.prototype;
  var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty$7.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
      isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  var nativeKeys = overArg(Object.keys, Object);
  var objectProto$7 = Object.prototype;
  var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty$6.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }
  var objectProto$6 = Object.prototype;
  var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty$5.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }
  var nativeCreate = getNative(Object, "create");
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
  var objectProto$5 = Object.prototype;
  var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED$2 ? void 0 : result;
    }
    return hasOwnProperty$4.call(data, key) ? data[key] : void 0;
  }
  var objectProto$4 = Object.prototype;
  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty$3.call(data, key);
  }
  var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
    return this;
  }
  function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  var Map$1 = getNative(root, "Map");
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map$1 || ListCache)(),
      "string": new Hash()
    };
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function getMapData(map2, key) {
    var data = map2.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function mapCacheDelete(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    var data = getMapData(this, key), size2 = data.size;
    data.set(key, value);
    this.size += data.size == size2 ? 0 : 1;
    return this;
  }
  function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  var FUNC_ERROR_TEXT$2 = "Expected a function";
  function memoize(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT$2);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
      if (cache2.has(key)) {
        return cache2.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache2.set(key, result) || cache2;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }
  memoize.Cache = MapCache;
  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped(func) {
    var result = memoize(func, function(key) {
      if (cache2.size === MAX_MEMOIZE_SIZE) {
        cache2.clear();
      }
      return key;
    });
    var cache2 = result.cache;
    return result;
  }
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function(string2) {
    var result = [];
    if (string2.charCodeAt(0) === 46) {
      result.push("");
    }
    string2.replace(rePropName, function(match2, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
    });
    return result;
  });
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  function castPath(value, object) {
    if (isArray(value)) {
      return value;
    }
    return isKey(value, object) ? [value] : stringToPath(toString(value));
  }
  var INFINITY = 1 / 0;
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  function baseGet(object, path) {
    path = castPath(path, object);
    var index = 0, length = path.length;
    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }
    return index && index == length ? object : void 0;
  }
  function get(object, path, defaultValue) {
    var result = object == null ? void 0 : baseGet(object, path);
    return result === void 0 ? defaultValue : result;
  }
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  var objectTag$2 = "[object Object]";
  var funcProto = Function.prototype, objectProto$3 = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag$2) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty$2.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  function baseSlice(array, start, end) {
    var index = -1, length = array.length;
    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }
  function castSlice(array, start, end) {
    var length = array.length;
    end = end === void 0 ? length : end;
    return !start && end >= length ? array : baseSlice(array, start, end);
  }
  var rsAstralRange$2 = "\\ud800-\\udfff", rsComboMarksRange$3 = "\\u0300-\\u036f", reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$3 = "\\u20d0-\\u20ff", rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3, rsVarRange$2 = "\\ufe0e\\ufe0f";
  var rsZWJ$2 = "\\u200d";
  var reHasUnicode = RegExp("[" + rsZWJ$2 + rsAstralRange$2 + rsComboRange$3 + rsVarRange$2 + "]");
  function hasUnicode(string2) {
    return reHasUnicode.test(string2);
  }
  function asciiToArray(string2) {
    return string2.split("");
  }
  var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$2 = "\\u0300-\\u036f", reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$2 = "\\u20d0-\\u20ff", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2, rsVarRange$1 = "\\ufe0e\\ufe0f";
  var rsAstral = "[" + rsAstralRange$1 + "]", rsCombo$2 = "[" + rsComboRange$2 + "]", rsFitz$1 = "\\ud83c[\\udffb-\\udfff]", rsModifier$1 = "(?:" + rsCombo$2 + "|" + rsFitz$1 + ")", rsNonAstral$1 = "[^" + rsAstralRange$1 + "]", rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ$1 = "\\u200d";
  var reOptMod$1 = rsModifier$1 + "?", rsOptVar$1 = "[" + rsVarRange$1 + "]?", rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsSymbol = "(?:" + [rsNonAstral$1 + rsCombo$2 + "?", rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join("|") + ")";
  var reUnicode = RegExp(rsFitz$1 + "(?=" + rsFitz$1 + ")|" + rsSymbol + rsSeq$1, "g");
  function unicodeToArray(string2) {
    return string2.match(reUnicode) || [];
  }
  function stringToArray(string2) {
    return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
  }
  function createCaseFirst(methodName) {
    return function(string2) {
      string2 = toString(string2);
      var strSymbols = hasUnicode(string2) ? stringToArray(string2) : void 0;
      var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
      var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
      return chr[methodName]() + trailing;
    };
  }
  var upperFirst = createCaseFirst("toUpperCase");
  function capitalize(string2) {
    return upperFirst(toString(string2).toLowerCase());
  }
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? void 0 : object[key];
    };
  }
  var deburredLetters = {
    // Latin-1 Supplement block.
    "À": "A",
    "Á": "A",
    "Â": "A",
    "Ã": "A",
    "Ä": "A",
    "Å": "A",
    "à": "a",
    "á": "a",
    "â": "a",
    "ã": "a",
    "ä": "a",
    "å": "a",
    "Ç": "C",
    "ç": "c",
    "Ð": "D",
    "ð": "d",
    "È": "E",
    "É": "E",
    "Ê": "E",
    "Ë": "E",
    "è": "e",
    "é": "e",
    "ê": "e",
    "ë": "e",
    "Ì": "I",
    "Í": "I",
    "Î": "I",
    "Ï": "I",
    "ì": "i",
    "í": "i",
    "î": "i",
    "ï": "i",
    "Ñ": "N",
    "ñ": "n",
    "Ò": "O",
    "Ó": "O",
    "Ô": "O",
    "Õ": "O",
    "Ö": "O",
    "Ø": "O",
    "ò": "o",
    "ó": "o",
    "ô": "o",
    "õ": "o",
    "ö": "o",
    "ø": "o",
    "Ù": "U",
    "Ú": "U",
    "Û": "U",
    "Ü": "U",
    "ù": "u",
    "ú": "u",
    "û": "u",
    "ü": "u",
    "Ý": "Y",
    "ý": "y",
    "ÿ": "y",
    "Æ": "Ae",
    "æ": "ae",
    "Þ": "Th",
    "þ": "th",
    "ß": "ss",
    // Latin Extended-A block.
    "Ā": "A",
    "Ă": "A",
    "Ą": "A",
    "ā": "a",
    "ă": "a",
    "ą": "a",
    "Ć": "C",
    "Ĉ": "C",
    "Ċ": "C",
    "Č": "C",
    "ć": "c",
    "ĉ": "c",
    "ċ": "c",
    "č": "c",
    "Ď": "D",
    "Đ": "D",
    "ď": "d",
    "đ": "d",
    "Ē": "E",
    "Ĕ": "E",
    "Ė": "E",
    "Ę": "E",
    "Ě": "E",
    "ē": "e",
    "ĕ": "e",
    "ė": "e",
    "ę": "e",
    "ě": "e",
    "Ĝ": "G",
    "Ğ": "G",
    "Ġ": "G",
    "Ģ": "G",
    "ĝ": "g",
    "ğ": "g",
    "ġ": "g",
    "ģ": "g",
    "Ĥ": "H",
    "Ħ": "H",
    "ĥ": "h",
    "ħ": "h",
    "Ĩ": "I",
    "Ī": "I",
    "Ĭ": "I",
    "Į": "I",
    "İ": "I",
    "ĩ": "i",
    "ī": "i",
    "ĭ": "i",
    "į": "i",
    "ı": "i",
    "Ĵ": "J",
    "ĵ": "j",
    "Ķ": "K",
    "ķ": "k",
    "ĸ": "k",
    "Ĺ": "L",
    "Ļ": "L",
    "Ľ": "L",
    "Ŀ": "L",
    "Ł": "L",
    "ĺ": "l",
    "ļ": "l",
    "ľ": "l",
    "ŀ": "l",
    "ł": "l",
    "Ń": "N",
    "Ņ": "N",
    "Ň": "N",
    "Ŋ": "N",
    "ń": "n",
    "ņ": "n",
    "ň": "n",
    "ŋ": "n",
    "Ō": "O",
    "Ŏ": "O",
    "Ő": "O",
    "ō": "o",
    "ŏ": "o",
    "ő": "o",
    "Ŕ": "R",
    "Ŗ": "R",
    "Ř": "R",
    "ŕ": "r",
    "ŗ": "r",
    "ř": "r",
    "Ś": "S",
    "Ŝ": "S",
    "Ş": "S",
    "Š": "S",
    "ś": "s",
    "ŝ": "s",
    "ş": "s",
    "š": "s",
    "Ţ": "T",
    "Ť": "T",
    "Ŧ": "T",
    "ţ": "t",
    "ť": "t",
    "ŧ": "t",
    "Ũ": "U",
    "Ū": "U",
    "Ŭ": "U",
    "Ů": "U",
    "Ű": "U",
    "Ų": "U",
    "ũ": "u",
    "ū": "u",
    "ŭ": "u",
    "ů": "u",
    "ű": "u",
    "ų": "u",
    "Ŵ": "W",
    "ŵ": "w",
    "Ŷ": "Y",
    "ŷ": "y",
    "Ÿ": "Y",
    "Ź": "Z",
    "Ż": "Z",
    "Ž": "Z",
    "ź": "z",
    "ż": "z",
    "ž": "z",
    "Ĳ": "IJ",
    "ĳ": "ij",
    "Œ": "Oe",
    "œ": "oe",
    "ŉ": "'n",
    "ſ": "s"
  };
  var deburrLetter = basePropertyOf(deburredLetters);
  const deburrLetter$1 = deburrLetter;
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
  var rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
  var rsCombo$1 = "[" + rsComboRange$1 + "]";
  var reComboMark = RegExp(rsCombo$1, "g");
  function deburr(string2) {
    string2 = toString(string2);
    return string2 && string2.replace(reLatin, deburrLetter$1).replace(reComboMark, "");
  }
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
  function asciiWords(string2) {
    return string2.match(reAsciiWord) || [];
  }
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
  function hasUnicodeWord(string2) {
    return reHasUnicodeWord.test(string2);
  }
  var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
  var rsApos$1 = "['’]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
  var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
  var reUnicodeWord = RegExp([
    rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
    rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
    rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
    rsUpper + "+" + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join("|"), "g");
  function unicodeWords(string2) {
    return string2.match(reUnicodeWord) || [];
  }
  function words(string2, pattern, guard) {
    string2 = toString(string2);
    pattern = guard ? void 0 : pattern;
    if (pattern === void 0) {
      return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
    }
    return string2.match(pattern) || [];
  }
  var rsApos = "['’]";
  var reApos = RegExp(rsApos, "g");
  function createCompounder(callback) {
    return function(string2) {
      return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
    };
  }
  var camelCase = createCompounder(function(result, word, index) {
    word = word.toLowerCase();
    return result + (index ? capitalize(word) : word);
  });
  var nativeIsFinite = root.isFinite, nativeMin$1 = Math.min;
  function createRound(methodName) {
    var func = Math[methodName];
    return function(number, precision) {
      number = toNumber(number);
      precision = precision == null ? 0 : nativeMin$1(toInteger(precision), 292);
      if (precision && nativeIsFinite(number)) {
        var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
        pair = (toString(value) + "e").split("e");
        return +(pair[0] + "e" + (+pair[1] - precision));
      }
      return func(number);
    };
  }
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  var LARGE_ARRAY_SIZE = 200;
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  function arrayFilter(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  function stubArray() {
    return [];
  }
  var objectProto$2 = Object.prototype;
  var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  const getSymbols$1 = getSymbols;
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols$1);
  }
  var DataView = getNative(root, "DataView");
  var Promise$1 = getNative(root, "Promise");
  var Set$1 = getNative(root, "Set");
  var mapTag$1 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$1 = "[object Set]", weakMapTag = "[object WeakMap]";
  var dataViewTag$1 = "[object DataView]";
  var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
  var getTag = baseGetTag;
  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$1 || Map$1 && getTag(new Map$1()) != mapTag$1 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$1 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag) {
    getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag$1;
          case mapCtorString:
            return mapTag$1;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag$1;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  const getTag$1 = getTag;
  var Uint8Array2 = root.Uint8Array;
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
    return result;
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  function SetCache(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache();
    while (++index < length) {
      this.add(values[index]);
    }
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function arraySome(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }
  function cacheHas(cache2, key) {
    return cache2.has(key);
  }
  var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack2.get(array);
    var othStacked = stack2.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }
    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
    stack2.set(array, other);
    stack2.set(other, array);
    while (++index < arrLength) {
      var arrValue = array[index], othValue = other[index];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack2) : customizer(arrValue, othValue, index, array, other, stack2);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
        result = false;
        break;
      }
    }
    stack2["delete"](array);
    stack2["delete"](other);
    return result;
  }
  function mapToArray(map2) {
    var index = -1, result = Array(map2.size);
    map2.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  function setToArray(set2) {
    var index = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
  var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
  var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq(+object, +other);
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case regexpTag:
      case stringTag:
        return object == other + "";
      case mapTag:
        var convert2 = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
        convert2 || (convert2 = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack2.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG$2;
        stack2.set(object, other);
        var result = equalArrays(convert2(object), convert2(other), bitmask, customizer, equalFunc, stack2);
        stack2["delete"](object);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  var COMPARE_PARTIAL_FLAG$3 = 1;
  var objectProto$1 = Object.prototype;
  var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
        return false;
      }
    }
    var objStacked = stack2.get(object);
    var othStacked = stack2.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }
    var result = true;
    stack2.set(object, other);
    stack2.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack2["delete"](object);
    stack2["delete"](other);
    return result;
  }
  var COMPARE_PARTIAL_FLAG$2 = 1;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack2 || (stack2 = new Stack());
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack2 || (stack2 = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack2 || (stack2 = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
  }
  function baseIsEqual(value, other, bitmask, customizer, stack2) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
  }
  var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length, length = index, noCustomizer = !customizer;
    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index--) {
      var data = matchData[index];
      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
        return false;
      }
    }
    while (++index < length) {
      data = matchData[index];
      var key = data[0], objValue = object[key], srcValue = data[1];
      if (noCustomizer && data[2]) {
        if (objValue === void 0 && !(key in object)) {
          return false;
        }
      } else {
        var stack2 = new Stack();
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack2);
        }
        if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack2) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  function isStrictComparable(value) {
    return value === value && !isObject(value);
  }
  function getMatchData(object) {
    var result = keys(object), length = result.length;
    while (length--) {
      var key = result[length], value = object[key];
      result[length] = [key, value, isStrictComparable(value)];
    }
    return result;
  }
  function matchesStrictComparable(key, srcValue) {
    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
    };
  }
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }
  function hasPath(object, path, hasFunc) {
    path = castPath(path, object);
    var index = -1, length = path.length, result = false;
    while (++index < length) {
      var key = toKey(path[index]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index != length) {
      return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
  }
  function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }
    return function(object) {
      var objValue = get(object, path);
      return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }
  function baseProperty(key) {
    return function(object) {
      return object == null ? void 0 : object[key];
    };
  }
  function basePropertyDeep(path) {
    return function(object) {
      return baseGet(object, path);
    };
  }
  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }
  function baseIteratee(value) {
    if (typeof value == "function") {
      return value;
    }
    if (value == null) {
      return identity;
    }
    if (typeof value == "object") {
      return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
  }
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  var baseFor = createBaseFor();
  function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
  }
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
      while (fromRight ? index-- : ++index < length) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }
  var baseEach = createBaseEach(baseForOwn);
  var now = function() {
    return root.Date.now();
  };
  var FUNC_ERROR_TEXT$1 = "Expected a function";
  var nativeMax = Math.max, nativeMin = Math.min;
  function debounce(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT$1);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
      leading = !!options.leading;
      maxing = "maxWait" in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time2) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time2;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time2) {
      lastInvokeTime = time2;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time2) : result;
    }
    function remainingWait(time2) {
      var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
      return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    function shouldInvoke(time2) {
      var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time2 = now();
      if (shouldInvoke(time2)) {
        return trailingEdge(time2);
      }
      timerId = setTimeout(timerExpired, remainingWait(time2));
    }
    function trailingEdge(time2) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time2);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush() {
      return timerId === void 0 ? result : trailingEdge(now());
    }
    function debounced() {
      var time2 = now(), isInvoking = shouldInvoke(time2);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time2;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  function assignMergeValue(object, key, value) {
    if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  function safeGet(object, key) {
    if (key === "constructor" && typeof object[key] === "function") {
      return;
    }
    if (key == "__proto__") {
      return;
    }
    return object[key];
  }
  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }
  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack2) {
    var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
    if (stacked) {
      assignMergeValue(object, key, stacked);
      return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack2) : void 0;
    var isCommon = newValue === void 0;
    if (isCommon) {
      var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
        newValue = objValue;
        if (isArguments(objValue)) {
          newValue = toPlainObject(objValue);
        } else if (!isObject(objValue) || isFunction(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      } else {
        isCommon = false;
      }
    }
    if (isCommon) {
      stack2.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
      stack2["delete"](srcValue);
    }
    assignMergeValue(object, key, newValue);
  }
  function baseMerge(object, source, srcIndex, customizer, stack2) {
    if (object === source) {
      return;
    }
    baseFor(source, function(srcValue, key) {
      stack2 || (stack2 = new Stack());
      if (isObject(srcValue)) {
        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack2);
      } else {
        var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack2) : void 0;
        if (newValue === void 0) {
          newValue = srcValue;
        }
        assignMergeValue(object, key, newValue);
      }
    }, keysIn);
  }
  function baseMap(collection, iteratee) {
    var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
    baseEach(collection, function(value, key, collection2) {
      result[++index] = iteratee(value, key, collection2);
    });
    return result;
  }
  function map(collection, iteratee) {
    var func = isArray(collection) ? arrayMap : baseMap;
    return func(collection, baseIteratee(iteratee));
  }
  var kebabCase = createCompounder(function(result, word, index) {
    return result + (index ? "-" : "") + word.toLowerCase();
  });
  var merge$1 = createAssigner(function(object, source, srcIndex) {
    baseMerge(object, source, srcIndex);
  });
  var round = createRound("round");
  var FUNC_ERROR_TEXT = "Expected a function";
  function throttle(func, wait, options) {
    var leading = true, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    if (isObject(options)) {
      leading = "leading" in options ? !!options.leading : leading;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
      "leading": leading,
      "maxWait": wait,
      "trailing": trailing
    });
  }
  const commonVariables$m = {
    fontFamily: 'v-sans, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
    fontFamilyMono: "v-mono, SFMono-Regular, Menlo, Consolas, Courier, monospace",
    fontWeight: "400",
    fontWeightStrong: "500",
    cubicBezierEaseInOut: "cubic-bezier(.4, 0, .2, 1)",
    cubicBezierEaseOut: "cubic-bezier(0, 0, .2, 1)",
    cubicBezierEaseIn: "cubic-bezier(.4, 0, 1, 1)",
    borderRadius: "3px",
    borderRadiusSmall: "2px",
    fontSize: "14px",
    fontSizeMini: "12px",
    fontSizeTiny: "12px",
    fontSizeSmall: "14px",
    fontSizeMedium: "14px",
    fontSizeLarge: "15px",
    fontSizeHuge: "16px",
    lineHeight: "1.6",
    heightMini: "16px",
    // private now, it's too small
    heightTiny: "22px",
    heightSmall: "28px",
    heightMedium: "34px",
    heightLarge: "40px",
    heightHuge: "46px"
  };
  const {
    fontSize,
    fontFamily,
    lineHeight: lineHeight$1
  } = commonVariables$m;
  const globalStyle = c$1("body", `
 margin: 0;
 font-size: ${fontSize};
 font-family: ${fontFamily};
 line-height: ${lineHeight$1};
 -webkit-text-size-adjust: 100%;
 -webkit-tap-highlight-color: transparent;
`, [c$1("input", `
 font-family: inherit;
 font-size: inherit;
 `)]);
  const configProviderInjectionKey = createInjectionKey("n-config-provider");
  const cssrAnchorMetaName = "naive-ui-style";
  function createTheme(theme) {
    return theme;
  }
  function useTheme(resolveId, mountId, style2, defaultTheme, props, clsPrefixRef) {
    const ssrAdapter2 = useSsrAdapter();
    const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
    if (style2) {
      const mountStyle = () => {
        const clsPrefix = clsPrefixRef === null || clsPrefixRef === void 0 ? void 0 : clsPrefixRef.value;
        style2.mount({
          id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
          head: true,
          props: {
            bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
          },
          anchorMetaName: cssrAnchorMetaName,
          ssr: ssrAdapter2,
          parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
        });
        if (!(NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.preflightStyleDisabled)) {
          globalStyle.mount({
            id: "n-global",
            head: true,
            anchorMetaName: cssrAnchorMetaName,
            ssr: ssrAdapter2,
            parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
          });
        }
      };
      if (ssrAdapter2) {
        mountStyle();
      } else {
        vue.onBeforeMount(mountStyle);
      }
    }
    const mergedThemeRef = vue.computed(() => {
      var _a;
      const {
        theme: {
          common: selfCommon,
          self: self2,
          peers = {}
        } = {},
        themeOverrides: selfOverrides = {},
        builtinThemeOverrides: builtinOverrides = {}
      } = props;
      const {
        common: selfCommonOverrides,
        peers: peersOverrides
      } = selfOverrides;
      const {
        common: globalCommon = void 0,
        [resolveId]: {
          common: globalSelfCommon = void 0,
          self: globalSelf = void 0,
          peers: globalPeers = {}
        } = {}
      } = (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeRef.value) || {};
      const {
        common: globalCommonOverrides = void 0,
        [resolveId]: globalSelfOverrides = {}
      } = (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeOverridesRef.value) || {};
      const {
        common: globalSelfCommonOverrides,
        peers: globalPeersOverrides = {}
      } = globalSelfOverrides;
      const mergedCommon = merge$1({}, selfCommon || globalSelfCommon || globalCommon || defaultTheme.common, globalCommonOverrides, globalSelfCommonOverrides, selfCommonOverrides);
      const mergedSelf = merge$1(
        // {}, executed every time, no need for empty obj
        (_a = self2 || globalSelf || defaultTheme.self) === null || _a === void 0 ? void 0 : _a(mergedCommon),
        builtinOverrides,
        globalSelfOverrides,
        selfOverrides
      );
      return {
        common: mergedCommon,
        self: mergedSelf,
        peers: merge$1({}, defaultTheme.peers, globalPeers, peers),
        peerOverrides: merge$1({}, builtinOverrides.peers, globalPeersOverrides, peersOverrides)
      };
    });
    return mergedThemeRef;
  }
  useTheme.props = {
    theme: Object,
    themeOverrides: Object,
    builtinThemeOverrides: Object
  };
  const defaultClsPrefix = "n";
  function useConfig(props = {}, options = {
    defaultBordered: true
  }) {
    const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
    return {
      // NConfigProvider,
      inlineThemeDisabled: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.inlineThemeDisabled,
      mergedRtlRef: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedRtlRef,
      mergedComponentPropsRef: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedComponentPropsRef,
      mergedBreakpointsRef: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBreakpointsRef,
      mergedBorderedRef: vue.computed(() => {
        var _a, _b;
        const {
          bordered
        } = props;
        if (bordered !== void 0)
          return bordered;
        return (_b = (_a = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBorderedRef.value) !== null && _a !== void 0 ? _a : options.defaultBordered) !== null && _b !== void 0 ? _b : true;
      }),
      mergedClsPrefixRef: NConfigProvider2 ? NConfigProvider2.mergedClsPrefixRef : vue.shallowRef(defaultClsPrefix),
      namespaceRef: vue.computed(() => NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedNamespaceRef.value)
    };
  }
  function useMergedClsPrefix() {
    const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
    return NConfigProvider2 ? NConfigProvider2.mergedClsPrefixRef : vue.shallowRef(defaultClsPrefix);
  }
  const enUS$1 = {
    name: "en-US",
    global: {
      undo: "Undo",
      redo: "Redo",
      confirm: "Confirm",
      clear: "Clear"
    },
    Popconfirm: {
      positiveText: "Confirm",
      negativeText: "Cancel"
    },
    Cascader: {
      placeholder: "Please Select",
      loading: "Loading",
      loadingRequiredMessage: (label) => `Please load all ${label}'s descendants before checking it.`
    },
    Time: {
      dateFormat: "yyyy-MM-dd",
      dateTimeFormat: "yyyy-MM-dd HH:mm:ss"
    },
    DatePicker: {
      yearFormat: "yyyy",
      monthFormat: "MMM",
      dayFormat: "eeeeee",
      yearTypeFormat: "yyyy",
      monthTypeFormat: "yyyy-MM",
      dateFormat: "yyyy-MM-dd",
      dateTimeFormat: "yyyy-MM-dd HH:mm:ss",
      quarterFormat: "yyyy-qqq",
      weekFormat: "YYYY-w",
      clear: "Clear",
      now: "Now",
      confirm: "Confirm",
      selectTime: "Select Time",
      selectDate: "Select Date",
      datePlaceholder: "Select Date",
      datetimePlaceholder: "Select Date and Time",
      monthPlaceholder: "Select Month",
      yearPlaceholder: "Select Year",
      quarterPlaceholder: "Select Quarter",
      weekPlaceholder: "Select Week",
      startDatePlaceholder: "Start Date",
      endDatePlaceholder: "End Date",
      startDatetimePlaceholder: "Start Date and Time",
      endDatetimePlaceholder: "End Date and Time",
      startMonthPlaceholder: "Start Month",
      endMonthPlaceholder: "End Month",
      monthBeforeYear: true,
      firstDayOfWeek: 6,
      today: "Today"
    },
    DataTable: {
      checkTableAll: "Select all in the table",
      uncheckTableAll: "Unselect all in the table",
      confirm: "Confirm",
      clear: "Clear"
    },
    LegacyTransfer: {
      sourceTitle: "Source",
      targetTitle: "Target"
    },
    Transfer: {
      selectAll: "Select all",
      unselectAll: "Unselect all",
      clearAll: "Clear",
      total: (num) => `Total ${num} items`,
      selected: (num) => `${num} items selected`
    },
    Empty: {
      description: "No Data"
    },
    Select: {
      placeholder: "Please Select"
    },
    TimePicker: {
      placeholder: "Select Time",
      positiveText: "OK",
      negativeText: "Cancel",
      now: "Now",
      clear: "Clear"
    },
    Pagination: {
      goto: "Goto",
      selectionSuffix: "page"
    },
    DynamicTags: {
      add: "Add"
    },
    Log: {
      loading: "Loading"
    },
    Input: {
      placeholder: "Please Input"
    },
    InputNumber: {
      placeholder: "Please Input"
    },
    DynamicInput: {
      create: "Create"
    },
    ThemeEditor: {
      title: "Theme Editor",
      clearAllVars: "Clear All Variables",
      clearSearch: "Clear Search",
      filterCompName: "Filter Component Name",
      filterVarName: "Filter Variable Name",
      import: "Import",
      export: "Export",
      restore: "Reset to Default"
    },
    Image: {
      tipPrevious: "Previous picture (←)",
      tipNext: "Next picture (→)",
      tipCounterclockwise: "Counterclockwise",
      tipClockwise: "Clockwise",
      tipZoomOut: "Zoom out",
      tipZoomIn: "Zoom in",
      tipDownload: "Download",
      tipClose: "Close (Esc)",
      // TODO: translation
      tipOriginalSize: "Zoom to original size"
    }
  };
  const enUS$2 = enUS$1;
  function buildFormatLongFn(args) {
    return (options = {}) => {
      const width = options.width ? String(options.width) : args.defaultWidth;
      const format2 = args.formats[width] || args.formats[args.defaultWidth];
      return format2;
    };
  }
  function buildLocalizeFn(args) {
    return (value, options) => {
      const context = (options == null ? void 0 : options.context) ? String(options.context) : "standalone";
      let valuesArray;
      if (context === "formatting" && args.formattingValues) {
        const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
        const width = (options == null ? void 0 : options.width) ? String(options.width) : defaultWidth;
        valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
      } else {
        const defaultWidth = args.defaultWidth;
        const width = (options == null ? void 0 : options.width) ? String(options.width) : args.defaultWidth;
        valuesArray = args.values[width] || args.values[defaultWidth];
      }
      const index = args.argumentCallback ? args.argumentCallback(value) : value;
      return valuesArray[index];
    };
  }
  function buildMatchFn(args) {
    return (string2, options = {}) => {
      const width = options.width;
      const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
      const matchResult = string2.match(matchPattern);
      if (!matchResult) {
        return null;
      }
      const matchedString = matchResult[0];
      const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
      const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
        findKey(parsePatterns, (pattern) => pattern.test(matchedString))
      );
      let value;
      value = args.valueCallback ? args.valueCallback(key) : key;
      value = options.valueCallback ? (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
        options.valueCallback(value)
      ) : value;
      const rest = string2.slice(matchedString.length);
      return { value, rest };
    };
  }
  function findKey(object, predicate) {
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
        return key;
      }
    }
    return void 0;
  }
  function findIndex(array, predicate) {
    for (let key = 0; key < array.length; key++) {
      if (predicate(array[key])) {
        return key;
      }
    }
    return void 0;
  }
  function buildMatchPatternFn(args) {
    return (string2, options = {}) => {
      const matchResult = string2.match(args.matchPattern);
      if (!matchResult)
        return null;
      const matchedString = matchResult[0];
      const parseResult = string2.match(args.parsePattern);
      if (!parseResult)
        return null;
      let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
      value = options.valueCallback ? options.valueCallback(value) : value;
      const rest = string2.slice(matchedString.length);
      return { value, rest };
    };
  }
  function toDate$1(argument) {
    const argStr = Object.prototype.toString.call(argument);
    if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
      return new argument.constructor(+argument);
    } else if (typeof argument === "number" || argStr === "[object Number]" || typeof argument === "string" || argStr === "[object String]") {
      return new Date(argument);
    } else {
      return /* @__PURE__ */ new Date(NaN);
    }
  }
  let defaultOptions = {};
  function getDefaultOptions$1() {
    return defaultOptions;
  }
  function startOfWeek(date, options) {
    var _a, _b, _c, _d;
    const defaultOptions2 = getDefaultOptions$1();
    const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.weekStartsOn) ?? defaultOptions2.weekStartsOn ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.weekStartsOn) ?? 0;
    const _date = toDate$1(date);
    const day = _date.getDay();
    const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    _date.setDate(_date.getDate() - diff);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }
  function isSameWeek(dateLeft, dateRight, options) {
    const dateLeftStartOfWeek = startOfWeek(dateLeft, options);
    const dateRightStartOfWeek = startOfWeek(dateRight, options);
    return +dateLeftStartOfWeek === +dateRightStartOfWeek;
  }
  const formatDistanceLocale = {
    lessThanXSeconds: {
      one: "less than a second",
      other: "less than {{count}} seconds"
    },
    xSeconds: {
      one: "1 second",
      other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
      one: "less than a minute",
      other: "less than {{count}} minutes"
    },
    xMinutes: {
      one: "1 minute",
      other: "{{count}} minutes"
    },
    aboutXHours: {
      one: "about 1 hour",
      other: "about {{count}} hours"
    },
    xHours: {
      one: "1 hour",
      other: "{{count}} hours"
    },
    xDays: {
      one: "1 day",
      other: "{{count}} days"
    },
    aboutXWeeks: {
      one: "about 1 week",
      other: "about {{count}} weeks"
    },
    xWeeks: {
      one: "1 week",
      other: "{{count}} weeks"
    },
    aboutXMonths: {
      one: "about 1 month",
      other: "about {{count}} months"
    },
    xMonths: {
      one: "1 month",
      other: "{{count}} months"
    },
    aboutXYears: {
      one: "about 1 year",
      other: "about {{count}} years"
    },
    xYears: {
      one: "1 year",
      other: "{{count}} years"
    },
    overXYears: {
      one: "over 1 year",
      other: "over {{count}} years"
    },
    almostXYears: {
      one: "almost 1 year",
      other: "almost {{count}} years"
    }
  };
  const formatDistance = (token, count, options) => {
    let result;
    const tokenValue = formatDistanceLocale[token];
    if (typeof tokenValue === "string") {
      result = tokenValue;
    } else if (count === 1) {
      result = tokenValue.one;
    } else {
      result = tokenValue.other.replace("{{count}}", count.toString());
    }
    if (options == null ? void 0 : options.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        return "in " + result;
      } else {
        return result + " ago";
      }
    }
    return result;
  };
  const formatRelativeLocale = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
  };
  const formatRelative = (token, _date, _baseDate, _options) => formatRelativeLocale[token];
  const eraValues = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
  };
  const quarterValues = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
  };
  const monthValues = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    wide: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ]
  };
  const dayValues = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ]
  };
  const dayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    }
  };
  const formattingDayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    }
  };
  const ordinalNumber = (dirtyNumber, _options) => {
    const number = Number(dirtyNumber);
    const rem100 = number % 100;
    if (rem100 > 20 || rem100 < 10) {
      switch (rem100 % 10) {
        case 1:
          return number + "st";
        case 2:
          return number + "nd";
        case 3:
          return number + "rd";
      }
    }
    return number + "th";
  };
  const localize = {
    ordinalNumber,
    era: buildLocalizeFn({
      values: eraValues,
      defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
      values: quarterValues,
      defaultWidth: "wide",
      argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
      values: monthValues,
      defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
      values: dayValues,
      defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
      values: dayPeriodValues,
      defaultWidth: "wide",
      formattingValues: formattingDayPeriodValues,
      defaultFormattingWidth: "wide"
    })
  };
  const matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
  const parseOrdinalNumberPattern = /\d+/i;
  const matchEraPatterns = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
  };
  const parseEraPatterns = {
    any: [/^b/i, /^(a|c)/i]
  };
  const matchQuarterPatterns = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
  };
  const parseQuarterPatterns = {
    any: [/1/i, /2/i, /3/i, /4/i]
  };
  const matchMonthPatterns = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  };
  const parseMonthPatterns = {
    narrow: [
      /^j/i,
      /^f/i,
      /^m/i,
      /^a/i,
      /^m/i,
      /^j/i,
      /^j/i,
      /^a/i,
      /^s/i,
      /^o/i,
      /^n/i,
      /^d/i
    ],
    any: [
      /^ja/i,
      /^f/i,
      /^mar/i,
      /^ap/i,
      /^may/i,
      /^jun/i,
      /^jul/i,
      /^au/i,
      /^s/i,
      /^o/i,
      /^n/i,
      /^d/i
    ]
  };
  const matchDayPatterns = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  };
  const parseDayPatterns = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
  };
  const matchDayPeriodPatterns = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
  };
  const parseDayPeriodPatterns = {
    any: {
      am: /^a/i,
      pm: /^p/i,
      midnight: /^mi/i,
      noon: /^no/i,
      morning: /morning/i,
      afternoon: /afternoon/i,
      evening: /evening/i,
      night: /night/i
    }
  };
  const match = {
    ordinalNumber: buildMatchPatternFn({
      matchPattern: matchOrdinalNumberPattern,
      parsePattern: parseOrdinalNumberPattern,
      valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
      matchPatterns: matchEraPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseEraPatterns,
      defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
      matchPatterns: matchQuarterPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseQuarterPatterns,
      defaultParseWidth: "any",
      valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
      matchPatterns: matchMonthPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseMonthPatterns,
      defaultParseWidth: "any"
    }),
    day: buildMatchFn({
      matchPatterns: matchDayPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseDayPatterns,
      defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
      matchPatterns: matchDayPeriodPatterns,
      defaultMatchWidth: "any",
      parsePatterns: parseDayPeriodPatterns,
      defaultParseWidth: "any"
    })
  };
  const dateFormats = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
  };
  const timeFormats = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
  };
  const dateTimeFormats = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
  };
  const formatLong = {
    date: buildFormatLongFn({
      formats: dateFormats,
      defaultWidth: "full"
    }),
    time: buildFormatLongFn({
      formats: timeFormats,
      defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
      formats: dateTimeFormats,
      defaultWidth: "full"
    })
  };
  const enUS = {
    code: "en-US",
    formatDistance,
    formatLong,
    formatRelative,
    localize,
    match,
    options: {
      weekStartsOn: 0,
      firstWeekContainsDate: 1
    }
  };
  const dateEnUs = {
    name: "en-US",
    locale: enUS
  };
  const dateEnUS = dateEnUs;
  function useLocale(ns) {
    const {
      mergedLocaleRef,
      mergedDateLocaleRef
    } = vue.inject(configProviderInjectionKey, null) || {};
    const localeRef = vue.computed(() => {
      var _a, _b;
      return (_b = (_a = mergedLocaleRef === null || mergedLocaleRef === void 0 ? void 0 : mergedLocaleRef.value) === null || _a === void 0 ? void 0 : _a[ns]) !== null && _b !== void 0 ? _b : enUS$2[ns];
    });
    const dateLocaleRef = vue.computed(() => {
      var _a;
      return (_a = mergedDateLocaleRef === null || mergedDateLocaleRef === void 0 ? void 0 : mergedDateLocaleRef.value) !== null && _a !== void 0 ? _a : dateEnUS;
    });
    return {
      dateLocaleRef,
      localeRef
    };
  }
  function useStyle(mountId, style2, clsPrefixRef) {
    if (!style2) {
      throwError("use-style", "No style is specified.");
      return;
    }
    const ssrAdapter2 = useSsrAdapter();
    const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
    const mountStyle = () => {
      const clsPrefix = clsPrefixRef.value;
      style2.mount({
        id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
        head: true,
        anchorMetaName: cssrAnchorMetaName,
        props: {
          bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
        },
        ssr: ssrAdapter2,
        parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
      });
      if (!(NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.preflightStyleDisabled)) {
        globalStyle.mount({
          id: "n-global",
          head: true,
          anchorMetaName: cssrAnchorMetaName,
          ssr: ssrAdapter2,
          parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
        });
      }
    };
    if (ssrAdapter2) {
      mountStyle();
    } else {
      vue.onBeforeMount(mountStyle);
    }
  }
  function useHljs(props, shouldHighlightRef) {
    const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
    {
      const warnHljs = () => {
        if (!props.hljs && !(NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedHljsRef.value)) {
          warn$2("code", "hljs is not set.");
        }
      };
      if (!shouldHighlightRef) {
        warnHljs();
      } else {
        vue.watchEffect(() => {
          if (shouldHighlightRef.value) {
            warnHljs();
          }
        });
      }
    }
    return vue.computed(() => {
      return props.hljs || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedHljsRef.value);
    });
  }
  function useThemeClass(componentName, hashRef, cssVarsRef, props) {
    if (!cssVarsRef)
      throwError("useThemeClass", "cssVarsRef is not passed");
    const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
    const mergedThemeHashRef = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeHashRef;
    const styleMountTarget = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget;
    const themeClassRef = vue.ref("");
    const ssrAdapter2 = useSsrAdapter();
    let renderCallback;
    const hashClassPrefix = `__${componentName}`;
    const mountStyle = () => {
      let finalThemeHash = hashClassPrefix;
      const hashValue = hashRef ? hashRef.value : void 0;
      const themeHash = mergedThemeHashRef === null || mergedThemeHashRef === void 0 ? void 0 : mergedThemeHashRef.value;
      if (themeHash)
        finalThemeHash += `-${themeHash}`;
      if (hashValue)
        finalThemeHash += `-${hashValue}`;
      const {
        themeOverrides,
        builtinThemeOverrides
      } = props;
      if (themeOverrides) {
        finalThemeHash += `-${murmur2(JSON.stringify(themeOverrides))}`;
      }
      if (builtinThemeOverrides) {
        finalThemeHash += `-${murmur2(JSON.stringify(builtinThemeOverrides))}`;
      }
      themeClassRef.value = finalThemeHash;
      renderCallback = () => {
        const cssVars = cssVarsRef.value;
        let style2 = "";
        for (const key in cssVars) {
          style2 += `${key}: ${cssVars[key]};`;
        }
        c$1(`.${finalThemeHash}`, style2).mount({
          id: finalThemeHash,
          ssr: ssrAdapter2,
          parent: styleMountTarget
        });
        renderCallback = void 0;
      };
    };
    vue.watchEffect(() => {
      mountStyle();
    });
    return {
      themeClass: themeClassRef,
      onRender: () => {
        renderCallback === null || renderCallback === void 0 ? void 0 : renderCallback();
      }
    };
  }
  function useRtl(mountId, rtlStateRef, clsPrefixRef) {
    if (!rtlStateRef)
      return void 0;
    const ssrAdapter2 = useSsrAdapter();
    const componentRtlStateRef = vue.computed(() => {
      const {
        value: rtlState
      } = rtlStateRef;
      if (!rtlState) {
        return void 0;
      }
      const componentRtlState = rtlState[mountId];
      if (!componentRtlState) {
        return void 0;
      }
      return componentRtlState;
    });
    const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
    const mountStyle = () => {
      vue.watchEffect(() => {
        const {
          value: clsPrefix
        } = clsPrefixRef;
        const id = `${clsPrefix}${mountId}Rtl`;
        if (exists(id, ssrAdapter2))
          return;
        const {
          value: componentRtlState
        } = componentRtlStateRef;
        if (!componentRtlState)
          return;
        componentRtlState.style.mount({
          id,
          head: true,
          anchorMetaName: cssrAnchorMetaName,
          props: {
            bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
          },
          ssr: ssrAdapter2,
          parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
        });
      });
    };
    if (ssrAdapter2) {
      mountStyle();
    } else {
      vue.onBeforeMount(mountStyle);
    }
    return componentRtlStateRef;
  }
  function getScrollTop(target) {
    return target instanceof HTMLElement ? target.scrollTop : window.scrollY;
  }
  function getRect(target) {
    return target instanceof HTMLElement ? target.getBoundingClientRect() : {
      top: 0,
      bottom: window.innerHeight
    };
  }
  const style$1D = cB("affix", [cM("affixed", {
    position: "fixed"
  }, [cM("absolute-positioned", {
    position: "absolute"
  })])]);
  const affixProps = {
    listenTo: [String, Object, Function],
    top: Number,
    bottom: Number,
    triggerTop: Number,
    triggerBottom: Number,
    position: {
      type: String,
      default: "fixed"
    },
    // deprecated
    offsetTop: {
      type: Number,
      validator: () => {
        {
          warn$2("affix", "`offset-top` is deprecated, please use `trigger-top` instead.");
        }
        return true;
      },
      default: void 0
    },
    offsetBottom: {
      type: Number,
      validator: () => {
        {
          warn$2("affix", "`offset-bottom` is deprecated, please use `trigger-bottom` instead.");
        }
        return true;
      },
      default: void 0
    },
    target: {
      type: Function,
      validator: () => {
        {
          warn$2("affix", "`target` is deprecated, please use `listen-to` instead.");
        }
        return true;
      },
      default: void 0
    }
  };
  const affixPropKeys = keysOf(affixProps);
  const NAffix = vue.defineComponent({
    name: "Affix",
    props: affixProps,
    setup(props) {
      const {
        mergedClsPrefixRef
      } = useConfig(props);
      useStyle("-affix", style$1D, mergedClsPrefixRef);
      let scrollTarget = null;
      const stickToTopRef = vue.ref(false);
      const stickToBottomRef = vue.ref(false);
      const bottomAffixedTriggerScrollTopRef = vue.ref(null);
      const topAffixedTriggerScrollTopRef = vue.ref(null);
      const affixedRef = vue.computed(() => {
        return stickToBottomRef.value || stickToTopRef.value;
      });
      const mergedOffsetTopRef = vue.computed(() => {
        var _a, _b;
        return (_b = (_a = props.triggerTop) !== null && _a !== void 0 ? _a : props.offsetTop) !== null && _b !== void 0 ? _b : props.top;
      });
      const mergedTopRef = vue.computed(() => {
        var _a, _b;
        return (_b = (_a = props.top) !== null && _a !== void 0 ? _a : props.triggerTop) !== null && _b !== void 0 ? _b : props.offsetTop;
      });
      const mergedBottomRef = vue.computed(() => {
        var _a, _b;
        return (_b = (_a = props.bottom) !== null && _a !== void 0 ? _a : props.triggerBottom) !== null && _b !== void 0 ? _b : props.offsetBottom;
      });
      const mergedOffsetBottomRef = vue.computed(() => {
        var _a, _b;
        return (_b = (_a = props.triggerBottom) !== null && _a !== void 0 ? _a : props.offsetBottom) !== null && _b !== void 0 ? _b : props.bottom;
      });
      const selfRef = vue.ref(null);
      const init2 = () => {
        const {
          target: getScrollTarget,
          listenTo
        } = props;
        if (getScrollTarget) {
          scrollTarget = getScrollTarget();
        } else if (listenTo) {
          scrollTarget = unwrapElement(listenTo);
        } else {
          scrollTarget = document;
        }
        if (scrollTarget) {
          scrollTarget.addEventListener("scroll", handleScroll);
          handleScroll();
        } else {
          warn$2("affix", "Target to be listened to is not valid.");
        }
      };
      function handleScroll() {
        beforeNextFrameOnce(_handleScroll);
      }
      function _handleScroll() {
        const {
          value: selfEl
        } = selfRef;
        if (!scrollTarget || !selfEl)
          return;
        const scrollTop = getScrollTop(scrollTarget);
        if (affixedRef.value) {
          if (topAffixedTriggerScrollTopRef.value !== null && scrollTop < topAffixedTriggerScrollTopRef.value) {
            stickToTopRef.value = false;
            topAffixedTriggerScrollTopRef.value = null;
          }
          if (bottomAffixedTriggerScrollTopRef.value !== null && scrollTop > bottomAffixedTriggerScrollTopRef.value) {
            stickToBottomRef.value = false;
            bottomAffixedTriggerScrollTopRef.value = null;
          }
          return;
        }
        const containerRect = getRect(scrollTarget);
        const affixRect = selfEl.getBoundingClientRect();
        const pxToTop = affixRect.top - containerRect.top;
        const pxToBottom = containerRect.bottom - affixRect.bottom;
        const mergedOffsetTop = mergedOffsetTopRef.value;
        const mergedOffsetBottom = mergedOffsetBottomRef.value;
        if (mergedOffsetTop !== void 0 && pxToTop <= mergedOffsetTop) {
          stickToTopRef.value = true;
          topAffixedTriggerScrollTopRef.value = scrollTop - (mergedOffsetTop - pxToTop);
        } else {
          stickToTopRef.value = false;
          topAffixedTriggerScrollTopRef.value = null;
        }
        if (mergedOffsetBottom !== void 0 && pxToBottom <= mergedOffsetBottom) {
          stickToBottomRef.value = true;
          bottomAffixedTriggerScrollTopRef.value = scrollTop + mergedOffsetBottom - pxToBottom;
        } else {
          stickToBottomRef.value = false;
          bottomAffixedTriggerScrollTopRef.value = null;
        }
      }
      vue.onMounted(() => {
        init2();
      });
      vue.onBeforeUnmount(() => {
        if (!scrollTarget)
          return;
        scrollTarget.removeEventListener("scroll", handleScroll);
      });
      return {
        selfRef,
        affixed: affixedRef,
        mergedClsPrefix: mergedClsPrefixRef,
        mergedstyle: vue.computed(() => {
          const style2 = {};
          if (stickToTopRef.value && mergedOffsetTopRef.value !== void 0 && mergedTopRef.value !== void 0) {
            style2.top = `${mergedTopRef.value}px`;
          }
          if (stickToBottomRef.value && mergedOffsetBottomRef.value !== void 0 && mergedBottomRef.value !== void 0) {
            style2.bottom = `${mergedBottomRef.value}px`;
          }
          return style2;
        })
      };
    },
    render() {
      const {
        mergedClsPrefix
      } = this;
      return vue.h("div", {
        ref: "selfRef",
        class: [`${mergedClsPrefix}-affix`, {
          [`${mergedClsPrefix}-affix--affixed`]: this.affixed,
          [`${mergedClsPrefix}-affix--absolute-positioned`]: this.position === "absolute"
        }],
        style: this.mergedstyle
      }, this.$slots);
    }
  });
  const AddIcon = vue.defineComponent({
    name: "Add",
    render() {
      return vue.h("svg", {
        width: "512",
        height: "512",
        viewBox: "0 0 512 512",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, vue.h("path", {
        d: "M256 112V400M400 256H112",
        stroke: "currentColor",
        "stroke-width": "32",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
      }));
    }
  });
  const ArrowDownIcon = vue.defineComponent({
    name: "ArrowDown",
    render() {
      return vue.h("svg", {
        viewBox: "0 0 28 28",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg"
      }, vue.h("g", {
        stroke: "none",
        "stroke-width": "1",
        "fill-rule": "evenodd"
      }, vue.h("g", {
        "fill-rule": "nonzero"
      }, vue.h("path", {
        d: "M23.7916,15.2664 C24.0788,14.9679 24.0696,14.4931 23.7711,14.206 C23.4726,13.9188 22.9978,13.928 22.7106,14.2265 L14.7511,22.5007 L14.7511,3.74792 C14.7511,3.33371 14.4153,2.99792 14.0011,2.99792 C13.5869,2.99792 13.2511,3.33371 13.2511,3.74793 L13.2511,22.4998 L5.29259,14.2265 C5.00543,13.928 4.53064,13.9188 4.23213,14.206 C3.93361,14.4931 3.9244,14.9679 4.21157,15.2664 L13.2809,24.6944 C13.6743,25.1034 14.3289,25.1034 14.7223,24.6944 L23.7916,15.2664 Z"
      }))));
    }
  });
  const ArrowUpIcon = vue.defineComponent({
    name: "ArrowUp",
    render() {
      return vue.h("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 20 20"
      }, vue.h("g", {
        fill: "none"
      }, vue.h("path", {
        d: "M3.13 9.163a.5.5 0 1 0 .74.674L9.5 3.67V17.5a.5.5 0 0 0 1 0V3.672l5.63 6.165a.5.5 0 0 0 .738-.674l-6.315-6.916a.746.746 0 0 0-.632-.24a.746.746 0 0 0-.476.24L3.131 9.163z",
        fill: "currentColor"
      })));
    }
  });
  function replaceable(name, icon) {
    return vue.defineComponent({
      name: upperFirst(name),
      setup() {
        var _a;
        const mergedIconsRef = (_a = vue.inject(configProviderInjectionKey, null)) === null || _a === void 0 ? void 0 : _a.mergedIconsRef;
        return () => {
          var _a2;
          const iconOverride = (_a2 = mergedIconsRef === null || mergedIconsRef === void 0 ? void 0 : mergedIconsRef.value) === null || _a2 === void 0 ? void 0 : _a2[name];
          return iconOverride ? iconOverride() : icon;
        };
      }
    });
  }
  const AttachIcon = replaceable("attach", vue.h("svg", {
    viewBox: "0 0 16 16",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg"
  }, vue.h("g", {
    stroke: "none",
    "stroke-width": "1",
    fill: "none",
    "fill-rule": "evenodd"
  }, vue.h("g", {
    fill: "currentColor",
    "fill-rule": "nonzero"
  }, vue.h("path", {
    d: "M3.25735931,8.70710678 L7.85355339,4.1109127 C8.82986412,3.13460197 10.4127766,3.13460197 11.3890873,4.1109127 C12.365398,5.08722343 12.365398,6.67013588 11.3890873,7.64644661 L6.08578644,12.9497475 C5.69526215,13.3402718 5.06209717,13.3402718 4.67157288,12.9497475 C4.28104858,12.5592232 4.28104858,11.9260582 4.67157288,11.5355339 L9.97487373,6.23223305 C10.1701359,6.0369709 10.1701359,5.72038841 9.97487373,5.52512627 C9.77961159,5.32986412 9.4630291,5.32986412 9.26776695,5.52512627 L3.96446609,10.8284271 C3.18341751,11.6094757 3.18341751,12.8758057 3.96446609,13.6568542 C4.74551468,14.4379028 6.01184464,14.4379028 6.79289322,13.6568542 L12.0961941,8.35355339 C13.4630291,6.98671837 13.4630291,4.77064094 12.0961941,3.40380592 C10.7293591,2.0369709 8.51328163,2.0369709 7.14644661,3.40380592 L2.55025253,8 C2.35499039,8.19526215 2.35499039,8.51184464 2.55025253,8.70710678 C2.74551468,8.90236893 3.06209717,8.90236893 3.25735931,8.70710678 Z"
  })))));
  const BackwardIcon = vue.defineComponent({
    name: "Backward",
    render() {
      return vue.h("svg", {
        viewBox: "0 0 20 20",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, vue.h("path", {
        d: "M12.2674 15.793C11.9675 16.0787 11.4927 16.0672 11.2071 15.7673L6.20572 10.5168C5.9298 10.2271 5.9298 9.7719 6.20572 9.48223L11.2071 4.23177C11.4927 3.93184 11.9675 3.92031 12.2674 4.206C12.5673 4.49169 12.5789 4.96642 12.2932 5.26634L7.78458 9.99952L12.2932 14.7327C12.5789 15.0326 12.5673 15.5074 12.2674 15.793Z",
        fill: "currentColor"
      }));
    }
  });
  const DateIcon = replaceable("date", vue.h("svg", {
    width: "28px",
    height: "28px",
    viewBox: "0 0 28 28",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg"
  }, vue.h("g", {
    stroke: "none",
    "stroke-width": "1",
    "fill-rule": "evenodd"
  }, vue.h("g", {
    "fill-rule": "nonzero"
  }, vue.h("path", {
    d: "M21.75,3 C23.5449254,3 25,4.45507456 25,6.25 L25,21.75 C25,23.5449254 23.5449254,25 21.75,25 L6.25,25 C4.45507456,25 3,23.5449254 3,21.75 L3,6.25 C3,4.45507456 4.45507456,3 6.25,3 L21.75,3 Z M23.5,9.503 L4.5,9.503 L4.5,21.75 C4.5,22.7164983 5.28350169,23.5 6.25,23.5 L21.75,23.5 C22.7164983,23.5 23.5,22.7164983 23.5,21.75 L23.5,9.503 Z M21.75,4.5 L6.25,4.5 C5.28350169,4.5 4.5,5.28350169 4.5,6.25 L4.5,8.003 L23.5,8.003 L23.5,6.25 C23.5,5.28350169 22.7164983,4.5 21.75,4.5 Z"
  })))));
  const FinishedIcon = vue.defineComponent({
    name: "Checkmark",
    render() {
      return vue.h("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 16 16"
      }, vue.h("g", {
        fill: "none"
      }, vue.h("path", {
        d: "M14.046 3.486a.75.75 0 0 1-.032 1.06l-7.93 7.474a.85.85 0 0 1-1.188-.022l-2.68-2.72a.75.75 0 1 1 1.068-1.053l2.234 2.267l7.468-7.038a.75.75 0 0 1 1.06.032z",
        fill: "currentColor"
      })));
    }
  });
  const ChevronLeftIcon = vue.defineComponent({
    name: "ChevronLeft",
    render() {
      return vue.h("svg", {
        viewBox: "0 0 16 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, vue.h("path", {
        d: "M10.3536 3.14645C10.5488 3.34171 10.5488 3.65829 10.3536 3.85355L6.20711 8L10.3536 12.1464C10.5488 12.3417 10.5488 12.6583 10.3536 12.8536C10.1583 13.0488 9.84171 13.0488 9.64645 12.8536L5.14645 8.35355C4.95118 8.15829 4.95118 7.84171 5.14645 7.64645L9.64645 3.14645C9.84171 2.95118 10.1583 2.95118 10.3536 3.14645Z",
        fill: "currentColor"
      }));
    }
  });
  const ChevronRightIcon = vue.defineComponent({
    name: "ChevronRight",
    render() {
      return vue.h("svg", {
        viewBox: "0 0 16 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, vue.h("path", {
        d: "M5.64645 3.14645C5.45118 3.34171 5.45118 3.65829 5.64645 3.85355L9.79289 8L5.64645 12.1464C5.45118 12.3417 5.45118 12.6583 5.64645 12.8536C5.84171 13.0488 6.15829 13.0488 6.35355 12.8536L10.8536 8.35355C11.0488 8.15829 11.0488 7.84171 10.8536 7.64645L6.35355 3.14645C6.15829 2.95118 5.84171 2.95118 5.64645 3.14645Z",
        fill: "currentColor"
      }));
    }
  });
  const ErrorIcon$1 = replaceable("close", vue.h("svg", {
    viewBox: "0 0 12 12",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-hidden": true
  }, vue.h("g", {
    stroke: "none",
    "stroke-width": "1",
    fill: "none",
    "fill-rule": "evenodd"
  }, vue.h("g", {
    fill: "currentColor",
    "fill-rule": "nonzero"
  }, vue.h("path", {
    d: "M2.08859116,2.2156945 L2.14644661,2.14644661 C2.32001296,1.97288026 2.58943736,1.95359511 2.7843055,2.08859116 L2.85355339,2.14644661 L6,5.293 L9.14644661,2.14644661 C9.34170876,1.95118446 9.65829124,1.95118446 9.85355339,2.14644661 C10.0488155,2.34170876 10.0488155,2.65829124 9.85355339,2.85355339 L6.707,6 L9.85355339,9.14644661 C10.0271197,9.32001296 10.0464049,9.58943736 9.91140884,9.7843055 L9.85355339,9.85355339 C9.67998704,10.0271197 9.41056264,10.0464049 9.2156945,9.91140884 L9.14644661,9.85355339 L6,6.707 L2.85355339,9.85355339 C2.65829124,10.0488155 2.34170876,10.0488155 2.14644661,9.85355339 C1.95118446,9.65829124 1.95118446,9.34170876 2.14644661,9.14644661 L5.293,6 L2.14644661,2.85355339 C1.97288026,2.67998704 1.95359511,2.41056264 2.08859116,2.2156945 L2.14644661,2.14644661 L2.08859116,2.2156945 Z"
  })))));
  const EyeIcon = vue.defineComponent({
    name: "Eye",
    render() {
      return vue.h("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 512"
      }, vue.h("path", {
        d: "M255.66 112c-77.94 0-157.89 45.11-220.83 135.33a16 16 0 0 0-.27 17.77C82.92 340.8 161.8 400 255.66 400c92.84 0 173.34-59.38 221.79-135.25a16.14 16.14 0 0 0 0-17.47C428.89 172.28 347.8 112 255.66 112z",
        fill: "none",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "32"
      }), vue.h("circle", {
        cx: "256",
        cy: "256",
        r: "80",
        fill: "none",
        stroke: "currentColor",
        "stroke-miterlimit": "10",
        "stroke-width": "32"
      }));
    }
  });
  const EyeOffIcon = vue.defineComponent({
    name: "EyeOff",
    render() {
      return vue.h("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 512"
      }, vue.h("path", {
        d: "M432 448a15.92 15.92 0 0 1-11.31-4.69l-352-352a16 16 0 0 1 22.62-22.62l352 352A16 16 0 0 1 432 448z",
        fill: "currentColor"
      }), vue.h("path", {
        d: "M255.66 384c-41.49 0-81.5-12.28-118.92-36.5c-34.07-22-64.74-53.51-88.7-91v-.08c19.94-28.57 41.78-52.73 65.24-72.21a2 2 0 0 0 .14-2.94L93.5 161.38a2 2 0 0 0-2.71-.12c-24.92 21-48.05 46.76-69.08 76.92a31.92 31.92 0 0 0-.64 35.54c26.41 41.33 60.4 76.14 98.28 100.65C162 402 207.9 416 255.66 416a239.13 239.13 0 0 0 75.8-12.58a2 2 0 0 0 .77-3.31l-21.58-21.58a4 4 0 0 0-3.83-1a204.8 204.8 0 0 1-51.16 6.47z",
        fill: "currentColor"
      }), vue.h("path", {
        d: "M490.84 238.6c-26.46-40.92-60.79-75.68-99.27-100.53C349 110.55 302 96 255.66 96a227.34 227.34 0 0 0-74.89 12.83a2 2 0 0 0-.75 3.31l21.55 21.55a4 4 0 0 0 3.88 1a192.82 192.82 0 0 1 50.21-6.69c40.69 0 80.58 12.43 118.55 37c34.71 22.4 65.74 53.88 89.76 91a.13.13 0 0 1 0 .16a310.72 310.72 0 0 1-64.12 72.73a2 2 0 0 0-.15 2.95l19.9 19.89a2 2 0 0 0 2.7.13a343.49 343.49 0 0 0 68.64-78.48a32.2 32.2 0 0 0-.1-34.78z",
        fill: "currentColor"
      }), vue.h("path", {
        d: "M256 160a95.88 95.88 0 0 0-21.37 2.4a2 2 0 0 0-1 3.38l112.59 112.56a2 2 0 0 0 3.38-1A96 96 0 0 0 256 160z",
        fill: "currentColor"
      }), vue.h("path", {
        d: "M165.78 233.66a2 2 0 0 0-3.38 1a96 96 0 0 0 115 115a2 2 0 0 0 1-3.38z",
        fill: "currentColor"
      }));
    }
  });
  const TrashIcon = replaceable("trash", vue.h("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 512 512"
  }, vue.h("path", {
    d: "M432,144,403.33,419.74A32,32,0,0,1,371.55,448H140.46a32,32,0,0,1-31.78-28.26L80,144",
    style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;"
  }), vue.h("rect", {
    x: "32",
    y: "64",
    width: "448",
    height: "80",
    rx: "16",
    ry: "16",
    style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;"
  }), vue.h("line", {
    x1: "312",
    y1: "240",
    x2: "200",
    y2: "352",
    style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;"
  }), vue.h("line", {
    x1: "312",
    y1: "352",
    x2: "200",
    y2: "240",
    style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;"
  })));
  const DownloadIcon = replaceable("download", vue.h("svg", {
    viewBox: "0 0 16 16",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg"
  }, vue.h("g", {
    stroke: "none",
    "stroke-width": "1",
    fill: "none",
    "fill-rule": "evenodd"
  }, vue.h("g", {
    fill: "currentColor",
    "fill-rule": "nonzero"
  }, vue.h("path", {
    d: "M3.5,13 L12.5,13 C12.7761424,13 13,13.2238576 13,13.5 C13,13.7454599 12.8231248,13.9496084 12.5898756,13.9919443 L12.5,14 L3.5,14 C3.22385763,14 3,13.7761424 3,13.5 C3,13.2545401 3.17687516,13.0503916 3.41012437,13.0080557 L3.5,13 L12.5,13 L3.5,13 Z M7.91012437,1.00805567 L8,1 C8.24545989,1 8.44960837,1.17687516 8.49194433,1.41012437 L8.5,1.5 L8.5,10.292 L11.1819805,7.6109127 C11.3555469,7.43734635 11.6249713,7.4180612 11.8198394,7.55305725 L11.8890873,7.6109127 C12.0626536,7.78447906 12.0819388,8.05390346 11.9469427,8.2487716 L11.8890873,8.31801948 L8.35355339,11.8535534 C8.17998704,12.0271197 7.91056264,12.0464049 7.7156945,11.9114088 L7.64644661,11.8535534 L4.1109127,8.31801948 C3.91565056,8.12275734 3.91565056,7.80617485 4.1109127,7.6109127 C4.28447906,7.43734635 4.55390346,7.4180612 4.7487716,7.55305725 L4.81801948,7.6109127 L7.5,10.292 L7.5,1.5 C7.5,1.25454011 7.67687516,1.05039163 7.91012437,1.00805567 L8,1 L7.91012437,1.00805567 Z"
  })))));
  const EmptyIcon = vue.defineComponent({
    name: "Empty",
    render() {
      return vue.h("svg", {
        viewBox: "0 0 28 28",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, vue.h("path", {
        d: "M26 7.5C26 11.0899 23.0899 14 19.5 14C15.9101 14 13 11.0899 13 7.5C13 3.91015 15.9101 1 19.5 1C23.0899 1 26 3.91015 26 7.5ZM16.8536 4.14645C16.6583 3.95118 16.3417 3.95118 16.1464 4.14645C15.9512 4.34171 15.9512 4.65829 16.1464 4.85355L18.7929 7.5L16.1464 10.1464C15.9512 10.3417 15.9512 10.6583 16.1464 10.8536C16.3417 11.0488 16.6583 11.0488 16.8536 10.8536L19.5 8.20711L22.1464 10.8536C22.3417 11.0488 22.6583 11.0488 22.8536 10.8536C23.0488 10.6583 23.0488 10.3417 22.8536 10.1464L20.2071 7.5L22.8536 4.85355C23.0488 4.65829 23.0488 4.34171 22.8536 4.14645C22.6583 3.95118 22.3417 3.95118 22.1464 4.14645L19.5 6.79289L16.8536 4.14645Z",
        fill: "currentColor"
      }), vue.h("path", {
        d: "M25 22.75V12.5991C24.5572 13.0765 24.053 13.4961 23.5 13.8454V16H17.5L17.3982 16.0068C17.0322 16.0565 16.75 16.3703 16.75 16.75C16.75 18.2688 15.5188 19.5 14 19.5C12.4812 19.5 11.25 18.2688 11.25 16.75L11.2432 16.6482C11.1935 16.2822 10.8797 16 10.5 16H4.5V7.25C4.5 6.2835 5.2835 5.5 6.25 5.5H12.2696C12.4146 4.97463 12.6153 4.47237 12.865 4H6.25C4.45507 4 3 5.45507 3 7.25V22.75C3 24.5449 4.45507 26 6.25 26H21.75C23.5449 26 25 24.5449 25 22.75ZM4.5 22.75V17.5H9.81597L9.85751 17.7041C10.2905 19.5919 11.9808 21 14 21L14.215 20.9947C16.2095 20.8953 17.842 19.4209 18.184 17.5H23.5V22.75C23.5 23.7165 22.7165 24.5 21.75 24.5H6.25C5.2835 24.5 4.5 23.7165 4.5 22.75Z",
        fill: "currentColor"
      }));
    }
  });
  const ErrorIcon = replaceable("error", vue.h("svg", {
    viewBox: "0 0 48 48",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg"
  }, vue.h("g", {
    stroke: "none",
    "stroke-width": "1",
    "fill-rule": "evenodd"
  }, vue.h("g", {
    "fill-rule": "nonzero"
  }, vue.h("path", {
    d: "M24,4 C35.045695,4 44,12.954305 44,24 C44,35.045695 35.045695,44 24,44 C12.954305,44 4,35.045695 4,24 C4,12.954305 12.954305,4 24,4 Z M17.8838835,16.1161165 L17.7823881,16.0249942 C17.3266086,15.6583353 16.6733914,15.6583353 16.2176119,16.0249942 L16.1161165,16.1161165 L16.0249942,16.2176119 C15.6583353,16.6733914 15.6583353,17.3266086 16.0249942,17.7823881 L16.1161165,17.8838835 L22.233,24 L16.1161165,30.1161165 L16.0249942,30.2176119 C15.6583353,30.6733914 15.6583353,31.3266086 16.0249942,31.7823881 L16.1161165,31.8838835 L16.2176119,31.9750058 C16.6733914,32.3416647 17.3266086,32.3416647 17.7823881,31.9750058 L17.8838835,31.8838835 L24,25.767 L30.1161165,31.8838835 L30.2176119,31.9750058 C30.6733914,32.3416647 31.3266086,32.3416647 31.7823881,31.9750058 L31.8838835,31.8838835 L31.9750058,31.7823881 C32.3416647,31.3266086 32.3416647,30.6733914 31.9750058,30.2176119 L31.8838835,30.1161165 L25.767,24 L31.8838835,17.8838835 L31.9750058,17.7823881 C32.3416647,17.3266086 32.3416647,16.6733914 31.9750058,16.2176119 L31.8838835,16.1161165 L31.7823881,16.0249942 C31.3266086,15.6583353 30.6733914,15.6583353 30.2176119,16.0249942 L30.1161165,16.1161165 L24,22.233 L17.8838835,16.1161165 L17.7823881,16.0249942 L17.8838835,16.1161165 Z"
  })))));
  const FastBackwardIcon = vue.defineComponent({
    name: "FastBackward",
    render() {
      return vue.h("svg", {
        viewBox: "0 0 20 20",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg"
      }, vue.h("g", {
        stroke: "none",
        "stroke-width": "1",
        fill: "none",
        "fill-rule": "evenodd"
      }, vue.h("g", {
        fill: "currentColor",
        "fill-rule": "nonzero"
      }, vue.h("path", {
        d: "M8.73171,16.7949 C9.03264,17.0795 9.50733,17.0663 9.79196,16.7654 C10.0766,16.4644 10.0634,15.9897 9.76243,15.7051 L4.52339,10.75 L17.2471,10.75 C17.6613,10.75 17.9971,10.4142 17.9971,10 C17.9971,9.58579 17.6613,9.25 17.2471,9.25 L4.52112,9.25 L9.76243,4.29275 C10.0634,4.00812 10.0766,3.53343 9.79196,3.2325 C9.50733,2.93156 9.03264,2.91834 8.73171,3.20297 L2.31449,9.27241 C2.14819,9.4297 2.04819,9.62981 2.01448,9.8386 C2.00308,9.89058 1.99707,9.94459 1.99707,10 C1.99707,10.0576 2.00356,10.1137 2.01585,10.1675 C2.05084,10.3733 2.15039,10.5702 2.31449,10.7254 L8.73171,16.7949 Z"
      }))));
    }
  });
  const FastForwardIcon = vue.defineComponent({
    name: "FastForward",
    render() {
      return vue.h("svg", {
        viewBox: "0 0 20 20",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg"
      }, vue.h("g", {
        stroke: "none",
        "stroke-width": "1",
        fill: "none",
        "fill-rule": "evenodd"
      }, vue.h("g", {
        fill: "currentColor",
        "fill-rule": "nonzero"
      }, vue.h("path", {
        d: "M11.2654,3.20511 C10.9644,2.92049 10.4897,2.93371 10.2051,3.23464 C9.92049,3.53558 9.93371,4.01027 10.2346,4.29489 L15.4737,9.25 L2.75,9.25 C2.33579,9.25 2,9.58579 2,10.0000012 C2,10.4142 2.33579,10.75 2.75,10.75 L15.476,10.75 L10.2346,15.7073 C9.93371,15.9919 9.92049,16.4666 10.2051,16.7675 C10.4897,17.0684 10.9644,17.0817 11.2654,16.797 L17.6826,10.7276 C17.8489,10.5703 17.9489,10.3702 17.9826,10.1614 C17.994,10.1094 18,10.0554 18,10.0000012 C18,9.94241 17.9935,9.88633 17.9812,9.83246 C17.9462,9.62667 17.8467,9.42976 17.6826,9.27455 L11.2654,3.20511 Z"
      }))));
    }
  });
  const FilterIcon = vue.defineComponent({
    name: "Filter",
    render() {
      return vue.h("svg", {
        viewBox: "0 0 28 28",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg"
      }, vue.h("g", {
        stroke: "none",
        "stroke-width": "1",
        "fill-rule": "evenodd"
      }, vue.h("g", {
        "fill-rule": "nonzero"
      }, vue.h("path", {
        d: "M17,19 C17.5522847,19 18,19.4477153 18,20 C18,20.5522847 17.5522847,21 17,21 L11,21 C10.4477153,21 10,20.5522847 10,20 C10,19.4477153 10.4477153,19 11,19 L17,19 Z M21,13 C21.5522847,13 22,13.4477153 22,14 C22,14.5522847 21.5522847,15 21,15 L7,15 C6.44771525,15 6,14.5522847 6,14 C6,13.4477153 6.44771525,13 7,13 L21,13 Z M24,7 C24.5522847,7 25,7.44771525 25,8 C25,8.55228475 24.5522847,9 24,9 L4,9 C3.44771525,9 3,8.55228475 3,8 C3,7.44771525 3.44771525,7 4,7 L24,7 Z"
      }))));
    }
  });
  const ForwardIcon = vue.defineComponent({
    name: "Forward",
    render() {
      return vue.h("svg", {
        viewBox: "0 0 20 20",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, vue.h("path", {
        d: "M7.73271 4.20694C8.03263 3.92125 8.50737 3.93279 8.79306 4.23271L13.7944 9.48318C14.0703 9.77285 14.0703 10.2281 13.7944 10.5178L8.79306 15.7682C8.50737 16.0681 8.03263 16.0797 7.73271 15.794C7.43279 15.5083 7.42125 15.0336 7.70694 14.7336L12.2155 10.0005L7.70694 5.26729C7.42125 4.96737 7.43279 4.49264 7.73271 4.20694Z",
        fill: "currentColor"
      }));
    }
  });
  const InfoIcon = replaceable("info", vue.h("svg", {
    viewBox: "0 0 28 28",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg"
  }, vue.h("g", {
    stroke: "none",
    "stroke-width": "1",
    "fill-rule": "evenodd"
  }, vue.h("g", {
    "fill-rule": "nonzero"
  }, vue.h("path", {
    d: "M14,2 C20.6274,2 26,7.37258 26,14 C26,20.6274 20.6274,26 14,26 C7.37258,26 2,20.6274 2,14 C2,7.37258 7.37258,2 14,2 Z M14,11 C13.4477,11 13,11.4477 13,12 L13,12 L13,20 C13,20.5523 13.4477,21 14,21 C14.5523,21 15,20.5523 15,20 L15,20 L15,12 C15,11.4477 14.5523,11 14,11 Z M14,6.75 C13.3096,6.75 12.75,7.30964 12.75,8 C12.75,8.69036 13.3096,9.25 14,9.25 C14.6904,9.25 15.25,8.69036 15.25,8 C15.25,7.30964 14.6904,6.75 14,6.75 Z"
  })))));
  const MoreIcon = vue.defineComponent({
    name: "More",
    render() {
      return vue.h("svg", {
        viewBox: "0 0 16 16",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg"
      }, vue.h("g", {
        stroke: "none",
        "stroke-width": "1",
        fill: "none",
        "fill-rule": "evenodd"
      }, vue.h("g", {
        fill: "currentColor",
        "fill-rule": "nonzero"
      }, vue.h("path", {
        d: "M4,7 C4.55228,7 5,7.44772 5,8 C5,8.55229 4.55228,9 4,9 C3.44772,9 3,8.55229 3,8 C3,7.44772 3.44772,7 4,7 Z M8,7 C8.55229,7 9,7.44772 9,8 C9,8.55229 8.55229,9 8,9 C7.44772,9 7,8.55229 7,8 C7,7.44772 7.44772,7 8,7 Z M12,7 C12.5523,7 13,7.44772 13,8 C13,8.55229 12.5523,9 12,9 C11.4477,9 11,8.55229 11,8 C11,7.44772 11.4477,7 12,7 Z"
      }))));
    }
  });
  const RemoveIcon = vue.defineComponent({
    name: "Remove",
    render() {
      return vue.h("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 512"
      }, vue.h("line", {
        x1: "400",
        y1: "256",
        x2: "112",
        y2: "256",
        style: "\n        fill: none;\n        stroke: currentColor;\n        stroke-linecap: round;\n        stroke-linejoin: round;\n        stroke-width: 32px;\n      "
      }));
    }
  });
  const SearchIcon = vue.defineComponent({
    name: "Search",
    render() {
      return vue.h("svg", {
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 512",
        style: "enable-background: new 0 0 512 512"
      }, vue.h("path", {
        d: "M443.5,420.2L336.7,312.4c20.9-26.2,33.5-59.4,33.5-95.5c0-84.5-68.5-153-153.1-153S64,132.5,64,217s68.5,153,153.1,153\n  c36.6,0,70.1-12.8,96.5-34.2l106.1,107.1c3.2,3.4,7.6,5.1,11.9,5.1c4.1,0,8.2-1.5,11.3-4.5C449.5,437.2,449.7,426.8,443.5,420.2z\n   M217.1,337.1c-32.1,0-62.3-12.5-85-35.2c-22.7-22.7-35.2-52.9-35.2-84.9c0-32.1,12.5-62.3,35.2-84.9c22.7-22.7,52.9-35.2,85-35.2\n  c32.1,0,62.3,12.5,85,35.2c22.7,22.7,35.2,52.9,35.2,84.9c0,32.1-12.5,62.3-35.2,84.9C279.4,324.6,249.2,337.1,217.1,337.1z"
      }));
    }
  });
  const SuccessIcon = replaceable("success", vue.h("svg", {
    viewBox: "0 0 48 48",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg"
  }, vue.h("g", {
    stroke: "none",
    "stroke-width": "1",
    "fill-rule": "evenodd"
  }, vue.h("g", {
    "fill-rule": "nonzero"
  }, vue.h("path", {
    d: "M24,4 C35.045695,4 44,12.954305 44,24 C44,35.045695 35.045695,44 24,44 C12.954305,44 4,35.045695 4,24 C4,12.954305 12.954305,4 24,4 Z M32.6338835,17.6161165 C32.1782718,17.1605048 31.4584514,17.1301307 30.9676119,17.5249942 L30.8661165,17.6161165 L20.75,27.732233 L17.1338835,24.1161165 C16.6457281,23.6279612 15.8542719,23.6279612 15.3661165,24.1161165 C14.9105048,24.5717282 14.8801307,25.2915486 15.2749942,25.7823881 L15.3661165,25.8838835 L19.8661165,30.3838835 C20.3217282,30.8394952 21.0415486,30.8698693 21.5323881,30.4750058 L21.6338835,30.3838835 L32.6338835,19.3838835 C33.1220388,18.8957281 33.1220388,18.1042719 32.6338835,17.6161165 Z"
  })))));
  const SwitcherIcon = vue.defineComponent({
    name: "Switcher",
    render() {
      return vue.h("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 32 32"
      }, vue.h("path", {
        d: "M12 8l10 8l-10 8z"
      }));
    }
  });
  const TimeIcon = replaceable("time", vue.h("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 512 512"
  }, vue.h("path", {
    d: "M256,64C150,64,64,150,64,256s86,192,192,192,192-86,192-192S362,64,256,64Z",
    style: "\n        fill: none;\n        stroke: currentColor;\n        stroke-miterlimit: 10;\n        stroke-width: 32px;\n      "
  }), vue.h("polyline", {
    points: "256 128 256 272 352 272",
    style: "\n        fill: none;\n        stroke: currentColor;\n        stroke-linecap: round;\n        stroke-linejoin: round;\n        stroke-width: 32px;\n      "
  })));
  const WarningIcon = replaceable("warning", vue.h("svg", {
    viewBox: "0 0 24 24",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg"
  }, vue.h("g", {
    stroke: "none",
    "stroke-width": "1",
    "fill-rule": "evenodd"
  }, vue.h("g", {
    "fill-rule": "nonzero"
  }, vue.h("path", {
    d: "M12,2 C17.523,2 22,6.478 22,12 C22,17.522 17.523,22 12,22 C6.477,22 2,17.522 2,12 C2,6.478 6.477,2 12,2 Z M12.0018002,15.0037242 C11.450254,15.0037242 11.0031376,15.4508407 11.0031376,16.0023869 C11.0031376,16.553933 11.450254,17.0010495 12.0018002,17.0010495 C12.5533463,17.0010495 13.0004628,16.553933 13.0004628,16.0023869 C13.0004628,15.4508407 12.5533463,15.0037242 12.0018002,15.0037242 Z M11.99964,7 C11.4868042,7.00018474 11.0642719,7.38637706 11.0066858,7.8837365 L11,8.00036004 L11.0018003,13.0012393 L11.00857,13.117858 C11.0665141,13.6151758 11.4893244,14.0010638 12.0021602,14.0008793 C12.514996,14.0006946 12.9375283,13.6145023 12.9951144,13.1171428 L13.0018002,13.0005193 L13,7.99964009 L12.9932303,7.8830214 C12.9352861,7.38570354 12.5124758,6.99981552 11.99964,7 Z"
  })))));
  const CancelIcon = replaceable("cancel", vue.h("svg", {
    viewBox: "0 0 16 16",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg"
  }, vue.h("g", {
    stroke: "none",
    "stroke-width": "1",
    fill: "none",
    "fill-rule": "evenodd"
  }, vue.h("g", {
    fill: "currentColor",
    "fill-rule": "nonzero"
  }, vue.h("path", {
    d: "M2.58859116,2.7156945 L2.64644661,2.64644661 C2.82001296,2.47288026 3.08943736,2.45359511 3.2843055,2.58859116 L3.35355339,2.64644661 L8,7.293 L12.6464466,2.64644661 C12.8417088,2.45118446 13.1582912,2.45118446 13.3535534,2.64644661 C13.5488155,2.84170876 13.5488155,3.15829124 13.3535534,3.35355339 L8.707,8 L13.3535534,12.6464466 C13.5271197,12.820013 13.5464049,13.0894374 13.4114088,13.2843055 L13.3535534,13.3535534 C13.179987,13.5271197 12.9105626,13.5464049 12.7156945,13.4114088 L12.6464466,13.3535534 L8,8.707 L3.35355339,13.3535534 C3.15829124,13.5488155 2.84170876,13.5488155 2.64644661,13.3535534 C2.45118446,13.1582912 2.45118446,12.8417088 2.64644661,12.6464466 L7.293,8 L2.64644661,3.35355339 C2.47288026,3.17998704 2.45359511,2.91056264 2.58859116,2.7156945 L2.64644661,2.64644661 L2.58859116,2.7156945 Z"
  })))));
  const ChevronDownIcon = vue.defineComponent({
    name: "ChevronDown",
    render() {
      return vue.h("svg", {
        viewBox: "0 0 16 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, vue.h("path", {
        d: "M3.14645 5.64645C3.34171 5.45118 3.65829 5.45118 3.85355 5.64645L8 9.79289L12.1464 5.64645C12.3417 5.45118 12.6583 5.45118 12.8536 5.64645C13.0488 5.84171 13.0488 6.15829 12.8536 6.35355L8.35355 10.8536C8.15829 11.0488 7.84171 11.0488 7.64645 10.8536L3.14645 6.35355C2.95118 6.15829 2.95118 5.84171 3.14645 5.64645Z",
        fill: "currentColor"
      }));
    }
  });
  const ClearIcon = replaceable("clear", vue.h("svg", {
    viewBox: "0 0 16 16",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg"
  }, vue.h("g", {
    stroke: "none",
    "stroke-width": "1",
    fill: "none",
    "fill-rule": "evenodd"
  }, vue.h("g", {
    fill: "currentColor",
    "fill-rule": "nonzero"
  }, vue.h("path", {
    d: "M8,2 C11.3137085,2 14,4.6862915 14,8 C14,11.3137085 11.3137085,14 8,14 C4.6862915,14 2,11.3137085 2,8 C2,4.6862915 4.6862915,2 8,2 Z M6.5343055,5.83859116 C6.33943736,5.70359511 6.07001296,5.72288026 5.89644661,5.89644661 L5.89644661,5.89644661 L5.83859116,5.9656945 C5.70359511,6.16056264 5.72288026,6.42998704 5.89644661,6.60355339 L5.89644661,6.60355339 L7.293,8 L5.89644661,9.39644661 L5.83859116,9.4656945 C5.70359511,9.66056264 5.72288026,9.92998704 5.89644661,10.1035534 L5.89644661,10.1035534 L5.9656945,10.1614088 C6.16056264,10.2964049 6.42998704,10.2771197 6.60355339,10.1035534 L6.60355339,10.1035534 L8,8.707 L9.39644661,10.1035534 L9.4656945,10.1614088 C9.66056264,10.2964049 9.92998704,10.2771197 10.1035534,10.1035534 L10.1035534,10.1035534 L10.1614088,10.0343055 C10.2964049,9.83943736 10.2771197,9.57001296 10.1035534,9.39644661 L10.1035534,9.39644661 L8.707,8 L10.1035534,6.60355339 L10.1614088,6.5343055 C10.2964049,6.33943736 10.2771197,6.07001296 10.1035534,5.89644661 L10.1035534,5.89644661 L10.0343055,5.83859116 C9.83943736,5.70359511 9.57001296,5.72288026 9.39644661,5.89644661 L9.39644661,5.89644661 L8,7.293 L6.60355339,5.89644661 Z"
  })))));
  const ChevronDownFilledIcon = vue.defineComponent({
    name: "ChevronDownFilled",
    render() {
      return vue.h("svg", {
        viewBox: "0 0 16 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, vue.h("path", {
        d: "M3.20041 5.73966C3.48226 5.43613 3.95681 5.41856 4.26034 5.70041L8 9.22652L11.7397 5.70041C12.0432 5.41856 12.5177 5.43613 12.7996 5.73966C13.0815 6.0432 13.0639 6.51775 12.7603 6.7996L8.51034 10.7996C8.22258 11.0668 7.77743 11.0668 7.48967 10.7996L3.23966 6.7996C2.93613 6.51775 2.91856 6.0432 3.20041 5.73966Z",
        fill: "currentColor"
      }));
    }
  });
  const ToIcon = replaceable("to", vue.h("svg", {
    viewBox: "0 0 20 20",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg"
  }, vue.h("g", {
    stroke: "none",
    "stroke-width": "1",
    fill: "none",
    "fill-rule": "evenodd"
  }, vue.h("g", {
    fill: "currentColor",
    "fill-rule": "nonzero"
  }, vue.h("path", {
    d: "M11.2654,3.20511 C10.9644,2.92049 10.4897,2.93371 10.2051,3.23464 C9.92049,3.53558 9.93371,4.01027 10.2346,4.29489 L15.4737,9.25 L2.75,9.25 C2.33579,9.25 2,9.58579 2,10.0000012 C2,10.4142 2.33579,10.75 2.75,10.75 L15.476,10.75 L10.2346,15.7073 C9.93371,15.9919 9.92049,16.4666 10.2051,16.7675 C10.4897,17.0684 10.9644,17.0817 11.2654,16.797 L17.6826,10.7276 C17.8489,10.5703 17.9489,10.3702 17.9826,10.1614 C17.994,10.1094 18,10.0554 18,10.0000012 C18,9.94241 17.9935,9.88633 17.9812,9.83246 C17.9462,9.62667 17.8467,9.42976 17.6826,9.27455 L11.2654,3.20511 Z"
  })))));
  const RetryIcon = replaceable("retry", vue.h("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 512 512"
  }, vue.h("path", {
    d: "M320,146s24.36-12-64-12A160,160,0,1,0,416,294",
    style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-miterlimit: 10; stroke-width: 32px;"
  }), vue.h("polyline", {
    points: "256 58 336 138 256 218",
    style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;"
  })));
  const ArrowBackIcon = vue.defineComponent({
    name: "ArrowBack",
    render() {
      return vue.h("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24"
      }, vue.h("path", {
        d: "M0 0h24v24H0V0z",
        fill: "none"
      }), vue.h("path", {
        d: "M19 11H7.83l4.88-4.88c.39-.39.39-1.03 0-1.42-.39-.39-1.02-.39-1.41 0l-6.59 6.59c-.39.39-.39 1.02 0 1.41l6.59 6.59c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41L7.83 13H19c.55 0 1-.45 1-1s-.45-1-1-1z"
      }));
    }
  });
  const RotateClockwiseIcon = replaceable("rotateClockwise", vue.h("svg", {
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, vue.h("path", {
    d: "M3 10C3 6.13401 6.13401 3 10 3C13.866 3 17 6.13401 17 10C17 12.7916 15.3658 15.2026 13 16.3265V14.5C13 14.2239 12.7761 14 12.5 14C12.2239 14 12 14.2239 12 14.5V17.5C12 17.7761 12.2239 18 12.5 18H15.5C15.7761 18 16 17.7761 16 17.5C16 17.2239 15.7761 17 15.5 17H13.8758C16.3346 15.6357 18 13.0128 18 10C18 5.58172 14.4183 2 10 2C5.58172 2 2 5.58172 2 10C2 10.2761 2.22386 10.5 2.5 10.5C2.77614 10.5 3 10.2761 3 10Z",
    fill: "currentColor"
  }), vue.h("path", {
    d: "M10 12C11.1046 12 12 11.1046 12 10C12 8.89543 11.1046 8 10 8C8.89543 8 8 8.89543 8 10C8 11.1046 8.89543 12 10 12ZM10 11C9.44772 11 9 10.5523 9 10C9 9.44772 9.44772 9 10 9C10.5523 9 11 9.44772 11 10C11 10.5523 10.5523 11 10 11Z",
    fill: "currentColor"
  })));
  const RotateCounterclockwiseIcon = replaceable("rotateClockwise", vue.h("svg", {
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, vue.h("path", {
    d: "M17 10C17 6.13401 13.866 3 10 3C6.13401 3 3 6.13401 3 10C3 12.7916 4.63419 15.2026 7 16.3265V14.5C7 14.2239 7.22386 14 7.5 14C7.77614 14 8 14.2239 8 14.5V17.5C8 17.7761 7.77614 18 7.5 18H4.5C4.22386 18 4 17.7761 4 17.5C4 17.2239 4.22386 17 4.5 17H6.12422C3.66539 15.6357 2 13.0128 2 10C2 5.58172 5.58172 2 10 2C14.4183 2 18 5.58172 18 10C18 10.2761 17.7761 10.5 17.5 10.5C17.2239 10.5 17 10.2761 17 10Z",
    fill: "currentColor"
  }), vue.h("path", {
    d: "M10 12C8.89543 12 8 11.1046 8 10C8 8.89543 8.89543 8 10 8C11.1046 8 12 8.89543 12 10C12 11.1046 11.1046 12 10 12ZM10 11C10.5523 11 11 10.5523 11 10C11 9.44772 10.5523 9 10 9C9.44772 9 9 9.44772 9 10C9 10.5523 9.44772 11 10 11Z",
    fill: "currentColor"
  })));
  const ZoomInIcon = replaceable("zoomIn", vue.h("svg", {
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, vue.h("path", {
    d: "M11.5 8.5C11.5 8.22386 11.2761 8 11 8H9V6C9 5.72386 8.77614 5.5 8.5 5.5C8.22386 5.5 8 5.72386 8 6V8H6C5.72386 8 5.5 8.22386 5.5 8.5C5.5 8.77614 5.72386 9 6 9H8V11C8 11.2761 8.22386 11.5 8.5 11.5C8.77614 11.5 9 11.2761 9 11V9H11C11.2761 9 11.5 8.77614 11.5 8.5Z",
    fill: "currentColor"
  }), vue.h("path", {
    d: "M8.5 3C11.5376 3 14 5.46243 14 8.5C14 9.83879 13.5217 11.0659 12.7266 12.0196L16.8536 16.1464C17.0488 16.3417 17.0488 16.6583 16.8536 16.8536C16.68 17.0271 16.4106 17.0464 16.2157 16.9114L16.1464 16.8536L12.0196 12.7266C11.0659 13.5217 9.83879 14 8.5 14C5.46243 14 3 11.5376 3 8.5C3 5.46243 5.46243 3 8.5 3ZM8.5 4C6.01472 4 4 6.01472 4 8.5C4 10.9853 6.01472 13 8.5 13C10.9853 13 13 10.9853 13 8.5C13 6.01472 10.9853 4 8.5 4Z",
    fill: "currentColor"
  })));
  const ZoomOutIcon = replaceable("zoomOut", vue.h("svg", {
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, vue.h("path", {
    d: "M11 8C11.2761 8 11.5 8.22386 11.5 8.5C11.5 8.77614 11.2761 9 11 9H6C5.72386 9 5.5 8.77614 5.5 8.5C5.5 8.22386 5.72386 8 6 8H11Z",
    fill: "currentColor"
  }), vue.h("path", {
    d: "M14 8.5C14 5.46243 11.5376 3 8.5 3C5.46243 3 3 5.46243 3 8.5C3 11.5376 5.46243 14 8.5 14C9.83879 14 11.0659 13.5217 12.0196 12.7266L16.1464 16.8536L16.2157 16.9114C16.4106 17.0464 16.68 17.0271 16.8536 16.8536C17.0488 16.6583 17.0488 16.3417 16.8536 16.1464L12.7266 12.0196C13.5217 11.0659 14 9.83879 14 8.5ZM4 8.5C4 6.01472 6.01472 4 8.5 4C10.9853 4 13 6.01472 13 8.5C13 10.9853 10.9853 13 8.5 13C6.01472 13 4 10.9853 4 8.5Z",
    fill: "currentColor"
  })));
  const ResizeSmallIcon = vue.defineComponent({
    name: "ResizeSmall",
    render() {
      return vue.h("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 20 20"
      }, vue.h("g", {
        fill: "none"
      }, vue.h("path", {
        d: "M5.5 4A1.5 1.5 0 0 0 4 5.5v1a.5.5 0 0 1-1 0v-1A2.5 2.5 0 0 1 5.5 3h1a.5.5 0 0 1 0 1h-1zM16 5.5A1.5 1.5 0 0 0 14.5 4h-1a.5.5 0 0 1 0-1h1A2.5 2.5 0 0 1 17 5.5v1a.5.5 0 0 1-1 0v-1zm0 9a1.5 1.5 0 0 1-1.5 1.5h-1a.5.5 0 0 0 0 1h1a2.5 2.5 0 0 0 2.5-2.5v-1a.5.5 0 0 0-1 0v1zm-12 0A1.5 1.5 0 0 0 5.5 16h1.25a.5.5 0 0 1 0 1H5.5A2.5 2.5 0 0 1 3 14.5v-1.25a.5.5 0 0 1 1 0v1.25zM8.5 7A1.5 1.5 0 0 0 7 8.5v3A1.5 1.5 0 0 0 8.5 13h3a1.5 1.5 0 0 0 1.5-1.5v-3A1.5 1.5 0 0 0 11.5 7h-3zM8 8.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3z",
        fill: "currentColor"
      })));
    }
  });
  const NIconSwitchTransition = vue.defineComponent({
    name: "BaseIconSwitchTransition",
    setup(_, {
      slots
    }) {
      const isMountedRef = isMounted();
      return () => vue.h(vue.Transition, {
        name: "icon-switch-transition",
        appear: isMountedRef.value
      }, slots);
    }
  });
  const NFadeInExpandTransition = vue.defineComponent({
    name: "FadeInExpandTransition",
    props: {
      appear: Boolean,
      group: Boolean,
      mode: String,
      onLeave: Function,
      onAfterLeave: Function,
      onAfterEnter: Function,
      width: Boolean,
      // reverse mode is only used in tree
      // it make it from expanded to collapsed after mounted
      reverse: Boolean
    },
    setup(props, {
      slots
    }) {
      function handleBeforeLeave(el) {
        if (props.width) {
          el.style.maxWidth = `${el.offsetWidth}px`;
        } else {
          el.style.maxHeight = `${el.offsetHeight}px`;
        }
        void el.offsetWidth;
      }
      function handleLeave(el) {
        if (props.width) {
          el.style.maxWidth = "0";
        } else {
          el.style.maxHeight = "0";
        }
        void el.offsetWidth;
        const {
          onLeave
        } = props;
        if (onLeave)
          onLeave();
      }
      function handleAfterLeave(el) {
        if (props.width) {
          el.style.maxWidth = "";
        } else {
          el.style.maxHeight = "";
        }
        const {
          onAfterLeave
        } = props;
        if (onAfterLeave)
          onAfterLeave();
      }
      function handleEnter(el) {
        el.style.transition = "none";
        if (props.width) {
          const memorizedWidth = el.offsetWidth;
          el.style.maxWidth = "0";
          void el.offsetWidth;
          el.style.transition = "";
          el.style.maxWidth = `${memorizedWidth}px`;
        } else {
          if (props.reverse) {
            el.style.maxHeight = `${el.offsetHeight}px`;
            void el.offsetHeight;
            el.style.transition = "";
            el.style.maxHeight = "0";
          } else {
            const memorizedHeight = el.offsetHeight;
            el.style.maxHeight = "0";
            void el.offsetWidth;
            el.style.transition = "";
            el.style.maxHeight = `${memorizedHeight}px`;
          }
        }
        void el.offsetWidth;
      }
      function handleAfterEnter(el) {
        var _a;
        if (props.width) {
          el.style.maxWidth = "";
        } else {
          if (!props.reverse) {
            el.style.maxHeight = "";
          }
        }
        (_a = props.onAfterEnter) === null || _a === void 0 ? void 0 : _a.call(props);
      }
      return () => {
        const {
          group,
          width,
          appear,
          mode
        } = props;
        const type = group ? vue.TransitionGroup : vue.Transition;
        const resolvedProps = {
          name: width ? "fade-in-width-expand-transition" : "fade-in-height-expand-transition",
          appear,
          onEnter: handleEnter,
          onAfterEnter: handleAfterEnter,
          onBeforeLeave: handleBeforeLeave,
          onLeave: handleLeave,
          onAfterLeave: handleAfterLeave
        };
        if (!group) {
          resolvedProps.mode = mode;
        }
        return vue.h(type, resolvedProps, slots);
      };
    }
  });
  const style$1C = cB("base-icon", `
 height: 1em;
 width: 1em;
 line-height: 1em;
 text-align: center;
 display: inline-block;
 position: relative;
 fill: currentColor;
 transform: translateZ(0);
`, [c$1("svg", `
 height: 1em;
 width: 1em;
 `)]);
  const NBaseIcon = vue.defineComponent({
    name: "BaseIcon",
    props: {
      role: String,
      ariaLabel: String,
      ariaDisabled: {
        type: Boolean,
        default: void 0
      },
      ariaHidden: {
        type: Boolean,
        default: void 0
      },
      clsPrefix: {
        type: String,
        required: true
      },
      onClick: Function,
      onMousedown: Function,
      onMouseup: Function
    },
    setup(props) {
      useStyle("-base-icon", style$1C, vue.toRef(props, "clsPrefix"));
    },
    render() {
      return vue.h("i", {
        class: `${this.clsPrefix}-base-icon`,
        onClick: this.onClick,
        onMousedown: this.onMousedown,
        onMouseup: this.onMouseup,
        role: this.role,
        "aria-label": this.ariaLabel,
        "aria-hidden": this.ariaHidden,
        "aria-disabled": this.ariaDisabled
      }, this.$slots);
    }
  });
  const style$1B = cB("base-close", `
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 background-color: transparent;
 color: var(--n-close-icon-color);
 border-radius: var(--n-close-border-radius);
 height: var(--n-close-size);
 width: var(--n-close-size);
 font-size: var(--n-close-icon-size);
 outline: none;
 border: none;
 position: relative;
 padding: 0;
`, [cM("absolute", `
 height: var(--n-close-icon-size);
 width: var(--n-close-icon-size);
 `), c$1("&::before", `
 content: "";
 position: absolute;
 width: var(--n-close-size);
 height: var(--n-close-size);
 left: 50%;
 top: 50%;
 transform: translateY(-50%) translateX(-50%);
 transition: inherit;
 border-radius: inherit;
 `), cNotM("disabled", [c$1("&:hover", `
 color: var(--n-close-icon-color-hover);
 `), c$1("&:hover::before", `
 background-color: var(--n-close-color-hover);
 `), c$1("&:focus::before", `
 background-color: var(--n-close-color-hover);
 `), c$1("&:active", `
 color: var(--n-close-icon-color-pressed);
 `), c$1("&:active::before", `
 background-color: var(--n-close-color-pressed);
 `)]), cM("disabled", `
 cursor: not-allowed;
 color: var(--n-close-icon-color-disabled);
 background-color: transparent;
 `), cM("round", [c$1("&::before", `
 border-radius: 50%;
 `)])]);
  const NBaseClose = vue.defineComponent({
    name: "BaseClose",
    props: {
      isButtonTag: {
        type: Boolean,
        default: true
      },
      clsPrefix: {
        type: String,
        required: true
      },
      disabled: {
        type: Boolean,
        default: void 0
      },
      focusable: {
        type: Boolean,
        default: true
      },
      round: Boolean,
      onClick: Function,
      absolute: Boolean
    },
    setup(props) {
      useStyle("-base-close", style$1B, vue.toRef(props, "clsPrefix"));
      return () => {
        const {
          clsPrefix,
          disabled,
          absolute,
          round: round2,
          isButtonTag
        } = props;
        const Tag = isButtonTag ? "button" : "div";
        return vue.h(Tag, {
          type: isButtonTag ? "button" : void 0,
          tabindex: disabled || !props.focusable ? -1 : 0,
          "aria-disabled": disabled,
          "aria-label": "close",
          role: isButtonTag ? void 0 : "button",
          disabled,
          class: [`${clsPrefix}-base-close`, absolute && `${clsPrefix}-base-close--absolute`, disabled && `${clsPrefix}-base-close--disabled`, round2 && `${clsPrefix}-base-close--round`],
          onMousedown: (e) => {
            if (!props.focusable) {
              e.preventDefault();
            }
          },
          onClick: props.onClick
        }, vue.h(NBaseIcon, {
          clsPrefix
        }, {
          default: () => vue.h(ErrorIcon$1, null)
        }));
      };
    }
  });
  const FocusDetector = vue.defineComponent({
    props: {
      onFocus: Function,
      onBlur: Function
    },
    setup(props) {
      return () => vue.h("div", {
        style: "width: 0; height: 0",
        tabindex: 0,
        onFocus: props.onFocus,
        onBlur: props.onBlur
      });
    }
  });
  const {
    cubicBezierEaseInOut: cubicBezierEaseInOut$4
  } = commonVariables$m;
  function iconSwitchTransition({
    originalTransform = "",
    left = 0,
    top = 0,
    transition = `all .3s ${cubicBezierEaseInOut$4} !important`
  } = {}) {
    return [c$1("&.icon-switch-transition-enter-from, &.icon-switch-transition-leave-to", {
      transform: `${originalTransform} scale(0.75)`,
      left,
      top,
      opacity: 0
    }), c$1("&.icon-switch-transition-enter-to, &.icon-switch-transition-leave-from", {
      transform: `scale(1) ${originalTransform}`,
      left,
      top,
      opacity: 1
    }), c$1("&.icon-switch-transition-enter-active, &.icon-switch-transition-leave-active", {
      transformOrigin: "center",
      position: "absolute",
      left,
      top,
      transition
    })];
  }
  const style$1A = c$1([c$1("@keyframes rotator", `
 0% {
 -webkit-transform: rotate(0deg);
 transform: rotate(0deg);
 }
 100% {
 -webkit-transform: rotate(360deg);
 transform: rotate(360deg);
 }`), cB("base-loading", `
 position: relative;
 line-height: 0;
 width: 1em;
 height: 1em;
 `, [cE("transition-wrapper", `
 position: absolute;
 width: 100%;
 height: 100%;
 `, [iconSwitchTransition()]), cE("placeholder", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [iconSwitchTransition({
    left: "50%",
    top: "50%",
    originalTransform: "translateX(-50%) translateY(-50%)"
  })]), cE("container", `
 animation: rotator 3s linear infinite both;
 `, [cE("icon", `
 height: 1em;
 width: 1em;
 `)])])]);
  const duration = "1.6s";
  const exposedLoadingProps = {
    strokeWidth: {
      type: Number,
      default: 28
    },
    stroke: {
      type: String,
      default: void 0
    }
  };
  const NBaseLoading = vue.defineComponent({
    name: "BaseLoading",
    props: Object.assign({
      clsPrefix: {
        type: String,
        required: true
      },
      show: {
        type: Boolean,
        default: true
      },
      scale: {
        type: Number,
        default: 1
      },
      radius: {
        type: Number,
        default: 100
      }
    }, exposedLoadingProps),
    setup(props) {
      useStyle("-base-loading", style$1A, vue.toRef(props, "clsPrefix"));
    },
    render() {
      const {
        clsPrefix,
        radius,
        strokeWidth,
        stroke,
        scale
      } = this;
      const scaledRadius = radius / scale;
      return vue.h("div", {
        class: `${clsPrefix}-base-loading`,
        role: "img",
        "aria-label": "loading"
      }, vue.h(NIconSwitchTransition, null, {
        default: () => this.show ? vue.h("div", {
          key: "icon",
          class: `${clsPrefix}-base-loading__transition-wrapper`
        }, vue.h("div", {
          class: `${clsPrefix}-base-loading__container`
        }, vue.h("svg", {
          class: `${clsPrefix}-base-loading__icon`,
          viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`,
          xmlns: "http://www.w3.org/2000/svg",
          style: {
            color: stroke
          }
        }, vue.h("g", null, vue.h("animateTransform", {
          attributeName: "transform",
          type: "rotate",
          values: `0 ${scaledRadius} ${scaledRadius};270 ${scaledRadius} ${scaledRadius}`,
          begin: "0s",
          dur: duration,
          fill: "freeze",
          repeatCount: "indefinite"
        }), vue.h("circle", {
          class: `${clsPrefix}-base-loading__icon`,
          fill: "none",
          stroke: "currentColor",
          "stroke-width": strokeWidth,
          "stroke-linecap": "round",
          cx: scaledRadius,
          cy: scaledRadius,
          r: radius - strokeWidth / 2,
          "stroke-dasharray": 5.67 * radius,
          "stroke-dashoffset": 18.48 * radius
        }, vue.h("animateTransform", {
          attributeName: "transform",
          type: "rotate",
          values: `0 ${scaledRadius} ${scaledRadius};135 ${scaledRadius} ${scaledRadius};450 ${scaledRadius} ${scaledRadius}`,
          begin: "0s",
          dur: duration,
          fill: "freeze",
          repeatCount: "indefinite"
        }), vue.h("animate", {
          attributeName: "stroke-dashoffset",
          values: `${5.67 * radius};${1.42 * radius};${5.67 * radius}`,
          begin: "0s",
          dur: duration,
          fill: "freeze",
          repeatCount: "indefinite"
        })))))) : vue.h("div", {
          key: "placeholder",
          class: `${clsPrefix}-base-loading__placeholder`
        }, this.$slots)
      }));
    }
  });
  function toArray(arg) {
    if (Array.isArray(arg))
      return arg;
    return [arg];
  }
  const TRAVERSE_COMMAND = {
    STOP: "STOP"
  };
  function traverseWithCb(treeNode, callback) {
    const command = callback(treeNode);
    if (treeNode.children !== void 0 && command !== TRAVERSE_COMMAND.STOP) {
      treeNode.children.forEach((childNode) => traverseWithCb(childNode, callback));
    }
  }
  function getNonLeafKeys(treeNodes, options = {}) {
    const { preserveGroup = false } = options;
    const keys2 = [];
    const cb = preserveGroup ? (node) => {
      if (!node.isLeaf) {
        keys2.push(node.key);
        traverse2(node.children);
      }
    } : (node) => {
      if (!node.isLeaf) {
        if (!node.isGroup)
          keys2.push(node.key);
        traverse2(node.children);
      }
    };
    function traverse2(nodes) {
      nodes.forEach(cb);
    }
    traverse2(treeNodes);
    return keys2;
  }
  function isLeaf(rawNode, getChildren) {
    const { isLeaf: isLeaf2 } = rawNode;
    if (isLeaf2 !== void 0)
      return isLeaf2;
    else if (!getChildren(rawNode))
      return true;
    return false;
  }
  function defaultGetChildren(node) {
    return node.children;
  }
  function defaultGetKey(node) {
    return node.key;
  }
  function isIgnored() {
    return false;
  }
  function isShallowLoaded(rawNode, getChildren) {
    const { isLeaf: isLeaf2 } = rawNode;
    if (isLeaf2 === false && !Array.isArray(getChildren(rawNode)))
      return false;
    return true;
  }
  function isDisabled(rawNode) {
    return rawNode.disabled === true;
  }
  function isExpilicitlyNotLoaded(rawNode, getChildren) {
    return rawNode.isLeaf === false && !Array.isArray(getChildren(rawNode));
  }
  function isNodeInvalid(rawNode, getChildren) {
    if (rawNode.isLeaf === true) {
      const children = getChildren(rawNode);
      if (Array.isArray(children) && children.length > 0)
        return true;
    }
    return false;
  }
  function unwrapCheckedKeys(result) {
    var _a;
    if (result === void 0 || result === null)
      return [];
    if (Array.isArray(result))
      return result;
    return (_a = result.checkedKeys) !== null && _a !== void 0 ? _a : [];
  }
  function unwrapIndeterminateKeys(result) {
    var _a;
    if (result === void 0 || result === null || Array.isArray(result)) {
      return [];
    }
    return (_a = result.indeterminateKeys) !== null && _a !== void 0 ? _a : [];
  }
  function merge(originalKeys, keysToAdd) {
    const set2 = new Set(originalKeys);
    keysToAdd.forEach((key) => {
      if (!set2.has(key)) {
        set2.add(key);
      }
    });
    return Array.from(set2);
  }
  function minus(originalKeys, keysToRemove) {
    const set2 = new Set(originalKeys);
    keysToRemove.forEach((key) => {
      if (set2.has(key)) {
        set2.delete(key);
      }
    });
    return Array.from(set2);
  }
  function isGroup(rawNode) {
    return (rawNode === null || rawNode === void 0 ? void 0 : rawNode.type) === "group";
  }
  function createIndexGetter(treeNodes) {
    const map2 = /* @__PURE__ */ new Map();
    treeNodes.forEach((treeNode, i) => {
      map2.set(treeNode.key, i);
    });
    return (key) => {
      var _a;
      return (_a = map2.get(key)) !== null && _a !== void 0 ? _a : null;
    };
  }
  class SubtreeNotLoadedError extends Error {
    constructor() {
      super();
      this.message = "SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded.";
    }
  }
  function getExtendedCheckedKeySetAfterCheck(checkKeys, currentCheckedKeys, treeMate, allowNotLoaded) {
    return getExtendedCheckedKeySet(currentCheckedKeys.concat(checkKeys), treeMate, allowNotLoaded, false);
  }
  function getAvailableAscendantNodeSet(uncheckedKeys, treeMate) {
    const visitedKeys = /* @__PURE__ */ new Set();
    uncheckedKeys.forEach((uncheckedKey) => {
      const uncheckedTreeNode = treeMate.treeNodeMap.get(uncheckedKey);
      if (uncheckedTreeNode !== void 0) {
        let nodeCursor = uncheckedTreeNode.parent;
        while (nodeCursor !== null) {
          if (nodeCursor.disabled)
            break;
          if (visitedKeys.has(nodeCursor.key))
            break;
          else {
            visitedKeys.add(nodeCursor.key);
          }
          nodeCursor = nodeCursor.parent;
        }
      }
    });
    return visitedKeys;
  }
  function getExtendedCheckedKeySetAfterUncheck(uncheckedKeys, currentCheckedKeys, treeMate, allowNotLoaded) {
    const extendedCheckedKeySet = getExtendedCheckedKeySet(currentCheckedKeys, treeMate, allowNotLoaded, false);
    const extendedKeySetToUncheck = getExtendedCheckedKeySet(uncheckedKeys, treeMate, allowNotLoaded, true);
    const ascendantKeySet = getAvailableAscendantNodeSet(uncheckedKeys, treeMate);
    const keysToRemove = [];
    extendedCheckedKeySet.forEach((key) => {
      if (extendedKeySetToUncheck.has(key) || ascendantKeySet.has(key)) {
        keysToRemove.push(key);
      }
    });
    keysToRemove.forEach((key) => extendedCheckedKeySet.delete(key));
    return extendedCheckedKeySet;
  }
  function getCheckedKeys(options, treeMate) {
    const { checkedKeys, keysToCheck, keysToUncheck, indeterminateKeys, cascade, leafOnly, checkStrategy, allowNotLoaded } = options;
    if (!cascade) {
      if (keysToCheck !== void 0) {
        return {
          checkedKeys: merge(checkedKeys, keysToCheck),
          indeterminateKeys: Array.from(indeterminateKeys)
        };
      } else if (keysToUncheck !== void 0) {
        return {
          checkedKeys: minus(checkedKeys, keysToUncheck),
          indeterminateKeys: Array.from(indeterminateKeys)
        };
      } else {
        return {
          checkedKeys: Array.from(checkedKeys),
          indeterminateKeys: Array.from(indeterminateKeys)
        };
      }
    }
    const { levelTreeNodeMap } = treeMate;
    let extendedCheckedKeySet;
    if (keysToUncheck !== void 0) {
      extendedCheckedKeySet = getExtendedCheckedKeySetAfterUncheck(keysToUncheck, checkedKeys, treeMate, allowNotLoaded);
    } else if (keysToCheck !== void 0) {
      extendedCheckedKeySet = getExtendedCheckedKeySetAfterCheck(keysToCheck, checkedKeys, treeMate, allowNotLoaded);
    } else {
      extendedCheckedKeySet = getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, false);
    }
    const checkStrategyIsParent = checkStrategy === "parent";
    const checkStrategyIsChild = checkStrategy === "child" || leafOnly;
    const syntheticCheckedKeySet = extendedCheckedKeySet;
    const syntheticIndeterminateKeySet = /* @__PURE__ */ new Set();
    const maxLevel = Math.max.apply(null, Array.from(levelTreeNodeMap.keys()));
    for (let level = maxLevel; level >= 0; level -= 1) {
      const levelIsZero = level === 0;
      const levelTreeNodes = levelTreeNodeMap.get(level);
      for (const levelTreeNode of levelTreeNodes) {
        if (levelTreeNode.isLeaf)
          continue;
        const { key: levelTreeNodeKey, shallowLoaded } = levelTreeNode;
        if (checkStrategyIsChild && shallowLoaded) {
          levelTreeNode.children.forEach((v) => {
            if (!v.disabled && !v.isLeaf && v.shallowLoaded && syntheticCheckedKeySet.has(v.key)) {
              syntheticCheckedKeySet.delete(v.key);
            }
          });
        }
        if (levelTreeNode.disabled || !shallowLoaded) {
          continue;
        }
        let fullyChecked = true;
        let partialChecked = false;
        let allDisabled = true;
        for (const childNode of levelTreeNode.children) {
          const childKey = childNode.key;
          if (childNode.disabled)
            continue;
          if (allDisabled)
            allDisabled = false;
          if (syntheticCheckedKeySet.has(childKey)) {
            partialChecked = true;
          } else if (syntheticIndeterminateKeySet.has(childKey)) {
            partialChecked = true;
            fullyChecked = false;
            break;
          } else {
            fullyChecked = false;
            if (partialChecked) {
              break;
            }
          }
        }
        if (fullyChecked && !allDisabled) {
          if (checkStrategyIsParent) {
            levelTreeNode.children.forEach((v) => {
              if (!v.disabled && syntheticCheckedKeySet.has(v.key)) {
                syntheticCheckedKeySet.delete(v.key);
              }
            });
          }
          syntheticCheckedKeySet.add(levelTreeNodeKey);
        } else if (partialChecked) {
          syntheticIndeterminateKeySet.add(levelTreeNodeKey);
        }
        if (levelIsZero && checkStrategyIsChild && syntheticCheckedKeySet.has(levelTreeNodeKey)) {
          syntheticCheckedKeySet.delete(levelTreeNodeKey);
        }
      }
    }
    return {
      checkedKeys: Array.from(syntheticCheckedKeySet),
      indeterminateKeys: Array.from(syntheticIndeterminateKeySet)
    };
  }
  function getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, isUnchecking) {
    const { treeNodeMap, getChildren } = treeMate;
    const visitedKeySet = /* @__PURE__ */ new Set();
    const extendedKeySet = new Set(checkedKeys);
    checkedKeys.forEach((checkedKey) => {
      const checkedTreeNode = treeNodeMap.get(checkedKey);
      if (checkedTreeNode !== void 0) {
        traverseWithCb(checkedTreeNode, (treeNode) => {
          if (treeNode.disabled) {
            return TRAVERSE_COMMAND.STOP;
          }
          const { key } = treeNode;
          if (visitedKeySet.has(key))
            return;
          visitedKeySet.add(key);
          extendedKeySet.add(key);
          if (isExpilicitlyNotLoaded(treeNode.rawNode, getChildren)) {
            if (isUnchecking) {
              return TRAVERSE_COMMAND.STOP;
            } else if (!allowNotLoaded) {
              throw new SubtreeNotLoadedError();
            }
          }
        });
      }
    });
    return extendedKeySet;
  }
  function getPath(key, { includeGroup = false, includeSelf = true }, treeMate) {
    var _a;
    const treeNodeMap = treeMate.treeNodeMap;
    let treeNode = key === null || key === void 0 ? null : (_a = treeNodeMap.get(key)) !== null && _a !== void 0 ? _a : null;
    const mergedPath = {
      keyPath: [],
      treeNodePath: [],
      treeNode
    };
    if (treeNode === null || treeNode === void 0 ? void 0 : treeNode.ignored) {
      mergedPath.treeNode = null;
      return mergedPath;
    }
    while (treeNode) {
      if (!treeNode.ignored && (includeGroup || !treeNode.isGroup)) {
        mergedPath.treeNodePath.push(treeNode);
      }
      treeNode = treeNode.parent;
    }
    mergedPath.treeNodePath.reverse();
    if (!includeSelf)
      mergedPath.treeNodePath.pop();
    mergedPath.keyPath = mergedPath.treeNodePath.map((treeNode2) => treeNode2.key);
    return mergedPath;
  }
  function getFirstAvailableNode(nodes) {
    if (nodes.length === 0)
      return null;
    const node = nodes[0];
    if (node.isGroup || node.ignored || node.disabled) {
      return node.getNext();
    }
    return node;
  }
  function rawGetNext(node, loop) {
    const sibs = node.siblings;
    const l = sibs.length;
    const { index } = node;
    if (loop) {
      return sibs[(index + 1) % l];
    } else {
      if (index === sibs.length - 1)
        return null;
      return sibs[index + 1];
    }
  }
  function move(fromNode, dir, { loop = false, includeDisabled = false } = {}) {
    const iterate = dir === "prev" ? rawGetPrev : rawGetNext;
    const getChildOptions = {
      reverse: dir === "prev"
    };
    let meet = false;
    let endNode = null;
    function traverse2(node) {
      if (node === null)
        return;
      if (node === fromNode) {
        if (!meet) {
          meet = true;
        } else if (!fromNode.disabled && !fromNode.isGroup) {
          endNode = fromNode;
          return;
        }
      } else {
        if ((!node.disabled || includeDisabled) && !node.ignored && !node.isGroup) {
          endNode = node;
          return;
        }
      }
      if (node.isGroup) {
        const child = getChild(node, getChildOptions);
        if (child !== null) {
          endNode = child;
        } else {
          traverse2(iterate(node, loop));
        }
      } else {
        const nextNode = iterate(node, false);
        if (nextNode !== null) {
          traverse2(nextNode);
        } else {
          const parent = rawGetParent(node);
          if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {
            traverse2(iterate(parent, loop));
          } else if (loop) {
            traverse2(iterate(node, true));
          }
        }
      }
    }
    traverse2(fromNode);
    return endNode;
  }
  function rawGetPrev(node, loop) {
    const sibs = node.siblings;
    const l = sibs.length;
    const { index } = node;
    if (loop) {
      return sibs[(index - 1 + l) % l];
    } else {
      if (index === 0)
        return null;
      return sibs[index - 1];
    }
  }
  function rawGetParent(node) {
    return node.parent;
  }
  function getChild(node, options = {}) {
    const { reverse = false } = options;
    const { children } = node;
    if (children) {
      const { length } = children;
      const start = reverse ? length - 1 : 0;
      const end = reverse ? -1 : length;
      const delta = reverse ? -1 : 1;
      for (let i = start; i !== end; i += delta) {
        const child = children[i];
        if (!child.disabled && !child.ignored) {
          if (child.isGroup) {
            const childInGroup = getChild(child, options);
            if (childInGroup !== null)
              return childInGroup;
          } else {
            return child;
          }
        }
      }
    }
    return null;
  }
  const moveMethods = {
    getChild() {
      if (this.ignored)
        return null;
      return getChild(this);
    },
    getParent() {
      const { parent } = this;
      if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {
        return parent.getParent();
      }
      return parent;
    },
    getNext(options = {}) {
      return move(this, "next", options);
    },
    getPrev(options = {}) {
      return move(this, "prev", options);
    }
  };
  function flatten$1(treeNodes, expandedKeys) {
    const expandedKeySet = expandedKeys ? new Set(expandedKeys) : void 0;
    const flattenedNodes = [];
    function traverse2(treeNodes2) {
      treeNodes2.forEach((treeNode) => {
        flattenedNodes.push(treeNode);
        if (treeNode.isLeaf || !treeNode.children || treeNode.ignored)
          return;
        if (treeNode.isGroup) {
          traverse2(treeNode.children);
        } else if (
          // normal non-leaf node
          expandedKeySet === void 0 || expandedKeySet.has(treeNode.key)
        ) {
          traverse2(treeNode.children);
        }
      });
    }
    traverse2(treeNodes);
    return flattenedNodes;
  }
  function contains(parent, child) {
    const parentKey = parent.key;
    while (child) {
      if (child.key === parentKey)
        return true;
      child = child.parent;
    }
    return false;
  }
  function createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, parent = null, level = 0) {
    const treeNodes = [];
    rawNodes.forEach((rawNode, index) => {
      var _a;
      if (isNodeInvalid(rawNode, getChildren)) {
        console.error("[treemate]: node", rawNode, "is invalid");
      }
      const treeNode = Object.create(nodeProto);
      treeNode.rawNode = rawNode;
      treeNode.siblings = treeNodes;
      treeNode.level = level;
      treeNode.index = index;
      treeNode.isFirstChild = index === 0;
      treeNode.isLastChild = index + 1 === rawNodes.length;
      treeNode.parent = parent;
      if (!treeNode.ignored) {
        const rawChildren = getChildren(rawNode);
        if (Array.isArray(rawChildren)) {
          treeNode.children = createTreeNodes(rawChildren, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, treeNode, level + 1);
        }
      }
      treeNodes.push(treeNode);
      treeNodeMap.set(treeNode.key, treeNode);
      if (!levelTreeNodeMap.has(level))
        levelTreeNodeMap.set(level, []);
      (_a = levelTreeNodeMap.get(level)) === null || _a === void 0 ? void 0 : _a.push(treeNode);
    });
    return treeNodes;
  }
  function createTreeMate(rawNodes, options = {}) {
    var _a;
    const treeNodeMap = /* @__PURE__ */ new Map();
    const levelTreeNodeMap = /* @__PURE__ */ new Map();
    const { getDisabled = isDisabled, getIgnored: getIgnored2 = isIgnored, getIsGroup: getIsGroup2 = isGroup, getKey = defaultGetKey } = options;
    const _getChildren = (_a = options.getChildren) !== null && _a !== void 0 ? _a : defaultGetChildren;
    const getChildren = options.ignoreEmptyChildren ? (node) => {
      const children = _getChildren(node);
      if (Array.isArray(children)) {
        if (!children.length)
          return null;
        return children;
      }
      return children;
    } : _getChildren;
    const nodeProto = Object.assign({
      get key() {
        return getKey(this.rawNode);
      },
      get disabled() {
        return getDisabled(this.rawNode);
      },
      get isGroup() {
        return getIsGroup2(this.rawNode);
      },
      get isLeaf() {
        return isLeaf(this.rawNode, getChildren);
      },
      get shallowLoaded() {
        return isShallowLoaded(this.rawNode, getChildren);
      },
      get ignored() {
        return getIgnored2(this.rawNode);
      },
      contains(node) {
        return contains(this, node);
      }
    }, moveMethods);
    const treeNodes = createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren);
    function getNode(key) {
      if (key === null || key === void 0)
        return null;
      const tmNode = treeNodeMap.get(key);
      if (tmNode && !tmNode.isGroup && !tmNode.ignored) {
        return tmNode;
      }
      return null;
    }
    function _getNode(key) {
      if (key === null || key === void 0)
        return null;
      const tmNode = treeNodeMap.get(key);
      if (tmNode && !tmNode.ignored) {
        return tmNode;
      }
      return null;
    }
    function getPrev(key, options2) {
      const node = _getNode(key);
      if (!node)
        return null;
      return node.getPrev(options2);
    }
    function getNext(key, options2) {
      const node = _getNode(key);
      if (!node)
        return null;
      return node.getNext(options2);
    }
    function getParent(key) {
      const node = _getNode(key);
      if (!node)
        return null;
      return node.getParent();
    }
    function getChild2(key) {
      const node = _getNode(key);
      if (!node)
        return null;
      return node.getChild();
    }
    const treemate = {
      treeNodes,
      treeNodeMap,
      levelTreeNodeMap,
      maxLevel: Math.max(...levelTreeNodeMap.keys()),
      getChildren,
      getFlattenedNodes(expandedKeys) {
        return flatten$1(treeNodes, expandedKeys);
      },
      getNode,
      getPrev,
      getNext,
      getParent,
      getChild: getChild2,
      getFirstAvailableNode() {
        return getFirstAvailableNode(treeNodes);
      },
      getPath(key, options2 = {}) {
        return getPath(key, options2, treemate);
      },
      getCheckedKeys(checkedKeys, options2 = {}) {
        const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
        return getCheckedKeys({
          checkedKeys: unwrapCheckedKeys(checkedKeys),
          indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
          cascade,
          leafOnly,
          checkStrategy,
          allowNotLoaded
        }, treemate);
      },
      check(keysToCheck, checkedKeys, options2 = {}) {
        const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
        return getCheckedKeys({
          checkedKeys: unwrapCheckedKeys(checkedKeys),
          indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
          keysToCheck: keysToCheck === void 0 || keysToCheck === null ? [] : toArray(keysToCheck),
          cascade,
          leafOnly,
          checkStrategy,
          allowNotLoaded
        }, treemate);
      },
      uncheck(keysToUncheck, checkedKeys, options2 = {}) {
        const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
        return getCheckedKeys({
          checkedKeys: unwrapCheckedKeys(checkedKeys),
          indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
          keysToUncheck: keysToUncheck === null || keysToUncheck === void 0 ? [] : toArray(keysToUncheck),
          cascade,
          leafOnly,
          checkStrategy,
          allowNotLoaded
        }, treemate);
      },
      getNonLeafKeys(options2 = {}) {
        return getNonLeafKeys(treeNodes, options2);
      }
    };
    return treemate;
  }
  const base = {
    neutralBase: "#FFF",
    neutralInvertBase: "#000",
    neutralTextBase: "#000",
    neutralPopover: "#fff",
    neutralCard: "#fff",
    neutralModal: "#fff",
    neutralBody: "#fff",
    alpha1: "0.82",
    alpha2: "0.72",
    alpha3: "0.38",
    alpha4: "0.24",
    // disabled text, placeholder, icon
    alpha5: "0.18",
    // disabled placeholder
    alphaClose: "0.6",
    alphaDisabled: "0.5",
    alphaDisabledInput: "0.02",
    alphaPending: "0.05",
    alphaTablePending: "0.02",
    alphaPressed: "0.07",
    alphaAvatar: "0.2",
    alphaRail: "0.14",
    alphaProgressRail: ".08",
    alphaBorder: "0.12",
    alphaDivider: "0.06",
    alphaInput: "0",
    alphaAction: "0.02",
    alphaTab: "0.04",
    alphaScrollbar: "0.25",
    alphaScrollbarHover: "0.4",
    alphaCode: "0.05",
    alphaTag: "0.02",
    // primary
    primaryHover: "#36ad6a",
    primaryDefault: "#18a058",
    primaryActive: "#0c7a43",
    primarySuppl: "#36ad6a",
    // info
    infoHover: "#4098fc",
    infoDefault: "#2080f0",
    infoActive: "#1060c9",
    infoSuppl: "#4098fc",
    // error
    errorHover: "#de576d",
    errorDefault: "#d03050",
    errorActive: "#ab1f3f",
    errorSuppl: "#de576d",
    // warning
    warningHover: "#fcb040",
    warningDefault: "#f0a020",
    warningActive: "#c97c10",
    warningSuppl: "#fcb040",
    // success
    successHover: "#36ad6a",
    successDefault: "#18a058",
    successActive: "#0c7a43",
    successSuppl: "#36ad6a"
  };
  const baseBackgroundRgb = rgba(base.neutralBase);
  const baseInvertBackgroundRgb = rgba(base.neutralInvertBase);
  const overlayPrefix = `rgba(${baseInvertBackgroundRgb.slice(0, 3).join(", ")}, `;
  function overlay(alpha) {
    return `${overlayPrefix + String(alpha)})`;
  }
  function neutral(alpha) {
    const overlayRgba = Array.from(baseInvertBackgroundRgb);
    overlayRgba[3] = Number(alpha);
    return composite(baseBackgroundRgb, overlayRgba);
  }
  const derived = Object.assign(Object.assign({
    name: "common"
  }, commonVariables$m), {
    baseColor: base.neutralBase,
    // primary color
    primaryColor: base.primaryDefault,
    primaryColorHover: base.primaryHover,
    primaryColorPressed: base.primaryActive,
    primaryColorSuppl: base.primarySuppl,
    // info color
    infoColor: base.infoDefault,
    infoColorHover: base.infoHover,
    infoColorPressed: base.infoActive,
    infoColorSuppl: base.infoSuppl,
    // success color
    successColor: base.successDefault,
    successColorHover: base.successHover,
    successColorPressed: base.successActive,
    successColorSuppl: base.successSuppl,
    // warning color
    warningColor: base.warningDefault,
    warningColorHover: base.warningHover,
    warningColorPressed: base.warningActive,
    warningColorSuppl: base.warningSuppl,
    // error color
    errorColor: base.errorDefault,
    errorColorHover: base.errorHover,
    errorColorPressed: base.errorActive,
    errorColorSuppl: base.errorSuppl,
    // text color
    textColorBase: base.neutralTextBase,
    textColor1: "rgb(31, 34, 37)",
    textColor2: "rgb(51, 54, 57)",
    textColor3: "rgb(118, 124, 130)",
    // textColor4: neutral(base.alpha4), // disabled, placeholder, icon
    // textColor5: neutral(base.alpha5),
    textColorDisabled: neutral(base.alpha4),
    placeholderColor: neutral(base.alpha4),
    placeholderColorDisabled: neutral(base.alpha5),
    iconColor: neutral(base.alpha4),
    iconColorHover: scaleColor(neutral(base.alpha4), {
      lightness: 0.75
    }),
    iconColorPressed: scaleColor(neutral(base.alpha4), {
      lightness: 0.9
    }),
    iconColorDisabled: neutral(base.alpha5),
    opacity1: base.alpha1,
    opacity2: base.alpha2,
    opacity3: base.alpha3,
    opacity4: base.alpha4,
    opacity5: base.alpha5,
    dividerColor: "rgb(239, 239, 245)",
    borderColor: "rgb(224, 224, 230)",
    // close
    closeIconColor: neutral(Number(base.alphaClose)),
    closeIconColorHover: neutral(Number(base.alphaClose)),
    closeIconColorPressed: neutral(Number(base.alphaClose)),
    closeColorHover: "rgba(0, 0, 0, .09)",
    closeColorPressed: "rgba(0, 0, 0, .13)",
    // clear
    clearColor: neutral(base.alpha4),
    clearColorHover: scaleColor(neutral(base.alpha4), {
      lightness: 0.75
    }),
    clearColorPressed: scaleColor(neutral(base.alpha4), {
      lightness: 0.9
    }),
    scrollbarColor: overlay(base.alphaScrollbar),
    scrollbarColorHover: overlay(base.alphaScrollbarHover),
    scrollbarWidth: "5px",
    scrollbarHeight: "5px",
    scrollbarBorderRadius: "5px",
    progressRailColor: neutral(base.alphaProgressRail),
    railColor: "rgb(219, 219, 223)",
    popoverColor: base.neutralPopover,
    tableColor: base.neutralCard,
    cardColor: base.neutralCard,
    modalColor: base.neutralModal,
    bodyColor: base.neutralBody,
    tagColor: "#eee",
    avatarColor: neutral(base.alphaAvatar),
    invertedColor: "rgb(0, 20, 40)",
    inputColor: neutral(base.alphaInput),
    codeColor: "rgb(244, 244, 248)",
    tabColor: "rgb(247, 247, 250)",
    actionColor: "rgb(250, 250, 252)",
    tableHeaderColor: "rgb(250, 250, 252)",
    hoverColor: "rgb(243, 243, 245)",
    // use color with alpha since it can be nested with header filter & sorter effect
    tableColorHover: "rgba(0, 0, 100, 0.03)",
    tableColorStriped: "rgba(0, 0, 100, 0.02)",
    pressedColor: "rgb(237, 237, 239)",
    opacityDisabled: base.alphaDisabled,
    inputColorDisabled: "rgb(250, 250, 252)",
    // secondary button color
    // can also be used in tertiary button & quaternary button
    buttonColor2: "rgba(46, 51, 56, .05)",
    buttonColor2Hover: "rgba(46, 51, 56, .09)",
    buttonColor2Pressed: "rgba(46, 51, 56, .13)",
    boxShadow1: "0 1px 2px -2px rgba(0, 0, 0, .08), 0 3px 6px 0 rgba(0, 0, 0, .06), 0 5px 12px 4px rgba(0, 0, 0, .04)",
    boxShadow2: "0 3px 6px -4px rgba(0, 0, 0, .12), 0 6px 16px 0 rgba(0, 0, 0, .08), 0 9px 28px 8px rgba(0, 0, 0, .05)",
    boxShadow3: "0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)"
  });
  const commonLight = derived;
  const commonVars$e = {
    iconSizeTiny: "28px",
    iconSizeSmall: "34px",
    iconSizeMedium: "40px",
    iconSizeLarge: "46px",
    iconSizeHuge: "52px"
  };
  function self$1h(vars) {
    const {
      textColorDisabled,
      iconColor,
      textColor2,
      fontSizeTiny,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      fontSizeHuge
    } = vars;
    return Object.assign(Object.assign({}, commonVars$e), {
      fontSizeTiny,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      fontSizeHuge,
      textColor: textColorDisabled,
      iconColor,
      extraTextColor: textColor2
    });
  }
  const emptyLight = {
    name: "Empty",
    common: commonLight,
    self: self$1h
  };
  const emptyLight$1 = emptyLight;
  const style$1z = cB("empty", `
 display: flex;
 flex-direction: column;
 align-items: center;
 font-size: var(--n-font-size);
`, [cE("icon", `
 width: var(--n-icon-size);
 height: var(--n-icon-size);
 font-size: var(--n-icon-size);
 line-height: var(--n-icon-size);
 color: var(--n-icon-color);
 transition:
 color .3s var(--n-bezier);
 `, [c$1("+", [cE("description", `
 margin-top: 8px;
 `)])]), cE("description", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), cE("extra", `
 text-align: center;
 transition: color .3s var(--n-bezier);
 margin-top: 12px;
 color: var(--n-extra-text-color);
 `)]);
  const emptyProps = Object.assign(Object.assign({}, useTheme.props), {
    description: String,
    showDescription: {
      type: Boolean,
      default: true
    },
    showIcon: {
      type: Boolean,
      default: true
    },
    size: {
      type: String,
      default: "medium"
    },
    renderIcon: Function
  });
  const NEmpty = vue.defineComponent({
    name: "Empty",
    props: emptyProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled,
        mergedComponentPropsRef
      } = useConfig(props);
      const themeRef = useTheme("Empty", "-empty", style$1z, emptyLight$1, props, mergedClsPrefixRef);
      const {
        localeRef
      } = useLocale("Empty");
      const mergedDescriptionRef = vue.computed(() => {
        var _a, _b, _c;
        return (_a = props.description) !== null && _a !== void 0 ? _a : (_c = (_b = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _b === void 0 ? void 0 : _b.Empty) === null || _c === void 0 ? void 0 : _c.description;
      });
      const mergedRenderIconRef = vue.computed(() => {
        var _a, _b;
        return ((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.Empty) === null || _b === void 0 ? void 0 : _b.renderIcon) || (() => vue.h(EmptyIcon, null));
      });
      const cssVarsRef = vue.computed(() => {
        const {
          size: size2
        } = props;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            [createKey("iconSize", size2)]: iconSize,
            [createKey("fontSize", size2)]: fontSize2,
            textColor,
            iconColor,
            extraTextColor
          }
        } = themeRef.value;
        return {
          "--n-icon-size": iconSize,
          "--n-font-size": fontSize2,
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-text-color": textColor,
          "--n-icon-color": iconColor,
          "--n-extra-text-color": extraTextColor
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("empty", vue.computed(() => {
        let hash = "";
        const {
          size: size2
        } = props;
        hash += size2[0];
        return hash;
      }), cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        mergedRenderIcon: mergedRenderIconRef,
        localizedDescription: vue.computed(() => {
          return mergedDescriptionRef.value || localeRef.value.description;
        }),
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      const {
        $slots,
        mergedClsPrefix,
        onRender
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h("div", {
        class: [`${mergedClsPrefix}-empty`, this.themeClass],
        style: this.cssVars
      }, this.showIcon ? vue.h("div", {
        class: `${mergedClsPrefix}-empty__icon`
      }, $slots.icon ? $slots.icon() : vue.h(NBaseIcon, {
        clsPrefix: mergedClsPrefix
      }, {
        default: this.mergedRenderIcon
      })) : null, this.showDescription ? vue.h("div", {
        class: `${mergedClsPrefix}-empty__description`
      }, $slots.default ? $slots.default() : this.localizedDescription) : null, $slots.extra ? vue.h("div", {
        class: `${mergedClsPrefix}-empty__extra`
      }, $slots.extra()) : null);
    }
  });
  const commonVars$d = {
    railInsetHorizontalBottom: "auto 2px 4px 2px",
    railInsetHorizontalTop: "4px 2px auto 2px",
    railInsetVerticalRight: "2px 4px 2px auto",
    railInsetVerticalLeft: "2px auto 2px 4px",
    railColor: "transparent"
  };
  function self$1g(vars) {
    const {
      scrollbarColor,
      scrollbarColorHover,
      scrollbarHeight,
      scrollbarWidth,
      scrollbarBorderRadius
    } = vars;
    return Object.assign(Object.assign({}, commonVars$d), {
      height: scrollbarHeight,
      width: scrollbarWidth,
      borderRadius: scrollbarBorderRadius,
      color: scrollbarColor,
      colorHover: scrollbarColorHover
    });
  }
  const scrollbarLight = {
    name: "Scrollbar",
    common: commonLight,
    self: self$1g
  };
  const scrollbarLight$1 = scrollbarLight;
  const {
    cubicBezierEaseInOut: cubicBezierEaseInOut$3
  } = commonVariables$m;
  function fadeInTransition({
    name = "fade-in",
    enterDuration = "0.2s",
    leaveDuration = "0.2s",
    enterCubicBezier = cubicBezierEaseInOut$3,
    leaveCubicBezier = cubicBezierEaseInOut$3
  } = {}) {
    return [c$1(`&.${name}-transition-enter-active`, {
      transition: `all ${enterDuration} ${enterCubicBezier}!important`
    }), c$1(`&.${name}-transition-leave-active`, {
      transition: `all ${leaveDuration} ${leaveCubicBezier}!important`
    }), c$1(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
      opacity: 0
    }), c$1(`&.${name}-transition-leave-from, &.${name}-transition-enter-to`, {
      opacity: 1
    })];
  }
  const style$1y = cB("scrollbar", `
 overflow: hidden;
 position: relative;
 z-index: auto;
 height: 100%;
 width: 100%;
`, [c$1(">", [cB("scrollbar-container", `
 width: 100%;
 overflow: scroll;
 height: 100%;
 min-height: inherit;
 max-height: inherit;
 scrollbar-width: none;
 `, [c$1("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), c$1(">", [
    // We can't set overflow hidden since it affects positioning.
    cB("scrollbar-content", `
 box-sizing: border-box;
 min-width: 100%;
 `)
  ])])]), c$1(">, +", [cB("scrollbar-rail", `
 position: absolute;
 pointer-events: none;
 user-select: none;
 background: var(--n-scrollbar-rail-color);
 -webkit-user-select: none;
 `, [cM("horizontal", `
 height: var(--n-scrollbar-height);
 `, [c$1(">", [cE("scrollbar", `
 height: var(--n-scrollbar-height);
 border-radius: var(--n-scrollbar-border-radius);
 right: 0;
 `)])]), cM("horizontal--top", `
 inset: var(--n-scrollbar-rail-inset-horizontal-top); 
 `), cM("horizontal--bottom", `
 inset: var(--n-scrollbar-rail-inset-horizontal-bottom); 
 `), cM("vertical", `
 width: var(--n-scrollbar-width);
 `, [c$1(">", [cE("scrollbar", `
 width: var(--n-scrollbar-width);
 border-radius: var(--n-scrollbar-border-radius);
 bottom: 0;
 `)])]), cM("vertical--left", `
 inset: var(--n-scrollbar-rail-inset-vertical-left); 
 `), cM("vertical--right", `
 inset: var(--n-scrollbar-rail-inset-vertical-right); 
 `), cM("disabled", [c$1(">", [cE("scrollbar", "pointer-events: none;")])]), c$1(">", [cE("scrollbar", `
 z-index: 1;
 position: absolute;
 cursor: pointer;
 pointer-events: all;
 background-color: var(--n-scrollbar-color);
 transition: background-color .2s var(--n-scrollbar-bezier);
 `, [fadeInTransition(), c$1("&:hover", "background-color: var(--n-scrollbar-color-hover);")])])])])]);
  const scrollbarProps$1 = Object.assign(Object.assign({}, useTheme.props), {
    duration: {
      type: Number,
      default: 0
    },
    scrollable: {
      type: Boolean,
      default: true
    },
    xScrollable: Boolean,
    trigger: {
      type: String,
      default: "hover"
    },
    useUnifiedContainer: Boolean,
    triggerDisplayManually: Boolean,
    // If container is set, resize observer won't not attached
    container: Function,
    content: Function,
    containerClass: String,
    containerStyle: [String, Object],
    contentClass: [String, Array],
    contentStyle: [String, Object],
    horizontalRailStyle: [String, Object],
    verticalRailStyle: [String, Object],
    onScroll: Function,
    onWheel: Function,
    onResize: Function,
    internalOnUpdateScrollLeft: Function,
    internalHoistYRail: Boolean,
    yPlacement: {
      type: String,
      default: "right"
    },
    xPlacement: {
      type: String,
      default: "bottom"
    }
  });
  const Scrollbar$2 = vue.defineComponent({
    name: "Scrollbar",
    props: scrollbarProps$1,
    inheritAttrs: false,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled,
        mergedRtlRef
      } = useConfig(props);
      const rtlEnabledRef = useRtl("Scrollbar", mergedRtlRef, mergedClsPrefixRef);
      const wrapperRef = vue.ref(null);
      const containerRef = vue.ref(null);
      const contentRef = vue.ref(null);
      const yRailRef = vue.ref(null);
      const xRailRef = vue.ref(null);
      const contentHeightRef = vue.ref(null);
      const contentWidthRef = vue.ref(null);
      const containerHeightRef = vue.ref(null);
      const containerWidthRef = vue.ref(null);
      const yRailSizeRef = vue.ref(null);
      const xRailSizeRef = vue.ref(null);
      const containerScrollTopRef = vue.ref(0);
      const containerScrollLeftRef = vue.ref(0);
      const isShowXBarRef = vue.ref(false);
      const isShowYBarRef = vue.ref(false);
      let yBarPressed = false;
      let xBarPressed = false;
      let xBarVanishTimerId;
      let yBarVanishTimerId;
      let memoYTop = 0;
      let memoXLeft = 0;
      let memoMouseX = 0;
      let memoMouseY = 0;
      const isIos2 = useIsIos();
      const themeRef = useTheme("Scrollbar", "-scrollbar", style$1y, scrollbarLight$1, props, mergedClsPrefixRef);
      const yBarSizeRef = vue.computed(() => {
        const {
          value: containerHeight
        } = containerHeightRef;
        const {
          value: contentHeight
        } = contentHeightRef;
        const {
          value: yRailSize
        } = yRailSizeRef;
        if (containerHeight === null || contentHeight === null || yRailSize === null) {
          return 0;
        } else {
          return Math.min(containerHeight, yRailSize * containerHeight / contentHeight + depx(themeRef.value.self.width) * 1.5);
        }
      });
      const yBarSizePxRef = vue.computed(() => {
        return `${yBarSizeRef.value}px`;
      });
      const xBarSizeRef = vue.computed(() => {
        const {
          value: containerWidth
        } = containerWidthRef;
        const {
          value: contentWidth
        } = contentWidthRef;
        const {
          value: xRailSize
        } = xRailSizeRef;
        if (containerWidth === null || contentWidth === null || xRailSize === null) {
          return 0;
        } else {
          return xRailSize * containerWidth / contentWidth + depx(themeRef.value.self.height) * 1.5;
        }
      });
      const xBarSizePxRef = vue.computed(() => {
        return `${xBarSizeRef.value}px`;
      });
      const yBarTopRef = vue.computed(() => {
        const {
          value: containerHeight
        } = containerHeightRef;
        const {
          value: containerScrollTop
        } = containerScrollTopRef;
        const {
          value: contentHeight
        } = contentHeightRef;
        const {
          value: yRailSize
        } = yRailSizeRef;
        if (containerHeight === null || contentHeight === null || yRailSize === null) {
          return 0;
        } else {
          const heightDiff = contentHeight - containerHeight;
          if (!heightDiff)
            return 0;
          return containerScrollTop / heightDiff * (yRailSize - yBarSizeRef.value);
        }
      });
      const yBarTopPxRef = vue.computed(() => {
        return `${yBarTopRef.value}px`;
      });
      const xBarLeftRef = vue.computed(() => {
        const {
          value: containerWidth
        } = containerWidthRef;
        const {
          value: containerScrollLeft
        } = containerScrollLeftRef;
        const {
          value: contentWidth
        } = contentWidthRef;
        const {
          value: xRailSize
        } = xRailSizeRef;
        if (containerWidth === null || contentWidth === null || xRailSize === null) {
          return 0;
        } else {
          const widthDiff = contentWidth - containerWidth;
          if (!widthDiff)
            return 0;
          return containerScrollLeft / widthDiff * (xRailSize - xBarSizeRef.value);
        }
      });
      const xBarLeftPxRef = vue.computed(() => {
        return `${xBarLeftRef.value}px`;
      });
      const needYBarRef = vue.computed(() => {
        const {
          value: containerHeight
        } = containerHeightRef;
        const {
          value: contentHeight
        } = contentHeightRef;
        return containerHeight !== null && contentHeight !== null && contentHeight > containerHeight;
      });
      const needXBarRef = vue.computed(() => {
        const {
          value: containerWidth
        } = containerWidthRef;
        const {
          value: contentWidth
        } = contentWidthRef;
        return containerWidth !== null && contentWidth !== null && contentWidth > containerWidth;
      });
      const mergedShowXBarRef = vue.computed(() => {
        const {
          trigger: trigger2
        } = props;
        return trigger2 === "none" || isShowXBarRef.value;
      });
      const mergedShowYBarRef = vue.computed(() => {
        const {
          trigger: trigger2
        } = props;
        return trigger2 === "none" || isShowYBarRef.value;
      });
      const mergedContainerRef = vue.computed(() => {
        const {
          container
        } = props;
        if (container)
          return container();
        return containerRef.value;
      });
      const mergedContentRef = vue.computed(() => {
        const {
          content
        } = props;
        if (content)
          return content();
        return contentRef.value;
      });
      const scrollTo = (options, y) => {
        if (!props.scrollable)
          return;
        if (typeof options === "number") {
          scrollToPosition(options, y !== null && y !== void 0 ? y : 0, 0, false, "auto");
          return;
        }
        const {
          left,
          top,
          index,
          elSize,
          position,
          behavior,
          el,
          debounce: debounce2 = true
        } = options;
        if (left !== void 0 || top !== void 0) {
          scrollToPosition(left !== null && left !== void 0 ? left : 0, top !== null && top !== void 0 ? top : 0, 0, false, behavior);
        }
        if (el !== void 0) {
          scrollToPosition(0, el.offsetTop, el.offsetHeight, debounce2, behavior);
        } else if (index !== void 0 && elSize !== void 0) {
          scrollToPosition(0, index * elSize, elSize, debounce2, behavior);
        } else if (position === "bottom") {
          scrollToPosition(0, Number.MAX_SAFE_INTEGER, 0, false, behavior);
        } else if (position === "top") {
          scrollToPosition(0, 0, 0, false, behavior);
        }
      };
      const activateState = useReactivated(() => {
        if (!props.container) {
          scrollTo({
            top: containerScrollTopRef.value,
            left: containerScrollLeftRef.value
          });
        }
      });
      const handleContentResize = () => {
        if (activateState.isDeactivated)
          return;
        sync();
      };
      const handleContainerResize = (e) => {
        if (activateState.isDeactivated)
          return;
        const {
          onResize
        } = props;
        if (onResize)
          onResize(e);
        sync();
      };
      const scrollBy = (options, y) => {
        if (!props.scrollable)
          return;
        const {
          value: container
        } = mergedContainerRef;
        if (!container)
          return;
        if (typeof options === "object") {
          container.scrollBy(options);
        } else {
          container.scrollBy(options, y || 0);
        }
      };
      function scrollToPosition(left, top, elSize, debounce2, behavior) {
        const {
          value: container
        } = mergedContainerRef;
        if (!container)
          return;
        if (debounce2) {
          const {
            scrollTop,
            offsetHeight
          } = container;
          if (top > scrollTop) {
            if (top + elSize <= scrollTop + offsetHeight)
              ;
            else {
              container.scrollTo({
                left,
                top: top + elSize - offsetHeight,
                behavior
              });
            }
            return;
          }
        }
        container.scrollTo({
          left,
          top,
          behavior
        });
      }
      function handleMouseEnterWrapper() {
        showXBar();
        showYBar();
        sync();
      }
      function handleMouseLeaveWrapper() {
        hideBar();
      }
      function hideBar() {
        hideYBar();
        hideXBar();
      }
      function hideYBar() {
        if (yBarVanishTimerId !== void 0) {
          window.clearTimeout(yBarVanishTimerId);
        }
        yBarVanishTimerId = window.setTimeout(() => {
          isShowYBarRef.value = false;
        }, props.duration);
      }
      function hideXBar() {
        if (xBarVanishTimerId !== void 0) {
          window.clearTimeout(xBarVanishTimerId);
        }
        xBarVanishTimerId = window.setTimeout(() => {
          isShowXBarRef.value = false;
        }, props.duration);
      }
      function showXBar() {
        if (xBarVanishTimerId !== void 0) {
          window.clearTimeout(xBarVanishTimerId);
        }
        isShowXBarRef.value = true;
      }
      function showYBar() {
        if (yBarVanishTimerId !== void 0) {
          window.clearTimeout(yBarVanishTimerId);
        }
        isShowYBarRef.value = true;
      }
      function handleScroll(e) {
        const {
          onScroll
        } = props;
        if (onScroll)
          onScroll(e);
        syncScrollState();
      }
      function syncScrollState() {
        const {
          value: container
        } = mergedContainerRef;
        if (container) {
          containerScrollTopRef.value = container.scrollTop;
          containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
        }
      }
      function syncPositionState() {
        const {
          value: content
        } = mergedContentRef;
        if (content) {
          contentHeightRef.value = content.offsetHeight;
          contentWidthRef.value = content.offsetWidth;
        }
        const {
          value: container
        } = mergedContainerRef;
        if (container) {
          containerHeightRef.value = container.offsetHeight;
          containerWidthRef.value = container.offsetWidth;
        }
        const {
          value: xRailEl
        } = xRailRef;
        const {
          value: yRailEl
        } = yRailRef;
        if (xRailEl) {
          xRailSizeRef.value = xRailEl.offsetWidth;
        }
        if (yRailEl) {
          yRailSizeRef.value = yRailEl.offsetHeight;
        }
      }
      function syncUnifiedContainer() {
        const {
          value: container
        } = mergedContainerRef;
        if (container) {
          containerScrollTopRef.value = container.scrollTop;
          containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
          containerHeightRef.value = container.offsetHeight;
          containerWidthRef.value = container.offsetWidth;
          contentHeightRef.value = container.scrollHeight;
          contentWidthRef.value = container.scrollWidth;
        }
        const {
          value: xRailEl
        } = xRailRef;
        const {
          value: yRailEl
        } = yRailRef;
        if (xRailEl) {
          xRailSizeRef.value = xRailEl.offsetWidth;
        }
        if (yRailEl) {
          yRailSizeRef.value = yRailEl.offsetHeight;
        }
      }
      function sync() {
        if (!props.scrollable)
          return;
        if (props.useUnifiedContainer) {
          syncUnifiedContainer();
        } else {
          syncPositionState();
          syncScrollState();
        }
      }
      function isMouseUpAway(e) {
        var _a;
        return !((_a = wrapperRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(e)));
      }
      function handleXScrollMouseDown(e) {
        e.preventDefault();
        e.stopPropagation();
        xBarPressed = true;
        on("mousemove", window, handleXScrollMouseMove, true);
        on("mouseup", window, handleXScrollMouseUp, true);
        memoXLeft = containerScrollLeftRef.value;
        memoMouseX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e.clientX : e.clientX;
      }
      function handleXScrollMouseMove(e) {
        if (!xBarPressed)
          return;
        if (xBarVanishTimerId !== void 0) {
          window.clearTimeout(xBarVanishTimerId);
        }
        if (yBarVanishTimerId !== void 0) {
          window.clearTimeout(yBarVanishTimerId);
        }
        const {
          value: containerWidth
        } = containerWidthRef;
        const {
          value: contentWidth
        } = contentWidthRef;
        const {
          value: xBarSize
        } = xBarSizeRef;
        if (containerWidth === null || contentWidth === null)
          return;
        const dX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e.clientX - memoMouseX : e.clientX - memoMouseX;
        const dScrollLeft = dX * (contentWidth - containerWidth) / (containerWidth - xBarSize);
        const toScrollLeftUpperBound = contentWidth - containerWidth;
        let toScrollLeft = memoXLeft + dScrollLeft;
        toScrollLeft = Math.min(toScrollLeftUpperBound, toScrollLeft);
        toScrollLeft = Math.max(toScrollLeft, 0);
        const {
          value: container
        } = mergedContainerRef;
        if (container) {
          container.scrollLeft = toScrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
          const {
            internalOnUpdateScrollLeft
          } = props;
          if (internalOnUpdateScrollLeft)
            internalOnUpdateScrollLeft(toScrollLeft);
        }
      }
      function handleXScrollMouseUp(e) {
        e.preventDefault();
        e.stopPropagation();
        off("mousemove", window, handleXScrollMouseMove, true);
        off("mouseup", window, handleXScrollMouseUp, true);
        xBarPressed = false;
        sync();
        if (isMouseUpAway(e)) {
          hideBar();
        }
      }
      function handleYScrollMouseDown(e) {
        e.preventDefault();
        e.stopPropagation();
        yBarPressed = true;
        on("mousemove", window, handleYScrollMouseMove, true);
        on("mouseup", window, handleYScrollMouseUp, true);
        memoYTop = containerScrollTopRef.value;
        memoMouseY = e.clientY;
      }
      function handleYScrollMouseMove(e) {
        if (!yBarPressed)
          return;
        if (xBarVanishTimerId !== void 0) {
          window.clearTimeout(xBarVanishTimerId);
        }
        if (yBarVanishTimerId !== void 0) {
          window.clearTimeout(yBarVanishTimerId);
        }
        const {
          value: containerHeight
        } = containerHeightRef;
        const {
          value: contentHeight
        } = contentHeightRef;
        const {
          value: yBarSize
        } = yBarSizeRef;
        if (containerHeight === null || contentHeight === null)
          return;
        const dY = e.clientY - memoMouseY;
        const dScrollTop = dY * (contentHeight - containerHeight) / (containerHeight - yBarSize);
        const toScrollTopUpperBound = contentHeight - containerHeight;
        let toScrollTop = memoYTop + dScrollTop;
        toScrollTop = Math.min(toScrollTopUpperBound, toScrollTop);
        toScrollTop = Math.max(toScrollTop, 0);
        const {
          value: container
        } = mergedContainerRef;
        if (container) {
          container.scrollTop = toScrollTop;
        }
      }
      function handleYScrollMouseUp(e) {
        e.preventDefault();
        e.stopPropagation();
        off("mousemove", window, handleYScrollMouseMove, true);
        off("mouseup", window, handleYScrollMouseUp, true);
        yBarPressed = false;
        sync();
        if (isMouseUpAway(e)) {
          hideBar();
        }
      }
      vue.watchEffect(() => {
        const {
          value: needXBar
        } = needXBarRef;
        const {
          value: needYBar
        } = needYBarRef;
        const {
          value: mergedClsPrefix
        } = mergedClsPrefixRef;
        const {
          value: xRailEl
        } = xRailRef;
        const {
          value: yRailEl
        } = yRailRef;
        if (xRailEl) {
          if (!needXBar) {
            xRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
          } else {
            xRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
          }
        }
        if (yRailEl) {
          if (!needYBar) {
            yRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
          } else {
            yRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
          }
        }
      });
      vue.onMounted(() => {
        if (props.container)
          return;
        sync();
      });
      vue.onBeforeUnmount(() => {
        if (xBarVanishTimerId !== void 0) {
          window.clearTimeout(xBarVanishTimerId);
        }
        if (yBarVanishTimerId !== void 0) {
          window.clearTimeout(yBarVanishTimerId);
        }
        off("mousemove", window, handleYScrollMouseMove, true);
        off("mouseup", window, handleYScrollMouseUp, true);
      });
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            color,
            colorHover,
            height,
            width,
            borderRadius,
            railInsetHorizontalTop,
            railInsetHorizontalBottom,
            railInsetVerticalRight,
            railInsetVerticalLeft,
            railColor
          }
        } = themeRef.value;
        return {
          "--n-scrollbar-bezier": cubicBezierEaseInOut2,
          "--n-scrollbar-color": color,
          "--n-scrollbar-color-hover": colorHover,
          "--n-scrollbar-border-radius": borderRadius,
          "--n-scrollbar-width": width,
          "--n-scrollbar-height": height,
          "--n-scrollbar-rail-inset-horizontal-top": railInsetHorizontalTop,
          "--n-scrollbar-rail-inset-horizontal-bottom": railInsetHorizontalBottom,
          "--n-scrollbar-rail-inset-vertical-right": (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? rtlInset(railInsetVerticalRight) : railInsetVerticalRight,
          "--n-scrollbar-rail-inset-vertical-left": (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? rtlInset(railInsetVerticalLeft) : railInsetVerticalLeft,
          "--n-scrollbar-rail-color": railColor
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("scrollbar", void 0, cssVarsRef, props) : void 0;
      const exposedMethods = {
        scrollTo,
        scrollBy,
        sync,
        syncUnifiedContainer,
        handleMouseEnterWrapper,
        handleMouseLeaveWrapper
      };
      return Object.assign(Object.assign({}, exposedMethods), {
        mergedClsPrefix: mergedClsPrefixRef,
        rtlEnabled: rtlEnabledRef,
        containerScrollTop: containerScrollTopRef,
        wrapperRef,
        containerRef,
        contentRef,
        yRailRef,
        xRailRef,
        needYBar: needYBarRef,
        needXBar: needXBarRef,
        yBarSizePx: yBarSizePxRef,
        xBarSizePx: xBarSizePxRef,
        yBarTopPx: yBarTopPxRef,
        xBarLeftPx: xBarLeftPxRef,
        isShowXBar: mergedShowXBarRef,
        isShowYBar: mergedShowYBarRef,
        isIos: isIos2,
        handleScroll,
        handleContentResize,
        handleContainerResize,
        handleYScrollMouseDown,
        handleXScrollMouseDown,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      });
    },
    render() {
      var _a;
      const {
        $slots,
        mergedClsPrefix,
        triggerDisplayManually,
        rtlEnabled,
        internalHoistYRail,
        yPlacement,
        xPlacement,
        xScrollable
      } = this;
      if (!this.scrollable)
        return (_a = $slots.default) === null || _a === void 0 ? void 0 : _a.call($slots);
      const triggerIsNone = this.trigger === "none";
      const createYRail = (className, style2) => {
        return vue.h("div", {
          ref: "yRailRef",
          class: [`${mergedClsPrefix}-scrollbar-rail`, `${mergedClsPrefix}-scrollbar-rail--vertical`, `${mergedClsPrefix}-scrollbar-rail--vertical--${yPlacement}`, className],
          "data-scrollbar-rail": true,
          style: [style2 || "", this.verticalRailStyle],
          "aria-hidden": true
        }, vue.h(triggerIsNone ? Wrapper : vue.Transition, triggerIsNone ? null : {
          name: "fade-in-transition"
        }, {
          default: () => this.needYBar && this.isShowYBar && !this.isIos ? vue.h("div", {
            class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`,
            style: {
              height: this.yBarSizePx,
              top: this.yBarTopPx
            },
            onMousedown: this.handleYScrollMouseDown
          }) : null
        }));
      };
      const createChildren = () => {
        var _a2, _b;
        (_a2 = this.onRender) === null || _a2 === void 0 ? void 0 : _a2.call(this);
        return vue.h("div", vue.mergeProps(this.$attrs, {
          role: "none",
          ref: "wrapperRef",
          class: [`${mergedClsPrefix}-scrollbar`, this.themeClass, rtlEnabled && `${mergedClsPrefix}-scrollbar--rtl`],
          style: this.cssVars,
          onMouseenter: triggerDisplayManually ? void 0 : this.handleMouseEnterWrapper,
          onMouseleave: triggerDisplayManually ? void 0 : this.handleMouseLeaveWrapper
        }), [this.container ? (_b = $slots.default) === null || _b === void 0 ? void 0 : _b.call($slots) : vue.h("div", {
          role: "none",
          ref: "containerRef",
          class: [`${mergedClsPrefix}-scrollbar-container`, this.containerClass],
          style: this.containerStyle,
          onScroll: this.handleScroll,
          onWheel: this.onWheel
        }, vue.h(VResizeObserver, {
          onResize: this.handleContentResize
        }, {
          default: () => vue.h("div", {
            ref: "contentRef",
            role: "none",
            style: [{
              width: this.xScrollable ? "fit-content" : null
            }, this.contentStyle],
            class: [`${mergedClsPrefix}-scrollbar-content`, this.contentClass]
          }, $slots)
        })), internalHoistYRail ? null : createYRail(void 0, void 0), xScrollable && vue.h("div", {
          ref: "xRailRef",
          class: [`${mergedClsPrefix}-scrollbar-rail`, `${mergedClsPrefix}-scrollbar-rail--horizontal`, `${mergedClsPrefix}-scrollbar-rail--horizontal--${xPlacement}`],
          style: this.horizontalRailStyle,
          "data-scrollbar-rail": true,
          "aria-hidden": true
        }, vue.h(triggerIsNone ? Wrapper : vue.Transition, triggerIsNone ? null : {
          name: "fade-in-transition"
        }, {
          default: () => this.needXBar && this.isShowXBar && !this.isIos ? vue.h("div", {
            class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`,
            style: {
              width: this.xBarSizePx,
              right: rtlEnabled ? this.xBarLeftPx : void 0,
              left: rtlEnabled ? void 0 : this.xBarLeftPx
            },
            onMousedown: this.handleXScrollMouseDown
          }) : null
        }))]);
      };
      const scrollbarNode = this.container ? createChildren() : vue.h(VResizeObserver, {
        onResize: this.handleContainerResize
      }, {
        default: createChildren
      });
      if (internalHoistYRail) {
        return vue.h(vue.Fragment, null, scrollbarNode, createYRail(this.themeClass, this.cssVars));
      } else {
        return scrollbarNode;
      }
    }
  });
  const NScrollbar = Scrollbar$2;
  const XScrollbar = Scrollbar$2;
  const commonVariables$l = {
    height: "calc(var(--n-option-height) * 7.6)",
    paddingTiny: "4px 0",
    paddingSmall: "4px 0",
    paddingMedium: "4px 0",
    paddingLarge: "4px 0",
    paddingHuge: "4px 0",
    optionPaddingTiny: "0 12px",
    optionPaddingSmall: "0 12px",
    optionPaddingMedium: "0 12px",
    optionPaddingLarge: "0 12px",
    optionPaddingHuge: "0 12px",
    loadingSize: "18px"
  };
  function self$1f(vars) {
    const {
      borderRadius,
      popoverColor,
      textColor3,
      dividerColor,
      textColor2,
      primaryColorPressed,
      textColorDisabled,
      primaryColor,
      opacityDisabled,
      hoverColor,
      fontSizeTiny,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      fontSizeHuge,
      heightTiny,
      heightSmall,
      heightMedium,
      heightLarge,
      heightHuge
    } = vars;
    return Object.assign(Object.assign({}, commonVariables$l), {
      optionFontSizeTiny: fontSizeTiny,
      optionFontSizeSmall: fontSizeSmall,
      optionFontSizeMedium: fontSizeMedium,
      optionFontSizeLarge: fontSizeLarge,
      optionFontSizeHuge: fontSizeHuge,
      optionHeightTiny: heightTiny,
      optionHeightSmall: heightSmall,
      optionHeightMedium: heightMedium,
      optionHeightLarge: heightLarge,
      optionHeightHuge: heightHuge,
      borderRadius,
      color: popoverColor,
      groupHeaderTextColor: textColor3,
      actionDividerColor: dividerColor,
      optionTextColor: textColor2,
      optionTextColorPressed: primaryColorPressed,
      optionTextColorDisabled: textColorDisabled,
      optionTextColorActive: primaryColor,
      optionOpacityDisabled: opacityDisabled,
      optionCheckColor: primaryColor,
      optionColorPending: hoverColor,
      optionColorActive: "rgba(0, 0, 0, 0)",
      optionColorActivePending: hoverColor,
      actionTextColor: textColor2,
      loadingColor: primaryColor
    });
  }
  const internalSelectMenuLight = createTheme({
    name: "InternalSelectMenu",
    common: commonLight,
    peers: {
      Scrollbar: scrollbarLight$1,
      Empty: emptyLight$1
    },
    self: self$1f
  });
  const internalSelectMenuLight$1 = internalSelectMenuLight;
  function renderCheckMark(show, clsPrefix) {
    return vue.h(vue.Transition, {
      name: "fade-in-scale-up-transition"
    }, {
      default: () => show ? vue.h(NBaseIcon, {
        clsPrefix,
        class: `${clsPrefix}-base-select-option__check`
      }, {
        default: () => vue.h(FinishedIcon)
      }) : null
    });
  }
  const NSelectOption = vue.defineComponent({
    name: "NBaseSelectOption",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      tmNode: {
        type: Object,
        required: true
      }
    },
    setup(props) {
      const {
        valueRef,
        pendingTmNodeRef,
        multipleRef,
        valueSetRef,
        renderLabelRef,
        renderOptionRef,
        labelFieldRef,
        valueFieldRef,
        showCheckmarkRef,
        nodePropsRef,
        handleOptionClick,
        handleOptionMouseEnter
      } = vue.inject(internalSelectionMenuInjectionKey);
      const isPendingRef = useMemo(() => {
        const {
          value: pendingTmNode
        } = pendingTmNodeRef;
        if (!pendingTmNode)
          return false;
        return props.tmNode.key === pendingTmNode.key;
      });
      function handleClick2(e) {
        const {
          tmNode
        } = props;
        if (tmNode.disabled)
          return;
        handleOptionClick(e, tmNode);
      }
      function handleMouseEnter(e) {
        const {
          tmNode
        } = props;
        if (tmNode.disabled)
          return;
        handleOptionMouseEnter(e, tmNode);
      }
      function handleMouseMove(e) {
        const {
          tmNode
        } = props;
        const {
          value: isPending
        } = isPendingRef;
        if (tmNode.disabled || isPending)
          return;
        handleOptionMouseEnter(e, tmNode);
      }
      return {
        multiple: multipleRef,
        isGrouped: useMemo(() => {
          const {
            tmNode
          } = props;
          const {
            parent
          } = tmNode;
          return parent && parent.rawNode.type === "group";
        }),
        showCheckmark: showCheckmarkRef,
        nodeProps: nodePropsRef,
        isPending: isPendingRef,
        isSelected: useMemo(() => {
          const {
            value
          } = valueRef;
          const {
            value: multiple
          } = multipleRef;
          if (value === null)
            return false;
          const optionValue = props.tmNode.rawNode[valueFieldRef.value];
          if (multiple) {
            const {
              value: valueSet
            } = valueSetRef;
            return valueSet.has(optionValue);
          } else {
            return value === optionValue;
          }
        }),
        labelField: labelFieldRef,
        renderLabel: renderLabelRef,
        renderOption: renderOptionRef,
        handleMouseMove,
        handleMouseEnter,
        handleClick: handleClick2
      };
    },
    render() {
      const {
        clsPrefix,
        tmNode: {
          rawNode
        },
        isSelected,
        isPending,
        isGrouped,
        showCheckmark,
        nodeProps,
        renderOption,
        renderLabel,
        handleClick: handleClick2,
        handleMouseEnter,
        handleMouseMove
      } = this;
      const checkmark = renderCheckMark(isSelected, clsPrefix);
      const children = renderLabel ? [renderLabel(rawNode, isSelected), showCheckmark && checkmark] : [render$1(rawNode[this.labelField], rawNode, isSelected), showCheckmark && checkmark];
      const attrs = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode);
      const node = vue.h("div", Object.assign({}, attrs, {
        class: [`${clsPrefix}-base-select-option`, rawNode.class, attrs === null || attrs === void 0 ? void 0 : attrs.class, {
          [`${clsPrefix}-base-select-option--disabled`]: rawNode.disabled,
          [`${clsPrefix}-base-select-option--selected`]: isSelected,
          [`${clsPrefix}-base-select-option--grouped`]: isGrouped,
          [`${clsPrefix}-base-select-option--pending`]: isPending,
          [`${clsPrefix}-base-select-option--show-checkmark`]: showCheckmark
        }],
        style: [(attrs === null || attrs === void 0 ? void 0 : attrs.style) || "", rawNode.style || ""],
        onClick: mergeEventHandlers([handleClick2, attrs === null || attrs === void 0 ? void 0 : attrs.onClick]),
        onMouseenter: mergeEventHandlers([handleMouseEnter, attrs === null || attrs === void 0 ? void 0 : attrs.onMouseenter]),
        onMousemove: mergeEventHandlers([handleMouseMove, attrs === null || attrs === void 0 ? void 0 : attrs.onMousemove])
      }), vue.h("div", {
        class: `${clsPrefix}-base-select-option__content`
      }, children));
      return rawNode.render ? rawNode.render({
        node,
        option: rawNode,
        selected: isSelected
      }) : renderOption ? renderOption({
        node,
        option: rawNode,
        selected: isSelected
      }) : node;
    }
  });
  const NSelectGroupHeader = vue.defineComponent({
    name: "NBaseSelectGroupHeader",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      tmNode: {
        type: Object,
        required: true
      }
    },
    setup() {
      const {
        renderLabelRef,
        renderOptionRef,
        labelFieldRef,
        nodePropsRef
      } = vue.inject(internalSelectionMenuInjectionKey);
      return {
        labelField: labelFieldRef,
        nodeProps: nodePropsRef,
        renderLabel: renderLabelRef,
        renderOption: renderOptionRef
      };
    },
    render() {
      const {
        clsPrefix,
        renderLabel,
        renderOption,
        nodeProps,
        tmNode: {
          rawNode
        }
      } = this;
      const attrs = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode);
      const children = renderLabel ? renderLabel(rawNode, false) : render$1(rawNode[this.labelField], rawNode, false);
      const node = vue.h("div", Object.assign({}, attrs, {
        class: [`${clsPrefix}-base-select-group-header`, attrs === null || attrs === void 0 ? void 0 : attrs.class]
      }), children);
      return rawNode.render ? rawNode.render({
        node,
        option: rawNode
      }) : renderOption ? renderOption({
        node,
        option: rawNode,
        selected: false
      }) : node;
    }
  });
  const {
    cubicBezierEaseIn: cubicBezierEaseIn$5,
    cubicBezierEaseOut: cubicBezierEaseOut$6
  } = commonVariables$m;
  function fadeInScaleUpTransition({
    transformOrigin = "inherit",
    duration: duration2 = ".2s",
    enterScale = ".9",
    originalTransform = "",
    originalTransition = ""
  } = {}) {
    return [c$1("&.fade-in-scale-up-transition-leave-active", {
      transformOrigin,
      transition: `opacity ${duration2} ${cubicBezierEaseIn$5}, transform ${duration2} ${cubicBezierEaseIn$5} ${originalTransition && `,${originalTransition}`}`
    }), c$1("&.fade-in-scale-up-transition-enter-active", {
      transformOrigin,
      transition: `opacity ${duration2} ${cubicBezierEaseOut$6}, transform ${duration2} ${cubicBezierEaseOut$6} ${originalTransition && `,${originalTransition}`}`
    }), c$1("&.fade-in-scale-up-transition-enter-from, &.fade-in-scale-up-transition-leave-to", {
      opacity: 0,
      transform: `${originalTransform} scale(${enterScale})`
    }), c$1("&.fade-in-scale-up-transition-leave-from, &.fade-in-scale-up-transition-enter-to", {
      opacity: 1,
      transform: `${originalTransform} scale(1)`
    })];
  }
  const style$1x = cB("base-select-menu", `
 line-height: 1.5;
 outline: none;
 z-index: 0;
 position: relative;
 border-radius: var(--n-border-radius);
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-color);
`, [cB("scrollbar", `
 max-height: var(--n-height);
 `), cB("virtual-list", `
 max-height: var(--n-height);
 `), cB("base-select-option", `
 min-height: var(--n-option-height);
 font-size: var(--n-option-font-size);
 display: flex;
 align-items: center;
 `, [cE("content", `
 z-index: 1;
 white-space: nowrap;
 text-overflow: ellipsis;
 overflow: hidden;
 `)]), cB("base-select-group-header", `
 min-height: var(--n-option-height);
 font-size: .93em;
 display: flex;
 align-items: center;
 `), cB("base-select-menu-option-wrapper", `
 position: relative;
 width: 100%;
 `), cE("loading, empty", `
 display: flex;
 padding: 12px 32px;
 flex: 1;
 justify-content: center;
 `), cE("loading", `
 color: var(--n-loading-color);
 font-size: var(--n-loading-size);
 `), cE("header", `
 padding: 8px var(--n-option-padding-left);
 font-size: var(--n-option-font-size);
 transition: 
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-action-divider-color);
 color: var(--n-action-text-color);
 `), cE("action", `
 padding: 8px var(--n-option-padding-left);
 font-size: var(--n-option-font-size);
 transition: 
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 border-top: 1px solid var(--n-action-divider-color);
 color: var(--n-action-text-color);
 `), cB("base-select-group-header", `
 position: relative;
 cursor: default;
 padding: var(--n-option-padding);
 color: var(--n-group-header-text-color);
 `), cB("base-select-option", `
 cursor: pointer;
 position: relative;
 padding: var(--n-option-padding);
 transition:
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 box-sizing: border-box;
 color: var(--n-option-text-color);
 opacity: 1;
 `, [cM("show-checkmark", `
 padding-right: calc(var(--n-option-padding-right) + 20px);
 `), c$1("&::before", `
 content: "";
 position: absolute;
 left: 4px;
 right: 4px;
 top: 0;
 bottom: 0;
 border-radius: var(--n-border-radius);
 transition: background-color .3s var(--n-bezier);
 `), c$1("&:active", `
 color: var(--n-option-text-color-pressed);
 `), cM("grouped", `
 padding-left: calc(var(--n-option-padding-left) * 1.5);
 `), cM("pending", [c$1("&::before", `
 background-color: var(--n-option-color-pending);
 `)]), cM("selected", `
 color: var(--n-option-text-color-active);
 `, [c$1("&::before", `
 background-color: var(--n-option-color-active);
 `), cM("pending", [c$1("&::before", `
 background-color: var(--n-option-color-active-pending);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 `, [cNotM("selected", `
 color: var(--n-option-text-color-disabled);
 `), cM("selected", `
 opacity: var(--n-option-opacity-disabled);
 `)]), cE("check", `
 font-size: 16px;
 position: absolute;
 right: calc(var(--n-option-padding-right) - 4px);
 top: calc(50% - 7px);
 color: var(--n-option-check-color);
 transition: color .3s var(--n-bezier);
 `, [fadeInScaleUpTransition({
    enterScale: "0.5"
  })])])]);
  const NInternalSelectMenu = vue.defineComponent({
    name: "InternalSelectMenu",
    props: Object.assign(Object.assign({}, useTheme.props), {
      clsPrefix: {
        type: String,
        required: true
      },
      scrollable: {
        type: Boolean,
        default: true
      },
      treeMate: {
        type: Object,
        required: true
      },
      multiple: Boolean,
      size: {
        type: String,
        default: "medium"
      },
      value: {
        type: [String, Number, Array],
        default: null
      },
      autoPending: Boolean,
      virtualScroll: {
        type: Boolean,
        default: true
      },
      // show is used to toggle pending state initialization
      show: {
        type: Boolean,
        default: true
      },
      labelField: {
        type: String,
        default: "label"
      },
      valueField: {
        type: String,
        default: "value"
      },
      loading: Boolean,
      focusable: Boolean,
      renderLabel: Function,
      renderOption: Function,
      nodeProps: Function,
      showCheckmark: {
        type: Boolean,
        default: true
      },
      onMousedown: Function,
      onScroll: Function,
      onFocus: Function,
      onBlur: Function,
      onKeyup: Function,
      onKeydown: Function,
      onTabOut: Function,
      onMouseenter: Function,
      onMouseleave: Function,
      onResize: Function,
      resetMenuOnOptionsChange: {
        type: Boolean,
        default: true
      },
      inlineThemeDisabled: Boolean,
      // deprecated
      onToggle: Function
    }),
    setup(props) {
      const {
        mergedClsPrefixRef,
        mergedRtlRef
      } = useConfig(props);
      const rtlEnabledRef = useRtl("InternalSelectMenu", mergedRtlRef, mergedClsPrefixRef);
      const themeRef = useTheme("InternalSelectMenu", "-internal-select-menu", style$1x, internalSelectMenuLight$1, props, vue.toRef(props, "clsPrefix"));
      const selfRef = vue.ref(null);
      const virtualListRef = vue.ref(null);
      const scrollbarRef = vue.ref(null);
      const flattenedNodesRef = vue.computed(() => props.treeMate.getFlattenedNodes());
      const fIndexGetterRef = vue.computed(() => createIndexGetter(flattenedNodesRef.value));
      const pendingNodeRef = vue.ref(null);
      function initPendingNode() {
        const {
          treeMate
        } = props;
        let defaultPendingNode = null;
        const {
          value
        } = props;
        if (value === null) {
          defaultPendingNode = treeMate.getFirstAvailableNode();
        } else {
          if (props.multiple) {
            defaultPendingNode = treeMate.getNode((value || [])[(value || []).length - 1]);
          } else {
            defaultPendingNode = treeMate.getNode(value);
          }
          if (!defaultPendingNode || defaultPendingNode.disabled) {
            defaultPendingNode = treeMate.getFirstAvailableNode();
          }
        }
        if (defaultPendingNode) {
          setPendingTmNode(defaultPendingNode);
        } else {
          setPendingTmNode(null);
        }
      }
      function clearPendingNodeIfInvalid() {
        const {
          value: pendingNode
        } = pendingNodeRef;
        if (pendingNode && !props.treeMate.getNode(pendingNode.key)) {
          pendingNodeRef.value = null;
        }
      }
      let initPendingNodeWatchStopHandle;
      vue.watch(() => props.show, (show) => {
        if (show) {
          initPendingNodeWatchStopHandle = vue.watch(() => props.treeMate, () => {
            if (props.resetMenuOnOptionsChange) {
              if (props.autoPending) {
                initPendingNode();
              } else {
                clearPendingNodeIfInvalid();
              }
              void vue.nextTick(scrollToPendingNode);
            } else {
              clearPendingNodeIfInvalid();
            }
          }, {
            immediate: true
          });
        } else {
          initPendingNodeWatchStopHandle === null || initPendingNodeWatchStopHandle === void 0 ? void 0 : initPendingNodeWatchStopHandle();
        }
      }, {
        immediate: true
      });
      vue.onBeforeUnmount(() => {
        initPendingNodeWatchStopHandle === null || initPendingNodeWatchStopHandle === void 0 ? void 0 : initPendingNodeWatchStopHandle();
      });
      const itemSizeRef = vue.computed(() => {
        return depx(themeRef.value.self[createKey("optionHeight", props.size)]);
      });
      const paddingRef = vue.computed(() => {
        return getMargin(themeRef.value.self[createKey("padding", props.size)]);
      });
      const valueSetRef = vue.computed(() => {
        if (props.multiple && Array.isArray(props.value)) {
          return new Set(props.value);
        }
        return /* @__PURE__ */ new Set();
      });
      const emptyRef = vue.computed(() => {
        const tmNodes = flattenedNodesRef.value;
        return tmNodes && tmNodes.length === 0;
      });
      function doToggle(tmNode) {
        const {
          onToggle
        } = props;
        if (onToggle)
          onToggle(tmNode);
      }
      function doScroll(e) {
        const {
          onScroll
        } = props;
        if (onScroll)
          onScroll(e);
      }
      function handleVirtualListScroll(e) {
        var _a;
        (_a = scrollbarRef.value) === null || _a === void 0 ? void 0 : _a.sync();
        doScroll(e);
      }
      function handleVirtualListResize() {
        var _a;
        (_a = scrollbarRef.value) === null || _a === void 0 ? void 0 : _a.sync();
      }
      function getPendingTmNode() {
        const {
          value: pendingTmNode
        } = pendingNodeRef;
        if (pendingTmNode)
          return pendingTmNode;
        return null;
      }
      function handleOptionMouseEnter(e, tmNode) {
        if (tmNode.disabled)
          return;
        setPendingTmNode(tmNode, false);
      }
      function handleOptionClick(e, tmNode) {
        if (tmNode.disabled)
          return;
        doToggle(tmNode);
      }
      function handleKeyUp(e) {
        var _a;
        if (happensIn(e, "action"))
          return;
        (_a = props.onKeyup) === null || _a === void 0 ? void 0 : _a.call(props, e);
      }
      function handleKeyDown(e) {
        var _a;
        if (happensIn(e, "action"))
          return;
        (_a = props.onKeydown) === null || _a === void 0 ? void 0 : _a.call(props, e);
      }
      function handleMouseDown(e) {
        var _a;
        (_a = props.onMousedown) === null || _a === void 0 ? void 0 : _a.call(props, e);
        if (props.focusable)
          return;
        e.preventDefault();
      }
      function next() {
        const {
          value: pendingTmNode
        } = pendingNodeRef;
        if (pendingTmNode) {
          setPendingTmNode(pendingTmNode.getNext({
            loop: true
          }), true);
        }
      }
      function prev() {
        const {
          value: pendingTmNode
        } = pendingNodeRef;
        if (pendingTmNode) {
          setPendingTmNode(pendingTmNode.getPrev({
            loop: true
          }), true);
        }
      }
      function setPendingTmNode(tmNode, doScroll2 = false) {
        pendingNodeRef.value = tmNode;
        if (doScroll2)
          scrollToPendingNode();
      }
      function scrollToPendingNode() {
        var _a, _b;
        const tmNode = pendingNodeRef.value;
        if (!tmNode)
          return;
        const fIndex = fIndexGetterRef.value(tmNode.key);
        if (fIndex === null)
          return;
        if (props.virtualScroll) {
          (_a = virtualListRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo({
            index: fIndex
          });
        } else {
          (_b = scrollbarRef.value) === null || _b === void 0 ? void 0 : _b.scrollTo({
            index: fIndex,
            elSize: itemSizeRef.value
          });
        }
      }
      function handleFocusin(e) {
        var _a, _b;
        if ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.target)) {
          (_b = props.onFocus) === null || _b === void 0 ? void 0 : _b.call(props, e);
        }
      }
      function handleFocusout(e) {
        var _a, _b;
        if (!((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget))) {
          (_b = props.onBlur) === null || _b === void 0 ? void 0 : _b.call(props, e);
        }
      }
      vue.provide(internalSelectionMenuInjectionKey, {
        handleOptionMouseEnter,
        handleOptionClick,
        valueSetRef,
        pendingTmNodeRef: pendingNodeRef,
        nodePropsRef: vue.toRef(props, "nodeProps"),
        showCheckmarkRef: vue.toRef(props, "showCheckmark"),
        multipleRef: vue.toRef(props, "multiple"),
        valueRef: vue.toRef(props, "value"),
        renderLabelRef: vue.toRef(props, "renderLabel"),
        renderOptionRef: vue.toRef(props, "renderOption"),
        labelFieldRef: vue.toRef(props, "labelField"),
        valueFieldRef: vue.toRef(props, "valueField")
      });
      vue.provide(internalSelectionMenuBodyInjectionKey, selfRef);
      vue.onMounted(() => {
        const {
          value
        } = scrollbarRef;
        if (value)
          value.sync();
      });
      const cssVarsRef = vue.computed(() => {
        const {
          size: size2
        } = props;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            height,
            borderRadius,
            color,
            groupHeaderTextColor,
            actionDividerColor,
            optionTextColorPressed,
            optionTextColor,
            optionTextColorDisabled,
            optionTextColorActive,
            optionOpacityDisabled,
            optionCheckColor,
            actionTextColor,
            optionColorPending,
            optionColorActive,
            loadingColor,
            loadingSize,
            optionColorActivePending,
            [createKey("optionFontSize", size2)]: fontSize2,
            [createKey("optionHeight", size2)]: optionHeight,
            [createKey("optionPadding", size2)]: optionPadding
          }
        } = themeRef.value;
        return {
          "--n-height": height,
          "--n-action-divider-color": actionDividerColor,
          "--n-action-text-color": actionTextColor,
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-border-radius": borderRadius,
          "--n-color": color,
          "--n-option-font-size": fontSize2,
          "--n-group-header-text-color": groupHeaderTextColor,
          "--n-option-check-color": optionCheckColor,
          "--n-option-color-pending": optionColorPending,
          "--n-option-color-active": optionColorActive,
          "--n-option-color-active-pending": optionColorActivePending,
          "--n-option-height": optionHeight,
          "--n-option-opacity-disabled": optionOpacityDisabled,
          "--n-option-text-color": optionTextColor,
          "--n-option-text-color-active": optionTextColorActive,
          "--n-option-text-color-disabled": optionTextColorDisabled,
          "--n-option-text-color-pressed": optionTextColorPressed,
          "--n-option-padding": optionPadding,
          "--n-option-padding-left": getMargin(optionPadding, "left"),
          "--n-option-padding-right": getMargin(optionPadding, "right"),
          "--n-loading-color": loadingColor,
          "--n-loading-size": loadingSize
        };
      });
      const {
        inlineThemeDisabled
      } = props;
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("internal-select-menu", vue.computed(() => props.size[0]), cssVarsRef, props) : void 0;
      const exposedProps = {
        selfRef,
        next,
        prev,
        getPendingTmNode
      };
      useOnResize(selfRef, props.onResize);
      return Object.assign({
        mergedTheme: themeRef,
        mergedClsPrefix: mergedClsPrefixRef,
        rtlEnabled: rtlEnabledRef,
        virtualListRef,
        scrollbarRef,
        itemSize: itemSizeRef,
        padding: paddingRef,
        flattenedNodes: flattenedNodesRef,
        empty: emptyRef,
        virtualListContainer() {
          const {
            value
          } = virtualListRef;
          return value === null || value === void 0 ? void 0 : value.listElRef;
        },
        virtualListContent() {
          const {
            value
          } = virtualListRef;
          return value === null || value === void 0 ? void 0 : value.itemsElRef;
        },
        doScroll,
        handleFocusin,
        handleFocusout,
        handleKeyUp,
        handleKeyDown,
        handleMouseDown,
        handleVirtualListResize,
        handleVirtualListScroll,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      }, exposedProps);
    },
    render() {
      const {
        $slots,
        virtualScroll,
        clsPrefix,
        mergedTheme,
        themeClass,
        onRender
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h("div", {
        ref: "selfRef",
        tabindex: this.focusable ? 0 : -1,
        class: [`${clsPrefix}-base-select-menu`, this.rtlEnabled && `${clsPrefix}-base-select-menu--rtl`, themeClass, this.multiple && `${clsPrefix}-base-select-menu--multiple`],
        style: this.cssVars,
        onFocusin: this.handleFocusin,
        onFocusout: this.handleFocusout,
        onKeyup: this.handleKeyUp,
        onKeydown: this.handleKeyDown,
        onMousedown: this.handleMouseDown,
        onMouseenter: this.onMouseenter,
        onMouseleave: this.onMouseleave
      }, resolveWrappedSlot($slots.header, (children) => children && vue.h("div", {
        class: `${clsPrefix}-base-select-menu__header`,
        "data-header": true,
        key: "header"
      }, children)), this.loading ? vue.h("div", {
        class: `${clsPrefix}-base-select-menu__loading`
      }, vue.h(NBaseLoading, {
        clsPrefix,
        strokeWidth: 20
      })) : !this.empty ? vue.h(NScrollbar, {
        ref: "scrollbarRef",
        theme: mergedTheme.peers.Scrollbar,
        themeOverrides: mergedTheme.peerOverrides.Scrollbar,
        scrollable: this.scrollable,
        container: virtualScroll ? this.virtualListContainer : void 0,
        content: virtualScroll ? this.virtualListContent : void 0,
        onScroll: virtualScroll ? void 0 : this.doScroll
      }, {
        default: () => {
          return virtualScroll ? vue.h(VVirtualList, {
            ref: "virtualListRef",
            class: `${clsPrefix}-virtual-list`,
            items: this.flattenedNodes,
            itemSize: this.itemSize,
            showScrollbar: false,
            paddingTop: this.padding.top,
            paddingBottom: this.padding.bottom,
            onResize: this.handleVirtualListResize,
            onScroll: this.handleVirtualListScroll,
            itemResizable: true
          }, {
            default: ({
              item: tmNode
            }) => {
              return tmNode.isGroup ? vue.h(NSelectGroupHeader, {
                key: tmNode.key,
                clsPrefix,
                tmNode
              }) : tmNode.ignored ? null : vue.h(NSelectOption, {
                clsPrefix,
                key: tmNode.key,
                tmNode
              });
            }
          }) : vue.h("div", {
            class: `${clsPrefix}-base-select-menu-option-wrapper`,
            style: {
              paddingTop: this.padding.top,
              paddingBottom: this.padding.bottom
            }
          }, this.flattenedNodes.map((tmNode) => tmNode.isGroup ? vue.h(NSelectGroupHeader, {
            key: tmNode.key,
            clsPrefix,
            tmNode
          }) : vue.h(NSelectOption, {
            clsPrefix,
            key: tmNode.key,
            tmNode
          })));
        }
      }) : vue.h("div", {
        class: `${clsPrefix}-base-select-menu__empty`,
        "data-empty": true
      }, resolveSlot($slots.empty, () => [vue.h(NEmpty, {
        theme: mergedTheme.peers.Empty,
        themeOverrides: mergedTheme.peerOverrides.Empty,
        size: this.size
      })])), resolveWrappedSlot($slots.action, (children) => children && [vue.h("div", {
        class: `${clsPrefix}-base-select-menu__action`,
        "data-action": true,
        key: "action"
      }, children), vue.h(FocusDetector, {
        onFocus: this.onTabOut,
        key: "focus-detector"
      })]));
    }
  });
  const style$1w = cB("base-wave", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
`);
  const NBaseWave = vue.defineComponent({
    name: "BaseWave",
    props: {
      clsPrefix: {
        type: String,
        required: true
      }
    },
    setup(props) {
      useStyle("-base-wave", style$1w, vue.toRef(props, "clsPrefix"));
      const selfRef = vue.ref(null);
      const activeRef = vue.ref(false);
      let animationTimerId = null;
      vue.onBeforeUnmount(() => {
        if (animationTimerId !== null) {
          window.clearTimeout(animationTimerId);
        }
      });
      return {
        active: activeRef,
        selfRef,
        play() {
          if (animationTimerId !== null) {
            window.clearTimeout(animationTimerId);
            activeRef.value = false;
            animationTimerId = null;
          }
          void vue.nextTick(() => {
            var _a;
            void ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.offsetHeight);
            activeRef.value = true;
            animationTimerId = window.setTimeout(() => {
              activeRef.value = false;
              animationTimerId = null;
            }, 1e3);
          });
        }
      };
    },
    render() {
      const {
        clsPrefix
      } = this;
      return vue.h("div", {
        ref: "selfRef",
        "aria-hidden": true,
        class: [`${clsPrefix}-base-wave`, this.active && `${clsPrefix}-base-wave--active`]
      });
    }
  });
  const style$1v = cB("base-menu-mask", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 align-items: center;
 justify-content: center;
 text-align: center;
 padding: 14px;
 overflow: hidden;
`, [fadeInTransition()]);
  const NBaseMenuMask = vue.defineComponent({
    name: "BaseMenuMask",
    props: {
      clsPrefix: {
        type: String,
        required: true
      }
    },
    setup(props) {
      useStyle("-base-menu-mask", style$1v, vue.toRef(props, "clsPrefix"));
      const messageRef = vue.ref(null);
      let timerId = null;
      const uncontrolledShowRef = vue.ref(false);
      vue.onBeforeUnmount(() => {
        if (timerId !== null) {
          window.clearTimeout(timerId);
        }
      });
      const exposedRef = {
        showOnce(message2, duration2 = 1500) {
          if (timerId)
            window.clearTimeout(timerId);
          uncontrolledShowRef.value = true;
          messageRef.value = message2;
          timerId = window.setTimeout(() => {
            uncontrolledShowRef.value = false;
            messageRef.value = null;
          }, duration2);
        }
      };
      return Object.assign({
        message: messageRef,
        show: uncontrolledShowRef
      }, exposedRef);
    },
    render() {
      return vue.h(vue.Transition, {
        name: "fade-in-transition"
      }, {
        default: () => this.show ? vue.h("div", {
          class: `${this.clsPrefix}-base-menu-mask`
        }, this.message) : null
      });
    }
  });
  const commonVariables$k = {
    space: "6px",
    spaceArrow: "10px",
    arrowOffset: "10px",
    arrowOffsetVertical: "10px",
    arrowHeight: "6px",
    padding: "8px 14px"
  };
  function self$1e(vars) {
    const {
      boxShadow2,
      popoverColor,
      textColor2,
      borderRadius,
      fontSize: fontSize2,
      dividerColor
    } = vars;
    return Object.assign(Object.assign({}, commonVariables$k), {
      fontSize: fontSize2,
      borderRadius,
      color: popoverColor,
      dividerColor,
      textColor: textColor2,
      boxShadow: boxShadow2
    });
  }
  const popoverLight = {
    name: "Popover",
    common: commonLight,
    self: self$1e
  };
  const popoverLight$1 = popoverLight;
  const oppositePlacement = {
    top: "bottom",
    bottom: "top",
    left: "right",
    right: "left"
  };
  const arrowSize = "var(--n-arrow-height) * 1.414";
  const style$1u = c$1([cB("popover", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 position: relative;
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 box-shadow: var(--n-box-shadow);
 word-break: break-word;
 `, [c$1(">", [cB("scrollbar", `
 height: inherit;
 max-height: inherit;
 `)]), cNotM("raw", `
 background-color: var(--n-color);
 border-radius: var(--n-border-radius);
 `, [cNotM("scrollable", [cNotM("show-header-or-footer", "padding: var(--n-padding);")])]), cE("header", `
 padding: var(--n-padding);
 border-bottom: 1px solid var(--n-divider-color);
 transition: border-color .3s var(--n-bezier);
 `), cE("footer", `
 padding: var(--n-padding);
 border-top: 1px solid var(--n-divider-color);
 transition: border-color .3s var(--n-bezier);
 `), cM("scrollable, show-header-or-footer", [cE("content", `
 padding: var(--n-padding);
 `)])]), cB("popover-shared", `
 transform-origin: inherit;
 `, [
    cB("popover-arrow-wrapper", `
 position: absolute;
 overflow: hidden;
 pointer-events: none;
 `, [cB("popover-arrow", `
 transition: background-color .3s var(--n-bezier);
 position: absolute;
 display: block;
 width: calc(${arrowSize});
 height: calc(${arrowSize});
 box-shadow: 0 0 8px 0 rgba(0, 0, 0, .12);
 transform: rotate(45deg);
 background-color: var(--n-color);
 pointer-events: all;
 `)]),
    // body transition
    c$1("&.popover-transition-enter-from, &.popover-transition-leave-to", `
 opacity: 0;
 transform: scale(.85);
 `),
    c$1("&.popover-transition-enter-to, &.popover-transition-leave-from", `
 transform: scale(1);
 opacity: 1;
 `),
    c$1("&.popover-transition-enter-active", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .15s var(--n-bezier-ease-out),
 transform .15s var(--n-bezier-ease-out);
 `),
    c$1("&.popover-transition-leave-active", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .15s var(--n-bezier-ease-in),
 transform .15s var(--n-bezier-ease-in);
 `)
  ]), placementStyle("top-start", `
 top: calc(${arrowSize} / -2);
 left: calc(${getArrowOffset("top-start")} - var(--v-offset-left));
 `), placementStyle("top", `
 top: calc(${arrowSize} / -2);
 transform: translateX(calc(${arrowSize} / -2)) rotate(45deg);
 left: 50%;
 `), placementStyle("top-end", `
 top: calc(${arrowSize} / -2);
 right: calc(${getArrowOffset("top-end")} + var(--v-offset-left));
 `), placementStyle("bottom-start", `
 bottom: calc(${arrowSize} / -2);
 left: calc(${getArrowOffset("bottom-start")} - var(--v-offset-left));
 `), placementStyle("bottom", `
 bottom: calc(${arrowSize} / -2);
 transform: translateX(calc(${arrowSize} / -2)) rotate(45deg);
 left: 50%;
 `), placementStyle("bottom-end", `
 bottom: calc(${arrowSize} / -2);
 right: calc(${getArrowOffset("bottom-end")} + var(--v-offset-left));
 `), placementStyle("left-start", `
 left: calc(${arrowSize} / -2);
 top: calc(${getArrowOffset("left-start")} - var(--v-offset-top));
 `), placementStyle("left", `
 left: calc(${arrowSize} / -2);
 transform: translateY(calc(${arrowSize} / -2)) rotate(45deg);
 top: 50%;
 `), placementStyle("left-end", `
 left: calc(${arrowSize} / -2);
 bottom: calc(${getArrowOffset("left-end")} + var(--v-offset-top));
 `), placementStyle("right-start", `
 right: calc(${arrowSize} / -2);
 top: calc(${getArrowOffset("right-start")} - var(--v-offset-top));
 `), placementStyle("right", `
 right: calc(${arrowSize} / -2);
 transform: translateY(calc(${arrowSize} / -2)) rotate(45deg);
 top: 50%;
 `), placementStyle("right-end", `
 right: calc(${arrowSize} / -2);
 bottom: calc(${getArrowOffset("right-end")} + var(--v-offset-top));
 `), ...map({
    top: ["right-start", "left-start"],
    right: ["top-end", "bottom-end"],
    bottom: ["right-end", "left-end"],
    left: ["top-start", "bottom-start"]
  }, (placements, direction) => {
    const isVertical = ["right", "left"].includes(direction);
    const sizeType = isVertical ? "width" : "height";
    return placements.map((placement) => {
      const isReverse = placement.split("-")[1] === "end";
      const targetSize = `var(--v-target-${sizeType}, 0px)`;
      const centerOffset = `calc((${targetSize} - ${arrowSize}) / 2)`;
      const offset = getArrowOffset(placement);
      return c$1(`[v-placement="${placement}"] >`, [cB("popover-shared", [cM("center-arrow", [cB("popover-arrow", `${direction}: calc(max(${centerOffset}, ${offset}) ${isReverse ? "+" : "-"} var(--v-offset-${isVertical ? "left" : "top"}));`)])])]);
    });
  })]);
  function getArrowOffset(placement) {
    return ["top", "bottom"].includes(placement.split("-")[0]) ? "var(--n-arrow-offset)" : "var(--n-arrow-offset-vertical)";
  }
  function placementStyle(placement, arrowStyleLiteral) {
    const position = placement.split("-")[0];
    const sizeStyle = ["top", "bottom"].includes(position) ? "height: var(--n-space-arrow);" : "width: var(--n-space-arrow);";
    return c$1(`[v-placement="${placement}"] >`, [cB("popover-shared", `
 margin-${oppositePlacement[position]}: var(--n-space);
 `, [cM("show-arrow", `
 margin-${oppositePlacement[position]}: var(--n-space-arrow);
 `), cM("overlap", `
 margin: 0;
 `), cCB("popover-arrow-wrapper", `
 right: 0;
 left: 0;
 top: 0;
 bottom: 0;
 ${position}: 100%;
 ${oppositePlacement[position]}: auto;
 ${sizeStyle}
 `, [cB("popover-arrow", arrowStyleLiteral)])])]);
  }
  const popoverBodyProps = Object.assign(Object.assign({}, useTheme.props), {
    to: useAdjustedTo.propTo,
    show: Boolean,
    trigger: String,
    showArrow: Boolean,
    delay: Number,
    duration: Number,
    raw: Boolean,
    arrowPointToCenter: Boolean,
    arrowClass: String,
    arrowStyle: [String, Object],
    arrowWrapperClass: String,
    arrowWrapperStyle: [String, Object],
    displayDirective: String,
    x: Number,
    y: Number,
    flip: Boolean,
    overlap: Boolean,
    placement: String,
    width: [Number, String],
    keepAliveOnHover: Boolean,
    scrollable: Boolean,
    contentClass: String,
    contentStyle: [Object, String],
    headerClass: String,
    headerStyle: [Object, String],
    footerClass: String,
    footerStyle: [Object, String],
    // private
    internalDeactivateImmediately: Boolean,
    animated: Boolean,
    onClickoutside: Function,
    internalTrapFocus: Boolean,
    internalOnAfterLeave: Function,
    // deprecated
    minWidth: Number,
    maxWidth: Number
  });
  function renderArrow({
    arrowClass,
    arrowStyle,
    arrowWrapperClass,
    arrowWrapperStyle,
    clsPrefix
  }) {
    return vue.h("div", {
      key: "__popover-arrow__",
      style: arrowWrapperStyle,
      class: [`${clsPrefix}-popover-arrow-wrapper`, arrowWrapperClass]
    }, vue.h("div", {
      class: [`${clsPrefix}-popover-arrow`, arrowClass],
      style: arrowStyle
    }));
  }
  const NPopoverBody = vue.defineComponent({
    name: "PopoverBody",
    inheritAttrs: false,
    props: popoverBodyProps,
    setup(props, {
      slots,
      attrs
    }) {
      const {
        namespaceRef,
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Popover", "-popover", style$1u, popoverLight$1, props, mergedClsPrefixRef);
      const followerRef = vue.ref(null);
      const NPopover2 = vue.inject("NPopover");
      const bodyRef = vue.ref(null);
      const followerEnabledRef = vue.ref(props.show);
      const displayedRef = vue.ref(false);
      vue.watchEffect(() => {
        const {
          show
        } = props;
        if (show && !isJsdom() && !props.internalDeactivateImmediately) {
          displayedRef.value = true;
        }
      });
      const directivesRef = vue.computed(() => {
        const {
          trigger: trigger2,
          onClickoutside
        } = props;
        const directives = [];
        const {
          positionManuallyRef: {
            value: positionManually
          }
        } = NPopover2;
        if (!positionManually) {
          if (trigger2 === "click" && !onClickoutside) {
            directives.push([clickoutside$1, handleClickOutside, void 0, {
              capture: true
            }]);
          }
          if (trigger2 === "hover") {
            directives.push([mousemoveoutside$1, handleMouseMoveOutside]);
          }
        }
        if (onClickoutside) {
          directives.push([clickoutside$1, handleClickOutside, void 0, {
            capture: true
          }]);
        }
        if (props.displayDirective === "show" || props.animated && displayedRef.value) {
          directives.push([vue.vShow, props.show]);
        }
        return directives;
      });
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2,
            cubicBezierEaseIn: cubicBezierEaseIn2,
            cubicBezierEaseOut: cubicBezierEaseOut2
          },
          self: {
            space,
            spaceArrow,
            padding,
            fontSize: fontSize2,
            textColor,
            dividerColor,
            color,
            boxShadow,
            borderRadius,
            arrowHeight,
            arrowOffset,
            arrowOffsetVertical
          }
        } = themeRef.value;
        return {
          "--n-box-shadow": boxShadow,
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-bezier-ease-in": cubicBezierEaseIn2,
          "--n-bezier-ease-out": cubicBezierEaseOut2,
          "--n-font-size": fontSize2,
          "--n-text-color": textColor,
          "--n-color": color,
          "--n-divider-color": dividerColor,
          "--n-border-radius": borderRadius,
          "--n-arrow-height": arrowHeight,
          "--n-arrow-offset": arrowOffset,
          "--n-arrow-offset-vertical": arrowOffsetVertical,
          "--n-padding": padding,
          "--n-space": space,
          "--n-space-arrow": spaceArrow
        };
      });
      const styleRef = vue.computed(() => {
        const width = props.width === "trigger" ? void 0 : formatLength(props.width);
        const style2 = [];
        if (width) {
          style2.push({
            width
          });
        }
        const {
          maxWidth,
          minWidth
        } = props;
        if (maxWidth) {
          style2.push({
            maxWidth: formatLength(maxWidth)
          });
        }
        if (minWidth) {
          style2.push({
            maxWidth: formatLength(minWidth)
          });
        }
        if (!inlineThemeDisabled) {
          style2.push(cssVarsRef.value);
        }
        return style2;
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("popover", void 0, cssVarsRef, props) : void 0;
      NPopover2.setBodyInstance({
        syncPosition
      });
      vue.onBeforeUnmount(() => {
        NPopover2.setBodyInstance(null);
      });
      vue.watch(vue.toRef(props, "show"), (value) => {
        if (props.animated)
          return;
        if (value) {
          followerEnabledRef.value = true;
        } else {
          followerEnabledRef.value = false;
        }
      });
      function syncPosition() {
        var _a;
        (_a = followerRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
      }
      function handleMouseEnter(e) {
        if (props.trigger === "hover" && props.keepAliveOnHover && props.show) {
          NPopover2.handleMouseEnter(e);
        }
      }
      function handleMouseLeave(e) {
        if (props.trigger === "hover" && props.keepAliveOnHover) {
          NPopover2.handleMouseLeave(e);
        }
      }
      function handleMouseMoveOutside(e) {
        if (props.trigger === "hover" && !getTriggerElement().contains(getPreciseEventTarget(e))) {
          NPopover2.handleMouseMoveOutside(e);
        }
      }
      function handleClickOutside(e) {
        if (props.trigger === "click" && !getTriggerElement().contains(getPreciseEventTarget(e)) || props.onClickoutside) {
          NPopover2.handleClickOutside(e);
        }
      }
      function getTriggerElement() {
        return NPopover2.getTriggerElement();
      }
      vue.provide(popoverBodyInjectionKey, bodyRef);
      vue.provide(drawerBodyInjectionKey, null);
      vue.provide(modalBodyInjectionKey, null);
      function renderContentNode() {
        themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender();
        const shouldRenderDom = props.displayDirective === "show" || props.show || props.animated && displayedRef.value;
        if (!shouldRenderDom) {
          return null;
        }
        let contentNode;
        const renderBody = NPopover2.internalRenderBodyRef.value;
        const {
          value: mergedClsPrefix
        } = mergedClsPrefixRef;
        if (!renderBody) {
          const {
            value: extraClass
          } = NPopover2.extraClassRef;
          const {
            internalTrapFocus
          } = props;
          const hasHeaderOrFooter = !isSlotEmpty(slots.header) || !isSlotEmpty(slots.footer);
          const renderContentInnerNode = () => {
            var _a, _b;
            const body = hasHeaderOrFooter ? vue.h(vue.Fragment, null, resolveWrappedSlot(slots.header, (children) => {
              return children ? vue.h("div", {
                class: [`${mergedClsPrefix}-popover__header`, props.headerClass],
                style: props.headerStyle
              }, children) : null;
            }), resolveWrappedSlot(slots.default, (children) => {
              return children ? vue.h("div", {
                class: [`${mergedClsPrefix}-popover__content`, props.contentClass],
                style: props.contentStyle
              }, slots) : null;
            }), resolveWrappedSlot(slots.footer, (children) => {
              return children ? vue.h("div", {
                class: [`${mergedClsPrefix}-popover__footer`, props.footerClass],
                style: props.footerStyle
              }, children) : null;
            })) : props.scrollable ? (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots) : vue.h("div", {
              class: [`${mergedClsPrefix}-popover__content`, props.contentClass],
              style: props.contentStyle
            }, slots);
            const maybeScrollableBody = props.scrollable ? vue.h(XScrollbar, {
              contentClass: hasHeaderOrFooter ? void 0 : `${mergedClsPrefix}-popover__content ${(_b = props.contentClass) !== null && _b !== void 0 ? _b : ""}`,
              contentStyle: hasHeaderOrFooter ? void 0 : props.contentStyle
            }, {
              default: () => body
            }) : body;
            const arrow = props.showArrow ? renderArrow({
              arrowClass: props.arrowClass,
              arrowStyle: props.arrowStyle,
              arrowWrapperClass: props.arrowWrapperClass,
              arrowWrapperStyle: props.arrowWrapperStyle,
              clsPrefix: mergedClsPrefix
            }) : null;
            return [maybeScrollableBody, arrow];
          };
          contentNode = vue.h("div", vue.mergeProps({
            class: [`${mergedClsPrefix}-popover`, `${mergedClsPrefix}-popover-shared`, themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value, extraClass.map((v) => `${mergedClsPrefix}-${v}`), {
              [`${mergedClsPrefix}-popover--scrollable`]: props.scrollable,
              [`${mergedClsPrefix}-popover--show-header-or-footer`]: hasHeaderOrFooter,
              [`${mergedClsPrefix}-popover--raw`]: props.raw,
              [`${mergedClsPrefix}-popover-shared--overlap`]: props.overlap,
              [`${mergedClsPrefix}-popover-shared--show-arrow`]: props.showArrow,
              [`${mergedClsPrefix}-popover-shared--center-arrow`]: props.arrowPointToCenter
            }],
            ref: bodyRef,
            style: styleRef.value,
            onKeydown: NPopover2.handleKeydown,
            onMouseenter: handleMouseEnter,
            onMouseleave: handleMouseLeave
          }, attrs), internalTrapFocus ? vue.h(FocusTrap, {
            active: props.show,
            autoFocus: true
          }, {
            default: renderContentInnerNode
          }) : renderContentInnerNode());
        } else {
          contentNode = renderBody(
            // The popover class and overlap class must exists, they will be used
            // to place the body & transition animation.
            // Shadow class exists for reuse box-shadow.
            [`${mergedClsPrefix}-popover-shared`, themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value, props.overlap && `${mergedClsPrefix}-popover-shared--overlap`, props.showArrow && `${mergedClsPrefix}-popover-shared--show-arrow`, props.arrowPointToCenter && `${mergedClsPrefix}-popover-shared--center-arrow`],
            bodyRef,
            styleRef.value,
            handleMouseEnter,
            handleMouseLeave
          );
        }
        return vue.withDirectives(contentNode, directivesRef.value);
      }
      return {
        displayed: displayedRef,
        namespace: namespaceRef,
        isMounted: NPopover2.isMountedRef,
        zIndex: NPopover2.zIndexRef,
        followerRef,
        adjustedTo: useAdjustedTo(props),
        followerEnabled: followerEnabledRef,
        renderContentNode
      };
    },
    render() {
      return vue.h(VFollower, {
        ref: "followerRef",
        zIndex: this.zIndex,
        show: this.show,
        enabled: this.followerEnabled,
        to: this.adjustedTo,
        x: this.x,
        y: this.y,
        flip: this.flip,
        placement: this.placement,
        containerClass: this.namespace,
        overlap: this.overlap,
        width: this.width === "trigger" ? "target" : void 0,
        teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey
      }, {
        default: () => {
          return this.animated ? vue.h(vue.Transition, {
            name: "popover-transition",
            appear: this.isMounted,
            // Don't use watch to enable follower, since the transition may
            // make position sync timing very subtle and buggy.
            onEnter: () => {
              this.followerEnabled = true;
            },
            onAfterLeave: () => {
              var _a;
              (_a = this.internalOnAfterLeave) === null || _a === void 0 ? void 0 : _a.call(this);
              this.followerEnabled = false;
              this.displayed = false;
            }
          }, {
            default: this.renderContentNode
          }) : this.renderContentNode();
        }
      });
    }
  });
  const bodyPropKeys = Object.keys(popoverBodyProps);
  const triggerEventMap = {
    focus: ["onFocus", "onBlur"],
    click: ["onClick"],
    hover: ["onMouseenter", "onMouseleave"],
    manual: [],
    nested: ["onFocus", "onBlur", "onMouseenter", "onMouseleave", "onClick"]
  };
  function appendEvents(vNode, trigger2, events2) {
    triggerEventMap[trigger2].forEach((eventName) => {
      if (!vNode.props) {
        vNode.props = {};
      } else {
        vNode.props = Object.assign({}, vNode.props);
      }
      const originalHandler = vNode.props[eventName];
      const handler = events2[eventName];
      if (!originalHandler) {
        vNode.props[eventName] = handler;
      } else {
        vNode.props[eventName] = (...args) => {
          originalHandler(...args);
          handler(...args);
        };
      }
    });
  }
  const popoverBaseProps = {
    show: {
      type: Boolean,
      default: void 0
    },
    defaultShow: Boolean,
    showArrow: {
      type: Boolean,
      default: true
    },
    trigger: {
      type: String,
      default: "hover"
    },
    delay: {
      type: Number,
      default: 100
    },
    duration: {
      type: Number,
      default: 100
    },
    raw: Boolean,
    placement: {
      type: String,
      default: "top"
    },
    x: Number,
    y: Number,
    arrowPointToCenter: Boolean,
    disabled: Boolean,
    getDisabled: Function,
    displayDirective: {
      type: String,
      default: "if"
    },
    arrowClass: String,
    arrowStyle: [String, Object],
    arrowWrapperClass: String,
    arrowWrapperStyle: [String, Object],
    flip: {
      type: Boolean,
      default: true
    },
    animated: {
      type: Boolean,
      default: true
    },
    width: {
      type: [Number, String],
      default: void 0
    },
    overlap: Boolean,
    keepAliveOnHover: {
      type: Boolean,
      default: true
    },
    zIndex: Number,
    to: useAdjustedTo.propTo,
    scrollable: Boolean,
    contentClass: String,
    contentStyle: [Object, String],
    headerClass: String,
    headerStyle: [Object, String],
    footerClass: String,
    footerStyle: [Object, String],
    // events
    onClickoutside: Function,
    "onUpdate:show": [Function, Array],
    onUpdateShow: [Function, Array],
    // internal
    internalDeactivateImmediately: Boolean,
    internalSyncTargetWithParent: Boolean,
    internalInheritedEventHandlers: {
      type: Array,
      default: () => []
    },
    internalTrapFocus: Boolean,
    internalExtraClass: {
      type: Array,
      default: () => []
    },
    // deprecated
    onShow: [Function, Array],
    onHide: [Function, Array],
    arrow: {
      type: Boolean,
      default: void 0
    },
    minWidth: Number,
    maxWidth: Number
  };
  const popoverProps = Object.assign(Object.assign(Object.assign({}, useTheme.props), popoverBaseProps), {
    internalOnAfterLeave: Function,
    internalRenderBody: Function
  });
  const NPopover = vue.defineComponent({
    name: "Popover",
    inheritAttrs: false,
    props: popoverProps,
    __popover__: true,
    setup(props) {
      {
        vue.watchEffect(() => {
          if (props.maxWidth !== void 0) {
            warnOnce("popover", "`max-width` is deprecated, please use `style` instead.");
          }
          if (props.minWidth !== void 0) {
            warnOnce("popover", "`min-width` is deprecated, please use `style` instead.");
          }
          if (props.arrow !== void 0) {
            warnOnce("popover", "`arrow` is deprecated, please use `showArrow` instead.");
          }
          if (props.onHide !== void 0) {
            warnOnce("popover", "`on-hide` is deprecated, please use `on-update:show` instead.");
          }
          if (props.onShow !== void 0) {
            warnOnce("popover", "`on-show` is deprecated, please use `on-update:show` instead.");
          }
        });
      }
      const isMountedRef = isMounted();
      const binderInstRef = vue.ref(null);
      const controlledShowRef = vue.computed(() => props.show);
      const uncontrolledShowRef = vue.ref(props.defaultShow);
      const mergedShowWithoutDisabledRef = useMergedState(controlledShowRef, uncontrolledShowRef);
      const mergedShowConsideringDisabledPropRef = useMemo(() => {
        if (props.disabled)
          return false;
        return mergedShowWithoutDisabledRef.value;
      });
      const getMergedDisabled = () => {
        if (props.disabled)
          return true;
        const {
          getDisabled
        } = props;
        if (getDisabled === null || getDisabled === void 0 ? void 0 : getDisabled())
          return true;
        return false;
      };
      const getMergedShow = () => {
        if (getMergedDisabled())
          return false;
        return mergedShowWithoutDisabledRef.value;
      };
      const compatibleShowArrowRef = useCompitable(props, ["arrow", "showArrow"]);
      const mergedShowArrowRef = vue.computed(() => {
        if (props.overlap)
          return false;
        return compatibleShowArrowRef.value;
      });
      let bodyInstance = null;
      const showTimerIdRef = vue.ref(null);
      const hideTimerIdRef = vue.ref(null);
      const positionManuallyRef = useMemo(() => {
        return props.x !== void 0 && props.y !== void 0;
      });
      function doUpdateShow(value) {
        const {
          "onUpdate:show": _onUpdateShow,
          onUpdateShow,
          onShow,
          onHide
        } = props;
        uncontrolledShowRef.value = value;
        if (_onUpdateShow) {
          call(_onUpdateShow, value);
        }
        if (onUpdateShow) {
          call(onUpdateShow, value);
        }
        if (value && onShow) {
          call(onShow, true);
        }
        if (value && onHide) {
          call(onHide, false);
        }
      }
      function syncPosition() {
        if (bodyInstance) {
          bodyInstance.syncPosition();
        }
      }
      function clearShowTimer() {
        const {
          value: showTimerId
        } = showTimerIdRef;
        if (showTimerId) {
          window.clearTimeout(showTimerId);
          showTimerIdRef.value = null;
        }
      }
      function clearHideTimer() {
        const {
          value: hideTimerId
        } = hideTimerIdRef;
        if (hideTimerId) {
          window.clearTimeout(hideTimerId);
          hideTimerIdRef.value = null;
        }
      }
      function handleFocus() {
        const mergedDisabled = getMergedDisabled();
        if (props.trigger === "focus" && !mergedDisabled) {
          if (getMergedShow())
            return;
          doUpdateShow(true);
        }
      }
      function handleBlur() {
        const mergedDisabled = getMergedDisabled();
        if (props.trigger === "focus" && !mergedDisabled) {
          if (!getMergedShow())
            return;
          doUpdateShow(false);
        }
      }
      function handleMouseEnter() {
        const mergedDisabled = getMergedDisabled();
        if (props.trigger === "hover" && !mergedDisabled) {
          clearHideTimer();
          if (showTimerIdRef.value !== null)
            return;
          if (getMergedShow())
            return;
          const delayCallback = () => {
            doUpdateShow(true);
            showTimerIdRef.value = null;
          };
          const {
            delay
          } = props;
          if (delay === 0) {
            delayCallback();
          } else {
            showTimerIdRef.value = window.setTimeout(delayCallback, delay);
          }
        }
      }
      function handleMouseLeave() {
        const mergedDisabled = getMergedDisabled();
        if (props.trigger === "hover" && !mergedDisabled) {
          clearShowTimer();
          if (hideTimerIdRef.value !== null)
            return;
          if (!getMergedShow())
            return;
          const delayedCallback = () => {
            doUpdateShow(false);
            hideTimerIdRef.value = null;
          };
          const {
            duration: duration2
          } = props;
          if (duration2 === 0) {
            delayedCallback();
          } else {
            hideTimerIdRef.value = window.setTimeout(delayedCallback, duration2);
          }
        }
      }
      function handleMouseMoveOutside() {
        handleMouseLeave();
      }
      function handleClickOutside(e) {
        var _a;
        if (!getMergedShow())
          return;
        if (props.trigger === "click") {
          clearShowTimer();
          clearHideTimer();
          doUpdateShow(false);
        }
        (_a = props.onClickoutside) === null || _a === void 0 ? void 0 : _a.call(props, e);
      }
      function handleClick2() {
        if (props.trigger === "click" && !getMergedDisabled()) {
          clearShowTimer();
          clearHideTimer();
          const nextShow = !getMergedShow();
          doUpdateShow(nextShow);
        }
      }
      function handleKeydown(e) {
        if (!props.internalTrapFocus)
          return;
        if (e.key === "Escape") {
          clearShowTimer();
          clearHideTimer();
          doUpdateShow(false);
        }
      }
      function setShow(value) {
        uncontrolledShowRef.value = value;
      }
      function getTriggerElement() {
        var _a;
        return (_a = binderInstRef.value) === null || _a === void 0 ? void 0 : _a.targetRef;
      }
      function setBodyInstance(value) {
        bodyInstance = value;
      }
      vue.provide("NPopover", {
        getTriggerElement,
        handleKeydown,
        handleMouseEnter,
        handleMouseLeave,
        handleClickOutside,
        handleMouseMoveOutside,
        setBodyInstance,
        positionManuallyRef,
        isMountedRef,
        zIndexRef: vue.toRef(props, "zIndex"),
        extraClassRef: vue.toRef(props, "internalExtraClass"),
        internalRenderBodyRef: vue.toRef(props, "internalRenderBody")
      });
      vue.watchEffect(() => {
        if (mergedShowWithoutDisabledRef.value && getMergedDisabled()) {
          doUpdateShow(false);
        }
      });
      const returned = {
        binderInstRef,
        positionManually: positionManuallyRef,
        mergedShowConsideringDisabledProp: mergedShowConsideringDisabledPropRef,
        // if to show popover body
        uncontrolledShow: uncontrolledShowRef,
        mergedShowArrow: mergedShowArrowRef,
        getMergedShow,
        setShow,
        handleClick: handleClick2,
        handleMouseEnter,
        handleMouseLeave,
        handleFocus,
        handleBlur,
        syncPosition
      };
      return returned;
    },
    render() {
      var _a;
      const {
        positionManually,
        $slots: slots
      } = this;
      let triggerVNode;
      let popoverInside = false;
      if (!positionManually) {
        if (slots.activator) {
          triggerVNode = getFirstSlotVNode(slots, "activator");
        } else {
          triggerVNode = getFirstSlotVNode(slots, "trigger");
        }
        if (triggerVNode) {
          triggerVNode = vue.cloneVNode(triggerVNode);
          triggerVNode = triggerVNode.type === vue.Text ? vue.h("span", [triggerVNode]) : triggerVNode;
          const handlers = {
            onClick: this.handleClick,
            onMouseenter: this.handleMouseEnter,
            onMouseleave: this.handleMouseLeave,
            onFocus: this.handleFocus,
            onBlur: this.handleBlur
          };
          if ((_a = triggerVNode.type) === null || _a === void 0 ? void 0 : _a.__popover__) {
            popoverInside = true;
            if (!triggerVNode.props) {
              triggerVNode.props = {
                internalSyncTargetWithParent: true,
                internalInheritedEventHandlers: []
              };
            }
            triggerVNode.props.internalSyncTargetWithParent = true;
            if (!triggerVNode.props.internalInheritedEventHandlers) {
              triggerVNode.props.internalInheritedEventHandlers = [handlers];
            } else {
              triggerVNode.props.internalInheritedEventHandlers = [handlers, ...triggerVNode.props.internalInheritedEventHandlers];
            }
          } else {
            const {
              internalInheritedEventHandlers
            } = this;
            const ascendantAndCurrentHandlers = [handlers, ...internalInheritedEventHandlers];
            const mergedHandlers = {
              onBlur: (e) => {
                ascendantAndCurrentHandlers.forEach((_handlers) => {
                  _handlers.onBlur(e);
                });
              },
              onFocus: (e) => {
                ascendantAndCurrentHandlers.forEach((_handlers) => {
                  _handlers.onFocus(e);
                });
              },
              onClick: (e) => {
                ascendantAndCurrentHandlers.forEach((_handlers) => {
                  _handlers.onClick(e);
                });
              },
              onMouseenter: (e) => {
                ascendantAndCurrentHandlers.forEach((_handlers) => {
                  _handlers.onMouseenter(e);
                });
              },
              onMouseleave: (e) => {
                ascendantAndCurrentHandlers.forEach((_handlers) => {
                  _handlers.onMouseleave(e);
                });
              }
            };
            appendEvents(triggerVNode, internalInheritedEventHandlers ? "nested" : positionManually ? "manual" : this.trigger, mergedHandlers);
          }
        }
      }
      return vue.h(VBinder, {
        ref: "binderInstRef",
        syncTarget: !popoverInside,
        syncTargetWithParent: this.internalSyncTargetWithParent
      }, {
        default: () => {
          void this.mergedShowConsideringDisabledProp;
          const mergedShow = this.getMergedShow();
          return [this.internalTrapFocus && mergedShow ? vue.withDirectives(vue.h("div", {
            style: {
              position: "fixed",
              inset: 0
            }
          }), [[zindexable$1, {
            enabled: mergedShow,
            zIndex: this.zIndex
          }]]) : null, positionManually ? null : vue.h(VTarget, null, {
            default: () => triggerVNode
          }), vue.h(NPopoverBody, keep(this.$props, bodyPropKeys, Object.assign(Object.assign({}, this.$attrs), {
            showArrow: this.mergedShowArrow,
            show: mergedShow
          })), {
            default: () => {
              var _a2, _b;
              return (_b = (_a2 = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a2);
            },
            header: () => {
              var _a2, _b;
              return (_b = (_a2 = this.$slots).header) === null || _b === void 0 ? void 0 : _b.call(_a2);
            },
            footer: () => {
              var _a2, _b;
              return (_b = (_a2 = this.$slots).footer) === null || _b === void 0 ? void 0 : _b.call(_a2);
            }
          })];
        }
      });
    }
  });
  const commonVariables$j = {
    closeIconSizeTiny: "12px",
    closeIconSizeSmall: "12px",
    closeIconSizeMedium: "14px",
    closeIconSizeLarge: "14px",
    closeSizeTiny: "16px",
    closeSizeSmall: "16px",
    closeSizeMedium: "18px",
    closeSizeLarge: "18px",
    padding: "0 7px",
    closeMargin: "0 0 0 4px"
  };
  function self$1d(vars) {
    const {
      textColor2,
      primaryColorHover,
      primaryColorPressed,
      primaryColor,
      infoColor,
      successColor,
      warningColor,
      errorColor,
      baseColor,
      borderColor,
      opacityDisabled,
      tagColor,
      closeIconColor,
      closeIconColorHover,
      closeIconColorPressed,
      borderRadiusSmall: borderRadius,
      fontSizeMini,
      fontSizeTiny,
      fontSizeSmall,
      fontSizeMedium,
      heightMini,
      heightTiny,
      heightSmall,
      heightMedium,
      closeColorHover,
      closeColorPressed,
      buttonColor2Hover,
      buttonColor2Pressed,
      fontWeightStrong
    } = vars;
    return Object.assign(Object.assign({}, commonVariables$j), {
      closeBorderRadius: borderRadius,
      heightTiny: heightMini,
      heightSmall: heightTiny,
      heightMedium: heightSmall,
      heightLarge: heightMedium,
      borderRadius,
      opacityDisabled,
      fontSizeTiny: fontSizeMini,
      fontSizeSmall: fontSizeTiny,
      fontSizeMedium: fontSizeSmall,
      fontSizeLarge: fontSizeMedium,
      fontWeightStrong,
      // checked
      textColorCheckable: textColor2,
      textColorHoverCheckable: textColor2,
      textColorPressedCheckable: textColor2,
      textColorChecked: baseColor,
      colorCheckable: "#0000",
      colorHoverCheckable: buttonColor2Hover,
      colorPressedCheckable: buttonColor2Pressed,
      colorChecked: primaryColor,
      colorCheckedHover: primaryColorHover,
      colorCheckedPressed: primaryColorPressed,
      // default
      border: `1px solid ${borderColor}`,
      textColor: textColor2,
      color: tagColor,
      colorBordered: "rgb(250, 250, 252)",
      closeIconColor,
      closeIconColorHover,
      closeIconColorPressed,
      closeColorHover,
      closeColorPressed,
      borderPrimary: `1px solid ${changeColor(primaryColor, {
        alpha: 0.3
      })}`,
      textColorPrimary: primaryColor,
      colorPrimary: changeColor(primaryColor, {
        alpha: 0.12
      }),
      colorBorderedPrimary: changeColor(primaryColor, {
        alpha: 0.1
      }),
      closeIconColorPrimary: primaryColor,
      closeIconColorHoverPrimary: primaryColor,
      closeIconColorPressedPrimary: primaryColor,
      closeColorHoverPrimary: changeColor(primaryColor, {
        alpha: 0.12
      }),
      closeColorPressedPrimary: changeColor(primaryColor, {
        alpha: 0.18
      }),
      borderInfo: `1px solid ${changeColor(infoColor, {
        alpha: 0.3
      })}`,
      textColorInfo: infoColor,
      colorInfo: changeColor(infoColor, {
        alpha: 0.12
      }),
      colorBorderedInfo: changeColor(infoColor, {
        alpha: 0.1
      }),
      closeIconColorInfo: infoColor,
      closeIconColorHoverInfo: infoColor,
      closeIconColorPressedInfo: infoColor,
      closeColorHoverInfo: changeColor(infoColor, {
        alpha: 0.12
      }),
      closeColorPressedInfo: changeColor(infoColor, {
        alpha: 0.18
      }),
      borderSuccess: `1px solid ${changeColor(successColor, {
        alpha: 0.3
      })}`,
      textColorSuccess: successColor,
      colorSuccess: changeColor(successColor, {
        alpha: 0.12
      }),
      colorBorderedSuccess: changeColor(successColor, {
        alpha: 0.1
      }),
      closeIconColorSuccess: successColor,
      closeIconColorHoverSuccess: successColor,
      closeIconColorPressedSuccess: successColor,
      closeColorHoverSuccess: changeColor(successColor, {
        alpha: 0.12
      }),
      closeColorPressedSuccess: changeColor(successColor, {
        alpha: 0.18
      }),
      borderWarning: `1px solid ${changeColor(warningColor, {
        alpha: 0.35
      })}`,
      textColorWarning: warningColor,
      colorWarning: changeColor(warningColor, {
        alpha: 0.15
      }),
      colorBorderedWarning: changeColor(warningColor, {
        alpha: 0.12
      }),
      closeIconColorWarning: warningColor,
      closeIconColorHoverWarning: warningColor,
      closeIconColorPressedWarning: warningColor,
      closeColorHoverWarning: changeColor(warningColor, {
        alpha: 0.12
      }),
      closeColorPressedWarning: changeColor(warningColor, {
        alpha: 0.18
      }),
      borderError: `1px solid ${changeColor(errorColor, {
        alpha: 0.23
      })}`,
      textColorError: errorColor,
      colorError: changeColor(errorColor, {
        alpha: 0.1
      }),
      colorBorderedError: changeColor(errorColor, {
        alpha: 0.08
      }),
      closeIconColorError: errorColor,
      closeIconColorHoverError: errorColor,
      closeIconColorPressedError: errorColor,
      closeColorHoverError: changeColor(errorColor, {
        alpha: 0.12
      }),
      closeColorPressedError: changeColor(errorColor, {
        alpha: 0.18
      })
    });
  }
  const tagLight = {
    name: "Tag",
    common: commonLight,
    self: self$1d
  };
  const tagLight$1 = tagLight;
  const commonProps = {
    color: Object,
    type: {
      type: String,
      default: "default"
    },
    round: Boolean,
    size: {
      type: String,
      default: "medium"
    },
    closable: Boolean,
    disabled: {
      type: Boolean,
      default: void 0
    }
  };
  const style$1t = cB("tag", `
 --n-close-margin: var(--n-close-margin-top) var(--n-close-margin-right) var(--n-close-margin-bottom) var(--n-close-margin-left);
 white-space: nowrap;
 position: relative;
 box-sizing: border-box;
 cursor: default;
 display: inline-flex;
 align-items: center;
 flex-wrap: nowrap;
 padding: var(--n-padding);
 border-radius: var(--n-border-radius);
 color: var(--n-text-color);
 background-color: var(--n-color);
 transition: 
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 line-height: 1;
 height: var(--n-height);
 font-size: var(--n-font-size);
`, [cM("strong", `
 font-weight: var(--n-font-weight-strong);
 `), cE("border", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 border: var(--n-border);
 transition: border-color .3s var(--n-bezier);
 `), cE("icon", `
 display: flex;
 margin: 0 4px 0 0;
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 font-size: var(--n-avatar-size-override);
 `), cE("avatar", `
 display: flex;
 margin: 0 6px 0 0;
 `), cE("close", `
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), cM("round", `
 padding: 0 calc(var(--n-height) / 3);
 border-radius: calc(var(--n-height) / 2);
 `, [cE("icon", `
 margin: 0 4px 0 calc((var(--n-height) - 8px) / -2);
 `), cE("avatar", `
 margin: 0 6px 0 calc((var(--n-height) - 8px) / -2);
 `), cM("closable", `
 padding: 0 calc(var(--n-height) / 4) 0 calc(var(--n-height) / 3);
 `)]), cM("icon, avatar", [cM("round", `
 padding: 0 calc(var(--n-height) / 3) 0 calc(var(--n-height) / 2);
 `)]), cM("disabled", `
 cursor: not-allowed !important;
 opacity: var(--n-opacity-disabled);
 `), cM("checkable", `
 cursor: pointer;
 box-shadow: none;
 color: var(--n-text-color-checkable);
 background-color: var(--n-color-checkable);
 `, [cNotM("disabled", [c$1("&:hover", "background-color: var(--n-color-hover-checkable);", [cNotM("checked", "color: var(--n-text-color-hover-checkable);")]), c$1("&:active", "background-color: var(--n-color-pressed-checkable);", [cNotM("checked", "color: var(--n-text-color-pressed-checkable);")])]), cM("checked", `
 color: var(--n-text-color-checked);
 background-color: var(--n-color-checked);
 `, [cNotM("disabled", [c$1("&:hover", "background-color: var(--n-color-checked-hover);"), c$1("&:active", "background-color: var(--n-color-checked-pressed);")])])])]);
  const tagProps = Object.assign(Object.assign(Object.assign({}, useTheme.props), commonProps), {
    bordered: {
      type: Boolean,
      default: void 0
    },
    checked: Boolean,
    checkable: Boolean,
    strong: Boolean,
    triggerClickOnClose: Boolean,
    onClose: [Array, Function],
    onMouseenter: Function,
    onMouseleave: Function,
    "onUpdate:checked": Function,
    onUpdateChecked: Function,
    // private
    internalCloseFocusable: {
      type: Boolean,
      default: true
    },
    internalCloseIsButtonTag: {
      type: Boolean,
      default: true
    },
    // deprecated
    onCheckedChange: Function
  });
  const tagInjectionKey = createInjectionKey("n-tag");
  const NTag = vue.defineComponent({
    name: "Tag",
    props: tagProps,
    setup(props) {
      {
        vue.watchEffect(() => {
          if (props.onCheckedChange !== void 0) {
            warnOnce("tag", "`on-checked-change` is deprecated, please use `on-update:checked` instead");
          }
        });
      }
      const contentRef = vue.ref(null);
      const {
        mergedBorderedRef,
        mergedClsPrefixRef,
        inlineThemeDisabled,
        mergedRtlRef
      } = useConfig(props);
      const themeRef = useTheme("Tag", "-tag", style$1t, tagLight$1, props, mergedClsPrefixRef);
      vue.provide(tagInjectionKey, {
        roundRef: vue.toRef(props, "round")
      });
      function handleClick2() {
        if (!props.disabled) {
          if (props.checkable) {
            const {
              checked,
              onCheckedChange,
              onUpdateChecked,
              "onUpdate:checked": _onUpdateChecked
            } = props;
            if (onUpdateChecked)
              onUpdateChecked(!checked);
            if (_onUpdateChecked)
              _onUpdateChecked(!checked);
            if (onCheckedChange)
              onCheckedChange(!checked);
          }
        }
      }
      function handleCloseClick(e) {
        if (!props.triggerClickOnClose) {
          e.stopPropagation();
        }
        if (!props.disabled) {
          const {
            onClose
          } = props;
          if (onClose)
            call(onClose, e);
        }
      }
      const tagPublicMethods = {
        setTextContent(textContent) {
          const {
            value
          } = contentRef;
          if (value)
            value.textContent = textContent;
        }
      };
      const rtlEnabledRef = useRtl("Tag", mergedRtlRef, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          type,
          size: size2,
          color: {
            color,
            textColor
          } = {}
        } = props;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            padding,
            closeMargin,
            borderRadius,
            opacityDisabled,
            textColorCheckable,
            textColorHoverCheckable,
            textColorPressedCheckable,
            textColorChecked,
            colorCheckable,
            colorHoverCheckable,
            colorPressedCheckable,
            colorChecked,
            colorCheckedHover,
            colorCheckedPressed,
            closeBorderRadius,
            fontWeightStrong,
            [createKey("colorBordered", type)]: colorBordered,
            [createKey("closeSize", size2)]: closeSize,
            [createKey("closeIconSize", size2)]: closeIconSize,
            [createKey("fontSize", size2)]: fontSize2,
            [createKey("height", size2)]: height,
            [createKey("color", type)]: typedColor,
            [createKey("textColor", type)]: typeTextColor,
            [createKey("border", type)]: border,
            [createKey("closeIconColor", type)]: closeIconColor,
            [createKey("closeIconColorHover", type)]: closeIconColorHover,
            [createKey("closeIconColorPressed", type)]: closeIconColorPressed,
            [createKey("closeColorHover", type)]: closeColorHover,
            [createKey("closeColorPressed", type)]: closeColorPressed
          }
        } = themeRef.value;
        const closeMarginDiscrete = getMargin(closeMargin);
        return {
          "--n-font-weight-strong": fontWeightStrong,
          "--n-avatar-size-override": `calc(${height} - 8px)`,
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-border-radius": borderRadius,
          "--n-border": border,
          "--n-close-icon-size": closeIconSize,
          "--n-close-color-pressed": closeColorPressed,
          "--n-close-color-hover": closeColorHover,
          "--n-close-border-radius": closeBorderRadius,
          "--n-close-icon-color": closeIconColor,
          "--n-close-icon-color-hover": closeIconColorHover,
          "--n-close-icon-color-pressed": closeIconColorPressed,
          "--n-close-icon-color-disabled": closeIconColor,
          "--n-close-margin-top": closeMarginDiscrete.top,
          "--n-close-margin-right": closeMarginDiscrete.right,
          "--n-close-margin-bottom": closeMarginDiscrete.bottom,
          "--n-close-margin-left": closeMarginDiscrete.left,
          "--n-close-size": closeSize,
          "--n-color": color || (mergedBorderedRef.value ? colorBordered : typedColor),
          "--n-color-checkable": colorCheckable,
          "--n-color-checked": colorChecked,
          "--n-color-checked-hover": colorCheckedHover,
          "--n-color-checked-pressed": colorCheckedPressed,
          "--n-color-hover-checkable": colorHoverCheckable,
          "--n-color-pressed-checkable": colorPressedCheckable,
          "--n-font-size": fontSize2,
          "--n-height": height,
          "--n-opacity-disabled": opacityDisabled,
          "--n-padding": padding,
          "--n-text-color": textColor || typeTextColor,
          "--n-text-color-checkable": textColorCheckable,
          "--n-text-color-checked": textColorChecked,
          "--n-text-color-hover-checkable": textColorHoverCheckable,
          "--n-text-color-pressed-checkable": textColorPressedCheckable
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("tag", vue.computed(() => {
        let hash = "";
        const {
          type,
          size: size2,
          color: {
            color,
            textColor
          } = {}
        } = props;
        hash += type[0];
        hash += size2[0];
        if (color) {
          hash += `a${color2Class(color)}`;
        }
        if (textColor) {
          hash += `b${color2Class(textColor)}`;
        }
        if (mergedBorderedRef.value) {
          hash += "c";
        }
        return hash;
      }), cssVarsRef, props) : void 0;
      return Object.assign(Object.assign({}, tagPublicMethods), {
        rtlEnabled: rtlEnabledRef,
        mergedClsPrefix: mergedClsPrefixRef,
        contentRef,
        mergedBordered: mergedBorderedRef,
        handleClick: handleClick2,
        handleCloseClick,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      });
    },
    render() {
      var _a, _b;
      const {
        mergedClsPrefix,
        rtlEnabled,
        closable,
        color: {
          borderColor
        } = {},
        round: round2,
        onRender,
        $slots
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      const avatarNode = resolveWrappedSlot($slots.avatar, (children) => children && vue.h("div", {
        class: `${mergedClsPrefix}-tag__avatar`
      }, children));
      const iconNode = resolveWrappedSlot($slots.icon, (children) => children && vue.h("div", {
        class: `${mergedClsPrefix}-tag__icon`
      }, children));
      return vue.h("div", {
        class: [`${mergedClsPrefix}-tag`, this.themeClass, {
          [`${mergedClsPrefix}-tag--rtl`]: rtlEnabled,
          [`${mergedClsPrefix}-tag--strong`]: this.strong,
          [`${mergedClsPrefix}-tag--disabled`]: this.disabled,
          [`${mergedClsPrefix}-tag--checkable`]: this.checkable,
          [`${mergedClsPrefix}-tag--checked`]: this.checkable && this.checked,
          [`${mergedClsPrefix}-tag--round`]: round2,
          [`${mergedClsPrefix}-tag--avatar`]: avatarNode,
          [`${mergedClsPrefix}-tag--icon`]: iconNode,
          [`${mergedClsPrefix}-tag--closable`]: closable
        }],
        style: this.cssVars,
        onClick: this.handleClick,
        onMouseenter: this.onMouseenter,
        onMouseleave: this.onMouseleave
      }, iconNode || avatarNode, vue.h("span", {
        class: `${mergedClsPrefix}-tag__content`,
        ref: "contentRef"
      }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a)), !this.checkable && closable ? vue.h(NBaseClose, {
        clsPrefix: mergedClsPrefix,
        class: `${mergedClsPrefix}-tag__close`,
        disabled: this.disabled,
        onClick: this.handleCloseClick,
        focusable: this.internalCloseFocusable,
        round: round2,
        isButtonTag: this.internalCloseIsButtonTag,
        absolute: true
      }) : null, !this.checkable && this.mergedBordered ? vue.h("div", {
        class: `${mergedClsPrefix}-tag__border`,
        style: {
          borderColor
        }
      }) : null);
    }
  });
  const style$1s = cB("base-clear", `
 flex-shrink: 0;
 height: 1em;
 width: 1em;
 position: relative;
`, [c$1(">", [cE("clear", `
 font-size: var(--n-clear-size);
 height: 1em;
 width: 1em;
 cursor: pointer;
 color: var(--n-clear-color);
 transition: color .3s var(--n-bezier);
 display: flex;
 `, [c$1("&:hover", `
 color: var(--n-clear-color-hover)!important;
 `), c$1("&:active", `
 color: var(--n-clear-color-pressed)!important;
 `)]), cE("placeholder", `
 display: flex;
 `), cE("clear, placeholder", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [iconSwitchTransition({
    originalTransform: "translateX(-50%) translateY(-50%)",
    left: "50%",
    top: "50%"
  })])])]);
  const NBaseClear = vue.defineComponent({
    name: "BaseClear",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      show: Boolean,
      onClear: Function
    },
    setup(props) {
      useStyle("-base-clear", style$1s, vue.toRef(props, "clsPrefix"));
      return {
        handleMouseDown(e) {
          e.preventDefault();
        }
      };
    },
    render() {
      const {
        clsPrefix
      } = this;
      return vue.h("div", {
        class: `${clsPrefix}-base-clear`
      }, vue.h(NIconSwitchTransition, null, {
        default: () => {
          var _a, _b;
          return this.show ? vue.h("div", {
            key: "dismiss",
            class: `${clsPrefix}-base-clear__clear`,
            onClick: this.onClear,
            onMousedown: this.handleMouseDown,
            "data-clear": true
          }, resolveSlot(this.$slots.icon, () => [vue.h(NBaseIcon, {
            clsPrefix
          }, {
            default: () => vue.h(ClearIcon, null)
          })])) : vue.h("div", {
            key: "icon",
            class: `${clsPrefix}-base-clear__placeholder`
          }, (_b = (_a = this.$slots).placeholder) === null || _b === void 0 ? void 0 : _b.call(_a));
        }
      }));
    }
  });
  const NBaseSuffix = vue.defineComponent({
    name: "InternalSelectionSuffix",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      showArrow: {
        type: Boolean,
        default: void 0
      },
      showClear: {
        type: Boolean,
        default: void 0
      },
      loading: {
        type: Boolean,
        default: false
      },
      onClear: Function
    },
    setup(props, {
      slots
    }) {
      return () => {
        const {
          clsPrefix
        } = props;
        return vue.h(NBaseLoading, {
          clsPrefix,
          class: `${clsPrefix}-base-suffix`,
          strokeWidth: 24,
          scale: 0.85,
          show: props.loading
        }, {
          default: () => props.showArrow ? vue.h(NBaseClear, {
            clsPrefix,
            show: props.showClear,
            onClear: props.onClear
          }, {
            placeholder: () => vue.h(NBaseIcon, {
              clsPrefix,
              class: `${clsPrefix}-base-suffix__arrow`
            }, {
              default: () => resolveSlot(slots.default, () => [vue.h(ChevronDownIcon, null)])
            })
          }) : null
        });
      };
    }
  });
  const commonVars$c = {
    paddingSingle: "0 26px 0 12px",
    paddingMultiple: "3px 26px 0 12px",
    clearSize: "16px",
    arrowSize: "16px"
  };
  function self$1c(vars) {
    const {
      borderRadius,
      textColor2,
      textColorDisabled,
      inputColor,
      inputColorDisabled,
      primaryColor,
      primaryColorHover,
      warningColor,
      warningColorHover,
      errorColor,
      errorColorHover,
      borderColor,
      iconColor,
      iconColorDisabled,
      clearColor,
      clearColorHover,
      clearColorPressed,
      placeholderColor,
      placeholderColorDisabled,
      fontSizeTiny,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      heightTiny,
      heightSmall,
      heightMedium,
      heightLarge
    } = vars;
    return Object.assign(Object.assign({}, commonVars$c), {
      fontSizeTiny,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      heightTiny,
      heightSmall,
      heightMedium,
      heightLarge,
      borderRadius,
      // default
      textColor: textColor2,
      textColorDisabled,
      placeholderColor,
      placeholderColorDisabled,
      color: inputColor,
      colorDisabled: inputColorDisabled,
      colorActive: inputColor,
      border: `1px solid ${borderColor}`,
      borderHover: `1px solid ${primaryColorHover}`,
      borderActive: `1px solid ${primaryColor}`,
      borderFocus: `1px solid ${primaryColorHover}`,
      boxShadowHover: "none",
      boxShadowActive: `0 0 0 2px ${changeColor(primaryColor, {
        alpha: 0.2
      })}`,
      boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, {
        alpha: 0.2
      })}`,
      caretColor: primaryColor,
      arrowColor: iconColor,
      arrowColorDisabled: iconColorDisabled,
      loadingColor: primaryColor,
      // warning
      borderWarning: `1px solid ${warningColor}`,
      borderHoverWarning: `1px solid ${warningColorHover}`,
      borderActiveWarning: `1px solid ${warningColor}`,
      borderFocusWarning: `1px solid ${warningColorHover}`,
      boxShadowHoverWarning: "none",
      boxShadowActiveWarning: `0 0 0 2px ${changeColor(warningColor, {
        alpha: 0.2
      })}`,
      boxShadowFocusWarning: `0 0 0 2px ${changeColor(warningColor, {
        alpha: 0.2
      })}`,
      colorActiveWarning: inputColor,
      caretColorWarning: warningColor,
      // error
      borderError: `1px solid ${errorColor}`,
      borderHoverError: `1px solid ${errorColorHover}`,
      borderActiveError: `1px solid ${errorColor}`,
      borderFocusError: `1px solid ${errorColorHover}`,
      boxShadowHoverError: "none",
      boxShadowActiveError: `0 0 0 2px ${changeColor(errorColor, {
        alpha: 0.2
      })}`,
      boxShadowFocusError: `0 0 0 2px ${changeColor(errorColor, {
        alpha: 0.2
      })}`,
      colorActiveError: inputColor,
      caretColorError: errorColor,
      clearColor,
      clearColorHover,
      clearColorPressed
    });
  }
  const internalSelectionLight = createTheme({
    name: "InternalSelection",
    common: commonLight,
    peers: {
      Popover: popoverLight$1
    },
    self: self$1c
  });
  const internalSelectionLight$1 = internalSelectionLight;
  const style$1r = c$1([cB("base-selection", `
 --n-padding-single: var(--n-padding-single-top) var(--n-padding-single-right) var(--n-padding-single-bottom) var(--n-padding-single-left);
 --n-padding-multiple: var(--n-padding-multiple-top) var(--n-padding-multiple-right) var(--n-padding-multiple-bottom) var(--n-padding-multiple-left);
 position: relative;
 z-index: auto;
 box-shadow: none;
 width: 100%;
 max-width: 100%;
 display: inline-block;
 vertical-align: bottom;
 border-radius: var(--n-border-radius);
 min-height: var(--n-height);
 line-height: 1.5;
 font-size: var(--n-font-size);
 `, [cB("base-loading", `
 color: var(--n-loading-color);
 `), cB("base-selection-tags", "min-height: var(--n-height);"), cE("border, state-border", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border: var(--n-border);
 border-radius: inherit;
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `), cE("state-border", `
 z-index: 1;
 border-color: #0000;
 `), cB("base-suffix", `
 cursor: pointer;
 position: absolute;
 top: 50%;
 transform: translateY(-50%);
 right: 10px;
 `, [cE("arrow", `
 font-size: var(--n-arrow-size);
 color: var(--n-arrow-color);
 transition: color .3s var(--n-bezier);
 `)]), cB("base-selection-overlay", `
 display: flex;
 align-items: center;
 white-space: nowrap;
 pointer-events: none;
 position: absolute;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 padding: var(--n-padding-single);
 transition: color .3s var(--n-bezier);
 `, [cE("wrapper", `
 flex-basis: 0;
 flex-grow: 1;
 overflow: hidden;
 text-overflow: ellipsis;
 `)]), cB("base-selection-placeholder", `
 color: var(--n-placeholder-color);
 `, [cE("inner", `
 max-width: 100%;
 overflow: hidden;
 `)]), cB("base-selection-tags", `
 cursor: pointer;
 outline: none;
 box-sizing: border-box;
 position: relative;
 z-index: auto;
 display: flex;
 padding: var(--n-padding-multiple);
 flex-wrap: wrap;
 align-items: center;
 width: 100%;
 vertical-align: bottom;
 background-color: var(--n-color);
 border-radius: inherit;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), cB("base-selection-label", `
 height: var(--n-height);
 display: inline-flex;
 width: 100%;
 vertical-align: bottom;
 cursor: pointer;
 outline: none;
 z-index: auto;
 box-sizing: border-box;
 position: relative;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-radius: inherit;
 background-color: var(--n-color);
 align-items: center;
 `, [cB("base-selection-input", `
 font-size: inherit;
 line-height: inherit;
 outline: none;
 cursor: pointer;
 box-sizing: border-box;
 border:none;
 width: 100%;
 padding: var(--n-padding-single);
 background-color: #0000;
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 caret-color: var(--n-caret-color);
 `, [cE("content", `
 text-overflow: ellipsis;
 overflow: hidden;
 white-space: nowrap; 
 `)]), cE("render-label", `
 color: var(--n-text-color);
 `)]), cNotM("disabled", [c$1("&:hover", [cE("state-border", `
 box-shadow: var(--n-box-shadow-hover);
 border: var(--n-border-hover);
 `)]), cM("focus", [cE("state-border", `
 box-shadow: var(--n-box-shadow-focus);
 border: var(--n-border-focus);
 `)]), cM("active", [cE("state-border", `
 box-shadow: var(--n-box-shadow-active);
 border: var(--n-border-active);
 `), cB("base-selection-label", "background-color: var(--n-color-active);"), cB("base-selection-tags", "background-color: var(--n-color-active);")])]), cM("disabled", "cursor: not-allowed;", [cE("arrow", `
 color: var(--n-arrow-color-disabled);
 `), cB("base-selection-label", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [cB("base-selection-input", `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 `), cE("render-label", `
 color: var(--n-text-color-disabled);
 `)]), cB("base-selection-tags", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `), cB("base-selection-placeholder", `
 cursor: not-allowed;
 color: var(--n-placeholder-color-disabled);
 `)]), cB("base-selection-input-tag", `
 height: calc(var(--n-height) - 6px);
 line-height: calc(var(--n-height) - 6px);
 outline: none;
 display: none;
 position: relative;
 margin-bottom: 3px;
 max-width: 100%;
 vertical-align: bottom;
 `, [cE("input", `
 font-size: inherit;
 font-family: inherit;
 min-width: 1px;
 padding: 0;
 background-color: #0000;
 outline: none;
 border: none;
 max-width: 100%;
 overflow: hidden;
 width: 1em;
 line-height: inherit;
 cursor: pointer;
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 `), cE("mirror", `
 position: absolute;
 left: 0;
 top: 0;
 white-space: pre;
 visibility: hidden;
 user-select: none;
 -webkit-user-select: none;
 opacity: 0;
 `)]), ["warning", "error"].map((status) => cM(`${status}-status`, [cE("state-border", `border: var(--n-border-${status});`), cNotM("disabled", [c$1("&:hover", [cE("state-border", `
 box-shadow: var(--n-box-shadow-hover-${status});
 border: var(--n-border-hover-${status});
 `)]), cM("active", [cE("state-border", `
 box-shadow: var(--n-box-shadow-active-${status});
 border: var(--n-border-active-${status});
 `), cB("base-selection-label", `background-color: var(--n-color-active-${status});`), cB("base-selection-tags", `background-color: var(--n-color-active-${status});`)]), cM("focus", [cE("state-border", `
 box-shadow: var(--n-box-shadow-focus-${status});
 border: var(--n-border-focus-${status});
 `)])])]))]), cB("base-selection-popover", `
 margin-bottom: -3px;
 display: flex;
 flex-wrap: wrap;
 margin-right: -8px;
 `), cB("base-selection-tag-wrapper", `
 max-width: 100%;
 display: inline-flex;
 padding: 0 7px 3px 0;
 `, [c$1("&:last-child", "padding-right: 0;"), cB("tag", `
 font-size: 14px;
 max-width: 100%;
 `, [cE("content", `
 line-height: 1.25;
 text-overflow: ellipsis;
 overflow: hidden;
 `)])])]);
  const NInternalSelection = vue.defineComponent({
    name: "InternalSelection",
    props: Object.assign(Object.assign({}, useTheme.props), {
      clsPrefix: {
        type: String,
        required: true
      },
      bordered: {
        type: Boolean,
        default: void 0
      },
      active: Boolean,
      pattern: {
        type: String,
        default: ""
      },
      placeholder: String,
      selectedOption: {
        type: Object,
        default: null
      },
      selectedOptions: {
        type: Array,
        default: null
      },
      labelField: {
        type: String,
        default: "label"
      },
      valueField: {
        type: String,
        default: "value"
      },
      multiple: Boolean,
      filterable: Boolean,
      clearable: Boolean,
      disabled: Boolean,
      size: {
        type: String,
        default: "medium"
      },
      loading: Boolean,
      autofocus: Boolean,
      showArrow: {
        type: Boolean,
        default: true
      },
      inputProps: Object,
      focused: Boolean,
      renderTag: Function,
      onKeydown: Function,
      onClick: Function,
      onBlur: Function,
      onFocus: Function,
      onDeleteOption: Function,
      maxTagCount: [String, Number],
      ellipsisTagPopoverProps: Object,
      onClear: Function,
      onPatternInput: Function,
      onPatternFocus: Function,
      onPatternBlur: Function,
      renderLabel: Function,
      status: String,
      inlineThemeDisabled: Boolean,
      ignoreComposition: {
        type: Boolean,
        default: true
      },
      onResize: Function
    }),
    setup(props) {
      const {
        mergedClsPrefixRef,
        mergedRtlRef
      } = useConfig(props);
      const rtlEnabledRef = useRtl("InternalSelection", mergedRtlRef, mergedClsPrefixRef);
      const patternInputMirrorRef = vue.ref(null);
      const patternInputRef = vue.ref(null);
      const selfRef = vue.ref(null);
      const multipleElRef = vue.ref(null);
      const singleElRef = vue.ref(null);
      const patternInputWrapperRef = vue.ref(null);
      const counterRef = vue.ref(null);
      const counterWrapperRef = vue.ref(null);
      const overflowRef = vue.ref(null);
      const inputTagElRef = vue.ref(null);
      const showTagsPopoverRef = vue.ref(false);
      const patternInputFocusedRef = vue.ref(false);
      const hoverRef = vue.ref(false);
      const themeRef = useTheme("InternalSelection", "-internal-selection", style$1r, internalSelectionLight$1, props, vue.toRef(props, "clsPrefix"));
      const mergedClearableRef = vue.computed(() => {
        return props.clearable && !props.disabled && (hoverRef.value || props.active);
      });
      const filterablePlaceholderRef = vue.computed(() => {
        return props.selectedOption ? props.renderTag ? props.renderTag({
          option: props.selectedOption,
          handleClose: () => {
          }
        }) : props.renderLabel ? props.renderLabel(props.selectedOption, true) : render$1(props.selectedOption[props.labelField], props.selectedOption, true) : props.placeholder;
      });
      const labelRef = vue.computed(() => {
        const option = props.selectedOption;
        if (!option)
          return void 0;
        return option[props.labelField];
      });
      const selectedRef = vue.computed(() => {
        if (props.multiple) {
          return !!(Array.isArray(props.selectedOptions) && props.selectedOptions.length);
        } else {
          return props.selectedOption !== null;
        }
      });
      function syncMirrorWidth() {
        var _a;
        const {
          value: patternInputMirrorEl
        } = patternInputMirrorRef;
        if (patternInputMirrorEl) {
          const {
            value: patternInputEl
          } = patternInputRef;
          if (patternInputEl) {
            patternInputEl.style.width = `${patternInputMirrorEl.offsetWidth}px`;
            if (props.maxTagCount !== "responsive") {
              (_a = overflowRef.value) === null || _a === void 0 ? void 0 : _a.sync({
                showAllItemsBeforeCalculate: false
              });
            }
          }
        }
      }
      function hideInputTag() {
        const {
          value: inputTagEl
        } = inputTagElRef;
        if (inputTagEl)
          inputTagEl.style.display = "none";
      }
      function showInputTag() {
        const {
          value: inputTagEl
        } = inputTagElRef;
        if (inputTagEl)
          inputTagEl.style.display = "inline-block";
      }
      vue.watch(vue.toRef(props, "active"), (value) => {
        if (!value)
          hideInputTag();
      });
      vue.watch(vue.toRef(props, "pattern"), () => {
        if (props.multiple) {
          void vue.nextTick(syncMirrorWidth);
        }
      });
      function doFocus(e) {
        const {
          onFocus
        } = props;
        if (onFocus)
          onFocus(e);
      }
      function doBlur(e) {
        const {
          onBlur
        } = props;
        if (onBlur)
          onBlur(e);
      }
      function doDeleteOption(value) {
        const {
          onDeleteOption
        } = props;
        if (onDeleteOption)
          onDeleteOption(value);
      }
      function doClear(e) {
        const {
          onClear
        } = props;
        if (onClear)
          onClear(e);
      }
      function doPatternInput(value) {
        const {
          onPatternInput
        } = props;
        if (onPatternInput)
          onPatternInput(value);
      }
      function handleFocusin(e) {
        var _a;
        if (!e.relatedTarget || !((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget))) {
          doFocus(e);
        }
      }
      function handleFocusout(e) {
        var _a;
        if ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget))
          return;
        doBlur(e);
      }
      function handleClear(e) {
        doClear(e);
      }
      function handleMouseEnter() {
        hoverRef.value = true;
      }
      function handleMouseLeave() {
        hoverRef.value = false;
      }
      function handleMouseDown(e) {
        if (!props.active || !props.filterable)
          return;
        if (e.target === patternInputRef.value)
          return;
        e.preventDefault();
      }
      function handleDeleteOption(option) {
        doDeleteOption(option);
      }
      const isComposingRef2 = vue.ref(false);
      function handlePatternKeyDown(e) {
        if (e.key === "Backspace" && !isComposingRef2.value) {
          if (!props.pattern.length) {
            const {
              selectedOptions
            } = props;
            if (selectedOptions === null || selectedOptions === void 0 ? void 0 : selectedOptions.length) {
              handleDeleteOption(selectedOptions[selectedOptions.length - 1]);
            }
          }
        }
      }
      let cachedInputEvent = null;
      function handlePatternInputInput(e) {
        const {
          value: patternInputMirrorEl
        } = patternInputMirrorRef;
        if (patternInputMirrorEl) {
          const inputText = e.target.value;
          patternInputMirrorEl.textContent = inputText;
          syncMirrorWidth();
        }
        if (props.ignoreComposition) {
          if (!isComposingRef2.value) {
            doPatternInput(e);
          } else {
            cachedInputEvent = e;
          }
        } else {
          doPatternInput(e);
        }
      }
      function handleCompositionStart() {
        isComposingRef2.value = true;
      }
      function handleCompositionEnd() {
        isComposingRef2.value = false;
        if (props.ignoreComposition) {
          doPatternInput(cachedInputEvent);
        }
        cachedInputEvent = null;
      }
      function handlePatternInputFocus(e) {
        var _a;
        patternInputFocusedRef.value = true;
        (_a = props.onPatternFocus) === null || _a === void 0 ? void 0 : _a.call(props, e);
      }
      function handlePatternInputBlur(e) {
        var _a;
        patternInputFocusedRef.value = false;
        (_a = props.onPatternBlur) === null || _a === void 0 ? void 0 : _a.call(props, e);
      }
      function blur() {
        var _a, _b;
        if (props.filterable) {
          patternInputFocusedRef.value = false;
          (_a = patternInputWrapperRef.value) === null || _a === void 0 ? void 0 : _a.blur();
          (_b = patternInputRef.value) === null || _b === void 0 ? void 0 : _b.blur();
        } else if (props.multiple) {
          const {
            value: multipleEl
          } = multipleElRef;
          multipleEl === null || multipleEl === void 0 ? void 0 : multipleEl.blur();
        } else {
          const {
            value: singleEl
          } = singleElRef;
          singleEl === null || singleEl === void 0 ? void 0 : singleEl.blur();
        }
      }
      function focus() {
        var _a, _b, _c;
        if (props.filterable) {
          patternInputFocusedRef.value = false;
          (_a = patternInputWrapperRef.value) === null || _a === void 0 ? void 0 : _a.focus();
        } else if (props.multiple) {
          (_b = multipleElRef.value) === null || _b === void 0 ? void 0 : _b.focus();
        } else {
          (_c = singleElRef.value) === null || _c === void 0 ? void 0 : _c.focus();
        }
      }
      function focusInput() {
        const {
          value: patternInputEl
        } = patternInputRef;
        if (patternInputEl) {
          showInputTag();
          patternInputEl.focus();
        }
      }
      function blurInput() {
        const {
          value: patternInputEl
        } = patternInputRef;
        if (patternInputEl) {
          patternInputEl.blur();
        }
      }
      function updateCounter(count) {
        const {
          value
        } = counterRef;
        if (value) {
          value.setTextContent(`+${count}`);
        }
      }
      function getCounter() {
        const {
          value
        } = counterWrapperRef;
        return value;
      }
      function getTail() {
        return patternInputRef.value;
      }
      let enterTimerId = null;
      function clearEnterTimer() {
        if (enterTimerId !== null)
          window.clearTimeout(enterTimerId);
      }
      function handleMouseEnterCounter() {
        if (props.active)
          return;
        clearEnterTimer();
        enterTimerId = window.setTimeout(() => {
          if (selectedRef.value) {
            showTagsPopoverRef.value = true;
          }
        }, 100);
      }
      function handleMouseLeaveCounter() {
        clearEnterTimer();
      }
      function onPopoverUpdateShow(show) {
        if (!show) {
          clearEnterTimer();
          showTagsPopoverRef.value = false;
        }
      }
      vue.watch(selectedRef, (value) => {
        if (!value) {
          showTagsPopoverRef.value = false;
        }
      });
      vue.onMounted(() => {
        vue.watchEffect(() => {
          const patternInputWrapperEl = patternInputWrapperRef.value;
          if (!patternInputWrapperEl)
            return;
          if (props.disabled) {
            patternInputWrapperEl.removeAttribute("tabindex");
          } else {
            patternInputWrapperEl.tabIndex = patternInputFocusedRef.value ? -1 : 0;
          }
        });
      });
      useOnResize(selfRef, props.onResize);
      const {
        inlineThemeDisabled
      } = props;
      const cssVarsRef = vue.computed(() => {
        const {
          size: size2
        } = props;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            borderRadius,
            color,
            placeholderColor,
            textColor,
            paddingSingle,
            paddingMultiple,
            caretColor,
            colorDisabled,
            textColorDisabled,
            placeholderColorDisabled,
            colorActive,
            boxShadowFocus,
            boxShadowActive,
            boxShadowHover,
            border,
            borderFocus,
            borderHover,
            borderActive,
            arrowColor,
            arrowColorDisabled,
            loadingColor,
            // form warning
            colorActiveWarning,
            boxShadowFocusWarning,
            boxShadowActiveWarning,
            boxShadowHoverWarning,
            borderWarning,
            borderFocusWarning,
            borderHoverWarning,
            borderActiveWarning,
            // form error
            colorActiveError,
            boxShadowFocusError,
            boxShadowActiveError,
            boxShadowHoverError,
            borderError,
            borderFocusError,
            borderHoverError,
            borderActiveError,
            // clear
            clearColor,
            clearColorHover,
            clearColorPressed,
            clearSize,
            // arrow
            arrowSize: arrowSize2,
            [createKey("height", size2)]: height,
            [createKey("fontSize", size2)]: fontSize2
          }
        } = themeRef.value;
        const paddingSingleDiscrete = getMargin(paddingSingle);
        const paddingMultipleDiscrete = getMargin(paddingMultiple);
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-border": border,
          "--n-border-active": borderActive,
          "--n-border-focus": borderFocus,
          "--n-border-hover": borderHover,
          "--n-border-radius": borderRadius,
          "--n-box-shadow-active": boxShadowActive,
          "--n-box-shadow-focus": boxShadowFocus,
          "--n-box-shadow-hover": boxShadowHover,
          "--n-caret-color": caretColor,
          "--n-color": color,
          "--n-color-active": colorActive,
          "--n-color-disabled": colorDisabled,
          "--n-font-size": fontSize2,
          "--n-height": height,
          "--n-padding-single-top": paddingSingleDiscrete.top,
          "--n-padding-multiple-top": paddingMultipleDiscrete.top,
          "--n-padding-single-right": paddingSingleDiscrete.right,
          "--n-padding-multiple-right": paddingMultipleDiscrete.right,
          "--n-padding-single-left": paddingSingleDiscrete.left,
          "--n-padding-multiple-left": paddingMultipleDiscrete.left,
          "--n-padding-single-bottom": paddingSingleDiscrete.bottom,
          "--n-padding-multiple-bottom": paddingMultipleDiscrete.bottom,
          "--n-placeholder-color": placeholderColor,
          "--n-placeholder-color-disabled": placeholderColorDisabled,
          "--n-text-color": textColor,
          "--n-text-color-disabled": textColorDisabled,
          "--n-arrow-color": arrowColor,
          "--n-arrow-color-disabled": arrowColorDisabled,
          "--n-loading-color": loadingColor,
          // form warning
          "--n-color-active-warning": colorActiveWarning,
          "--n-box-shadow-focus-warning": boxShadowFocusWarning,
          "--n-box-shadow-active-warning": boxShadowActiveWarning,
          "--n-box-shadow-hover-warning": boxShadowHoverWarning,
          "--n-border-warning": borderWarning,
          "--n-border-focus-warning": borderFocusWarning,
          "--n-border-hover-warning": borderHoverWarning,
          "--n-border-active-warning": borderActiveWarning,
          // form error
          "--n-color-active-error": colorActiveError,
          "--n-box-shadow-focus-error": boxShadowFocusError,
          "--n-box-shadow-active-error": boxShadowActiveError,
          "--n-box-shadow-hover-error": boxShadowHoverError,
          "--n-border-error": borderError,
          "--n-border-focus-error": borderFocusError,
          "--n-border-hover-error": borderHoverError,
          "--n-border-active-error": borderActiveError,
          // clear
          "--n-clear-size": clearSize,
          "--n-clear-color": clearColor,
          "--n-clear-color-hover": clearColorHover,
          "--n-clear-color-pressed": clearColorPressed,
          // arrow-size
          "--n-arrow-size": arrowSize2
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("internal-selection", vue.computed(() => {
        return props.size[0];
      }), cssVarsRef, props) : void 0;
      return {
        mergedTheme: themeRef,
        mergedClearable: mergedClearableRef,
        mergedClsPrefix: mergedClsPrefixRef,
        rtlEnabled: rtlEnabledRef,
        patternInputFocused: patternInputFocusedRef,
        filterablePlaceholder: filterablePlaceholderRef,
        label: labelRef,
        selected: selectedRef,
        showTagsPanel: showTagsPopoverRef,
        isComposing: isComposingRef2,
        // dom ref
        counterRef,
        counterWrapperRef,
        patternInputMirrorRef,
        patternInputRef,
        selfRef,
        multipleElRef,
        singleElRef,
        patternInputWrapperRef,
        overflowRef,
        inputTagElRef,
        handleMouseDown,
        handleFocusin,
        handleClear,
        handleMouseEnter,
        handleMouseLeave,
        handleDeleteOption,
        handlePatternKeyDown,
        handlePatternInputInput,
        handlePatternInputBlur,
        handlePatternInputFocus,
        handleMouseEnterCounter,
        handleMouseLeaveCounter,
        handleFocusout,
        handleCompositionEnd,
        handleCompositionStart,
        onPopoverUpdateShow,
        focus,
        focusInput,
        blur,
        blurInput,
        updateCounter,
        getCounter,
        getTail,
        renderLabel: props.renderLabel,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      const {
        status,
        multiple,
        size: size2,
        disabled,
        filterable,
        maxTagCount,
        bordered,
        clsPrefix,
        ellipsisTagPopoverProps,
        onRender,
        renderTag,
        renderLabel
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      const maxTagCountResponsive = maxTagCount === "responsive";
      const maxTagCountNumeric = typeof maxTagCount === "number";
      const useMaxTagCount = maxTagCountResponsive || maxTagCountNumeric;
      const suffix2 = vue.h(Wrapper, null, {
        default: () => vue.h(NBaseSuffix, {
          clsPrefix,
          loading: this.loading,
          showArrow: this.showArrow,
          showClear: this.mergedClearable && this.selected,
          onClear: this.handleClear
        }, {
          default: () => {
            var _a, _b;
            return (_b = (_a = this.$slots).arrow) === null || _b === void 0 ? void 0 : _b.call(_a);
          }
        })
      });
      let body;
      if (multiple) {
        const {
          labelField
        } = this;
        const createTag = (option) => vue.h("div", {
          class: `${clsPrefix}-base-selection-tag-wrapper`,
          key: option.value
        }, renderTag ? renderTag({
          option,
          handleClose: () => {
            this.handleDeleteOption(option);
          }
        }) : vue.h(NTag, {
          size: size2,
          closable: !option.disabled,
          disabled,
          onClose: () => {
            this.handleDeleteOption(option);
          },
          internalCloseIsButtonTag: false,
          internalCloseFocusable: false
        }, {
          default: () => renderLabel ? renderLabel(option, true) : render$1(option[labelField], option, true)
        }));
        const createOriginalTagNodes = () => (maxTagCountNumeric ? this.selectedOptions.slice(0, maxTagCount) : this.selectedOptions).map(createTag);
        const input = filterable ? vue.h("div", {
          class: `${clsPrefix}-base-selection-input-tag`,
          ref: "inputTagElRef",
          key: "__input-tag__"
        }, vue.h("input", Object.assign({}, this.inputProps, {
          ref: "patternInputRef",
          tabindex: -1,
          disabled,
          value: this.pattern,
          autofocus: this.autofocus,
          class: `${clsPrefix}-base-selection-input-tag__input`,
          onBlur: this.handlePatternInputBlur,
          onFocus: this.handlePatternInputFocus,
          onKeydown: this.handlePatternKeyDown,
          onInput: this.handlePatternInputInput,
          onCompositionstart: this.handleCompositionStart,
          onCompositionend: this.handleCompositionEnd
        })), vue.h("span", {
          ref: "patternInputMirrorRef",
          class: `${clsPrefix}-base-selection-input-tag__mirror`
        }, this.pattern)) : null;
        const renderCounter = maxTagCountResponsive ? () => vue.h("div", {
          class: `${clsPrefix}-base-selection-tag-wrapper`,
          ref: "counterWrapperRef"
        }, vue.h(NTag, {
          size: size2,
          ref: "counterRef",
          onMouseenter: this.handleMouseEnterCounter,
          onMouseleave: this.handleMouseLeaveCounter,
          disabled
        })) : void 0;
        let counter;
        if (maxTagCountNumeric) {
          const rest = this.selectedOptions.length - maxTagCount;
          if (rest > 0) {
            counter = vue.h("div", {
              class: `${clsPrefix}-base-selection-tag-wrapper`,
              key: "__counter__"
            }, vue.h(NTag, {
              size: size2,
              ref: "counterRef",
              onMouseenter: this.handleMouseEnterCounter,
              disabled
            }, {
              default: () => `+${rest}`
            }));
          }
        }
        const tags = maxTagCountResponsive ? filterable ? vue.h(VOverflow, {
          ref: "overflowRef",
          updateCounter: this.updateCounter,
          getCounter: this.getCounter,
          getTail: this.getTail,
          style: {
            width: "100%",
            display: "flex",
            overflow: "hidden"
          }
        }, {
          default: createOriginalTagNodes,
          counter: renderCounter,
          tail: () => input
        }) : vue.h(VOverflow, {
          ref: "overflowRef",
          updateCounter: this.updateCounter,
          getCounter: this.getCounter,
          style: {
            width: "100%",
            display: "flex",
            overflow: "hidden"
          }
        }, {
          default: createOriginalTagNodes,
          counter: renderCounter
        }) : maxTagCountNumeric && counter ? createOriginalTagNodes().concat(counter) : createOriginalTagNodes();
        const renderPopover = useMaxTagCount ? () => vue.h("div", {
          class: `${clsPrefix}-base-selection-popover`
        }, maxTagCountResponsive ? createOriginalTagNodes() : this.selectedOptions.map(createTag)) : void 0;
        const popoverProps2 = useMaxTagCount ? Object.assign({
          show: this.showTagsPanel,
          trigger: "hover",
          overlap: true,
          placement: "top",
          width: "trigger",
          onUpdateShow: this.onPopoverUpdateShow,
          theme: this.mergedTheme.peers.Popover,
          themeOverrides: this.mergedTheme.peerOverrides.Popover
        }, ellipsisTagPopoverProps) : null;
        const showPlaceholder = this.selected ? false : this.active ? !this.pattern && !this.isComposing : true;
        const placeholder = showPlaceholder ? vue.h("div", {
          class: `${clsPrefix}-base-selection-placeholder ${clsPrefix}-base-selection-overlay`
        }, vue.h("div", {
          class: `${clsPrefix}-base-selection-placeholder__inner`
        }, this.placeholder)) : null;
        const popoverTrigger = filterable ? vue.h("div", {
          ref: "patternInputWrapperRef",
          class: `${clsPrefix}-base-selection-tags`
        }, tags, maxTagCountResponsive ? null : input, suffix2) : vue.h("div", {
          ref: "multipleElRef",
          class: `${clsPrefix}-base-selection-tags`,
          tabindex: disabled ? void 0 : 0
        }, tags, suffix2);
        body = vue.h(vue.Fragment, null, useMaxTagCount ? vue.h(NPopover, Object.assign({}, popoverProps2, {
          scrollable: true,
          style: "max-height: calc(var(--v-target-height) * 6.6);"
        }), {
          trigger: () => popoverTrigger,
          default: renderPopover
        }) : popoverTrigger, placeholder);
      } else {
        if (filterable) {
          const hasInput = this.pattern || this.isComposing;
          const showPlaceholder = this.active ? !hasInput : !this.selected;
          const showSelectedLabel = this.active ? false : this.selected;
          body = vue.h("div", {
            ref: "patternInputWrapperRef",
            class: `${clsPrefix}-base-selection-label`,
            title: this.patternInputFocused ? void 0 : getTitleAttribute(this.label)
          }, vue.h("input", Object.assign({}, this.inputProps, {
            ref: "patternInputRef",
            class: `${clsPrefix}-base-selection-input`,
            value: this.active ? this.pattern : "",
            placeholder: "",
            readonly: disabled,
            disabled,
            tabindex: -1,
            autofocus: this.autofocus,
            onFocus: this.handlePatternInputFocus,
            onBlur: this.handlePatternInputBlur,
            onInput: this.handlePatternInputInput,
            onCompositionstart: this.handleCompositionStart,
            onCompositionend: this.handleCompositionEnd
          })), showSelectedLabel ? vue.h("div", {
            class: `${clsPrefix}-base-selection-label__render-label ${clsPrefix}-base-selection-overlay`,
            key: "input"
          }, vue.h("div", {
            class: `${clsPrefix}-base-selection-overlay__wrapper`
          }, renderTag ? renderTag({
            option: this.selectedOption,
            handleClose: () => {
            }
          }) : renderLabel ? renderLabel(this.selectedOption, true) : render$1(this.label, this.selectedOption, true))) : null, showPlaceholder ? vue.h("div", {
            class: `${clsPrefix}-base-selection-placeholder ${clsPrefix}-base-selection-overlay`,
            key: "placeholder"
          }, vue.h("div", {
            class: `${clsPrefix}-base-selection-overlay__wrapper`
          }, this.filterablePlaceholder)) : null, suffix2);
        } else {
          body = vue.h("div", {
            ref: "singleElRef",
            class: `${clsPrefix}-base-selection-label`,
            tabindex: this.disabled ? void 0 : 0
          }, this.label !== void 0 ? vue.h("div", {
            class: `${clsPrefix}-base-selection-input`,
            title: getTitleAttribute(this.label),
            key: "input"
          }, vue.h("div", {
            class: `${clsPrefix}-base-selection-input__content`
          }, renderTag ? renderTag({
            option: this.selectedOption,
            handleClose: () => {
            }
          }) : renderLabel ? renderLabel(this.selectedOption, true) : render$1(this.label, this.selectedOption, true))) : vue.h("div", {
            class: `${clsPrefix}-base-selection-placeholder ${clsPrefix}-base-selection-overlay`,
            key: "placeholder"
          }, vue.h("div", {
            class: `${clsPrefix}-base-selection-placeholder__inner`
          }, this.placeholder)), suffix2);
        }
      }
      return vue.h("div", {
        ref: "selfRef",
        class: [`${clsPrefix}-base-selection`, this.rtlEnabled && `${clsPrefix}-base-selection--rtl`, this.themeClass, status && `${clsPrefix}-base-selection--${status}-status`, {
          [`${clsPrefix}-base-selection--active`]: this.active,
          [`${clsPrefix}-base-selection--selected`]: this.selected || this.active && this.pattern,
          [`${clsPrefix}-base-selection--disabled`]: this.disabled,
          [`${clsPrefix}-base-selection--multiple`]: this.multiple,
          // focus is not controlled by selection itself since it always need
          // to be managed together with menu. provide :focus style will cause
          // many redundant codes.
          [`${clsPrefix}-base-selection--focus`]: this.focused
        }],
        style: this.cssVars,
        onClick: this.onClick,
        onMouseenter: this.handleMouseEnter,
        onMouseleave: this.handleMouseLeave,
        onKeydown: this.onKeydown,
        onFocusin: this.handleFocusin,
        onFocusout: this.handleFocusout,
        onMousedown: this.handleMouseDown
      }, body, bordered ? vue.h("div", {
        class: `${clsPrefix}-base-selection__border`
      }) : null, bordered ? vue.h("div", {
        class: `${clsPrefix}-base-selection__state-border`
      }) : null);
    }
  });
  const SlotMachineNumber = vue.defineComponent({
    name: "SlotMachineNumber",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      value: {
        // could be '+', 1, 2, ...
        type: [Number, String],
        required: true
      },
      oldOriginalNumber: {
        type: Number,
        default: void 0
      },
      newOriginalNumber: {
        type: Number,
        default: void 0
      }
    },
    setup(props) {
      const numberRef = vue.ref(null);
      const oldNumberRef = vue.ref(props.value);
      const newNumberRef = vue.ref(props.value);
      const scrollAnimationDirectionRef = vue.ref("up");
      const activeRef = vue.ref(false);
      const newNumberScrollAnimationClassRef = vue.computed(() => {
        return activeRef.value ? `${props.clsPrefix}-base-slot-machine-current-number--${scrollAnimationDirectionRef.value}-scroll` : null;
      });
      const oldNumberScrollAnimationClassRef = vue.computed(() => {
        return activeRef.value ? `${props.clsPrefix}-base-slot-machine-old-number--${scrollAnimationDirectionRef.value}-scroll` : null;
      });
      vue.watch(vue.toRef(props, "value"), (value, oldValue) => {
        oldNumberRef.value = oldValue;
        newNumberRef.value = value;
        void vue.nextTick(scroll);
      });
      function scroll() {
        const newOriginalNumber = props.newOriginalNumber;
        const oldOriginalNumber = props.oldOriginalNumber;
        if (oldOriginalNumber === void 0 || newOriginalNumber === void 0) {
          return;
        }
        if (newOriginalNumber > oldOriginalNumber) {
          scrollByDir("up");
        } else if (oldOriginalNumber > newOriginalNumber) {
          scrollByDir("down");
        }
      }
      function scrollByDir(dir) {
        scrollAnimationDirectionRef.value = dir;
        activeRef.value = false;
        void vue.nextTick(() => {
          var _a;
          void ((_a = numberRef.value) === null || _a === void 0 ? void 0 : _a.offsetWidth);
          activeRef.value = true;
        });
      }
      return () => {
        const {
          clsPrefix
        } = props;
        return vue.h("span", {
          ref: numberRef,
          class: `${clsPrefix}-base-slot-machine-number`
        }, oldNumberRef.value !== null ? vue.h("span", {
          class: [`${clsPrefix}-base-slot-machine-old-number ${clsPrefix}-base-slot-machine-old-number--top`, oldNumberScrollAnimationClassRef.value]
        }, oldNumberRef.value) : null, vue.h("span", {
          class: [`${clsPrefix}-base-slot-machine-current-number`, newNumberScrollAnimationClassRef.value]
        }, vue.h("span", {
          ref: "numberWrapper",
          class: [`${clsPrefix}-base-slot-machine-current-number__inner`, typeof props.value !== "number" && `${clsPrefix}-base-slot-machine-current-number__inner--not-number`]
        }, newNumberRef.value)), oldNumberRef.value !== null ? vue.h("span", {
          class: [`${clsPrefix}-base-slot-machine-old-number ${clsPrefix}-base-slot-machine-old-number--bottom`, oldNumberScrollAnimationClassRef.value]
        }, oldNumberRef.value) : null);
      };
    }
  });
  const {
    cubicBezierEaseInOut: cubicBezierEaseInOut$2
  } = commonVariables$m;
  function fadeInWidthExpandTransition({
    duration: duration2 = ".2s",
    delay = ".1s"
  } = {}) {
    return [c$1("&.fade-in-width-expand-transition-leave-from, &.fade-in-width-expand-transition-enter-to", {
      opacity: 1
    }), c$1("&.fade-in-width-expand-transition-leave-to, &.fade-in-width-expand-transition-enter-from", `
 opacity: 0!important;
 margin-left: 0!important;
 margin-right: 0!important;
 `), c$1("&.fade-in-width-expand-transition-leave-active", `
 overflow: hidden;
 transition:
 opacity ${duration2} ${cubicBezierEaseInOut$2},
 max-width ${duration2} ${cubicBezierEaseInOut$2} ${delay},
 margin-left ${duration2} ${cubicBezierEaseInOut$2} ${delay},
 margin-right ${duration2} ${cubicBezierEaseInOut$2} ${delay};
 `), c$1("&.fade-in-width-expand-transition-enter-active", `
 overflow: hidden;
 transition:
 opacity ${duration2} ${cubicBezierEaseInOut$2} ${delay},
 max-width ${duration2} ${cubicBezierEaseInOut$2},
 margin-left ${duration2} ${cubicBezierEaseInOut$2},
 margin-right ${duration2} ${cubicBezierEaseInOut$2};
 `)];
  }
  const {
    cubicBezierEaseOut: cubicBezierEaseOut$5
  } = commonVariables$m;
  function fadeUpWidthExpandTransition({
    duration: duration2 = ".2s"
  } = {}) {
    return [c$1("&.fade-up-width-expand-transition-leave-active", {
      transition: `
 opacity ${duration2} ${cubicBezierEaseOut$5},
 max-width ${duration2} ${cubicBezierEaseOut$5},
 transform ${duration2} ${cubicBezierEaseOut$5}
 `
    }), c$1("&.fade-up-width-expand-transition-enter-active", {
      transition: `
 opacity ${duration2} ${cubicBezierEaseOut$5},
 max-width ${duration2} ${cubicBezierEaseOut$5},
 transform ${duration2} ${cubicBezierEaseOut$5}
 `
    }), c$1("&.fade-up-width-expand-transition-enter-to", {
      opacity: 1,
      transform: "translateX(0) translateY(0)"
    }), c$1("&.fade-up-width-expand-transition-enter-from", {
      maxWidth: "0 !important",
      opacity: 0,
      transform: "translateY(60%)"
    }), c$1("&.fade-up-width-expand-transition-leave-from", {
      opacity: 1,
      transform: "translateY(0)"
    }), c$1("&.fade-up-width-expand-transition-leave-to", {
      maxWidth: "0 !important",
      opacity: 0,
      transform: "translateY(60%)"
    })];
  }
  const style$1q = c$1([c$1("@keyframes n-base-slot-machine-fade-up-in", `
 from {
 transform: translateY(60%);
 opacity: 0;
 }
 to {
 transform: translateY(0);
 opacity: 1;
 }
 `), c$1("@keyframes n-base-slot-machine-fade-down-in", `
 from {
 transform: translateY(-60%);
 opacity: 0;
 }
 to {
 transform: translateY(0);
 opacity: 1;
 }
 `), c$1("@keyframes n-base-slot-machine-fade-up-out", `
 from {
 transform: translateY(0%);
 opacity: 1;
 }
 to {
 transform: translateY(-60%);
 opacity: 0;
 }
 `), c$1("@keyframes n-base-slot-machine-fade-down-out", `
 from {
 transform: translateY(0%);
 opacity: 1;
 }
 to {
 transform: translateY(60%);
 opacity: 0;
 }
 `), cB("base-slot-machine", `
 overflow: hidden;
 white-space: nowrap;
 display: inline-block;
 height: 18px;
 line-height: 18px;
 `, [cB("base-slot-machine-number", `
 display: inline-block;
 position: relative;
 height: 18px;
 width: .6em;
 max-width: .6em;
 `, [
    fadeUpWidthExpandTransition({
      duration: ".2s"
    }),
    // use 0s, not 0
    fadeInWidthExpandTransition({
      duration: ".2s",
      delay: "0s"
    }),
    cB("base-slot-machine-old-number", `
 display: inline-block;
 opacity: 0;
 position: absolute;
 left: 0;
 right: 0;
 `, [cM("top", {
      transform: "translateY(-100%)"
    }), cM("bottom", {
      transform: "translateY(100%)"
    }), cM("down-scroll", {
      animation: "n-base-slot-machine-fade-down-out .2s cubic-bezier(0, 0, .2, 1)",
      animationIterationCount: 1
    }), cM("up-scroll", {
      animation: "n-base-slot-machine-fade-up-out .2s cubic-bezier(0, 0, .2, 1)",
      animationIterationCount: 1
    })]),
    cB("base-slot-machine-current-number", `
 display: inline-block;
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 0;
 opacity: 1;
 transform: translateY(0);
 width: .6em;
 `, [cM("down-scroll", {
      animation: "n-base-slot-machine-fade-down-in .2s cubic-bezier(0, 0, .2, 1)",
      animationIterationCount: 1
    }), cM("up-scroll", {
      animation: "n-base-slot-machine-fade-up-in .2s cubic-bezier(0, 0, .2, 1)",
      animationIterationCount: 1
    }), cE("inner", `
 display: inline-block;
 position: absolute;
 right: 0;
 top: 0;
 width: .6em;
 `, [cM("not-number", `
 right: unset;
 left: 0;
 `)])])
  ])])]);
  const NBaseSlotMachine = vue.defineComponent({
    name: "BaseSlotMachine",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      value: {
        type: [Number, String],
        default: 0
      },
      max: {
        type: Number,
        default: void 0
      },
      appeared: {
        type: Boolean,
        required: true
      }
    },
    setup(props) {
      useStyle("-base-slot-machine", style$1q, vue.toRef(props, "clsPrefix"));
      const oldValueRef = vue.ref();
      const newValueRef = vue.ref();
      const numbersRef = vue.computed(() => {
        if (typeof props.value === "string")
          return [];
        if (props.value < 1)
          return [0];
        const numbers = [];
        let value = props.value;
        if (props.max !== void 0) {
          value = Math.min(props.max, value);
        }
        while (value >= 1) {
          numbers.push(value % 10);
          value /= 10;
          value = Math.floor(value);
        }
        numbers.reverse();
        return numbers;
      });
      vue.watch(vue.toRef(props, "value"), (value, oldValue) => {
        if (typeof value === "string") {
          newValueRef.value = void 0;
          oldValueRef.value = void 0;
        } else {
          if (typeof oldValue === "string") {
            newValueRef.value = value;
            oldValueRef.value = void 0;
          } else {
            newValueRef.value = value;
            oldValueRef.value = oldValue;
          }
        }
      });
      return () => {
        const {
          value,
          clsPrefix
        } = props;
        return typeof value === "number" ? vue.h("span", {
          class: `${clsPrefix}-base-slot-machine`
        }, vue.h(vue.TransitionGroup, {
          name: "fade-up-width-expand-transition",
          tag: "span"
        }, {
          default: () => numbersRef.value.map((number, i) => vue.h(SlotMachineNumber, {
            clsPrefix,
            key: numbersRef.value.length - i - 1,
            oldOriginalNumber: oldValueRef.value,
            newOriginalNumber: newValueRef.value,
            value: number
          }))
        }), vue.h(NFadeInExpandTransition, {
          key: "+",
          width: true
        }, {
          default: () => props.max !== void 0 && props.max < value ? vue.h(SlotMachineNumber, {
            clsPrefix,
            value: "+"
          }) : null
        })) : vue.h("span", {
          class: `${clsPrefix}-base-slot-machine`
        }, value);
      };
    }
  });
  const commonVars$b = {
    iconMargin: "11px 8px 0 12px",
    iconMarginRtl: "11px 12px 0 8px",
    iconSize: "24px",
    closeIconSize: "16px",
    closeSize: "20px",
    closeMargin: "13px 14px 0 0",
    closeMarginRtl: "13px 0 0 14px",
    padding: "13px"
  };
  function self$1b(vars) {
    const {
      lineHeight: lineHeight2,
      borderRadius,
      fontWeightStrong,
      baseColor,
      dividerColor,
      actionColor,
      textColor1,
      textColor2,
      closeColorHover,
      closeColorPressed,
      closeIconColor,
      closeIconColorHover,
      closeIconColorPressed,
      infoColor,
      successColor,
      warningColor,
      errorColor,
      fontSize: fontSize2
    } = vars;
    return Object.assign(Object.assign({}, commonVars$b), {
      fontSize: fontSize2,
      lineHeight: lineHeight2,
      titleFontWeight: fontWeightStrong,
      borderRadius,
      border: `1px solid ${dividerColor}`,
      color: actionColor,
      titleTextColor: textColor1,
      iconColor: textColor2,
      contentTextColor: textColor2,
      closeBorderRadius: borderRadius,
      closeColorHover,
      closeColorPressed,
      closeIconColor,
      closeIconColorHover,
      closeIconColorPressed,
      borderInfo: `1px solid ${composite(baseColor, changeColor(infoColor, {
        alpha: 0.25
      }))}`,
      colorInfo: composite(baseColor, changeColor(infoColor, {
        alpha: 0.08
      })),
      titleTextColorInfo: textColor1,
      iconColorInfo: infoColor,
      contentTextColorInfo: textColor2,
      closeColorHoverInfo: closeColorHover,
      closeColorPressedInfo: closeColorPressed,
      closeIconColorInfo: closeIconColor,
      closeIconColorHoverInfo: closeIconColorHover,
      closeIconColorPressedInfo: closeIconColorPressed,
      borderSuccess: `1px solid ${composite(baseColor, changeColor(successColor, {
        alpha: 0.25
      }))}`,
      colorSuccess: composite(baseColor, changeColor(successColor, {
        alpha: 0.08
      })),
      titleTextColorSuccess: textColor1,
      iconColorSuccess: successColor,
      contentTextColorSuccess: textColor2,
      closeColorHoverSuccess: closeColorHover,
      closeColorPressedSuccess: closeColorPressed,
      closeIconColorSuccess: closeIconColor,
      closeIconColorHoverSuccess: closeIconColorHover,
      closeIconColorPressedSuccess: closeIconColorPressed,
      borderWarning: `1px solid ${composite(baseColor, changeColor(warningColor, {
        alpha: 0.33
      }))}`,
      colorWarning: composite(baseColor, changeColor(warningColor, {
        alpha: 0.08
      })),
      titleTextColorWarning: textColor1,
      iconColorWarning: warningColor,
      contentTextColorWarning: textColor2,
      closeColorHoverWarning: closeColorHover,
      closeColorPressedWarning: closeColorPressed,
      closeIconColorWarning: closeIconColor,
      closeIconColorHoverWarning: closeIconColorHover,
      closeIconColorPressedWarning: closeIconColorPressed,
      borderError: `1px solid ${composite(baseColor, changeColor(errorColor, {
        alpha: 0.25
      }))}`,
      colorError: composite(baseColor, changeColor(errorColor, {
        alpha: 0.08
      })),
      titleTextColorError: textColor1,
      iconColorError: errorColor,
      contentTextColorError: textColor2,
      closeColorHoverError: closeColorHover,
      closeColorPressedError: closeColorPressed,
      closeIconColorError: closeIconColor,
      closeIconColorHoverError: closeIconColorHover,
      closeIconColorPressedError: closeIconColorPressed
    });
  }
  const alertLight = {
    name: "Alert",
    common: commonLight,
    self: self$1b
  };
  const alertLight$1 = alertLight;
  const {
    cubicBezierEaseInOut: cubicBezierEaseInOut$1,
    cubicBezierEaseOut: cubicBezierEaseOut$4,
    cubicBezierEaseIn: cubicBezierEaseIn$4
  } = commonVariables$m;
  function fadeInHeightExpandTransition({
    overflow = "hidden",
    duration: duration2 = ".3s",
    originalTransition = "",
    leavingDelay = "0s",
    foldPadding = false,
    enterToProps = void 0,
    leaveToProps = void 0,
    reverse = false
  } = {}) {
    const enterClass = reverse ? "leave" : "enter";
    const leaveClass = reverse ? "enter" : "leave";
    return [c$1(`&.fade-in-height-expand-transition-${leaveClass}-from,
 &.fade-in-height-expand-transition-${enterClass}-to`, Object.assign(Object.assign({}, enterToProps), {
      opacity: 1
    })), c$1(`&.fade-in-height-expand-transition-${leaveClass}-to,
 &.fade-in-height-expand-transition-${enterClass}-from`, Object.assign(Object.assign({}, leaveToProps), {
      opacity: 0,
      marginTop: "0 !important",
      marginBottom: "0 !important",
      paddingTop: foldPadding ? "0 !important" : void 0,
      paddingBottom: foldPadding ? "0 !important" : void 0
    })), c$1(`&.fade-in-height-expand-transition-${leaveClass}-active`, `
 overflow: ${overflow};
 transition:
 max-height ${duration2} ${cubicBezierEaseInOut$1} ${leavingDelay},
 opacity ${duration2} ${cubicBezierEaseOut$4} ${leavingDelay},
 margin-top ${duration2} ${cubicBezierEaseInOut$1} ${leavingDelay},
 margin-bottom ${duration2} ${cubicBezierEaseInOut$1} ${leavingDelay},
 padding-top ${duration2} ${cubicBezierEaseInOut$1} ${leavingDelay},
 padding-bottom ${duration2} ${cubicBezierEaseInOut$1} ${leavingDelay}
 ${originalTransition ? `,${originalTransition}` : ""}
 `), c$1(`&.fade-in-height-expand-transition-${enterClass}-active`, `
 overflow: ${overflow};
 transition:
 max-height ${duration2} ${cubicBezierEaseInOut$1},
 opacity ${duration2} ${cubicBezierEaseIn$4},
 margin-top ${duration2} ${cubicBezierEaseInOut$1},
 margin-bottom ${duration2} ${cubicBezierEaseInOut$1},
 padding-top ${duration2} ${cubicBezierEaseInOut$1},
 padding-bottom ${duration2} ${cubicBezierEaseInOut$1}
 ${originalTransition ? `,${originalTransition}` : ""}
 `)];
  }
  const style$1p = cB("alert", `
 line-height: var(--n-line-height);
 border-radius: var(--n-border-radius);
 position: relative;
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-color);
 text-align: start;
 word-break: break-word;
`, [
    cE("border", `
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 transition: border-color .3s var(--n-bezier);
 border: var(--n-border);
 pointer-events: none;
 `),
    cM("closable", [cB("alert-body", [cE("title", `
 padding-right: 24px;
 `)])]),
    cE("icon", {
      color: "var(--n-icon-color)"
    }),
    cB("alert-body", {
      padding: "var(--n-padding)"
    }, [cE("title", {
      color: "var(--n-title-text-color)"
    }), cE("content", {
      color: "var(--n-content-text-color)"
    })]),
    fadeInHeightExpandTransition({
      originalTransition: "transform .3s var(--n-bezier)",
      enterToProps: {
        transform: "scale(1)"
      },
      leaveToProps: {
        transform: "scale(0.9)"
      }
    }),
    cE("icon", `
 position: absolute;
 left: 0;
 top: 0;
 align-items: center;
 justify-content: center;
 display: flex;
 width: var(--n-icon-size);
 height: var(--n-icon-size);
 font-size: var(--n-icon-size);
 margin: var(--n-icon-margin);
 `),
    cE("close", `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 position: absolute;
 right: 0;
 top: 0;
 margin: var(--n-close-margin);
 `),
    cM("show-icon", [cB("alert-body", {
      paddingLeft: "calc(var(--n-icon-margin-left) + var(--n-icon-size) + var(--n-icon-margin-right))"
    })]),
    // fix: https://github.com/tusen-ai/naive-ui/issues/4588
    cM("right-adjust", [cB("alert-body", {
      paddingRight: "calc(var(--n-close-size) + var(--n-padding) + 2px)"
    })]),
    cB("alert-body", `
 border-radius: var(--n-border-radius);
 transition: border-color .3s var(--n-bezier);
 `, [cE("title", `
 transition: color .3s var(--n-bezier);
 font-size: 16px;
 line-height: 19px;
 font-weight: var(--n-title-font-weight);
 `, [c$1("& +", [cE("content", {
      marginTop: "9px"
    })])]), cE("content", {
      transition: "color .3s var(--n-bezier)",
      fontSize: "var(--n-font-size)"
    })]),
    cE("icon", {
      transition: "color .3s var(--n-bezier)"
    })
  ]);
  const alertProps = Object.assign(Object.assign({}, useTheme.props), {
    title: String,
    showIcon: {
      type: Boolean,
      default: true
    },
    type: {
      type: String,
      default: "default"
    },
    bordered: {
      type: Boolean,
      default: true
    },
    closable: Boolean,
    onClose: Function,
    onAfterLeave: Function,
    /** @deprecated */
    onAfterHide: Function
  });
  const Alert = vue.defineComponent({
    name: "Alert",
    inheritAttrs: false,
    props: alertProps,
    setup(props) {
      {
        vue.watchEffect(() => {
          if (props.onAfterHide !== void 0) {
            warnOnce("alert", "`on-after-hide` is deprecated, please use `on-after-leave` instead.");
          }
        });
      }
      const {
        mergedClsPrefixRef,
        mergedBorderedRef,
        inlineThemeDisabled,
        mergedRtlRef
      } = useConfig(props);
      const themeRef = useTheme("Alert", "-alert", style$1p, alertLight$1, props, mergedClsPrefixRef);
      const rtlEnabledRef = useRtl("Alert", mergedRtlRef, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: self2
        } = themeRef.value;
        const {
          fontSize: fontSize2,
          borderRadius,
          titleFontWeight,
          lineHeight: lineHeight2,
          iconSize,
          iconMargin,
          iconMarginRtl,
          closeIconSize,
          closeBorderRadius,
          closeSize,
          closeMargin,
          closeMarginRtl,
          padding
        } = self2;
        const {
          type
        } = props;
        const {
          left,
          right
        } = getMargin(iconMargin);
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-color": self2[createKey("color", type)],
          "--n-close-icon-size": closeIconSize,
          "--n-close-border-radius": closeBorderRadius,
          "--n-close-color-hover": self2[createKey("closeColorHover", type)],
          "--n-close-color-pressed": self2[createKey("closeColorPressed", type)],
          "--n-close-icon-color": self2[createKey("closeIconColor", type)],
          "--n-close-icon-color-hover": self2[createKey("closeIconColorHover", type)],
          "--n-close-icon-color-pressed": self2[createKey("closeIconColorPressed", type)],
          "--n-icon-color": self2[createKey("iconColor", type)],
          "--n-border": self2[createKey("border", type)],
          "--n-title-text-color": self2[createKey("titleTextColor", type)],
          "--n-content-text-color": self2[createKey("contentTextColor", type)],
          "--n-line-height": lineHeight2,
          "--n-border-radius": borderRadius,
          "--n-font-size": fontSize2,
          "--n-title-font-weight": titleFontWeight,
          "--n-icon-size": iconSize,
          "--n-icon-margin": iconMargin,
          "--n-icon-margin-rtl": iconMarginRtl,
          "--n-close-size": closeSize,
          "--n-close-margin": closeMargin,
          "--n-close-margin-rtl": closeMarginRtl,
          "--n-padding": padding,
          "--n-icon-margin-left": left,
          "--n-icon-margin-right": right
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("alert", vue.computed(() => {
        return props.type[0];
      }), cssVarsRef, props) : void 0;
      const visibleRef = vue.ref(true);
      const doAfterLeave = () => {
        const {
          onAfterLeave,
          onAfterHide
          // deprecated
        } = props;
        if (onAfterLeave)
          onAfterLeave();
        if (onAfterHide)
          onAfterHide();
      };
      const handleCloseClick = () => {
        var _a;
        void Promise.resolve((_a = props.onClose) === null || _a === void 0 ? void 0 : _a.call(props)).then((result) => {
          if (result === false)
            return;
          visibleRef.value = false;
        });
      };
      const handleAfterLeave = () => {
        doAfterLeave();
      };
      return {
        rtlEnabled: rtlEnabledRef,
        mergedClsPrefix: mergedClsPrefixRef,
        mergedBordered: mergedBorderedRef,
        visible: visibleRef,
        handleCloseClick,
        handleAfterLeave,
        mergedTheme: themeRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      return vue.h(NFadeInExpandTransition, {
        onAfterLeave: this.handleAfterLeave
      }, {
        default: () => {
          const {
            mergedClsPrefix,
            $slots
          } = this;
          const attrs = {
            class: [
              `${mergedClsPrefix}-alert`,
              this.themeClass,
              this.closable && `${mergedClsPrefix}-alert--closable`,
              this.showIcon && `${mergedClsPrefix}-alert--show-icon`,
              // fix: https://github.com/tusen-ai/naive-ui/issues/4588
              !this.title && this.closable && `${mergedClsPrefix}-alert--right-adjust`,
              this.rtlEnabled && `${mergedClsPrefix}-alert--rtl`
            ],
            style: this.cssVars,
            role: "alert"
          };
          return this.visible ? vue.h("div", Object.assign({}, vue.mergeProps(this.$attrs, attrs)), this.closable && vue.h(NBaseClose, {
            clsPrefix: mergedClsPrefix,
            class: `${mergedClsPrefix}-alert__close`,
            onClick: this.handleCloseClick
          }), this.bordered && vue.h("div", {
            class: `${mergedClsPrefix}-alert__border`
          }), this.showIcon && vue.h("div", {
            class: `${mergedClsPrefix}-alert__icon`,
            "aria-hidden": "true"
          }, resolveSlot($slots.icon, () => [vue.h(NBaseIcon, {
            clsPrefix: mergedClsPrefix
          }, {
            default: () => {
              switch (this.type) {
                case "success":
                  return vue.h(SuccessIcon, null);
                case "info":
                  return vue.h(InfoIcon, null);
                case "warning":
                  return vue.h(WarningIcon, null);
                case "error":
                  return vue.h(ErrorIcon, null);
                default:
                  return null;
              }
            }
          })])), vue.h("div", {
            class: [`${mergedClsPrefix}-alert-body`, this.mergedBordered && `${mergedClsPrefix}-alert-body--bordered`]
          }, resolveWrappedSlot($slots.header, (children) => {
            const mergedChildren = children || this.title;
            return mergedChildren ? vue.h("div", {
              class: `${mergedClsPrefix}-alert-body__title`
            }, mergedChildren) : null;
          }), $slots.default && vue.h("div", {
            class: `${mergedClsPrefix}-alert-body__content`
          }, $slots))) : null;
        }
      });
    }
  });
  const commonVars$a = {
    linkFontSize: "13px",
    linkPadding: "0 0 0 16px",
    railWidth: "4px"
  };
  function self$1a(vars) {
    const {
      borderRadius,
      railColor,
      primaryColor,
      primaryColorHover,
      primaryColorPressed,
      textColor2
    } = vars;
    return Object.assign(Object.assign({}, commonVars$a), {
      borderRadius,
      railColor,
      railColorActive: primaryColor,
      linkColor: changeColor(primaryColor, {
        alpha: 0.15
      }),
      linkTextColor: textColor2,
      linkTextColorHover: primaryColorHover,
      linkTextColorPressed: primaryColorPressed,
      linkTextColorActive: primaryColor
    });
  }
  const anchorLight = {
    name: "Anchor",
    common: commonLight,
    self: self$1a
  };
  const anchorLight$1 = anchorLight;
  const style$1o = cB("anchor", `
 position: relative;
`, [cNotM("block", `
 padding-left: var(--n-rail-width);
 `, [cB("anchor-link", [c$1("+, >", [cB("anchor-link", `
 margin-top: .5em;
 `)])]), cB("anchor-link-background", `
 max-width: 0;
 border-top-right-radius: 10.5px;
 border-bottom-right-radius: 10.5px;
 `), cNotM("show-rail", [c$1(">", [cB("anchor-link", "padding-left: 0;")])])]), cM("block", [cB("anchor-link", `
 margin-bottom: 4px;
 padding: 2px 8px;
 transition: background-color .3s var(--n-bezier);
 background-color: transparent;
 border-radius: var(--n-link-border-radius);
 `, [cM("active", `
 background-color: var(--n-link-color);
 `)])]), cB("anchor-link-background", `
 position: absolute;
 left: calc(var(--n-rail-width) / 2);
 width: 100%;
 background-color: var(--n-link-color);
 transition:
 top .15s var(--n-bezier),
 max-width .15s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), cB("anchor-rail", `
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 width: var(--n-rail-width);
 border-radius: calc(var(--n-rail-width) / 2);
 overflow: hidden;
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-rail-color);
 `, [cE("bar", `
 position: absolute;
 left: 0;
 width: var(--n-rail-width);
 height: 21px;
 background-color: #0000;
 transition: 
 top .15s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [cM("active", {
    backgroundColor: "var(--n-rail-color-active)"
  })])]), cB("anchor-link", `
 padding: var(--n-link-padding);
 position: relative;
 line-height: 1.5;
 font-size: var(--n-link-font-size);
 min-height: 1.5em;
 display: flex;
 flex-direction: column;
 `, [cM("active", [c$1(">", [cE("title", `
 color: var(--n-link-text-color-active);
 `)])]), cE("title", `
 outline: none;
 max-width: 100%;
 text-decoration: none;
 white-space: nowrap;
 text-overflow: ellipsis;
 overflow: hidden;
 cursor: pointer;
 display: inline-block;
 padding-right: 16px;
 transition: color .3s var(--n-bezier);
 color: var(--n-link-text-color);
 `, [c$1("&:hover, &:focus", `
 color: var(--n-link-text-color-hover);
 `), c$1("&:active", `
 color: var(--n-link-text-color-pressed);
 `)])])]);
  const anchorInjectionKey = createInjectionKey("n-anchor");
  const anchorLinkProps = {
    title: String,
    href: String
  };
  const Link = vue.defineComponent({
    name: "AnchorLink",
    props: anchorLinkProps,
    setup(props, {
      slots
    }) {
      const titleRef = vue.ref(null);
      const NAnchor = vue.inject(anchorInjectionKey);
      const hrefRef = vue.toRef(props, "href");
      const activeRef = useMemo(() => {
        return hrefRef.value && hrefRef.value === NAnchor.activeHref.value;
      });
      useInjectionCollection(anchorInjectionKey, "collectedLinkHrefs", hrefRef);
      useInjectionElementCollection(anchorInjectionKey, "titleEls", () => titleRef.value);
      vue.watch(activeRef, (value) => {
        if (value && titleRef.value) {
          NAnchor.updateBarPosition(titleRef.value);
        }
      });
      function handleClick2() {
        if (props.href !== void 0) {
          NAnchor.setActiveHref(props.href);
        }
      }
      return () => {
        var _a;
        const {
          value: mergedClsPrefix
        } = NAnchor.mergedClsPrefix;
        return vue.h("div", {
          class: [`${mergedClsPrefix}-anchor-link`, activeRef.value && `${mergedClsPrefix}-anchor-link--active`]
        }, vue.h("a", {
          ref: titleRef,
          class: [`${mergedClsPrefix}-anchor-link__title`],
          href: props.href,
          title: getTitleAttribute(props.title),
          onClick: handleClick2
        }, props.title), (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots));
      };
    }
  });
  function getOffset(el, scrollTarget) {
    const {
      top: elTop,
      height
    } = el.getBoundingClientRect();
    const scrollTargetTop = scrollTarget instanceof HTMLElement ? scrollTarget.getBoundingClientRect().top : 0;
    return {
      top: elTop - scrollTargetTop,
      height
    };
  }
  const baseAnchorProps = {
    type: {
      type: String,
      default: "rail"
    },
    showRail: {
      type: Boolean,
      default: true
    },
    showBackground: {
      type: Boolean,
      default: true
    },
    bound: {
      type: Number,
      default: 12
    },
    internalScrollable: Boolean,
    ignoreGap: Boolean,
    offsetTarget: [String, Object, Function]
  };
  const baseAnchorPropKeys = keysOf(baseAnchorProps);
  const NBaseAnchor = vue.defineComponent({
    name: "BaseAnchor",
    props: Object.assign(Object.assign({}, baseAnchorProps), {
      mergedClsPrefix: {
        type: String,
        required: true
      }
    }),
    setup(props) {
      const collectedLinkHrefs = [];
      const titleEls = [];
      const activeHrefRef = vue.ref(null);
      const slotRef = vue.ref(null);
      const barRef = vue.ref(null);
      const selfRef = vue.ref(null);
      const isBlockTypeRef = vue.computed(() => {
        return props.type === "block";
      });
      const mergedShowRailRef = vue.computed(() => {
        return !isBlockTypeRef.value && props.showRail;
      });
      function disableTransitionOneTick() {
        const {
          value: barEl
        } = barRef;
        const {
          value: slotEl
        } = slotRef;
        if (barEl) {
          barEl.style.transition = "none";
        }
        if (slotEl) {
          slotEl.style.transition = "none";
        }
        if (titleEls) {
          titleEls.forEach((titleEl) => {
            titleEl.style.transition = "none";
          });
        }
        void vue.nextTick(() => {
          const {
            value: nextBarEl
          } = barRef;
          const {
            value: nextSlotEl
          } = slotRef;
          if (nextBarEl) {
            void nextBarEl.offsetWidth;
            nextBarEl.style.transition = "";
          }
          if (nextSlotEl) {
            void nextSlotEl.offsetWidth;
            nextSlotEl.style.transition = "";
          }
          if (titleEls) {
            titleEls.forEach((titleEl) => {
              void titleEl.offsetWidth;
              titleEl.style.transition = "";
            });
          }
        });
      }
      function updateBarPosition(linkTitleEl, transition = true) {
        const {
          value: barEl
        } = barRef;
        const {
          value: slotEl
        } = slotRef;
        const {
          value: selfEl
        } = selfRef;
        if (!selfEl || !barEl)
          return;
        if (!transition) {
          barEl.style.transition = "none";
          if (slotEl)
            slotEl.style.transition = "none";
        }
        const {
          offsetHeight,
          offsetWidth
        } = linkTitleEl;
        const {
          top: linkTitleClientTop,
          left: linkTitleClientLeft
        } = linkTitleEl.getBoundingClientRect();
        const {
          top: anchorClientTop,
          left: anchorClientLeft
        } = selfEl.getBoundingClientRect();
        const offsetTop = linkTitleClientTop - anchorClientTop;
        const offsetLeft = linkTitleClientLeft - anchorClientLeft;
        barEl.style.top = `${offsetTop}px`;
        barEl.style.height = `${offsetHeight}px`;
        if (slotEl) {
          slotEl.style.top = `${offsetTop}px`;
          slotEl.style.height = `${offsetHeight}px`;
          slotEl.style.maxWidth = `${offsetWidth + offsetLeft}px`;
        }
        void barEl.offsetHeight;
        if (slotEl)
          void slotEl.offsetHeight;
        if (!transition) {
          barEl.style.transition = "";
          if (slotEl)
            slotEl.style.transition = "";
        }
      }
      const handleScroll = throttle(() => {
        _handleScroll(true);
      }, 128);
      function setActiveHref(href, transition = true) {
        const idMatchResult = /^#([^#]+)$/.exec(href);
        if (!idMatchResult)
          return;
        const linkEl = document.getElementById(idMatchResult[1]);
        if (!linkEl)
          return;
        activeHrefRef.value = href;
        linkEl.scrollIntoView();
        if (!transition) {
          disableTransitionOneTick();
        }
        handleScroll();
      }
      function _handleScroll(transition = true) {
        var _a;
        const links = [];
        const offsetTarget = unwrapElement((_a = props.offsetTarget) !== null && _a !== void 0 ? _a : document);
        collectedLinkHrefs.forEach((href) => {
          const idMatchResult = /#([^#]+)$/.exec(href);
          if (!idMatchResult)
            return;
          const linkEl = document.getElementById(idMatchResult[1]);
          if (linkEl && offsetTarget) {
            const {
              top,
              height
            } = getOffset(linkEl, offsetTarget);
            links.push({
              top,
              height,
              href
            });
          }
        });
        links.sort((a2, b) => {
          if (a2.top > b.top) {
            return 1;
          } else if (a2.top === b.top && a2.height < b.height) {
            return -1;
          }
          return -1;
        });
        const currentActiveHref = activeHrefRef.value;
        const {
          bound,
          ignoreGap
        } = props;
        const activeLink = links.reduce((prevLink, link) => {
          if (link.top + link.height < 0) {
            if (ignoreGap) {
              return link;
            } else {
              return prevLink;
            }
          }
          if (link.top <= bound) {
            if (prevLink === null) {
              return link;
            } else if (link.top === prevLink.top) {
              if (link.href === currentActiveHref) {
                return link;
              } else {
                return prevLink;
              }
            } else if (link.top > prevLink.top) {
              return link;
            } else {
              return prevLink;
            }
          }
          return prevLink;
        }, null);
        if (!transition)
          disableTransitionOneTick();
        if (activeLink) {
          activeHrefRef.value = activeLink.href;
        } else {
          activeHrefRef.value = null;
        }
      }
      vue.provide(anchorInjectionKey, {
        activeHref: activeHrefRef,
        mergedClsPrefix: vue.toRef(props, "mergedClsPrefix"),
        updateBarPosition,
        setActiveHref,
        collectedLinkHrefs,
        titleEls
      });
      vue.onMounted(() => {
        document.addEventListener("scroll", handleScroll, true);
        setActiveHref(window.location.hash);
        _handleScroll(false);
      });
      onFontsReady(() => {
        setActiveHref(window.location.hash);
        _handleScroll(false);
      });
      vue.onBeforeUnmount(() => {
        document.removeEventListener("scroll", handleScroll, true);
      });
      vue.watch(activeHrefRef, (value) => {
        if (value === null) {
          const {
            value: slotEl
          } = slotRef;
          if (slotEl && !isBlockTypeRef.value) {
            slotEl.style.maxWidth = "0";
          }
        }
      });
      return {
        selfRef,
        barRef,
        slotRef,
        setActiveHref,
        activeHref: activeHrefRef,
        isBlockType: isBlockTypeRef,
        mergedShowRail: mergedShowRailRef
      };
    },
    render() {
      var _a;
      const {
        mergedClsPrefix,
        mergedShowRail,
        isBlockType,
        $slots
      } = this;
      const Anchor = vue.h("div", {
        class: [`${mergedClsPrefix}-anchor`, isBlockType && `${mergedClsPrefix}-anchor--block`, mergedShowRail && `${mergedClsPrefix}-anchor--show-rail`],
        ref: "selfRef"
      }, mergedShowRail && this.showBackground ? vue.h("div", {
        ref: "slotRef",
        class: `${mergedClsPrefix}-anchor-link-background`
      }) : null, mergedShowRail ? vue.h("div", {
        class: `${mergedClsPrefix}-anchor-rail`
      }, vue.h("div", {
        ref: "barRef",
        class: [`${mergedClsPrefix}-anchor-rail__bar`, this.activeHref !== null && `${mergedClsPrefix}-anchor-rail__bar--active`]
      })) : null, (_a = $slots.default) === null || _a === void 0 ? void 0 : _a.call($slots));
      return this.internalScrollable ? vue.h(NScrollbar, null, {
        default: () => Anchor
      }) : Anchor;
    }
  });
  const anchorProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), {
    affix: Boolean
  }), affixProps), baseAnchorProps);
  const AnchorAdapter = vue.defineComponent({
    name: "Anchor",
    props: anchorProps,
    setup(props, {
      slots
    }) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Anchor", "-anchor", style$1o, anchorLight$1, props, mergedClsPrefixRef);
      const anchorRef = vue.ref(null);
      const cssVarsRef = vue.computed(() => {
        const {
          self: {
            railColor,
            linkColor,
            railColorActive,
            linkTextColor,
            linkTextColorHover,
            linkTextColorPressed,
            linkTextColorActive,
            linkFontSize,
            railWidth,
            linkPadding,
            borderRadius
          },
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          }
        } = themeRef.value;
        return {
          "--n-link-border-radius": borderRadius,
          "--n-link-color": linkColor,
          "--n-link-font-size": linkFontSize,
          "--n-link-text-color": linkTextColor,
          "--n-link-text-color-hover": linkTextColorHover,
          "--n-link-text-color-active": linkTextColorActive,
          "--n-link-text-color-pressed": linkTextColorPressed,
          "--n-link-padding": linkPadding,
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-rail-color": railColor,
          "--n-rail-color-active": railColorActive,
          "--n-rail-width": railWidth
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("anchor", void 0, cssVarsRef, props) : void 0;
      return {
        scrollTo(href) {
          var _a;
          (_a = anchorRef.value) === null || _a === void 0 ? void 0 : _a.setActiveHref(href);
        },
        renderAnchor: () => {
          themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender();
          return vue.h(NBaseAnchor, Object.assign({
            ref: anchorRef,
            style: inlineThemeDisabled ? void 0 : cssVarsRef.value,
            class: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value
          }, keep(props, baseAnchorPropKeys), {
            mergedClsPrefix: mergedClsPrefixRef.value
          }), slots);
        }
      };
    },
    render() {
      return !this.affix ? this.renderAnchor() : vue.h(NAffix, Object.assign({}, keep(this, affixPropKeys)), {
        default: this.renderAnchor
      });
    }
  });
  function getIsGroup(option) {
    return option.type === "group";
  }
  function getIgnored(option) {
    return option.type === "ignored";
  }
  function patternMatched(pattern, value) {
    try {
      return !!(1 + value.toString().toLowerCase().indexOf(pattern.trim().toLowerCase()));
    } catch (_a) {
      return false;
    }
  }
  function createTmOptions(valueField, childrenField) {
    const options = {
      getIsGroup,
      getIgnored,
      getKey(option) {
        if (getIsGroup(option)) {
          return option.name || option.key || "key-required";
        }
        return option[valueField];
      },
      getChildren(option) {
        return option[childrenField];
      }
    };
    return options;
  }
  function filterOptions(originalOpts, filter, pattern, childrenField) {
    if (!filter)
      return originalOpts;
    function traverse2(options) {
      if (!Array.isArray(options))
        return [];
      const filteredOptions = [];
      for (const option of options) {
        if (getIsGroup(option)) {
          const children = traverse2(option[childrenField]);
          if (children.length) {
            filteredOptions.push(Object.assign({}, option, {
              [childrenField]: children
            }));
          }
        } else if (getIgnored(option)) {
          continue;
        } else if (filter(pattern, option)) {
          filteredOptions.push(option);
        }
      }
      return filteredOptions;
    }
    return traverse2(originalOpts);
  }
  function createValOptMap(options, valueField, childrenField) {
    const valOptMap = /* @__PURE__ */ new Map();
    options.forEach((option) => {
      if (getIsGroup(option)) {
        option[childrenField].forEach((selectGroupOption) => {
          valOptMap.set(selectGroupOption[valueField], selectGroupOption);
        });
      } else {
        valOptMap.set(option[valueField], option);
      }
    });
    return valOptMap;
  }
  const isChrome = isBrowser$2 && "chrome" in window;
  isBrowser$2 && navigator.userAgent.includes("Firefox");
  const isSafari = isBrowser$2 && navigator.userAgent.includes("Safari") && !isChrome;
  const commonVariables$i = {
    paddingTiny: "0 8px",
    paddingSmall: "0 10px",
    paddingMedium: "0 12px",
    paddingLarge: "0 14px",
    clearSize: "16px"
  };
  function self$19(vars) {
    const {
      textColor2,
      textColor3,
      textColorDisabled,
      primaryColor,
      primaryColorHover,
      inputColor,
      inputColorDisabled,
      borderColor,
      warningColor,
      warningColorHover,
      errorColor,
      errorColorHover,
      borderRadius,
      lineHeight: lineHeight2,
      fontSizeTiny,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      heightTiny,
      heightSmall,
      heightMedium,
      heightLarge,
      actionColor,
      clearColor,
      clearColorHover,
      clearColorPressed,
      placeholderColor,
      placeholderColorDisabled,
      iconColor,
      iconColorDisabled,
      iconColorHover,
      iconColorPressed
    } = vars;
    return Object.assign(Object.assign({}, commonVariables$i), {
      countTextColorDisabled: textColorDisabled,
      countTextColor: textColor3,
      heightTiny,
      heightSmall,
      heightMedium,
      heightLarge,
      fontSizeTiny,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      lineHeight: lineHeight2,
      lineHeightTextarea: lineHeight2,
      borderRadius,
      iconSize: "16px",
      groupLabelColor: actionColor,
      groupLabelTextColor: textColor2,
      textColor: textColor2,
      textColorDisabled,
      textDecorationColor: textColor2,
      caretColor: primaryColor,
      placeholderColor,
      placeholderColorDisabled,
      color: inputColor,
      colorDisabled: inputColorDisabled,
      colorFocus: inputColor,
      groupLabelBorder: `1px solid ${borderColor}`,
      border: `1px solid ${borderColor}`,
      borderHover: `1px solid ${primaryColorHover}`,
      borderDisabled: `1px solid ${borderColor}`,
      borderFocus: `1px solid ${primaryColorHover}`,
      boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, {
        alpha: 0.2
      })}`,
      loadingColor: primaryColor,
      // warning
      loadingColorWarning: warningColor,
      borderWarning: `1px solid ${warningColor}`,
      borderHoverWarning: `1px solid ${warningColorHover}`,
      colorFocusWarning: inputColor,
      borderFocusWarning: `1px solid ${warningColorHover}`,
      boxShadowFocusWarning: `0 0 0 2px ${changeColor(warningColor, {
        alpha: 0.2
      })}`,
      caretColorWarning: warningColor,
      // error
      loadingColorError: errorColor,
      borderError: `1px solid ${errorColor}`,
      borderHoverError: `1px solid ${errorColorHover}`,
      colorFocusError: inputColor,
      borderFocusError: `1px solid ${errorColorHover}`,
      boxShadowFocusError: `0 0 0 2px ${changeColor(errorColor, {
        alpha: 0.2
      })}`,
      caretColorError: errorColor,
      clearColor,
      clearColorHover,
      clearColorPressed,
      iconColor,
      iconColorDisabled,
      iconColorHover,
      iconColorPressed,
      suffixTextColor: textColor2
    });
  }
  const inputLight = {
    name: "Input",
    common: commonLight,
    self: self$19
  };
  const inputLight$1 = inputLight;
  const inputInjectionKey = createInjectionKey("n-input");
  function len(s) {
    let count = 0;
    for (const _ of s) {
      count++;
    }
    return count;
  }
  function isEmptyInputValue(value) {
    return value === "" || value == null;
  }
  function useCursor(inputElRef) {
    const selectionRef = vue.ref(null);
    function recordCursor() {
      const {
        value: input
      } = inputElRef;
      if (!(input === null || input === void 0 ? void 0 : input.focus)) {
        reset();
        return;
      }
      const {
        selectionStart,
        selectionEnd,
        value
      } = input;
      if (selectionStart == null || selectionEnd == null) {
        reset();
        return;
      }
      selectionRef.value = {
        start: selectionStart,
        end: selectionEnd,
        beforeText: value.slice(0, selectionStart),
        afterText: value.slice(selectionEnd)
      };
    }
    function restoreCursor() {
      var _a;
      const {
        value: selection
      } = selectionRef;
      const {
        value: inputEl
      } = inputElRef;
      if (!selection || !inputEl) {
        return;
      }
      const {
        value
      } = inputEl;
      const {
        start,
        beforeText,
        afterText
      } = selection;
      let startPos = value.length;
      if (value.endsWith(afterText)) {
        startPos = value.length - afterText.length;
      } else if (value.startsWith(beforeText)) {
        startPos = beforeText.length;
      } else {
        const beforeLastChar = beforeText[start - 1];
        const newIndex = value.indexOf(beforeLastChar, start - 1);
        if (newIndex !== -1) {
          startPos = newIndex + 1;
        }
      }
      (_a = inputEl.setSelectionRange) === null || _a === void 0 ? void 0 : _a.call(inputEl, startPos, startPos);
    }
    function reset() {
      selectionRef.value = null;
    }
    vue.watch(inputElRef, reset);
    return {
      recordCursor,
      restoreCursor
    };
  }
  const WordCount = vue.defineComponent({
    name: "InputWordCount",
    setup(_, {
      slots
    }) {
      const {
        mergedValueRef,
        maxlengthRef,
        mergedClsPrefixRef,
        countGraphemesRef
      } = vue.inject(inputInjectionKey);
      const wordCountRef = vue.computed(() => {
        const {
          value: mergedValue
        } = mergedValueRef;
        if (mergedValue === null || Array.isArray(mergedValue))
          return 0;
        return (countGraphemesRef.value || len)(mergedValue);
      });
      return () => {
        const {
          value: maxlength
        } = maxlengthRef;
        const {
          value: mergedValue
        } = mergedValueRef;
        return vue.h("span", {
          class: `${mergedClsPrefixRef.value}-input-word-count`
        }, resolveSlotWithProps(slots.default, {
          value: mergedValue === null || Array.isArray(mergedValue) ? "" : mergedValue
        }, () => [maxlength === void 0 ? wordCountRef.value : `${wordCountRef.value} / ${maxlength}`]));
      };
    }
  });
  const style$1n = cB("input", `
 max-width: 100%;
 cursor: text;
 line-height: 1.5;
 z-index: auto;
 outline: none;
 box-sizing: border-box;
 position: relative;
 display: inline-flex;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color .3s var(--n-bezier);
 font-size: var(--n-font-size);
 --n-padding-vertical: calc((var(--n-height) - 1.5 * var(--n-font-size)) / 2);
`, [
    // common
    cE("input, textarea", `
 overflow: hidden;
 flex-grow: 1;
 position: relative;
 `),
    cE("input-el, textarea-el, input-mirror, textarea-mirror, separator, placeholder", `
 box-sizing: border-box;
 font-size: inherit;
 line-height: 1.5;
 font-family: inherit;
 border: none;
 outline: none;
 background-color: #0000;
 text-align: inherit;
 transition:
 -webkit-text-fill-color .3s var(--n-bezier),
 caret-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier);
 `),
    cE("input-el, textarea-el", `
 -webkit-appearance: none;
 scrollbar-width: none;
 width: 100%;
 min-width: 0;
 text-decoration-color: var(--n-text-decoration-color);
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 background-color: transparent;
 `, [c$1("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), c$1("&::placeholder", `
 color: #0000;
 -webkit-text-fill-color: transparent !important;
 `), c$1("&:-webkit-autofill ~", [cE("placeholder", "display: none;")])]),
    cM("round", [cNotM("textarea", "border-radius: calc(var(--n-height) / 2);")]),
    cE("placeholder", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 overflow: hidden;
 color: var(--n-placeholder-color);
 `, [c$1("span", `
 width: 100%;
 display: inline-block;
 `)]),
    cM("textarea", [cE("placeholder", "overflow: visible;")]),
    cNotM("autosize", "width: 100%;"),
    cM("autosize", [cE("textarea-el, input-el", `
 position: absolute;
 top: 0;
 left: 0;
 height: 100%;
 `)]),
    // input
    cB("input-wrapper", `
 overflow: hidden;
 display: inline-flex;
 flex-grow: 1;
 position: relative;
 padding-left: var(--n-padding-left);
 padding-right: var(--n-padding-right);
 `),
    cE("input-mirror", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre;
 pointer-events: none;
 `),
    cE("input-el", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [c$1("&[type=password]::-ms-reveal", "display: none;"), c$1("+", [cE("placeholder", `
 display: flex;
 align-items: center; 
 `)])]),
    cNotM("textarea", [cE("placeholder", "white-space: nowrap;")]),
    cE("eye", `
 display: flex;
 align-items: center;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `),
    // textarea
    cM("textarea", "width: 100%;", [cB("input-word-count", `
 position: absolute;
 right: var(--n-padding-right);
 bottom: var(--n-padding-vertical);
 `), cM("resizable", [cB("input-wrapper", `
 resize: vertical;
 min-height: var(--n-height);
 `)]), cE("textarea-el, textarea-mirror, placeholder", `
 height: 100%;
 padding-left: 0;
 padding-right: 0;
 padding-top: var(--n-padding-vertical);
 padding-bottom: var(--n-padding-vertical);
 word-break: break-word;
 display: inline-block;
 vertical-align: bottom;
 box-sizing: border-box;
 line-height: var(--n-line-height-textarea);
 margin: 0;
 resize: none;
 white-space: pre-wrap;
 scroll-padding-block-end: var(--n-padding-vertical);
 `), cE("textarea-mirror", `
 width: 100%;
 pointer-events: none;
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre-wrap;
 overflow-wrap: break-word;
 `)]),
    // pair
    cM("pair", [cE("input-el, placeholder", "text-align: center;"), cE("separator", `
 display: flex;
 align-items: center;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 white-space: nowrap;
 `, [cB("icon", `
 color: var(--n-icon-color);
 `), cB("base-icon", `
 color: var(--n-icon-color);
 `)])]),
    cM("disabled", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [cE("border", "border: var(--n-border-disabled);"), cE("input-el, textarea-el", `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 text-decoration-color: var(--n-text-color-disabled);
 `), cE("placeholder", "color: var(--n-placeholder-color-disabled);"), cE("separator", "color: var(--n-text-color-disabled);", [cB("icon", `
 color: var(--n-icon-color-disabled);
 `), cB("base-icon", `
 color: var(--n-icon-color-disabled);
 `)]), cB("input-word-count", `
 color: var(--n-count-text-color-disabled);
 `), cE("suffix, prefix", "color: var(--n-text-color-disabled);", [cB("icon", `
 color: var(--n-icon-color-disabled);
 `), cB("internal-icon", `
 color: var(--n-icon-color-disabled);
 `)])]),
    cNotM("disabled", [cE("eye", `
 color: var(--n-icon-color);
 cursor: pointer;
 `, [c$1("&:hover", `
 color: var(--n-icon-color-hover);
 `), c$1("&:active", `
 color: var(--n-icon-color-pressed);
 `)]), c$1("&:hover", [cE("state-border", "border: var(--n-border-hover);")]), cM("focus", "background-color: var(--n-color-focus);", [cE("state-border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]),
    cE("border, state-border", `
 box-sizing: border-box;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border-radius: inherit;
 border: var(--n-border);
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `),
    cE("state-border", `
 border-color: #0000;
 z-index: 1;
 `),
    cE("prefix", "margin-right: 4px;"),
    cE("suffix", `
 margin-left: 4px;
 `),
    cE("suffix, prefix", `
 transition: color .3s var(--n-bezier);
 flex-wrap: nowrap;
 flex-shrink: 0;
 line-height: var(--n-height);
 white-space: nowrap;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 color: var(--n-suffix-text-color);
 `, [cB("base-loading", `
 font-size: var(--n-icon-size);
 margin: 0 2px;
 color: var(--n-loading-color);
 `), cB("base-clear", `
 font-size: var(--n-icon-size);
 `, [cE("placeholder", [cB("base-icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)])]), c$1(">", [cB("icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)]), cB("base-icon", `
 font-size: var(--n-icon-size);
 `)]),
    cB("input-word-count", `
 pointer-events: none;
 line-height: 1.5;
 font-size: .85em;
 color: var(--n-count-text-color);
 transition: color .3s var(--n-bezier);
 margin-left: 4px;
 font-variant: tabular-nums;
 `),
    ["warning", "error"].map((status) => cM(`${status}-status`, [cNotM("disabled", [cB("base-loading", `
 color: var(--n-loading-color-${status})
 `), cE("input-el, textarea-el", `
 caret-color: var(--n-caret-color-${status});
 `), cE("state-border", `
 border: var(--n-border-${status});
 `), c$1("&:hover", [cE("state-border", `
 border: var(--n-border-hover-${status});
 `)]), c$1("&:focus", `
 background-color: var(--n-color-focus-${status});
 `, [cE("state-border", `
 box-shadow: var(--n-box-shadow-focus-${status});
 border: var(--n-border-focus-${status});
 `)]), cM("focus", `
 background-color: var(--n-color-focus-${status});
 `, [cE("state-border", `
 box-shadow: var(--n-box-shadow-focus-${status});
 border: var(--n-border-focus-${status});
 `)])])]))
  ]);
  const safariStyle = cB("input", [cM("disabled", [cE("input-el, textarea-el", `
 -webkit-text-fill-color: var(--n-text-color-disabled);
 `)])]);
  const inputProps = Object.assign(Object.assign({}, useTheme.props), {
    bordered: {
      type: Boolean,
      default: void 0
    },
    type: {
      type: String,
      default: "text"
    },
    placeholder: [Array, String],
    defaultValue: {
      type: [String, Array],
      default: null
    },
    value: [String, Array],
    disabled: {
      type: Boolean,
      default: void 0
    },
    size: String,
    rows: {
      type: [Number, String],
      default: 3
    },
    round: Boolean,
    minlength: [String, Number],
    maxlength: [String, Number],
    clearable: Boolean,
    autosize: {
      type: [Boolean, Object],
      default: false
    },
    pair: Boolean,
    separator: String,
    readonly: {
      type: [String, Boolean],
      default: false
    },
    passivelyActivated: Boolean,
    showPasswordOn: String,
    stateful: {
      type: Boolean,
      default: true
    },
    autofocus: Boolean,
    inputProps: Object,
    resizable: {
      type: Boolean,
      default: true
    },
    showCount: Boolean,
    loading: {
      type: Boolean,
      default: void 0
    },
    allowInput: Function,
    renderCount: Function,
    onMousedown: Function,
    onKeydown: Function,
    onKeyup: [Function, Array],
    onInput: [Function, Array],
    onFocus: [Function, Array],
    onBlur: [Function, Array],
    onClick: [Function, Array],
    onChange: [Function, Array],
    onClear: [Function, Array],
    countGraphemes: Function,
    status: String,
    "onUpdate:value": [Function, Array],
    onUpdateValue: [Function, Array],
    /** private */
    textDecoration: [String, Array],
    attrSize: {
      type: Number,
      default: 20
    },
    onInputBlur: [Function, Array],
    onInputFocus: [Function, Array],
    onDeactivate: [Function, Array],
    onActivate: [Function, Array],
    onWrapperFocus: [Function, Array],
    onWrapperBlur: [Function, Array],
    internalDeactivateOnEnter: Boolean,
    internalForceFocus: Boolean,
    internalLoadingBeforeSuffix: {
      type: Boolean,
      default: true
    },
    /** deprecated */
    showPasswordToggle: Boolean
  });
  const NInput = vue.defineComponent({
    name: "Input",
    props: inputProps,
    setup(props) {
      {
        vue.watchEffect(() => {
          if (props.showPasswordToggle) {
            warnOnce("input", '`show-password-toggle` is deprecated, please use `showPasswordOn="click"` instead');
          }
        });
      }
      const {
        mergedClsPrefixRef,
        mergedBorderedRef,
        inlineThemeDisabled,
        mergedRtlRef
      } = useConfig(props);
      const themeRef = useTheme("Input", "-input", style$1n, inputLight$1, props, mergedClsPrefixRef);
      if (isSafari) {
        useStyle("-input-safari", safariStyle, mergedClsPrefixRef);
      }
      const wrapperElRef = vue.ref(null);
      const textareaElRef = vue.ref(null);
      const textareaMirrorElRef = vue.ref(null);
      const inputMirrorElRef = vue.ref(null);
      const inputElRef = vue.ref(null);
      const inputEl2Ref = vue.ref(null);
      const currentFocusedInputRef = vue.ref(null);
      const focusedInputCursorControl = useCursor(currentFocusedInputRef);
      const textareaScrollbarInstRef = vue.ref(null);
      const {
        localeRef
      } = useLocale("Input");
      const uncontrolledValueRef = vue.ref(props.defaultValue);
      const controlledValueRef = vue.toRef(props, "value");
      const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
      const formItem = useFormItem(props);
      const {
        mergedSizeRef,
        mergedDisabledRef,
        mergedStatusRef
      } = formItem;
      const focusedRef = vue.ref(false);
      const hoverRef = vue.ref(false);
      const isComposingRef2 = vue.ref(false);
      const activatedRef = vue.ref(false);
      let syncSource = null;
      const mergedPlaceholderRef = vue.computed(() => {
        const {
          placeholder,
          pair
        } = props;
        if (pair) {
          if (Array.isArray(placeholder)) {
            return placeholder;
          } else if (placeholder === void 0) {
            return ["", ""];
          }
          return [placeholder, placeholder];
        } else if (placeholder === void 0) {
          return [localeRef.value.placeholder];
        } else {
          return [placeholder];
        }
      });
      const showPlaceholder1Ref = vue.computed(() => {
        const {
          value: isComposing
        } = isComposingRef2;
        const {
          value: mergedValue
        } = mergedValueRef;
        const {
          value: mergedPlaceholder
        } = mergedPlaceholderRef;
        return !isComposing && (isEmptyInputValue(mergedValue) || Array.isArray(mergedValue) && isEmptyInputValue(mergedValue[0])) && mergedPlaceholder[0];
      });
      const showPlaceholder2Ref = vue.computed(() => {
        const {
          value: isComposing
        } = isComposingRef2;
        const {
          value: mergedValue
        } = mergedValueRef;
        const {
          value: mergedPlaceholder
        } = mergedPlaceholderRef;
        return !isComposing && mergedPlaceholder[1] && (isEmptyInputValue(mergedValue) || Array.isArray(mergedValue) && isEmptyInputValue(mergedValue[1]));
      });
      const mergedFocusRef = useMemo(() => {
        return props.internalForceFocus || focusedRef.value;
      });
      const showClearButton = useMemo(() => {
        if (mergedDisabledRef.value || props.readonly || !props.clearable || !mergedFocusRef.value && !hoverRef.value) {
          return false;
        }
        const {
          value: mergedValue
        } = mergedValueRef;
        const {
          value: mergedFocus
        } = mergedFocusRef;
        if (props.pair) {
          return !!(Array.isArray(mergedValue) && (mergedValue[0] || mergedValue[1])) && (hoverRef.value || mergedFocus);
        } else {
          return !!mergedValue && (hoverRef.value || mergedFocus);
        }
      });
      const mergedShowPasswordOnRef = vue.computed(() => {
        const {
          showPasswordOn
        } = props;
        if (showPasswordOn) {
          return showPasswordOn;
        }
        if (props.showPasswordToggle)
          return "click";
        return void 0;
      });
      const passwordVisibleRef = vue.ref(false);
      const textDecorationStyleRef = vue.computed(() => {
        const {
          textDecoration
        } = props;
        if (!textDecoration)
          return ["", ""];
        if (Array.isArray(textDecoration)) {
          return textDecoration.map((v) => ({
            textDecoration: v
          }));
        }
        return [{
          textDecoration
        }];
      });
      const textAreaScrollContainerWidthRef = vue.ref(void 0);
      const updateTextAreaStyle = () => {
        var _a, _b;
        if (props.type === "textarea") {
          const {
            autosize
          } = props;
          if (autosize) {
            textAreaScrollContainerWidthRef.value = (_b = (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.$el) === null || _b === void 0 ? void 0 : _b.offsetWidth;
          }
          if (!textareaElRef.value)
            return;
          if (typeof autosize === "boolean")
            return;
          const {
            paddingTop: stylePaddingTop,
            paddingBottom: stylePaddingBottom,
            lineHeight: styleLineHeight
          } = window.getComputedStyle(textareaElRef.value);
          const paddingTop = Number(stylePaddingTop.slice(0, -2));
          const paddingBottom = Number(stylePaddingBottom.slice(0, -2));
          const lineHeight2 = Number(styleLineHeight.slice(0, -2));
          const {
            value: textareaMirrorEl
          } = textareaMirrorElRef;
          if (!textareaMirrorEl)
            return;
          if (autosize.minRows) {
            const minRows = Math.max(autosize.minRows, 1);
            const styleMinHeight = `${paddingTop + paddingBottom + lineHeight2 * minRows}px`;
            textareaMirrorEl.style.minHeight = styleMinHeight;
          }
          if (autosize.maxRows) {
            const styleMaxHeight = `${paddingTop + paddingBottom + lineHeight2 * autosize.maxRows}px`;
            textareaMirrorEl.style.maxHeight = styleMaxHeight;
          }
        }
      };
      const maxlengthRef = vue.computed(() => {
        const {
          maxlength
        } = props;
        return maxlength === void 0 ? void 0 : Number(maxlength);
      });
      vue.onMounted(() => {
        const {
          value
        } = mergedValueRef;
        if (!Array.isArray(value)) {
          syncMirror(value);
        }
      });
      const vm = vue.getCurrentInstance().proxy;
      function doUpdateValue(value, meta) {
        const {
          onUpdateValue,
          "onUpdate:value": _onUpdateValue,
          onInput
        } = props;
        const {
          nTriggerFormInput
        } = formItem;
        if (onUpdateValue)
          call(onUpdateValue, value, meta);
        if (_onUpdateValue)
          call(_onUpdateValue, value, meta);
        if (onInput)
          call(onInput, value, meta);
        uncontrolledValueRef.value = value;
        nTriggerFormInput();
      }
      function doChange(value, meta) {
        const {
          onChange
        } = props;
        const {
          nTriggerFormChange
        } = formItem;
        if (onChange)
          call(onChange, value, meta);
        uncontrolledValueRef.value = value;
        nTriggerFormChange();
      }
      function doBlur(e) {
        const {
          onBlur
        } = props;
        const {
          nTriggerFormBlur
        } = formItem;
        if (onBlur)
          call(onBlur, e);
        nTriggerFormBlur();
      }
      function doFocus(e) {
        const {
          onFocus
        } = props;
        const {
          nTriggerFormFocus
        } = formItem;
        if (onFocus)
          call(onFocus, e);
        nTriggerFormFocus();
      }
      function doClear(e) {
        const {
          onClear
        } = props;
        if (onClear)
          call(onClear, e);
      }
      function doUpdateValueBlur(e) {
        const {
          onInputBlur
        } = props;
        if (onInputBlur)
          call(onInputBlur, e);
      }
      function doUpdateValueFocus(e) {
        const {
          onInputFocus
        } = props;
        if (onInputFocus)
          call(onInputFocus, e);
      }
      function doDeactivate() {
        const {
          onDeactivate
        } = props;
        if (onDeactivate)
          call(onDeactivate);
      }
      function doActivate() {
        const {
          onActivate
        } = props;
        if (onActivate)
          call(onActivate);
      }
      function doClick(e) {
        const {
          onClick
        } = props;
        if (onClick)
          call(onClick, e);
      }
      function doWrapperFocus(e) {
        const {
          onWrapperFocus
        } = props;
        if (onWrapperFocus)
          call(onWrapperFocus, e);
      }
      function doWrapperBlur(e) {
        const {
          onWrapperBlur
        } = props;
        if (onWrapperBlur)
          call(onWrapperBlur, e);
      }
      function handleCompositionStart() {
        isComposingRef2.value = true;
      }
      function handleCompositionEnd(e) {
        isComposingRef2.value = false;
        if (e.target === inputEl2Ref.value) {
          handleInput(e, 1);
        } else {
          handleInput(e, 0);
        }
      }
      function handleInput(e, index = 0, event = "input") {
        const targetValue = e.target.value;
        syncMirror(targetValue);
        if (e instanceof InputEvent && !e.isComposing) {
          isComposingRef2.value = false;
        }
        if (props.type === "textarea") {
          const {
            value: textareaScrollbarInst
          } = textareaScrollbarInstRef;
          if (textareaScrollbarInst) {
            textareaScrollbarInst.syncUnifiedContainer();
          }
        }
        syncSource = targetValue;
        if (isComposingRef2.value)
          return;
        focusedInputCursorControl.recordCursor();
        const isIncomingValueValid = allowInput(targetValue);
        if (isIncomingValueValid) {
          if (!props.pair) {
            if (event === "input") {
              doUpdateValue(targetValue, {
                source: index
              });
            } else {
              doChange(targetValue, {
                source: index
              });
            }
          } else {
            let {
              value
            } = mergedValueRef;
            if (!Array.isArray(value)) {
              value = ["", ""];
            } else {
              value = [value[0], value[1]];
            }
            value[index] = targetValue;
            if (event === "input") {
              doUpdateValue(value, {
                source: index
              });
            } else {
              doChange(value, {
                source: index
              });
            }
          }
        }
        vm.$forceUpdate();
        if (!isIncomingValueValid) {
          void vue.nextTick(focusedInputCursorControl.restoreCursor);
        }
      }
      function allowInput(value) {
        const {
          countGraphemes,
          maxlength,
          minlength
        } = props;
        if (countGraphemes) {
          let graphemesCount;
          if (maxlength !== void 0) {
            if (graphemesCount === void 0) {
              graphemesCount = countGraphemes(value);
            }
            if (graphemesCount > Number(maxlength))
              return false;
          }
          if (minlength !== void 0) {
            if (graphemesCount === void 0) {
              graphemesCount = countGraphemes(value);
            }
            if (graphemesCount < Number(maxlength))
              return false;
          }
        }
        const {
          allowInput: allowInput2
        } = props;
        if (typeof allowInput2 === "function") {
          return allowInput2(value);
        }
        return true;
      }
      function handleInputBlur(e) {
        doUpdateValueBlur(e);
        if (e.relatedTarget === wrapperElRef.value) {
          doDeactivate();
        }
        if (!(e.relatedTarget !== null && (e.relatedTarget === inputElRef.value || e.relatedTarget === inputEl2Ref.value || e.relatedTarget === textareaElRef.value))) {
          activatedRef.value = false;
        }
        dealWithEvent(e, "blur");
        currentFocusedInputRef.value = null;
      }
      function handleInputFocus(e, index) {
        doUpdateValueFocus(e);
        focusedRef.value = true;
        activatedRef.value = true;
        doActivate();
        dealWithEvent(e, "focus");
        if (index === 0) {
          currentFocusedInputRef.value = inputElRef.value;
        } else if (index === 1) {
          currentFocusedInputRef.value = inputEl2Ref.value;
        } else if (index === 2) {
          currentFocusedInputRef.value = textareaElRef.value;
        }
      }
      function handleWrapperBlur(e) {
        if (props.passivelyActivated) {
          doWrapperBlur(e);
          dealWithEvent(e, "blur");
        }
      }
      function handleWrapperFocus(e) {
        if (props.passivelyActivated) {
          focusedRef.value = true;
          doWrapperFocus(e);
          dealWithEvent(e, "focus");
        }
      }
      function dealWithEvent(e, type) {
        if (e.relatedTarget !== null && (e.relatedTarget === inputElRef.value || e.relatedTarget === inputEl2Ref.value || e.relatedTarget === textareaElRef.value || e.relatedTarget === wrapperElRef.value))
          ;
        else {
          if (type === "focus") {
            doFocus(e);
            focusedRef.value = true;
          } else if (type === "blur") {
            doBlur(e);
            focusedRef.value = false;
          }
        }
      }
      function handleChange(e, index) {
        handleInput(e, index, "change");
      }
      function handleClick2(e) {
        doClick(e);
      }
      function handleClear(e) {
        doClear(e);
        clearValue();
      }
      function clearValue() {
        if (props.pair) {
          doUpdateValue(["", ""], {
            source: "clear"
          });
          doChange(["", ""], {
            source: "clear"
          });
        } else {
          doUpdateValue("", {
            source: "clear"
          });
          doChange("", {
            source: "clear"
          });
        }
      }
      function handleMouseDown(e) {
        const {
          onMousedown
        } = props;
        if (onMousedown)
          onMousedown(e);
        const {
          tagName
        } = e.target;
        if (tagName !== "INPUT" && tagName !== "TEXTAREA") {
          if (props.resizable) {
            const {
              value: wrapperEl
            } = wrapperElRef;
            if (wrapperEl) {
              const {
                left,
                top,
                width,
                height
              } = wrapperEl.getBoundingClientRect();
              const resizeHandleSize = 14;
              if (left + width - resizeHandleSize < e.clientX && e.clientX < left + width && top + height - resizeHandleSize < e.clientY && e.clientY < top + height) {
                return;
              }
            }
          }
          e.preventDefault();
          if (!focusedRef.value) {
            focus();
          }
        }
      }
      function handleMouseEnter() {
        var _a;
        hoverRef.value = true;
        if (props.type === "textarea") {
          (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.handleMouseEnterWrapper();
        }
      }
      function handleMouseLeave() {
        var _a;
        hoverRef.value = false;
        if (props.type === "textarea") {
          (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.handleMouseLeaveWrapper();
        }
      }
      function handlePasswordToggleClick() {
        if (mergedDisabledRef.value)
          return;
        if (mergedShowPasswordOnRef.value !== "click")
          return;
        passwordVisibleRef.value = !passwordVisibleRef.value;
      }
      function handlePasswordToggleMousedown(e) {
        if (mergedDisabledRef.value)
          return;
        e.preventDefault();
        const preventDefaultOnce = (e2) => {
          e2.preventDefault();
          off("mouseup", document, preventDefaultOnce);
        };
        on("mouseup", document, preventDefaultOnce);
        if (mergedShowPasswordOnRef.value !== "mousedown")
          return;
        passwordVisibleRef.value = true;
        const hidePassword = () => {
          passwordVisibleRef.value = false;
          off("mouseup", document, hidePassword);
        };
        on("mouseup", document, hidePassword);
      }
      function handleWrapperKeyup(e) {
        if (props.onKeyup)
          call(props.onKeyup, e);
      }
      function handleWrapperKeydown(e) {
        if (props.onKeydown)
          call(props.onKeydown, e);
        switch (e.key) {
          case "Escape":
            handleWrapperKeydownEsc();
            break;
          case "Enter":
            handleWrapperKeydownEnter(e);
            break;
        }
      }
      function handleWrapperKeydownEnter(e) {
        var _a, _b;
        if (props.passivelyActivated) {
          const {
            value: focused
          } = activatedRef;
          if (focused) {
            if (props.internalDeactivateOnEnter) {
              handleWrapperKeydownEsc();
            }
            return;
          }
          e.preventDefault();
          if (props.type === "textarea") {
            (_a = textareaElRef.value) === null || _a === void 0 ? void 0 : _a.focus();
          } else {
            (_b = inputElRef.value) === null || _b === void 0 ? void 0 : _b.focus();
          }
        }
      }
      function handleWrapperKeydownEsc() {
        if (props.passivelyActivated) {
          activatedRef.value = false;
          void vue.nextTick(() => {
            var _a;
            (_a = wrapperElRef.value) === null || _a === void 0 ? void 0 : _a.focus();
          });
        }
      }
      function focus() {
        var _a, _b, _c;
        if (mergedDisabledRef.value)
          return;
        if (props.passivelyActivated) {
          (_a = wrapperElRef.value) === null || _a === void 0 ? void 0 : _a.focus();
        } else {
          (_b = textareaElRef.value) === null || _b === void 0 ? void 0 : _b.focus();
          (_c = inputElRef.value) === null || _c === void 0 ? void 0 : _c.focus();
        }
      }
      function blur() {
        var _a;
        if ((_a = wrapperElRef.value) === null || _a === void 0 ? void 0 : _a.contains(document.activeElement)) {
          document.activeElement.blur();
        }
      }
      function select() {
        var _a, _b;
        (_a = textareaElRef.value) === null || _a === void 0 ? void 0 : _a.select();
        (_b = inputElRef.value) === null || _b === void 0 ? void 0 : _b.select();
      }
      function activate() {
        if (mergedDisabledRef.value)
          return;
        if (textareaElRef.value)
          textareaElRef.value.focus();
        else if (inputElRef.value)
          inputElRef.value.focus();
      }
      function deactivate() {
        const {
          value: wrapperEl
        } = wrapperElRef;
        if ((wrapperEl === null || wrapperEl === void 0 ? void 0 : wrapperEl.contains(document.activeElement)) && wrapperEl !== document.activeElement) {
          handleWrapperKeydownEsc();
        }
      }
      function scrollTo(options) {
        if (props.type === "textarea") {
          const {
            value: textareaEl
          } = textareaElRef;
          textareaEl === null || textareaEl === void 0 ? void 0 : textareaEl.scrollTo(options);
        } else {
          const {
            value: inputEl
          } = inputElRef;
          inputEl === null || inputEl === void 0 ? void 0 : inputEl.scrollTo(options);
        }
      }
      function syncMirror(value) {
        const {
          type,
          pair,
          autosize
        } = props;
        if (!pair && autosize) {
          if (type === "textarea") {
            const {
              value: textareaMirrorEl
            } = textareaMirrorElRef;
            if (textareaMirrorEl) {
              textareaMirrorEl.textContent = `${value !== null && value !== void 0 ? value : ""}\r
`;
            }
          } else {
            const {
              value: inputMirrorEl
            } = inputMirrorElRef;
            if (inputMirrorEl) {
              if (value) {
                inputMirrorEl.textContent = value;
              } else {
                inputMirrorEl.innerHTML = "&nbsp;";
              }
            }
          }
        }
      }
      function handleTextAreaMirrorResize() {
        updateTextAreaStyle();
      }
      const placeholderStyleRef = vue.ref({
        top: "0"
      });
      function handleTextAreaScroll(e) {
        var _a;
        const {
          scrollTop
        } = e.target;
        placeholderStyleRef.value.top = `${-scrollTop}px`;
        (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.syncUnifiedContainer();
      }
      let stopWatchMergedValue1 = null;
      vue.watchEffect(() => {
        const {
          autosize,
          type
        } = props;
        if (autosize && type === "textarea") {
          stopWatchMergedValue1 = vue.watch(mergedValueRef, (value) => {
            if (!Array.isArray(value) && value !== syncSource) {
              syncMirror(value);
            }
          });
        } else {
          stopWatchMergedValue1 === null || stopWatchMergedValue1 === void 0 ? void 0 : stopWatchMergedValue1();
        }
      });
      let stopWatchMergedValue2 = null;
      vue.watchEffect(() => {
        if (props.type === "textarea") {
          stopWatchMergedValue2 = vue.watch(mergedValueRef, (value) => {
            var _a;
            if (!Array.isArray(value) && value !== syncSource) {
              (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.syncUnifiedContainer();
            }
          });
        } else {
          stopWatchMergedValue2 === null || stopWatchMergedValue2 === void 0 ? void 0 : stopWatchMergedValue2();
        }
      });
      vue.provide(inputInjectionKey, {
        mergedValueRef,
        maxlengthRef,
        mergedClsPrefixRef,
        countGraphemesRef: vue.toRef(props, "countGraphemes")
      });
      const exposedProps = {
        wrapperElRef,
        inputElRef,
        textareaElRef,
        isCompositing: isComposingRef2,
        clear: clearValue,
        focus,
        blur,
        select,
        deactivate,
        activate,
        scrollTo
      };
      const rtlEnabledRef = useRtl("Input", mergedRtlRef, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          value: size2
        } = mergedSizeRef;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            color,
            borderRadius,
            textColor,
            caretColor,
            caretColorError,
            caretColorWarning,
            textDecorationColor,
            border,
            borderDisabled,
            borderHover,
            borderFocus,
            placeholderColor,
            placeholderColorDisabled,
            lineHeightTextarea,
            colorDisabled,
            colorFocus,
            textColorDisabled,
            boxShadowFocus,
            iconSize,
            colorFocusWarning,
            boxShadowFocusWarning,
            borderWarning,
            borderFocusWarning,
            borderHoverWarning,
            colorFocusError,
            boxShadowFocusError,
            borderError,
            borderFocusError,
            borderHoverError,
            clearSize,
            clearColor,
            clearColorHover,
            clearColorPressed,
            iconColor,
            iconColorDisabled,
            suffixTextColor,
            countTextColor,
            countTextColorDisabled,
            iconColorHover,
            iconColorPressed,
            loadingColor,
            loadingColorError,
            loadingColorWarning,
            [createKey("padding", size2)]: padding,
            [createKey("fontSize", size2)]: fontSize2,
            [createKey("height", size2)]: height
          }
        } = themeRef.value;
        const {
          left: paddingLeft,
          right: paddingRight
        } = getMargin(padding);
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-count-text-color": countTextColor,
          "--n-count-text-color-disabled": countTextColorDisabled,
          "--n-color": color,
          "--n-font-size": fontSize2,
          "--n-border-radius": borderRadius,
          "--n-height": height,
          "--n-padding-left": paddingLeft,
          "--n-padding-right": paddingRight,
          "--n-text-color": textColor,
          "--n-caret-color": caretColor,
          "--n-text-decoration-color": textDecorationColor,
          "--n-border": border,
          "--n-border-disabled": borderDisabled,
          "--n-border-hover": borderHover,
          "--n-border-focus": borderFocus,
          "--n-placeholder-color": placeholderColor,
          "--n-placeholder-color-disabled": placeholderColorDisabled,
          "--n-icon-size": iconSize,
          "--n-line-height-textarea": lineHeightTextarea,
          "--n-color-disabled": colorDisabled,
          "--n-color-focus": colorFocus,
          "--n-text-color-disabled": textColorDisabled,
          "--n-box-shadow-focus": boxShadowFocus,
          "--n-loading-color": loadingColor,
          // form warning
          "--n-caret-color-warning": caretColorWarning,
          "--n-color-focus-warning": colorFocusWarning,
          "--n-box-shadow-focus-warning": boxShadowFocusWarning,
          "--n-border-warning": borderWarning,
          "--n-border-focus-warning": borderFocusWarning,
          "--n-border-hover-warning": borderHoverWarning,
          "--n-loading-color-warning": loadingColorWarning,
          // form error
          "--n-caret-color-error": caretColorError,
          "--n-color-focus-error": colorFocusError,
          "--n-box-shadow-focus-error": boxShadowFocusError,
          "--n-border-error": borderError,
          "--n-border-focus-error": borderFocusError,
          "--n-border-hover-error": borderHoverError,
          "--n-loading-color-error": loadingColorError,
          // clear-button
          "--n-clear-color": clearColor,
          "--n-clear-size": clearSize,
          "--n-clear-color-hover": clearColorHover,
          "--n-clear-color-pressed": clearColorPressed,
          "--n-icon-color": iconColor,
          "--n-icon-color-hover": iconColorHover,
          "--n-icon-color-pressed": iconColorPressed,
          "--n-icon-color-disabled": iconColorDisabled,
          "--n-suffix-text-color": suffixTextColor
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("input", vue.computed(() => {
        const {
          value: size2
        } = mergedSizeRef;
        return size2[0];
      }), cssVarsRef, props) : void 0;
      return Object.assign(Object.assign({}, exposedProps), {
        // DOM ref
        wrapperElRef,
        inputElRef,
        inputMirrorElRef,
        inputEl2Ref,
        textareaElRef,
        textareaMirrorElRef,
        textareaScrollbarInstRef,
        // value
        rtlEnabled: rtlEnabledRef,
        uncontrolledValue: uncontrolledValueRef,
        mergedValue: mergedValueRef,
        passwordVisible: passwordVisibleRef,
        mergedPlaceholder: mergedPlaceholderRef,
        showPlaceholder1: showPlaceholder1Ref,
        showPlaceholder2: showPlaceholder2Ref,
        mergedFocus: mergedFocusRef,
        isComposing: isComposingRef2,
        activated: activatedRef,
        showClearButton,
        mergedSize: mergedSizeRef,
        mergedDisabled: mergedDisabledRef,
        textDecorationStyle: textDecorationStyleRef,
        mergedClsPrefix: mergedClsPrefixRef,
        mergedBordered: mergedBorderedRef,
        mergedShowPasswordOn: mergedShowPasswordOnRef,
        placeholderStyle: placeholderStyleRef,
        mergedStatus: mergedStatusRef,
        textAreaScrollContainerWidth: textAreaScrollContainerWidthRef,
        // methods
        handleTextAreaScroll,
        handleCompositionStart,
        handleCompositionEnd,
        handleInput,
        handleInputBlur,
        handleInputFocus,
        handleWrapperBlur,
        handleWrapperFocus,
        handleMouseEnter,
        handleMouseLeave,
        handleMouseDown,
        handleChange,
        handleClick: handleClick2,
        handleClear,
        handlePasswordToggleClick,
        handlePasswordToggleMousedown,
        handleWrapperKeydown,
        handleWrapperKeyup,
        handleTextAreaMirrorResize,
        getTextareaScrollContainer: () => {
          return textareaElRef.value;
        },
        mergedTheme: themeRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      });
    },
    render() {
      var _a, _b;
      const {
        mergedClsPrefix,
        mergedStatus,
        themeClass,
        type,
        countGraphemes,
        onRender
      } = this;
      const $slots = this.$slots;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h("div", {
        ref: "wrapperElRef",
        class: [`${mergedClsPrefix}-input`, themeClass, mergedStatus && `${mergedClsPrefix}-input--${mergedStatus}-status`, {
          [`${mergedClsPrefix}-input--rtl`]: this.rtlEnabled,
          [`${mergedClsPrefix}-input--disabled`]: this.mergedDisabled,
          [`${mergedClsPrefix}-input--textarea`]: type === "textarea",
          [`${mergedClsPrefix}-input--resizable`]: this.resizable && !this.autosize,
          [`${mergedClsPrefix}-input--autosize`]: this.autosize,
          [`${mergedClsPrefix}-input--round`]: this.round && !(type === "textarea"),
          [`${mergedClsPrefix}-input--pair`]: this.pair,
          [`${mergedClsPrefix}-input--focus`]: this.mergedFocus,
          [`${mergedClsPrefix}-input--stateful`]: this.stateful
        }],
        style: this.cssVars,
        tabindex: !this.mergedDisabled && this.passivelyActivated && !this.activated ? 0 : void 0,
        onFocus: this.handleWrapperFocus,
        onBlur: this.handleWrapperBlur,
        onClick: this.handleClick,
        onMousedown: this.handleMouseDown,
        onMouseenter: this.handleMouseEnter,
        onMouseleave: this.handleMouseLeave,
        onCompositionstart: this.handleCompositionStart,
        onCompositionend: this.handleCompositionEnd,
        onKeyup: this.handleWrapperKeyup,
        onKeydown: this.handleWrapperKeydown
      }, vue.h("div", {
        class: `${mergedClsPrefix}-input-wrapper`
      }, resolveWrappedSlot($slots.prefix, (children) => children && vue.h("div", {
        class: `${mergedClsPrefix}-input__prefix`
      }, children)), type === "textarea" ? vue.h(NScrollbar, {
        ref: "textareaScrollbarInstRef",
        class: `${mergedClsPrefix}-input__textarea`,
        container: this.getTextareaScrollContainer,
        triggerDisplayManually: true,
        useUnifiedContainer: true,
        internalHoistYRail: true
      }, {
        default: () => {
          var _a2, _b2;
          const {
            textAreaScrollContainerWidth
          } = this;
          const scrollContainerWidthStyle = {
            width: this.autosize && textAreaScrollContainerWidth && `${textAreaScrollContainerWidth}px`
          };
          return vue.h(vue.Fragment, null, vue.h("textarea", Object.assign({}, this.inputProps, {
            ref: "textareaElRef",
            class: [`${mergedClsPrefix}-input__textarea-el`, (_a2 = this.inputProps) === null || _a2 === void 0 ? void 0 : _a2.class],
            autofocus: this.autofocus,
            rows: Number(this.rows),
            placeholder: this.placeholder,
            value: this.mergedValue,
            disabled: this.mergedDisabled,
            maxlength: countGraphemes ? void 0 : this.maxlength,
            minlength: countGraphemes ? void 0 : this.minlength,
            readonly: this.readonly,
            tabindex: this.passivelyActivated && !this.activated ? -1 : void 0,
            style: [this.textDecorationStyle[0], (_b2 = this.inputProps) === null || _b2 === void 0 ? void 0 : _b2.style, scrollContainerWidthStyle],
            onBlur: this.handleInputBlur,
            onFocus: (e) => {
              this.handleInputFocus(e, 2);
            },
            onInput: this.handleInput,
            onChange: this.handleChange,
            onScroll: this.handleTextAreaScroll
          })), this.showPlaceholder1 ? vue.h("div", {
            class: `${mergedClsPrefix}-input__placeholder`,
            style: [this.placeholderStyle, scrollContainerWidthStyle],
            key: "placeholder"
          }, this.mergedPlaceholder[0]) : null, this.autosize ? vue.h(VResizeObserver, {
            onResize: this.handleTextAreaMirrorResize
          }, {
            default: () => vue.h("div", {
              ref: "textareaMirrorElRef",
              class: `${mergedClsPrefix}-input__textarea-mirror`,
              key: "mirror"
            })
          }) : null);
        }
      }) : vue.h("div", {
        class: `${mergedClsPrefix}-input__input`
      }, vue.h("input", Object.assign({
        type: type === "password" && this.mergedShowPasswordOn && this.passwordVisible ? "text" : type
      }, this.inputProps, {
        ref: "inputElRef",
        class: [`${mergedClsPrefix}-input__input-el`, (_a = this.inputProps) === null || _a === void 0 ? void 0 : _a.class],
        style: [this.textDecorationStyle[0], (_b = this.inputProps) === null || _b === void 0 ? void 0 : _b.style],
        tabindex: this.passivelyActivated && !this.activated ? -1 : void 0,
        placeholder: this.mergedPlaceholder[0],
        disabled: this.mergedDisabled,
        maxlength: countGraphemes ? void 0 : this.maxlength,
        minlength: countGraphemes ? void 0 : this.minlength,
        value: Array.isArray(this.mergedValue) ? this.mergedValue[0] : this.mergedValue,
        readonly: this.readonly,
        autofocus: this.autofocus,
        size: this.attrSize,
        onBlur: this.handleInputBlur,
        onFocus: (e) => {
          this.handleInputFocus(e, 0);
        },
        onInput: (e) => {
          this.handleInput(e, 0);
        },
        onChange: (e) => {
          this.handleChange(e, 0);
        }
      })), this.showPlaceholder1 ? vue.h("div", {
        class: `${mergedClsPrefix}-input__placeholder`
      }, vue.h("span", null, this.mergedPlaceholder[0])) : null, this.autosize ? vue.h("div", {
        class: `${mergedClsPrefix}-input__input-mirror`,
        key: "mirror",
        ref: "inputMirrorElRef"
      }, " ") : null), !this.pair && resolveWrappedSlot($slots.suffix, (children) => {
        return children || this.clearable || this.showCount || this.mergedShowPasswordOn || this.loading !== void 0 ? vue.h("div", {
          class: `${mergedClsPrefix}-input__suffix`
        }, [resolveWrappedSlot($slots["clear-icon-placeholder"], (children2) => {
          return (this.clearable || children2) && vue.h(NBaseClear, {
            clsPrefix: mergedClsPrefix,
            show: this.showClearButton,
            onClear: this.handleClear
          }, {
            placeholder: () => children2,
            icon: () => {
              var _a2, _b2;
              return (_b2 = (_a2 = this.$slots)["clear-icon"]) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
            }
          });
        }), !this.internalLoadingBeforeSuffix ? children : null, this.loading !== void 0 ? vue.h(NBaseSuffix, {
          clsPrefix: mergedClsPrefix,
          loading: this.loading,
          showArrow: false,
          showClear: false,
          style: this.cssVars
        }) : null, this.internalLoadingBeforeSuffix ? children : null, this.showCount && this.type !== "textarea" ? vue.h(WordCount, null, {
          default: (props) => {
            var _a2;
            return (_a2 = $slots.count) === null || _a2 === void 0 ? void 0 : _a2.call($slots, props);
          }
        }) : null, this.mergedShowPasswordOn && this.type === "password" ? vue.h("div", {
          class: `${mergedClsPrefix}-input__eye`,
          onMousedown: this.handlePasswordToggleMousedown,
          onClick: this.handlePasswordToggleClick
        }, this.passwordVisible ? resolveSlot($slots["password-visible-icon"], () => [vue.h(NBaseIcon, {
          clsPrefix: mergedClsPrefix
        }, {
          default: () => vue.h(EyeIcon, null)
        })]) : resolveSlot($slots["password-invisible-icon"], () => [vue.h(NBaseIcon, {
          clsPrefix: mergedClsPrefix
        }, {
          default: () => vue.h(EyeOffIcon, null)
        })])) : null]) : null;
      })), this.pair ? vue.h("span", {
        class: `${mergedClsPrefix}-input__separator`
      }, resolveSlot($slots.separator, () => [this.separator])) : null, this.pair ? vue.h("div", {
        class: `${mergedClsPrefix}-input-wrapper`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-input__input`
      }, vue.h("input", {
        ref: "inputEl2Ref",
        type: this.type,
        class: `${mergedClsPrefix}-input__input-el`,
        tabindex: this.passivelyActivated && !this.activated ? -1 : void 0,
        placeholder: this.mergedPlaceholder[1],
        disabled: this.mergedDisabled,
        maxlength: countGraphemes ? void 0 : this.maxlength,
        minlength: countGraphemes ? void 0 : this.minlength,
        value: Array.isArray(this.mergedValue) ? this.mergedValue[1] : void 0,
        readonly: this.readonly,
        style: this.textDecorationStyle[1],
        onBlur: this.handleInputBlur,
        onFocus: (e) => {
          this.handleInputFocus(e, 1);
        },
        onInput: (e) => {
          this.handleInput(e, 1);
        },
        onChange: (e) => {
          this.handleChange(e, 1);
        }
      }), this.showPlaceholder2 ? vue.h("div", {
        class: `${mergedClsPrefix}-input__placeholder`
      }, vue.h("span", null, this.mergedPlaceholder[1])) : null), resolveWrappedSlot($slots.suffix, (children) => {
        return (this.clearable || children) && vue.h("div", {
          class: `${mergedClsPrefix}-input__suffix`
        }, [this.clearable && vue.h(NBaseClear, {
          clsPrefix: mergedClsPrefix,
          show: this.showClearButton,
          onClear: this.handleClear
        }, {
          icon: () => {
            var _a2;
            return (_a2 = $slots["clear-icon"]) === null || _a2 === void 0 ? void 0 : _a2.call($slots);
          },
          placeholder: () => {
            var _a2;
            return (_a2 = $slots["clear-icon-placeholder"]) === null || _a2 === void 0 ? void 0 : _a2.call($slots);
          }
        }), children]);
      })) : null, this.mergedBordered ? vue.h("div", {
        class: `${mergedClsPrefix}-input__border`
      }) : null, this.mergedBordered ? vue.h("div", {
        class: `${mergedClsPrefix}-input__state-border`
      }) : null, this.showCount && type === "textarea" ? vue.h(WordCount, null, {
        default: (props) => {
          var _a2;
          const {
            renderCount
          } = this;
          if (renderCount) {
            return renderCount(props);
          }
          return (_a2 = $slots.count) === null || _a2 === void 0 ? void 0 : _a2.call($slots, props);
        }
      }) : null);
    }
  });
  const style$1m = cB("input-group", `
 display: inline-flex;
 width: 100%;
 flex-wrap: nowrap;
 vertical-align: bottom;
`, [c$1(">", [cB("input", [c$1("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), c$1("&:not(:first-child)", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 margin-left: -1px!important;
 `)]), cB("button", [c$1("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `, [cE("state-border, border", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `)]), c$1("&:not(:first-child)", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `, [cE("state-border, border", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `)])]), c$1("*", [c$1("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `, [c$1(">", [cB("input", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), cB("base-selection", [cB("base-selection-label", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), cB("base-selection-tags", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), cE("box-shadow, border, state-border", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `)])])]), c$1("&:not(:first-child)", `
 margin-left: -1px!important;
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `, [c$1(">", [cB("input", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), cB("base-selection", [cB("base-selection-label", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), cB("base-selection-tags", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), cE("box-shadow, border, state-border", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `)])])])])])]);
  const inputGroupProps = {};
  const NInputGroup = vue.defineComponent({
    name: "InputGroup",
    props: inputGroupProps,
    setup(props) {
      const {
        mergedClsPrefixRef
      } = useConfig(props);
      useStyle("-input-group", style$1m, mergedClsPrefixRef);
      return {
        mergedClsPrefix: mergedClsPrefixRef
      };
    },
    render() {
      const {
        mergedClsPrefix
      } = this;
      return vue.h("div", {
        class: `${mergedClsPrefix}-input-group`
      }, this.$slots);
    }
  });
  const style$1l = cB("input-group-label", `
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 box-sizing: border-box;
 padding: 0 12px;
 display: inline-block;
 border-radius: var(--n-border-radius);
 background-color: var(--n-group-label-color);
 color: var(--n-group-label-text-color);
 font-size: var(--n-font-size);
 line-height: var(--n-height);
 height: var(--n-height);
 flex-shrink: 0;
 white-space: nowrap;
 transition: 
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
`, [cE("border", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 border: var(--n-group-label-border);
 transition: border-color .3s var(--n-bezier);
 `)]);
  const inputGroupLabelProps = Object.assign(Object.assign({}, useTheme.props), {
    size: {
      type: String,
      default: "medium"
    },
    bordered: {
      type: Boolean,
      default: void 0
    }
  });
  const InputGroupLabel = vue.defineComponent({
    name: "InputGroupLabel",
    props: inputGroupLabelProps,
    setup(props) {
      const {
        mergedBorderedRef,
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Input", "-input-group-label", style$1l, inputLight$1, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          size: size2
        } = props;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            groupLabelColor,
            borderRadius,
            groupLabelTextColor,
            lineHeight: lineHeight2,
            groupLabelBorder,
            [createKey("fontSize", size2)]: fontSize2,
            [createKey("height", size2)]: height
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-group-label-color": groupLabelColor,
          "--n-group-label-border": groupLabelBorder,
          "--n-border-radius": borderRadius,
          "--n-group-label-text-color": groupLabelTextColor,
          "--n-font-size": fontSize2,
          "--n-line-height": lineHeight2,
          "--n-height": height
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("input-group-label", vue.computed(() => props.size[0]), cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        mergedBordered: mergedBorderedRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a, _b, _c;
      const {
        mergedClsPrefix
      } = this;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      return vue.h("div", {
        class: [`${mergedClsPrefix}-input-group-label`, this.themeClass],
        style: this.cssVars
      }, (_c = (_b = this.$slots).default) === null || _c === void 0 ? void 0 : _c.call(_b), this.mergedBordered ? vue.h("div", {
        class: `${mergedClsPrefix}-input-group-label__border`
      }) : null);
    }
  });
  function self$18(vars) {
    const {
      boxShadow2
    } = vars;
    return {
      menuBoxShadow: boxShadow2
    };
  }
  const autoCompleteLight = createTheme({
    name: "AutoComplete",
    common: commonLight,
    peers: {
      InternalSelectMenu: internalSelectMenuLight$1,
      Input: inputLight$1
    },
    self: self$18
  });
  const autoCompleteLight$1 = autoCompleteLight;
  function mapAutoCompleteOptionsToSelectOptions(options) {
    return options.map(convertAutoCompleteOptionToSelectOption);
  }
  function convertAutoCompleteOptionToSelectOption(option) {
    var _a, _b;
    if (typeof option === "string") {
      return {
        label: option,
        value: option
      };
    } else if (option.type === "group") {
      const groupOption = {
        type: "group",
        label: (_a = option.label) !== null && _a !== void 0 ? _a : option.name,
        value: (_b = option.value) !== null && _b !== void 0 ? _b : option.name,
        key: option.key || option.name,
        children: option.children.map((groupOption2) => convertAutoCompleteOptionToSelectOption(groupOption2))
      };
      return groupOption;
    } else {
      return option;
    }
  }
  const style$1k = c$1([cB("auto-complete", `
 z-index: auto;
 position: relative;
 display: inline-flex;
 width: 100%;
 `), cB("auto-complete-menu", `
 margin: 4px 0;
 box-shadow: var(--n-menu-box-shadow);
 `, [fadeInScaleUpTransition({
    originalTransition: "background-color .3s var(--n-bezier), box-shadow .3s var(--n-bezier)"
  })])]);
  const autoCompleteProps = Object.assign(Object.assign({}, useTheme.props), {
    to: useAdjustedTo.propTo,
    menuProps: Object,
    append: Boolean,
    bordered: {
      type: Boolean,
      default: void 0
    },
    clearable: {
      type: Boolean,
      default: void 0
    },
    defaultValue: {
      type: String,
      default: null
    },
    loading: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    placeholder: String,
    placement: {
      type: String,
      default: "bottom-start"
    },
    value: String,
    blurAfterSelect: Boolean,
    clearAfterSelect: Boolean,
    getShow: Function,
    showEmpty: Boolean,
    inputProps: Object,
    renderOption: Function,
    renderLabel: Function,
    size: String,
    options: {
      type: Array,
      default: () => []
    },
    zIndex: Number,
    status: String,
    "onUpdate:value": [Function, Array],
    onUpdateValue: [Function, Array],
    onSelect: [Function, Array],
    onBlur: [Function, Array],
    onFocus: [Function, Array],
    // deprecated
    onInput: [Function, Array]
  });
  const AutoComplete = vue.defineComponent({
    name: "AutoComplete",
    props: autoCompleteProps,
    setup(props) {
      {
        vue.watchEffect(() => {
          if (props.onInput !== void 0) {
            warnOnce("auto-complete", "`on-input` is deprecated, please use `on-update:value` instead.");
          }
        });
      }
      const {
        mergedBorderedRef,
        namespaceRef,
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const formItem = useFormItem(props);
      const {
        mergedSizeRef,
        mergedDisabledRef,
        mergedStatusRef
      } = formItem;
      const triggerElRef = vue.ref(null);
      const menuInstRef = vue.ref(null);
      const uncontrolledValueRef = vue.ref(props.defaultValue);
      const controlledValueRef = vue.toRef(props, "value");
      const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
      const canBeActivatedRef = vue.ref(false);
      const isComposingRef2 = vue.ref(false);
      const themeRef = useTheme("AutoComplete", "-auto-complete", style$1k, autoCompleteLight$1, props, mergedClsPrefixRef);
      const selectOptionsRef = vue.computed(() => {
        return mapAutoCompleteOptionsToSelectOptions(props.options);
      });
      const mergedShowOptionsRef = vue.computed(() => {
        const {
          getShow
        } = props;
        if (getShow) {
          return getShow(mergedValueRef.value || "");
        }
        return !!mergedValueRef.value;
      });
      const activeRef = vue.computed(() => {
        return mergedShowOptionsRef.value && canBeActivatedRef.value && (props.showEmpty ? true : !!selectOptionsRef.value.length);
      });
      const treeMateRef = vue.computed(() => createTreeMate(selectOptionsRef.value, createTmOptions("value", "children")));
      function doUpdateValue(value) {
        const {
          "onUpdate:value": _onUpdateValue,
          onUpdateValue,
          onInput
        } = props;
        const {
          nTriggerFormInput,
          nTriggerFormChange
        } = formItem;
        if (onUpdateValue)
          call(onUpdateValue, value);
        if (_onUpdateValue)
          call(_onUpdateValue, value);
        if (onInput)
          call(onInput, value);
        uncontrolledValueRef.value = value;
        nTriggerFormInput();
        nTriggerFormChange();
      }
      function doSelect(value) {
        const {
          onSelect
        } = props;
        const {
          nTriggerFormInput,
          nTriggerFormChange
        } = formItem;
        if (onSelect)
          call(onSelect, value);
        nTriggerFormInput();
        nTriggerFormChange();
      }
      function doBlur(e) {
        const {
          onBlur
        } = props;
        const {
          nTriggerFormBlur
        } = formItem;
        if (onBlur)
          call(onBlur, e);
        nTriggerFormBlur();
      }
      function doFocus(e) {
        const {
          onFocus
        } = props;
        const {
          nTriggerFormFocus
        } = formItem;
        if (onFocus)
          call(onFocus, e);
        nTriggerFormFocus();
      }
      function handleCompositionStart() {
        isComposingRef2.value = true;
      }
      function handleCompositionEnd() {
        window.setTimeout(() => {
          isComposingRef2.value = false;
        }, 0);
      }
      function handleKeyDown(e) {
        var _a, _b, _c;
        switch (e.key) {
          case "Enter":
            if (!isComposingRef2.value) {
              const pendingOptionTmNode = (_a = menuInstRef.value) === null || _a === void 0 ? void 0 : _a.getPendingTmNode();
              if (pendingOptionTmNode) {
                select(pendingOptionTmNode.rawNode);
                e.preventDefault();
              }
            }
            break;
          case "ArrowDown":
            (_b = menuInstRef.value) === null || _b === void 0 ? void 0 : _b.next();
            break;
          case "ArrowUp":
            (_c = menuInstRef.value) === null || _c === void 0 ? void 0 : _c.prev();
            break;
        }
      }
      function select(option) {
        if ((option === null || option === void 0 ? void 0 : option.value) !== void 0) {
          doSelect(option.value);
          if (props.clearAfterSelect) {
            doUpdateValue(null);
          } else if (option.label !== void 0) {
            doUpdateValue(props.append ? `${mergedValueRef.value}${option.label}` : option.label);
          }
          canBeActivatedRef.value = false;
          if (props.blurAfterSelect) {
            blur();
          }
        }
      }
      function handleClear() {
        doUpdateValue(null);
      }
      function handleFocus(e) {
        canBeActivatedRef.value = true;
        doFocus(e);
      }
      function handleBlur(e) {
        canBeActivatedRef.value = false;
        doBlur(e);
      }
      function handleInput(value) {
        canBeActivatedRef.value = true;
        doUpdateValue(value);
      }
      function handleToggle(option) {
        select(option.rawNode);
      }
      function handleClickOutsideMenu(e) {
        var _a;
        if (!((_a = triggerElRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(e)))) {
          canBeActivatedRef.value = false;
        }
      }
      function blur() {
        var _a, _b;
        if ((_a = triggerElRef.value) === null || _a === void 0 ? void 0 : _a.contains(document.activeElement)) {
          (_b = document.activeElement) === null || _b === void 0 ? void 0 : _b.blur();
        }
      }
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            menuBoxShadow
          }
        } = themeRef.value;
        return {
          "--n-menu-box-shadow": menuBoxShadow,
          "--n-bezier": cubicBezierEaseInOut2
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("auto-complete", void 0, cssVarsRef, props) : void 0;
      const inputInstRef = vue.ref(null);
      const exposedMethods = {
        focus: () => {
          var _a;
          (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
        },
        blur: () => {
          var _a;
          (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.blur();
        }
      };
      return {
        focus: exposedMethods.focus,
        blur: exposedMethods.blur,
        inputInstRef,
        uncontrolledValue: uncontrolledValueRef,
        mergedValue: mergedValueRef,
        isMounted: isMounted(),
        adjustedTo: useAdjustedTo(props),
        menuInstRef,
        triggerElRef,
        treeMate: treeMateRef,
        mergedSize: mergedSizeRef,
        mergedDisabled: mergedDisabledRef,
        active: activeRef,
        mergedStatus: mergedStatusRef,
        handleClear,
        handleFocus,
        handleBlur,
        handleInput,
        handleToggle,
        handleClickOutsideMenu,
        handleCompositionStart,
        handleCompositionEnd,
        handleKeyDown,
        mergedTheme: themeRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
        mergedBordered: mergedBorderedRef,
        namespace: namespaceRef,
        mergedClsPrefix: mergedClsPrefixRef
      };
    },
    render() {
      const {
        mergedClsPrefix
      } = this;
      return vue.h("div", {
        class: `${mergedClsPrefix}-auto-complete`,
        ref: "triggerElRef",
        onKeydown: this.handleKeyDown,
        onCompositionstart: this.handleCompositionStart,
        onCompositionend: this.handleCompositionEnd
      }, vue.h(VBinder, null, {
        default: () => [vue.h(VTarget, null, {
          default: () => {
            const defaultSlot = this.$slots.default;
            if (defaultSlot) {
              return getFirstSlotVNode(this.$slots, "default", {
                handleInput: this.handleInput,
                handleFocus: this.handleFocus,
                handleBlur: this.handleBlur,
                value: this.mergedValue
              });
            }
            const {
              mergedTheme
            } = this;
            return vue.h(NInput, {
              ref: "inputInstRef",
              status: this.mergedStatus,
              theme: mergedTheme.peers.Input,
              themeOverrides: mergedTheme.peerOverrides.Input,
              bordered: this.mergedBordered,
              value: this.mergedValue,
              placeholder: this.placeholder,
              size: this.mergedSize,
              disabled: this.mergedDisabled,
              clearable: this.clearable,
              loading: this.loading,
              inputProps: this.inputProps,
              onClear: this.handleClear,
              onFocus: this.handleFocus,
              onUpdateValue: this.handleInput,
              onBlur: this.handleBlur
            }, {
              suffix: () => {
                var _a, _b;
                return (_b = (_a = this.$slots).suffix) === null || _b === void 0 ? void 0 : _b.call(_a);
              },
              prefix: () => {
                var _a, _b;
                return (_b = (_a = this.$slots).prefix) === null || _b === void 0 ? void 0 : _b.call(_a);
              }
            });
          }
        }), vue.h(VFollower, {
          show: this.active,
          to: this.adjustedTo,
          containerClass: this.namespace,
          zIndex: this.zIndex,
          teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey,
          placement: this.placement,
          width: "target"
        }, {
          default: () => vue.h(vue.Transition, {
            name: "fade-in-scale-up-transition",
            appear: this.isMounted
          }, {
            default: () => {
              var _a;
              (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
              if (!this.active)
                return null;
              const {
                menuProps: menuProps2
              } = this;
              return vue.withDirectives(vue.h(NInternalSelectMenu, Object.assign({}, menuProps2, {
                clsPrefix: mergedClsPrefix,
                ref: "menuInstRef",
                theme: this.mergedTheme.peers.InternalSelectMenu,
                themeOverrides: this.mergedTheme.peerOverrides.InternalSelectMenu,
                "auto-pending": true,
                class: [`${mergedClsPrefix}-auto-complete-menu`, this.themeClass, menuProps2 === null || menuProps2 === void 0 ? void 0 : menuProps2.class],
                style: [menuProps2 === null || menuProps2 === void 0 ? void 0 : menuProps2.style, this.cssVars],
                treeMate: this.treeMate,
                multiple: false,
                renderLabel: this.renderLabel,
                renderOption: this.renderOption,
                size: "medium",
                onToggle: this.handleToggle
              }), {
                empty: () => {
                  var _a2, _b;
                  return (_b = (_a2 = this.$slots).empty) === null || _b === void 0 ? void 0 : _b.call(_a2);
                }
              }), [[clickoutside$1, this.handleClickOutsideMenu, void 0, {
                capture: true
              }]]);
            }
          })
        })]
      }));
    }
  });
  const isImageSupportNativeLazy = isBrowser$2 && "loading" in document.createElement("img");
  function resolveOptionsAndHash(options = {}) {
    var _a;
    const {
      root: root2 = null
    } = options;
    return {
      hash: `${options.rootMargin || "0px 0px 0px 0px"}-${Array.isArray(options.threshold) ? options.threshold.join(",") : (_a = options.threshold) !== null && _a !== void 0 ? _a : "0"}`,
      options: Object.assign(Object.assign({}, options), {
        root: (typeof root2 === "string" ? document.querySelector(root2) : root2) || document.documentElement
      })
    };
  }
  const observers = /* @__PURE__ */ new WeakMap();
  const unobserveHandleMap = /* @__PURE__ */ new WeakMap();
  const shouldStartLoadingRefMap = /* @__PURE__ */ new WeakMap();
  const observeIntersection = (el, options, shouldStartLoadingRef) => {
    if (!el)
      return () => {
      };
    const resolvedOptionsAndHash = resolveOptionsAndHash(options);
    const {
      root: root2
    } = resolvedOptionsAndHash.options;
    let rootObservers;
    const _rootObservers = observers.get(root2);
    if (_rootObservers) {
      rootObservers = _rootObservers;
    } else {
      rootObservers = /* @__PURE__ */ new Map();
      observers.set(root2, rootObservers);
    }
    let observer;
    let observerAndObservedElements;
    if (rootObservers.has(resolvedOptionsAndHash.hash)) {
      observerAndObservedElements = rootObservers.get(resolvedOptionsAndHash.hash);
      if (!observerAndObservedElements[1].has(el)) {
        observer = observerAndObservedElements[0];
        observerAndObservedElements[1].add(el);
        observer.observe(el);
      }
    } else {
      observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const _unobserve = unobserveHandleMap.get(entry.target);
            const _shouldStartLoadingRef = shouldStartLoadingRefMap.get(entry.target);
            if (_unobserve)
              _unobserve();
            if (_shouldStartLoadingRef) {
              _shouldStartLoadingRef.value = true;
            }
          }
        });
      }, resolvedOptionsAndHash.options);
      observer.observe(el);
      observerAndObservedElements = [observer, /* @__PURE__ */ new Set([el])];
      rootObservers.set(resolvedOptionsAndHash.hash, observerAndObservedElements);
    }
    let unobservered = false;
    const unobserve = () => {
      if (unobservered)
        return;
      unobserveHandleMap.delete(el);
      shouldStartLoadingRefMap.delete(el);
      unobservered = true;
      if (observerAndObservedElements[1].has(el)) {
        observerAndObservedElements[0].unobserve(el);
        observerAndObservedElements[1].delete(el);
      }
      if (observerAndObservedElements[1].size <= 0) {
        rootObservers.delete(resolvedOptionsAndHash.hash);
      }
      if (!rootObservers.size) {
        observers.delete(root2);
      }
    };
    unobserveHandleMap.set(el, unobserve);
    shouldStartLoadingRefMap.set(el, shouldStartLoadingRef);
    return unobserve;
  };
  function self$17(vars) {
    const {
      borderRadius,
      avatarColor,
      cardColor,
      fontSize: fontSize2,
      heightTiny,
      heightSmall,
      heightMedium,
      heightLarge,
      heightHuge,
      modalColor,
      popoverColor
    } = vars;
    return {
      borderRadius,
      fontSize: fontSize2,
      border: `2px solid ${cardColor}`,
      heightTiny,
      heightSmall,
      heightMedium,
      heightLarge,
      heightHuge,
      color: composite(cardColor, avatarColor),
      colorModal: composite(modalColor, avatarColor),
      colorPopover: composite(popoverColor, avatarColor)
    };
  }
  const avatarLight = {
    name: "Avatar",
    common: commonLight,
    self: self$17
  };
  const avatarLight$1 = avatarLight;
  const avatarGroupInjectionKey = createInjectionKey("n-avatar-group");
  const style$1j = cB("avatar", `
 width: var(--n-merged-size);
 height: var(--n-merged-size);
 color: #FFF;
 font-size: var(--n-font-size);
 display: inline-flex;
 position: relative;
 overflow: hidden;
 text-align: center;
 border: var(--n-border);
 border-radius: var(--n-border-radius);
 --n-merged-color: var(--n-color);
 background-color: var(--n-merged-color);
 transition:
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
`, [insideModal(c$1("&", "--n-merged-color: var(--n-color-modal);")), insidePopover(c$1("&", "--n-merged-color: var(--n-color-popover);")), c$1("img", `
 width: 100%;
 height: 100%;
 `), cE("text", `
 white-space: nowrap;
 display: inline-block;
 position: absolute;
 left: 50%;
 top: 50%;
 `), cB("icon", `
 vertical-align: bottom;
 font-size: calc(var(--n-merged-size) - 6px);
 `), cE("text", "line-height: 1.25")]);
  const avatarProps = Object.assign(Object.assign({}, useTheme.props), {
    size: [String, Number],
    src: String,
    circle: {
      type: Boolean,
      default: void 0
    },
    objectFit: String,
    round: {
      type: Boolean,
      default: void 0
    },
    bordered: {
      type: Boolean,
      default: void 0
    },
    onError: Function,
    fallbackSrc: String,
    intersectionObserverOptions: Object,
    lazy: Boolean,
    onLoad: Function,
    renderPlaceholder: Function,
    renderFallback: Function,
    imgProps: Object,
    /** @deprecated */
    color: String
  });
  const NAvatar = vue.defineComponent({
    name: "Avatar",
    props: avatarProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const hasLoadErrorRef = vue.ref(false);
      let memoedTextHtml = null;
      const textRef = vue.ref(null);
      const selfRef = vue.ref(null);
      const fitTextTransform = () => {
        const {
          value: textEl
        } = textRef;
        if (textEl) {
          if (memoedTextHtml === null || memoedTextHtml !== textEl.innerHTML) {
            memoedTextHtml = textEl.innerHTML;
            const {
              value: selfEl
            } = selfRef;
            if (selfEl) {
              const {
                offsetWidth: elWidth,
                offsetHeight: elHeight
              } = selfEl;
              const {
                offsetWidth: textWidth,
                offsetHeight: textHeight
              } = textEl;
              const radix = 0.9;
              const ratio = Math.min(elWidth / textWidth * radix, elHeight / textHeight * radix, 1);
              textEl.style.transform = `translateX(-50%) translateY(-50%) scale(${ratio})`;
            }
          }
        }
      };
      const NAvatarGroup = vue.inject(avatarGroupInjectionKey, null);
      const mergedSizeRef = vue.computed(() => {
        const {
          size: size2
        } = props;
        if (size2)
          return size2;
        const {
          size: avatarGroupSize
        } = NAvatarGroup || {};
        if (avatarGroupSize)
          return avatarGroupSize;
        return "medium";
      });
      const themeRef = useTheme("Avatar", "-avatar", style$1j, avatarLight$1, props, mergedClsPrefixRef);
      const TagInjection = vue.inject(tagInjectionKey, null);
      const mergedRoundRef = vue.computed(() => {
        if (NAvatarGroup)
          return true;
        const {
          round: round2,
          circle
        } = props;
        if (round2 !== void 0 || circle !== void 0)
          return round2 || circle;
        if (TagInjection) {
          return TagInjection.roundRef.value;
        }
        return false;
      });
      const mergedBorderedRef = vue.computed(() => {
        if (NAvatarGroup)
          return true;
        return props.bordered || false;
      });
      const cssVarsRef = vue.computed(() => {
        const size2 = mergedSizeRef.value;
        const round2 = mergedRoundRef.value;
        const bordered = mergedBorderedRef.value;
        const {
          color: propColor
        } = props;
        const {
          self: {
            borderRadius,
            fontSize: fontSize2,
            color,
            border,
            colorModal,
            colorPopover
          },
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          }
        } = themeRef.value;
        let height;
        if (typeof size2 === "number") {
          height = `${size2}px`;
        } else {
          height = themeRef.value.self[createKey("height", size2)];
        }
        return {
          "--n-font-size": fontSize2,
          "--n-border": bordered ? border : "none",
          "--n-border-radius": round2 ? "50%" : borderRadius,
          "--n-color": propColor || color,
          "--n-color-modal": propColor || colorModal,
          "--n-color-popover": propColor || colorPopover,
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-merged-size": `var(--n-avatar-size-override, ${height})`
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("avatar", vue.computed(() => {
        const size2 = mergedSizeRef.value;
        const round2 = mergedRoundRef.value;
        const bordered = mergedBorderedRef.value;
        const {
          color
        } = props;
        let hash = "";
        if (size2) {
          if (typeof size2 === "number") {
            hash += `a${size2}`;
          } else {
            hash += size2[0];
          }
        }
        if (round2) {
          hash += "b";
        }
        if (bordered) {
          hash += "c";
        }
        if (color) {
          hash += color2Class(color);
        }
        return hash;
      }), cssVarsRef, props) : void 0;
      const shouldStartLoadingRef = vue.ref(!props.lazy);
      vue.onMounted(() => {
        if (props.lazy && props.intersectionObserverOptions) {
          let unobserve;
          const stopWatchHandle = vue.watchEffect(() => {
            unobserve === null || unobserve === void 0 ? void 0 : unobserve();
            unobserve = void 0;
            if (props.lazy) {
              unobserve = observeIntersection(selfRef.value, props.intersectionObserverOptions, shouldStartLoadingRef);
            }
          });
          vue.onBeforeUnmount(() => {
            stopWatchHandle();
            unobserve === null || unobserve === void 0 ? void 0 : unobserve();
          });
        }
      });
      vue.watch(() => {
        var _a;
        return props.src || ((_a = props.imgProps) === null || _a === void 0 ? void 0 : _a.src);
      }, () => {
        hasLoadErrorRef.value = false;
      });
      const loadedRef = vue.ref(!props.lazy);
      return {
        textRef,
        selfRef,
        mergedRoundRef,
        mergedClsPrefix: mergedClsPrefixRef,
        fitTextTransform,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
        hasLoadError: hasLoadErrorRef,
        shouldStartLoading: shouldStartLoadingRef,
        loaded: loadedRef,
        mergedOnError: (e) => {
          if (!shouldStartLoadingRef.value)
            return;
          hasLoadErrorRef.value = true;
          const {
            onError,
            imgProps: {
              onError: imgPropsOnError
            } = {}
          } = props;
          onError === null || onError === void 0 ? void 0 : onError(e);
          imgPropsOnError === null || imgPropsOnError === void 0 ? void 0 : imgPropsOnError(e);
        },
        mergedOnLoad: (e) => {
          const {
            onLoad,
            imgProps: {
              onLoad: imgPropsOnLoad
            } = {}
          } = props;
          onLoad === null || onLoad === void 0 ? void 0 : onLoad(e);
          imgPropsOnLoad === null || imgPropsOnLoad === void 0 ? void 0 : imgPropsOnLoad(e);
          loadedRef.value = true;
        }
      };
    },
    render() {
      var _a, _b;
      const {
        $slots,
        src,
        mergedClsPrefix,
        lazy,
        onRender,
        loaded,
        hasLoadError,
        imgProps = {}
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      let img;
      const placeholderNode = !loaded && !hasLoadError && (this.renderPlaceholder ? this.renderPlaceholder() : (_b = (_a = this.$slots).placeholder) === null || _b === void 0 ? void 0 : _b.call(_a));
      if (this.hasLoadError) {
        img = this.renderFallback ? this.renderFallback() : resolveSlot($slots.fallback, () => [vue.h("img", {
          src: this.fallbackSrc,
          style: {
            objectFit: this.objectFit
          }
        })]);
      } else {
        img = resolveWrappedSlot($slots.default, (children) => {
          if (children) {
            return vue.h(VResizeObserver, {
              onResize: this.fitTextTransform
            }, {
              default: () => vue.h("span", {
                ref: "textRef",
                class: `${mergedClsPrefix}-avatar__text`
              }, children)
            });
          } else if (src || imgProps.src) {
            const loadSrc = this.src || imgProps.src;
            return vue.h("img", Object.assign(Object.assign({}, imgProps), {
              loading: (
                // If interseciton observer options is set, do not use native lazy
                isImageSupportNativeLazy && !this.intersectionObserverOptions && lazy ? "lazy" : "eager"
              ),
              src: lazy && this.intersectionObserverOptions ? this.shouldStartLoading ? loadSrc : void 0 : loadSrc,
              "data-image-src": loadSrc,
              onLoad: this.mergedOnLoad,
              onError: this.mergedOnError,
              style: [imgProps.style || "", {
                objectFit: this.objectFit
              }, placeholderNode ? {
                height: "0",
                width: "0",
                visibility: "hidden",
                position: "absolute"
              } : ""]
            }));
          }
        });
      }
      return vue.h("span", {
        ref: "selfRef",
        class: [`${mergedClsPrefix}-avatar`, this.themeClass],
        style: this.cssVars
      }, img, lazy && placeholderNode);
    }
  });
  function self$16() {
    return {
      gap: "-12px"
    };
  }
  const avatarGroupLight = createTheme({
    name: "AvatarGroup",
    common: commonLight,
    peers: {
      Avatar: avatarLight$1
    },
    self: self$16
  });
  const avatarGroupLight$1 = avatarGroupLight;
  const style$1i = cB("avatar-group", `
 flex-wrap: nowrap;
 display: inline-flex;
 position: relative;
`, [cM("expand-on-hover", [cB("avatar", [c$1("&:not(:first-child)", `
 transition: margin .3s var(--n-bezier);
 `)]), c$1("&:hover", [cNotM("vertical", [cB("avatar", [c$1("&:not(:first-child)", `
 margin-left: 0 !important;
 `)])]), cM("vertical", [cB("avatar", [c$1("&:not(:first-child)", `
 margin-top: 0 !important;
 `)])])])]), cNotM("vertical", `
 flex-direction: row;
 `, [cB("avatar", [c$1("&:not(:first-child)", `
 margin-left: var(--n-gap);
 `)])]), cM("vertical", `
 flex-direction: column;
 `, [cB("avatar", [c$1("&:not(:first-child)", `
 margin-top: var(--n-gap);
 `)])])]);
  const avatarGroupProps = Object.assign(Object.assign({}, useTheme.props), {
    max: Number,
    maxStyle: [Object, String],
    options: {
      type: Array,
      default: () => []
    },
    vertical: Boolean,
    expandOnHover: Boolean,
    size: [String, Number]
  });
  const AvatarGroup = vue.defineComponent({
    name: "AvatarGroup",
    props: avatarGroupProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        mergedRtlRef
      } = useConfig(props);
      const mergedThemeRef = useTheme("AvatarGroup", "-avatar-group", style$1i, avatarGroupLight$1, props, mergedClsPrefixRef);
      vue.provide(avatarGroupInjectionKey, props);
      const rtlEnabledRef = useRtl("AvatarGroup", mergedRtlRef, mergedClsPrefixRef);
      const restOptionsRef = vue.computed(() => {
        const {
          max
        } = props;
        if (max === void 0)
          return void 0;
        const {
          options
        } = props;
        if (options.length > max)
          return options.slice(max - 1, options.length);
        return [];
      });
      const displayedOptionsRef = vue.computed(() => {
        const {
          options,
          max
        } = props;
        if (max === void 0)
          return options;
        if (options.length > max)
          return options.slice(0, max - 1);
        if (options.length === max)
          return options.slice(0, max);
        return options;
      });
      return {
        mergedTheme: mergedThemeRef,
        rtlEnabled: rtlEnabledRef,
        mergedClsPrefix: mergedClsPrefixRef,
        restOptions: restOptionsRef,
        displayedOptions: displayedOptionsRef,
        cssVars: vue.computed(() => {
          return {
            "--n-gap": mergedThemeRef.value.self.gap
          };
        })
      };
    },
    render() {
      const {
        mergedClsPrefix,
        displayedOptions,
        restOptions,
        mergedTheme,
        $slots
      } = this;
      return vue.h("div", {
        class: [`${mergedClsPrefix}-avatar-group`, this.rtlEnabled && `${mergedClsPrefix}-avatar-group--rtl`, this.vertical && `${mergedClsPrefix}-avatar-group--vertical`, this.expandOnHover && `${mergedClsPrefix}-avatar-group--expand-on-hover`],
        style: this.cssVars,
        role: "group"
      }, displayedOptions.map((option) => {
        return $slots.avatar ? $slots.avatar({
          option
        }) : vue.h(NAvatar, {
          src: option.src,
          theme: mergedTheme.peers.Avatar,
          themeOverrides: mergedTheme.peerOverrides.Avatar
        });
      }), restOptions !== void 0 && restOptions.length > 0 && ($slots.rest ? $slots.rest({
        options: restOptions,
        rest: restOptions.length
      }) : vue.h(NAvatar, {
        style: this.maxStyle,
        theme: mergedTheme.peers.Avatar,
        themeOverrides: mergedTheme.peerOverrides.Avatar
      }, {
        default: () => `+${restOptions.length}`
      })));
    }
  });
  const commonVariables$h = {
    width: "44px",
    height: "44px",
    borderRadius: "22px",
    iconSize: "26px"
  };
  function self$15(vars) {
    const {
      popoverColor,
      textColor2,
      primaryColorHover,
      primaryColorPressed
    } = vars;
    return Object.assign(Object.assign({}, commonVariables$h), {
      color: popoverColor,
      textColor: textColor2,
      iconColor: textColor2,
      iconColorHover: primaryColorHover,
      iconColorPressed: primaryColorPressed,
      boxShadow: "0 2px 8px 0px rgba(0, 0, 0, .12)",
      boxShadowHover: "0 2px 12px 0px rgba(0, 0, 0, .18)",
      boxShadowPressed: "0 2px 12px 0px rgba(0, 0, 0, .18)"
    });
  }
  const backTopLight = {
    name: "BackTop",
    common: commonLight,
    self: self$15
  };
  const backTopLight$1 = backTopLight;
  const BackTopIcon = vue.h("svg", {
    viewBox: "0 0 24 24",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    xlinkHref: "http://www.w3.org/1999/xlink"
  }, vue.h("g", {
    stroke: "none",
    "stroke-width": "1",
    "fill-rule": "evenodd"
  }, vue.h("g", {
    transform: "translate(-139.000000, -4423.000000)",
    "fill-rule": "nonzero"
  }, vue.h("g", {
    transform: "translate(120.000000, 4285.000000)"
  }, vue.h("g", {
    transform: "translate(7.000000, 126.000000)"
  }, vue.h("g", {
    transform: "translate(24.000000, 24.000000) scale(1, -1) translate(-24.000000, -24.000000) translate(12.000000, 12.000000)"
  }, vue.h("g", {
    transform: "translate(4.000000, 2.000000)"
  }, vue.h("path", {
    d: "M8,0 C8.51283584,0 8.93550716,0.38604019 8.99327227,0.883378875 L9,1 L9,10.584 L12.2928932,7.29289322 C12.6834175,6.90236893 13.3165825,6.90236893 13.7071068,7.29289322 C14.0675907,7.65337718 14.0953203,8.22060824 13.7902954,8.61289944 L13.7071068,8.70710678 L8.70710678,13.7071068 L8.62544899,13.7803112 L8.618,13.784 L8.59530661,13.8036654 L8.4840621,13.8753288 L8.37133602,13.9287745 L8.22929083,13.9735893 L8.14346259,13.9897165 L8.03324678,13.9994506 L7.9137692,13.9962979 L7.77070917,13.9735893 L7.6583843,13.9401293 L7.57677845,13.9063266 L7.47929125,13.8540045 L7.4048407,13.8036865 L7.38131006,13.7856883 C7.35030318,13.7612383 7.32077858,13.7349921 7.29289322,13.7071068 L2.29289322,8.70710678 L2.20970461,8.61289944 C1.90467972,8.22060824 1.93240926,7.65337718 2.29289322,7.29289322 C2.65337718,6.93240926 3.22060824,6.90467972 3.61289944,7.20970461 L3.70710678,7.29289322 L7,10.585 L7,1 L7.00672773,0.883378875 C7.06449284,0.38604019 7.48716416,0 8,0 Z"
  }), vue.h("path", {
    d: "M14.9333333,15.9994506 C15.5224371,15.9994506 16,16.4471659 16,16.9994506 C16,17.5122865 15.5882238,17.9349578 15.0577292,17.9927229 L14.9333333,17.9994506 L1.06666667,17.9994506 C0.477562934,17.9994506 0,17.5517354 0,16.9994506 C0,16.4866148 0.411776203,16.0639435 0.9422708,16.0061783 L1.06666667,15.9994506 L14.9333333,15.9994506 Z"
  }))))))));
  const style$1h = cB("back-top", `
 position: fixed;
 right: 40px;
 bottom: 40px;
 cursor: pointer;
 display: flex;
 align-items: center;
 justify-content: center;
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 height: var(--n-height);
 min-width: var(--n-width);
 box-shadow: var(--n-box-shadow);
 background-color: var(--n-color);
`, [fadeInScaleUpTransition(), cM("transition-disabled", {
    transition: "none !important"
  }), cB("base-icon", `
 font-size: var(--n-icon-size);
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 `), c$1("svg", {
    pointerEvents: "none"
  }), c$1("&:hover", {
    boxShadow: "var(--n-box-shadow-hover)"
  }, [cB("base-icon", {
    color: "var(--n-icon-color-hover)"
  })]), c$1("&:active", {
    boxShadow: "var(--n-box-shadow-pressed)"
  }, [cB("base-icon", {
    color: "var(--n-icon-color-pressed)"
  })])]);
  const backTopProps = Object.assign(Object.assign({}, useTheme.props), {
    show: {
      type: Boolean,
      default: void 0
    },
    right: {
      type: [Number, String],
      default: 40
    },
    bottom: {
      type: [Number, String],
      default: 40
    },
    to: {
      type: [String, Object],
      default: "body"
    },
    visibilityHeight: {
      type: Number,
      default: 180
    },
    listenTo: [String, Object, Function],
    "onUpdate:show": {
      type: Function,
      default: () => {
      }
    },
    // deprecated
    target: Function,
    onShow: Function,
    onHide: Function
  });
  const BackTop = vue.defineComponent({
    name: "BackTop",
    // make style applied to back-top button
    inheritAttrs: false,
    props: backTopProps,
    setup(props) {
      {
        vue.watchEffect(() => {
          if (props.target !== void 0) {
            warnOnce("back-top", "`target` is deprecated, please use `listen-to` instead.");
          }
          if (props.onShow !== void 0) {
            warnOnce("back-top", "`on-show` is deprecated, please use `on-update:show` instead.");
          }
          if (props.onHide !== void 0) {
            warnOnce("back-top", "`on-hide` is deprecated, please use `on-update:show` instead.");
          }
        });
      }
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const scrollTopRef = vue.ref(null);
      const uncontrolledShowRef = vue.ref(false);
      vue.watchEffect(() => {
        const {
          value: scrollTop
        } = scrollTopRef;
        if (scrollTop === null) {
          uncontrolledShowRef.value = false;
          return;
        }
        uncontrolledShowRef.value = scrollTop >= props.visibilityHeight;
      });
      const DomInfoReadyRef = vue.ref(false);
      vue.watch(uncontrolledShowRef, (value) => {
        var _a;
        if (DomInfoReadyRef.value) {
          (_a = props["onUpdate:show"]) === null || _a === void 0 ? void 0 : _a.call(props, value);
        }
      });
      const controlledShowRef = vue.toRef(props, "show");
      const mergedShowRef = useMergedState(controlledShowRef, uncontrolledShowRef);
      const transitionDisabledRef = vue.ref(true);
      const placeholderRef = vue.ref(null);
      const styleRef = vue.computed(() => {
        return {
          right: `calc(${formatLength(props.right)} + ${lockHtmlScrollRightCompensationRef.value})`,
          bottom: formatLength(props.bottom)
        };
      });
      let scrollElement;
      let scrollListenerRegistered;
      vue.watch(mergedShowRef, (value) => {
        var _a, _b;
        if (DomInfoReadyRef.value) {
          if (value) {
            (_a = props.onShow) === null || _a === void 0 ? void 0 : _a.call(props);
          }
          (_b = props.onHide) === null || _b === void 0 ? void 0 : _b.call(props);
        }
      });
      const themeRef = useTheme("BackTop", "-back-top", style$1h, backTopLight$1, props, mergedClsPrefixRef);
      function init2() {
        var _a;
        if (scrollListenerRegistered)
          return;
        scrollListenerRegistered = true;
        const scrollEl = ((_a = props.target) === null || _a === void 0 ? void 0 : _a.call(props)) || unwrapElement(props.listenTo) || getScrollParent$1(placeholderRef.value);
        if (!scrollEl) {
          {
            warn$2("back-top", "Container of back-top element is not found. This could be a bug of naive-ui.");
          }
          return;
        }
        scrollElement = scrollEl === document.documentElement ? document : scrollEl;
        const {
          to
        } = props;
        const target = typeof to === "string" ? document.querySelector(to) : to;
        if (!target) {
          warn$2("back-top", "Target is not found.");
        }
        scrollElement.addEventListener("scroll", handleScroll);
        handleScroll();
      }
      function handleClick2() {
        (isDocument(scrollElement) ? document.documentElement : scrollElement).scrollTo({
          top: 0,
          behavior: "smooth"
        });
      }
      function handleScroll() {
        scrollTopRef.value = (isDocument(scrollElement) ? document.documentElement : scrollElement).scrollTop;
        if (!DomInfoReadyRef.value) {
          void vue.nextTick(() => {
            DomInfoReadyRef.value = true;
          });
        }
      }
      function handleAfterEnter() {
        transitionDisabledRef.value = false;
      }
      vue.onMounted(() => {
        init2();
        transitionDisabledRef.value = mergedShowRef.value;
      });
      vue.onBeforeUnmount(() => {
        if (scrollElement) {
          scrollElement.removeEventListener("scroll", handleScroll);
        }
      });
      const cssVarsRef = vue.computed(() => {
        const {
          self: {
            color,
            boxShadow,
            boxShadowHover,
            boxShadowPressed,
            iconColor,
            iconColorHover,
            iconColorPressed,
            width,
            height,
            iconSize,
            borderRadius,
            textColor
          },
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-border-radius": borderRadius,
          "--n-height": height,
          "--n-width": width,
          "--n-box-shadow": boxShadow,
          "--n-box-shadow-hover": boxShadowHover,
          "--n-box-shadow-pressed": boxShadowPressed,
          "--n-color": color,
          "--n-icon-size": iconSize,
          "--n-icon-color": iconColor,
          "--n-icon-color-hover": iconColorHover,
          "--n-icon-color-pressed": iconColorPressed,
          "--n-text-color": textColor
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("back-top", void 0, cssVarsRef, props) : void 0;
      return {
        placeholderRef,
        style: styleRef,
        mergedShow: mergedShowRef,
        isMounted: isMounted(),
        scrollElement: vue.ref(null),
        scrollTop: scrollTopRef,
        DomInfoReady: DomInfoReadyRef,
        transitionDisabled: transitionDisabledRef,
        mergedClsPrefix: mergedClsPrefixRef,
        handleAfterEnter,
        handleScroll,
        handleClick: handleClick2,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      const {
        mergedClsPrefix
      } = this;
      return vue.h("div", {
        ref: "placeholderRef",
        class: `${mergedClsPrefix}-back-top-placeholder`,
        style: "display: none",
        "aria-hidden": true
      }, vue.h(LazyTeleport, {
        to: this.to,
        show: this.mergedShow
      }, {
        default: () => vue.h(vue.Transition, {
          name: "fade-in-scale-up-transition",
          appear: this.isMounted,
          onAfterEnter: this.handleAfterEnter
        }, {
          default: () => {
            var _a;
            (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
            return this.mergedShow ? vue.h("div", vue.mergeProps(this.$attrs, {
              class: [`${mergedClsPrefix}-back-top`, this.themeClass, this.transitionDisabled && `${mergedClsPrefix}-back-top--transition-disabled`],
              style: [this.style, this.cssVars],
              onClick: this.handleClick
            }), resolveSlot(this.$slots.default, () => [vue.h(NBaseIcon, {
              clsPrefix: mergedClsPrefix
            }, {
              default: () => BackTopIcon
            })])) : null;
          }
        })
      }));
    }
  });
  function self$14(vars) {
    const {
      errorColor,
      infoColor,
      successColor,
      warningColor,
      fontFamily: fontFamily2
    } = vars;
    return {
      color: errorColor,
      colorInfo: infoColor,
      colorSuccess: successColor,
      colorError: errorColor,
      colorWarning: warningColor,
      fontSize: "12px",
      fontFamily: fontFamily2
    };
  }
  const badgeLight = {
    name: "Badge",
    common: commonLight,
    self: self$14
  };
  const badgeLight$1 = badgeLight;
  const style$1g = c$1([c$1("@keyframes badge-wave-spread", {
    from: {
      boxShadow: "0 0 0.5px 0px var(--n-ripple-color)",
      opacity: 0.6
    },
    to: {
      // don't use exact 5px since chrome will display the animation with glitches
      boxShadow: "0 0 0.5px 4.5px var(--n-ripple-color)",
      opacity: 0
    }
  }), cB("badge", `
 display: inline-flex;
 position: relative;
 vertical-align: middle;
 font-family: var(--n-font-family);
 `, [cM("as-is", [cB("badge-sup", {
    position: "static",
    transform: "translateX(0)"
  }, [fadeInScaleUpTransition({
    transformOrigin: "left bottom",
    originalTransform: "translateX(0)"
  })])]), cM("dot", [cB("badge-sup", `
 height: 8px;
 width: 8px;
 padding: 0;
 min-width: 8px;
 left: 100%;
 bottom: calc(100% - 4px);
 `, [c$1("::before", "border-radius: 4px;")])]), cB("badge-sup", `
 background: var(--n-color);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 color: #FFF;
 position: absolute;
 height: 18px;
 line-height: 18px;
 border-radius: 9px;
 padding: 0 6px;
 text-align: center;
 font-size: var(--n-font-size);
 transform: translateX(-50%);
 left: 100%;
 bottom: calc(100% - 9px);
 font-variant-numeric: tabular-nums;
 z-index: 2;
 display: flex;
 align-items: center;
 `, [fadeInScaleUpTransition({
    transformOrigin: "left bottom",
    originalTransform: "translateX(-50%)"
  }), cB("base-wave", {
    zIndex: 1,
    animationDuration: "2s",
    animationIterationCount: "infinite",
    animationDelay: "1s",
    animationTimingFunction: "var(--n-ripple-bezier)",
    animationName: "badge-wave-spread"
  }), c$1("&::before", `
 opacity: 0;
 transform: scale(1);
 border-radius: 9px;
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)])])]);
  const badgeProps = Object.assign(Object.assign({}, useTheme.props), {
    value: [String, Number],
    max: Number,
    dot: Boolean,
    type: {
      type: String,
      default: "default"
    },
    show: {
      type: Boolean,
      default: true
    },
    showZero: Boolean,
    processing: Boolean,
    color: String,
    offset: Array
  });
  const Badge = vue.defineComponent({
    name: "Badge",
    props: badgeProps,
    setup(props, {
      slots
    }) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled,
        mergedRtlRef
      } = useConfig(props);
      const themeRef = useTheme("Badge", "-badge", style$1g, badgeLight$1, props, mergedClsPrefixRef);
      const appearedRef = vue.ref(false);
      const handleAfterEnter = () => {
        appearedRef.value = true;
      };
      const handleAfterLeave = () => {
        appearedRef.value = false;
      };
      const showBadgeRef = vue.computed(() => {
        return props.show && (props.dot || props.value !== void 0 && !(!props.showZero && Number(props.value) <= 0) || !isSlotEmpty(slots.value));
      });
      vue.onMounted(() => {
        if (showBadgeRef.value)
          appearedRef.value = true;
      });
      const rtlEnabledRef = useRtl("Badge", mergedRtlRef, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          type,
          color: propColor
        } = props;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2,
            cubicBezierEaseOut: cubicBezierEaseOut2
          },
          self: {
            [createKey("color", type)]: color,
            fontFamily: fontFamily2,
            fontSize: fontSize2
          }
        } = themeRef.value;
        return {
          "--n-font-size": fontSize2,
          "--n-font-family": fontFamily2,
          "--n-color": propColor || color,
          "--n-ripple-color": propColor || color,
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-ripple-bezier": cubicBezierEaseOut2
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("badge", vue.computed(() => {
        let hash = "";
        const {
          type,
          color
        } = props;
        if (type) {
          hash += type[0];
        }
        if (color) {
          hash += color2Class(color);
        }
        return hash;
      }), cssVarsRef, props) : void 0;
      const offsetStyleRef = vue.computed(() => {
        const {
          offset
        } = props;
        if (!offset)
          return void 0;
        const [x, y] = offset;
        const reslovedOffsetX = typeof x === "number" ? `${x}px` : x;
        const reslovedOffsetY = typeof y === "number" ? `${y}px` : y;
        return {
          transform: `translate(calc(${(rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? "50%" : "-50%"} + ${reslovedOffsetX}), ${reslovedOffsetY})`
        };
      });
      return {
        rtlEnabled: rtlEnabledRef,
        mergedClsPrefix: mergedClsPrefixRef,
        appeared: appearedRef,
        showBadge: showBadgeRef,
        handleAfterEnter,
        handleAfterLeave,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
        offsetStyle: offsetStyleRef
      };
    },
    render() {
      var _a;
      const {
        mergedClsPrefix,
        onRender,
        themeClass,
        $slots
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      const children = (_a = $slots.default) === null || _a === void 0 ? void 0 : _a.call($slots);
      return vue.h("div", {
        class: [`${mergedClsPrefix}-badge`, this.rtlEnabled && `${mergedClsPrefix}-badge--rtl`, themeClass, {
          [`${mergedClsPrefix}-badge--dot`]: this.dot,
          [`${mergedClsPrefix}-badge--as-is`]: !children
        }],
        style: this.cssVars
      }, children, vue.h(vue.Transition, {
        name: "fade-in-scale-up-transition",
        onAfterEnter: this.handleAfterEnter,
        onAfterLeave: this.handleAfterLeave
      }, {
        default: () => this.showBadge ? vue.h("sup", {
          class: `${mergedClsPrefix}-badge-sup`,
          title: getTitleAttribute(this.value),
          style: this.offsetStyle
        }, resolveSlot($slots.value, () => [!this.dot ? vue.h(NBaseSlotMachine, {
          clsPrefix: mergedClsPrefix,
          appeared: this.appeared,
          max: this.max,
          value: this.value
        }) : null]), this.processing ? vue.h(NBaseWave, {
          clsPrefix: mergedClsPrefix
        }) : null) : null
      }));
    }
  });
  const commonVariables$g = {
    fontWeightActive: "400"
  };
  function self$13(vars) {
    const {
      fontSize: fontSize2,
      textColor3,
      textColor2,
      borderRadius,
      buttonColor2Hover,
      buttonColor2Pressed
    } = vars;
    return Object.assign(Object.assign({}, commonVariables$g), {
      fontSize: fontSize2,
      itemLineHeight: "1.25",
      itemTextColor: textColor3,
      itemTextColorHover: textColor2,
      itemTextColorPressed: textColor2,
      itemTextColorActive: textColor2,
      itemBorderRadius: borderRadius,
      itemColorHover: buttonColor2Hover,
      itemColorPressed: buttonColor2Pressed,
      separatorColor: textColor3
    });
  }
  const breadcrumbLight = {
    name: "Breadcrumb",
    common: commonLight,
    self: self$13
  };
  const breadcrumbLight$1 = breadcrumbLight;
  const style$1f = cB("breadcrumb", `
 white-space: nowrap;
 cursor: default;
 line-height: var(--n-item-line-height);
`, [c$1("ul", `
 list-style: none;
 padding: 0;
 margin: 0;
 `), c$1("a", `
 color: inherit;
 text-decoration: inherit;
 `), cB("breadcrumb-item", `
 font-size: var(--n-font-size);
 transition: color .3s var(--n-bezier);
 display: inline-flex;
 align-items: center;
 `, [cB("icon", `
 font-size: 18px;
 vertical-align: -.2em;
 transition: color .3s var(--n-bezier);
 color: var(--n-item-text-color);
 `), c$1("&:not(:last-child)", [cM("clickable", [cE("link", `
 cursor: pointer;
 `, [c$1("&:hover", `
 background-color: var(--n-item-color-hover);
 `), c$1("&:active", `
 background-color: var(--n-item-color-pressed); 
 `)])])]), cE("link", `
 padding: 4px;
 border-radius: var(--n-item-border-radius);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 color: var(--n-item-text-color);
 position: relative;
 `, [c$1("&:hover", `
 color: var(--n-item-text-color-hover);
 `, [cB("icon", `
 color: var(--n-item-text-color-hover);
 `)]), c$1("&:active", `
 color: var(--n-item-text-color-pressed);
 `, [cB("icon", `
 color: var(--n-item-text-color-pressed);
 `)])]), cE("separator", `
 margin: 0 8px;
 color: var(--n-separator-color);
 transition: color .3s var(--n-bezier);
 user-select: none;
 -webkit-user-select: none;
 `), c$1("&:last-child", [cE("link", `
 font-weight: var(--n-font-weight-active);
 cursor: unset;
 color: var(--n-item-text-color-active);
 `, [cB("icon", `
 color: var(--n-item-text-color-active);
 `)]), cE("separator", `
 display: none;
 `)])])]);
  const breadcrumbInjectionKey = createInjectionKey("n-breadcrumb");
  const breadcrumbProps = Object.assign(Object.assign({}, useTheme.props), {
    separator: {
      type: String,
      default: "/"
    }
  });
  const Breadcrumb = vue.defineComponent({
    name: "Breadcrumb",
    props: breadcrumbProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Breadcrumb", "-breadcrumb", style$1f, breadcrumbLight$1, props, mergedClsPrefixRef);
      vue.provide(breadcrumbInjectionKey, {
        separatorRef: vue.toRef(props, "separator"),
        mergedClsPrefixRef
      });
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            separatorColor,
            itemTextColor,
            itemTextColorHover,
            itemTextColorPressed,
            itemTextColorActive,
            fontSize: fontSize2,
            fontWeightActive,
            itemBorderRadius,
            itemColorHover,
            itemColorPressed,
            itemLineHeight
          }
        } = themeRef.value;
        return {
          "--n-font-size": fontSize2,
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-item-text-color": itemTextColor,
          "--n-item-text-color-hover": itemTextColorHover,
          "--n-item-text-color-pressed": itemTextColorPressed,
          "--n-item-text-color-active": itemTextColorActive,
          "--n-separator-color": separatorColor,
          "--n-item-color-hover": itemColorHover,
          "--n-item-color-pressed": itemColorPressed,
          "--n-item-border-radius": itemBorderRadius,
          "--n-font-weight-active": fontWeightActive,
          "--n-item-line-height": itemLineHeight
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("breadcrumb", void 0, cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      return vue.h("nav", {
        class: [`${this.mergedClsPrefix}-breadcrumb`, this.themeClass],
        style: this.cssVars,
        "aria-label": "Breadcrumb"
      }, vue.h("ul", null, this.$slots));
    }
  });
  function useBrowserLocation(customWindow = isBrowser$2 ? window : null) {
    const getWindowLocation = () => {
      const {
        hash,
        host,
        hostname,
        href,
        origin,
        pathname,
        port,
        protocol,
        search
      } = (customWindow === null || customWindow === void 0 ? void 0 : customWindow.location) || {};
      return {
        hash,
        host,
        hostname,
        href,
        origin,
        pathname,
        port,
        protocol,
        search
      };
    };
    const locationState = vue.ref(getWindowLocation());
    const updateLocation = () => {
      locationState.value = getWindowLocation();
    };
    vue.onMounted(() => {
      if (customWindow) {
        customWindow.addEventListener("popstate", updateLocation);
        customWindow.addEventListener("hashchange", updateLocation);
      }
    });
    vue.onUnmounted(() => {
      if (customWindow) {
        customWindow.removeEventListener("popstate", updateLocation);
        customWindow.removeEventListener("hashchange", updateLocation);
      }
    });
    return locationState;
  }
  const breadcrumbItemProps = {
    separator: String,
    href: String,
    clickable: {
      type: Boolean,
      default: true
    },
    onClick: Function
  };
  const BreadcrumbItem = vue.defineComponent({
    name: "BreadcrumbItem",
    props: breadcrumbItemProps,
    setup(props, {
      slots
    }) {
      const NBreadcrumb = vue.inject(breadcrumbInjectionKey, null);
      if (!NBreadcrumb) {
        {
          warn$2("breadcrumb", "`n-breadcrumb-item` must be placed inside `n-breadcrumb`.");
        }
        return () => null;
      }
      const {
        separatorRef,
        mergedClsPrefixRef
      } = NBreadcrumb;
      const browserLocationRef = useBrowserLocation();
      const htmlTagRef = vue.computed(() => props.href ? "a" : "span");
      const ariaCurrentRef = vue.computed(() => browserLocationRef.value.href === props.href ? "location" : null);
      return () => {
        const {
          value: mergedClsPrefix
        } = mergedClsPrefixRef;
        return vue.h("li", {
          class: [`${mergedClsPrefix}-breadcrumb-item`, props.clickable && `${mergedClsPrefix}-breadcrumb-item--clickable`]
        }, vue.h(htmlTagRef.value, {
          class: `${mergedClsPrefix}-breadcrumb-item__link`,
          "aria-current": ariaCurrentRef.value,
          href: props.href,
          onClick: props.onClick
        }, slots), vue.h("span", {
          class: `${mergedClsPrefix}-breadcrumb-item__separator`,
          "aria-hidden": "true"
        }, resolveSlot(slots.separator, () => {
          var _a;
          return [(_a = props.separator) !== null && _a !== void 0 ? _a : separatorRef.value];
        })));
      };
    }
  });
  function createHoverColor(rgb) {
    return composite(rgb, [255, 255, 255, 0.16]);
  }
  function createPressedColor(rgb) {
    return composite(rgb, [0, 0, 0, 0.12]);
  }
  const buttonGroupInjectionKey = createInjectionKey("n-button-group");
  const commonVariables$f = {
    paddingTiny: "0 6px",
    paddingSmall: "0 10px",
    paddingMedium: "0 14px",
    paddingLarge: "0 18px",
    paddingRoundTiny: "0 10px",
    paddingRoundSmall: "0 14px",
    paddingRoundMedium: "0 18px",
    paddingRoundLarge: "0 22px",
    iconMarginTiny: "6px",
    iconMarginSmall: "6px",
    iconMarginMedium: "6px",
    iconMarginLarge: "6px",
    iconSizeTiny: "14px",
    iconSizeSmall: "18px",
    iconSizeMedium: "18px",
    iconSizeLarge: "20px",
    rippleDuration: ".6s"
  };
  function self$12(vars) {
    const {
      heightTiny,
      heightSmall,
      heightMedium,
      heightLarge,
      borderRadius,
      fontSizeTiny,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      opacityDisabled,
      textColor2,
      textColor3,
      primaryColorHover,
      primaryColorPressed,
      borderColor,
      primaryColor,
      baseColor,
      infoColor,
      infoColorHover,
      infoColorPressed,
      successColor,
      successColorHover,
      successColorPressed,
      warningColor,
      warningColorHover,
      warningColorPressed,
      errorColor,
      errorColorHover,
      errorColorPressed,
      fontWeight,
      buttonColor2,
      buttonColor2Hover,
      buttonColor2Pressed,
      fontWeightStrong
    } = vars;
    return Object.assign(Object.assign({}, commonVariables$f), {
      heightTiny,
      heightSmall,
      heightMedium,
      heightLarge,
      borderRadiusTiny: borderRadius,
      borderRadiusSmall: borderRadius,
      borderRadiusMedium: borderRadius,
      borderRadiusLarge: borderRadius,
      fontSizeTiny,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      opacityDisabled,
      // secondary
      colorOpacitySecondary: "0.16",
      colorOpacitySecondaryHover: "0.22",
      colorOpacitySecondaryPressed: "0.28",
      colorSecondary: buttonColor2,
      colorSecondaryHover: buttonColor2Hover,
      colorSecondaryPressed: buttonColor2Pressed,
      // tertiary
      colorTertiary: buttonColor2,
      colorTertiaryHover: buttonColor2Hover,
      colorTertiaryPressed: buttonColor2Pressed,
      // quaternary
      colorQuaternary: "#0000",
      colorQuaternaryHover: buttonColor2Hover,
      colorQuaternaryPressed: buttonColor2Pressed,
      // default type
      color: "#0000",
      colorHover: "#0000",
      colorPressed: "#0000",
      colorFocus: "#0000",
      colorDisabled: "#0000",
      textColor: textColor2,
      textColorTertiary: textColor3,
      textColorHover: primaryColorHover,
      textColorPressed: primaryColorPressed,
      textColorFocus: primaryColorHover,
      textColorDisabled: textColor2,
      textColorText: textColor2,
      textColorTextHover: primaryColorHover,
      textColorTextPressed: primaryColorPressed,
      textColorTextFocus: primaryColorHover,
      textColorTextDisabled: textColor2,
      textColorGhost: textColor2,
      textColorGhostHover: primaryColorHover,
      textColorGhostPressed: primaryColorPressed,
      textColorGhostFocus: primaryColorHover,
      textColorGhostDisabled: textColor2,
      border: `1px solid ${borderColor}`,
      borderHover: `1px solid ${primaryColorHover}`,
      borderPressed: `1px solid ${primaryColorPressed}`,
      borderFocus: `1px solid ${primaryColorHover}`,
      borderDisabled: `1px solid ${borderColor}`,
      rippleColor: primaryColor,
      // primary
      colorPrimary: primaryColor,
      colorHoverPrimary: primaryColorHover,
      colorPressedPrimary: primaryColorPressed,
      colorFocusPrimary: primaryColorHover,
      colorDisabledPrimary: primaryColor,
      textColorPrimary: baseColor,
      textColorHoverPrimary: baseColor,
      textColorPressedPrimary: baseColor,
      textColorFocusPrimary: baseColor,
      textColorDisabledPrimary: baseColor,
      textColorTextPrimary: primaryColor,
      textColorTextHoverPrimary: primaryColorHover,
      textColorTextPressedPrimary: primaryColorPressed,
      textColorTextFocusPrimary: primaryColorHover,
      textColorTextDisabledPrimary: textColor2,
      textColorGhostPrimary: primaryColor,
      textColorGhostHoverPrimary: primaryColorHover,
      textColorGhostPressedPrimary: primaryColorPressed,
      textColorGhostFocusPrimary: primaryColorHover,
      textColorGhostDisabledPrimary: primaryColor,
      borderPrimary: `1px solid ${primaryColor}`,
      borderHoverPrimary: `1px solid ${primaryColorHover}`,
      borderPressedPrimary: `1px solid ${primaryColorPressed}`,
      borderFocusPrimary: `1px solid ${primaryColorHover}`,
      borderDisabledPrimary: `1px solid ${primaryColor}`,
      rippleColorPrimary: primaryColor,
      // info
      colorInfo: infoColor,
      colorHoverInfo: infoColorHover,
      colorPressedInfo: infoColorPressed,
      colorFocusInfo: infoColorHover,
      colorDisabledInfo: infoColor,
      textColorInfo: baseColor,
      textColorHoverInfo: baseColor,
      textColorPressedInfo: baseColor,
      textColorFocusInfo: baseColor,
      textColorDisabledInfo: baseColor,
      textColorTextInfo: infoColor,
      textColorTextHoverInfo: infoColorHover,
      textColorTextPressedInfo: infoColorPressed,
      textColorTextFocusInfo: infoColorHover,
      textColorTextDisabledInfo: textColor2,
      textColorGhostInfo: infoColor,
      textColorGhostHoverInfo: infoColorHover,
      textColorGhostPressedInfo: infoColorPressed,
      textColorGhostFocusInfo: infoColorHover,
      textColorGhostDisabledInfo: infoColor,
      borderInfo: `1px solid ${infoColor}`,
      borderHoverInfo: `1px solid ${infoColorHover}`,
      borderPressedInfo: `1px solid ${infoColorPressed}`,
      borderFocusInfo: `1px solid ${infoColorHover}`,
      borderDisabledInfo: `1px solid ${infoColor}`,
      rippleColorInfo: infoColor,
      // success
      colorSuccess: successColor,
      colorHoverSuccess: successColorHover,
      colorPressedSuccess: successColorPressed,
      colorFocusSuccess: successColorHover,
      colorDisabledSuccess: successColor,
      textColorSuccess: baseColor,
      textColorHoverSuccess: baseColor,
      textColorPressedSuccess: baseColor,
      textColorFocusSuccess: baseColor,
      textColorDisabledSuccess: baseColor,
      textColorTextSuccess: successColor,
      textColorTextHoverSuccess: successColorHover,
      textColorTextPressedSuccess: successColorPressed,
      textColorTextFocusSuccess: successColorHover,
      textColorTextDisabledSuccess: textColor2,
      textColorGhostSuccess: successColor,
      textColorGhostHoverSuccess: successColorHover,
      textColorGhostPressedSuccess: successColorPressed,
      textColorGhostFocusSuccess: successColorHover,
      textColorGhostDisabledSuccess: successColor,
      borderSuccess: `1px solid ${successColor}`,
      borderHoverSuccess: `1px solid ${successColorHover}`,
      borderPressedSuccess: `1px solid ${successColorPressed}`,
      borderFocusSuccess: `1px solid ${successColorHover}`,
      borderDisabledSuccess: `1px solid ${successColor}`,
      rippleColorSuccess: successColor,
      // warning
      colorWarning: warningColor,
      colorHoverWarning: warningColorHover,
      colorPressedWarning: warningColorPressed,
      colorFocusWarning: warningColorHover,
      colorDisabledWarning: warningColor,
      textColorWarning: baseColor,
      textColorHoverWarning: baseColor,
      textColorPressedWarning: baseColor,
      textColorFocusWarning: baseColor,
      textColorDisabledWarning: baseColor,
      textColorTextWarning: warningColor,
      textColorTextHoverWarning: warningColorHover,
      textColorTextPressedWarning: warningColorPressed,
      textColorTextFocusWarning: warningColorHover,
      textColorTextDisabledWarning: textColor2,
      textColorGhostWarning: warningColor,
      textColorGhostHoverWarning: warningColorHover,
      textColorGhostPressedWarning: warningColorPressed,
      textColorGhostFocusWarning: warningColorHover,
      textColorGhostDisabledWarning: warningColor,
      borderWarning: `1px solid ${warningColor}`,
      borderHoverWarning: `1px solid ${warningColorHover}`,
      borderPressedWarning: `1px solid ${warningColorPressed}`,
      borderFocusWarning: `1px solid ${warningColorHover}`,
      borderDisabledWarning: `1px solid ${warningColor}`,
      rippleColorWarning: warningColor,
      // error
      colorError: errorColor,
      colorHoverError: errorColorHover,
      colorPressedError: errorColorPressed,
      colorFocusError: errorColorHover,
      colorDisabledError: errorColor,
      textColorError: baseColor,
      textColorHoverError: baseColor,
      textColorPressedError: baseColor,
      textColorFocusError: baseColor,
      textColorDisabledError: baseColor,
      textColorTextError: errorColor,
      textColorTextHoverError: errorColorHover,
      textColorTextPressedError: errorColorPressed,
      textColorTextFocusError: errorColorHover,
      textColorTextDisabledError: textColor2,
      textColorGhostError: errorColor,
      textColorGhostHoverError: errorColorHover,
      textColorGhostPressedError: errorColorPressed,
      textColorGhostFocusError: errorColorHover,
      textColorGhostDisabledError: errorColor,
      borderError: `1px solid ${errorColor}`,
      borderHoverError: `1px solid ${errorColorHover}`,
      borderPressedError: `1px solid ${errorColorPressed}`,
      borderFocusError: `1px solid ${errorColorHover}`,
      borderDisabledError: `1px solid ${errorColor}`,
      rippleColorError: errorColor,
      waveOpacity: "0.6",
      fontWeight,
      fontWeightStrong
    });
  }
  const buttonLight = {
    name: "Button",
    common: commonLight,
    self: self$12
  };
  const buttonLight$1 = buttonLight;
  const style$1e = c$1([cB("button", `
 margin: 0;
 font-weight: var(--n-font-weight);
 line-height: 1;
 font-family: inherit;
 padding: var(--n-padding);
 height: var(--n-height);
 font-size: var(--n-font-size);
 border-radius: var(--n-border-radius);
 color: var(--n-text-color);
 background-color: var(--n-color);
 width: var(--n-width);
 white-space: nowrap;
 outline: none;
 position: relative;
 z-index: auto;
 border: none;
 display: inline-flex;
 flex-wrap: nowrap;
 flex-shrink: 0;
 align-items: center;
 justify-content: center;
 user-select: none;
 -webkit-user-select: none;
 text-align: center;
 cursor: pointer;
 text-decoration: none;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cM("color", [cE("border", {
    borderColor: "var(--n-border-color)"
  }), cM("disabled", [cE("border", {
    borderColor: "var(--n-border-color-disabled)"
  })]), cNotM("disabled", [c$1("&:focus", [cE("state-border", {
    borderColor: "var(--n-border-color-focus)"
  })]), c$1("&:hover", [cE("state-border", {
    borderColor: "var(--n-border-color-hover)"
  })]), c$1("&:active", [cE("state-border", {
    borderColor: "var(--n-border-color-pressed)"
  })]), cM("pressed", [cE("state-border", {
    borderColor: "var(--n-border-color-pressed)"
  })])])]), cM("disabled", {
    backgroundColor: "var(--n-color-disabled)",
    color: "var(--n-text-color-disabled)"
  }, [cE("border", {
    border: "var(--n-border-disabled)"
  })]), cNotM("disabled", [c$1("&:focus", {
    backgroundColor: "var(--n-color-focus)",
    color: "var(--n-text-color-focus)"
  }, [cE("state-border", {
    border: "var(--n-border-focus)"
  })]), c$1("&:hover", {
    backgroundColor: "var(--n-color-hover)",
    color: "var(--n-text-color-hover)"
  }, [cE("state-border", {
    border: "var(--n-border-hover)"
  })]), c$1("&:active", {
    backgroundColor: "var(--n-color-pressed)",
    color: "var(--n-text-color-pressed)"
  }, [cE("state-border", {
    border: "var(--n-border-pressed)"
  })]), cM("pressed", {
    backgroundColor: "var(--n-color-pressed)",
    color: "var(--n-text-color-pressed)"
  }, [cE("state-border", {
    border: "var(--n-border-pressed)"
  })])]), cM("loading", "cursor: wait;"), cB("base-wave", `
 pointer-events: none;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 animation-iteration-count: 1;
 animation-duration: var(--n-ripple-duration);
 animation-timing-function: var(--n-bezier-ease-out), var(--n-bezier-ease-out);
 `, [cM("active", {
    zIndex: 1,
    animationName: "button-wave-spread, button-wave-opacity"
  })]), isBrowser$2 && "MozBoxSizing" in document.createElement("div").style ? c$1("&::moz-focus-inner", {
    border: 0
  }) : null, cE("border, state-border", `
 position: absolute;
 left: 0;
 top: 0;
 right: 0;
 bottom: 0;
 border-radius: inherit;
 transition: border-color .3s var(--n-bezier);
 pointer-events: none;
 `), cE("border", {
    border: "var(--n-border)"
  }), cE("state-border", {
    border: "var(--n-border)",
    borderColor: "#0000",
    zIndex: 1
  }), cE("icon", `
 margin: var(--n-icon-margin);
 margin-left: 0;
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 max-width: var(--n-icon-size);
 font-size: var(--n-icon-size);
 position: relative;
 flex-shrink: 0;
 `, [cB("icon-slot", `
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 `, [iconSwitchTransition({
    top: "50%",
    originalTransform: "translateY(-50%)"
  })]), fadeInWidthExpandTransition()]), cE("content", `
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 min-width: 0;
 `, [c$1("~", [cE("icon", {
    margin: "var(--n-icon-margin)",
    marginRight: 0
  })])]), cM("block", `
 display: flex;
 width: 100%;
 `), cM("dashed", [cE("border, state-border", {
    borderStyle: "dashed !important"
  })]), cM("disabled", {
    cursor: "not-allowed",
    opacity: "var(--n-opacity-disabled)"
  })]), c$1("@keyframes button-wave-spread", {
    from: {
      boxShadow: "0 0 0.5px 0 var(--n-ripple-color)"
    },
    to: {
      // don't use exact 5px since chrome will display the animation with glitches
      boxShadow: "0 0 0.5px 4.5px var(--n-ripple-color)"
    }
  }), c$1("@keyframes button-wave-opacity", {
    from: {
      opacity: "var(--n-wave-opacity)"
    },
    to: {
      opacity: 0
    }
  })]);
  const buttonProps = Object.assign(Object.assign({}, useTheme.props), {
    color: String,
    textColor: String,
    text: Boolean,
    block: Boolean,
    loading: Boolean,
    disabled: Boolean,
    circle: Boolean,
    size: String,
    ghost: Boolean,
    round: Boolean,
    secondary: Boolean,
    tertiary: Boolean,
    quaternary: Boolean,
    strong: Boolean,
    focusable: {
      type: Boolean,
      default: true
    },
    keyboard: {
      type: Boolean,
      default: true
    },
    tag: {
      type: String,
      default: "button"
    },
    type: {
      type: String,
      default: "default"
    },
    dashed: Boolean,
    renderIcon: Function,
    iconPlacement: {
      type: String,
      default: "left"
    },
    attrType: {
      type: String,
      default: "button"
    },
    bordered: {
      type: Boolean,
      default: true
    },
    onClick: [Function, Array],
    nativeFocusBehavior: {
      type: Boolean,
      default: !isSafari
    }
  });
  const Button = vue.defineComponent({
    name: "Button",
    props: buttonProps,
    setup(props) {
      {
        vue.watchEffect(() => {
          const {
            dashed,
            ghost,
            text: text2,
            secondary,
            tertiary,
            quaternary
          } = props;
          if ((dashed || ghost || text2) && (secondary || tertiary || quaternary)) {
            warnOnce("button", "`dashed`, `ghost` and `text` props can't be used along with `secondary`, `tertiary` and `quaternary` props.");
          }
        });
      }
      const selfElRef = vue.ref(null);
      const waveElRef = vue.ref(null);
      const enterPressedRef = vue.ref(false);
      const showBorderRef = useMemo(() => {
        return !props.quaternary && !props.tertiary && !props.secondary && !props.text && (!props.color || props.ghost || props.dashed) && props.bordered;
      });
      const NButtonGroup2 = vue.inject(buttonGroupInjectionKey, {});
      const {
        mergedSizeRef
      } = useFormItem({}, {
        defaultSize: "medium",
        mergedSize: (NFormItem2) => {
          const {
            size: size2
          } = props;
          if (size2)
            return size2;
          const {
            size: buttonGroupSize
          } = NButtonGroup2;
          if (buttonGroupSize)
            return buttonGroupSize;
          const {
            mergedSize: formItemSize2
          } = NFormItem2 || {};
          if (formItemSize2) {
            return formItemSize2.value;
          }
          return "medium";
        }
      });
      const mergedFocusableRef = vue.computed(() => {
        return props.focusable && !props.disabled;
      });
      const handleMousedown = (e) => {
        var _a;
        if (!mergedFocusableRef.value) {
          e.preventDefault();
        }
        if (props.nativeFocusBehavior) {
          return;
        }
        e.preventDefault();
        if (props.disabled) {
          return;
        }
        if (mergedFocusableRef.value) {
          (_a = selfElRef.value) === null || _a === void 0 ? void 0 : _a.focus({
            preventScroll: true
          });
        }
      };
      const handleClick2 = (e) => {
        var _a;
        if (!props.disabled && !props.loading) {
          const {
            onClick
          } = props;
          if (onClick)
            call(onClick, e);
          if (!props.text) {
            (_a = waveElRef.value) === null || _a === void 0 ? void 0 : _a.play();
          }
        }
      };
      const handleKeyup = (e) => {
        switch (e.key) {
          case "Enter":
            if (!props.keyboard) {
              return;
            }
            enterPressedRef.value = false;
        }
      };
      const handleKeydown = (e) => {
        switch (e.key) {
          case "Enter":
            if (!props.keyboard || props.loading) {
              e.preventDefault();
              return;
            }
            enterPressedRef.value = true;
        }
      };
      const handleBlur = () => {
        enterPressedRef.value = false;
      };
      const {
        inlineThemeDisabled,
        mergedClsPrefixRef,
        mergedRtlRef
      } = useConfig(props);
      const themeRef = useTheme("Button", "-button", style$1e, buttonLight$1, props, mergedClsPrefixRef);
      const rtlEnabledRef = useRtl("Button", mergedRtlRef, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const theme = themeRef.value;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2,
            cubicBezierEaseOut: cubicBezierEaseOut2
          },
          self: self2
        } = theme;
        const {
          rippleDuration,
          opacityDisabled,
          fontWeight,
          fontWeightStrong
        } = self2;
        const size2 = mergedSizeRef.value;
        const {
          dashed,
          type,
          ghost,
          text: text2,
          color,
          round: round2,
          circle,
          textColor,
          secondary,
          tertiary,
          quaternary,
          strong
        } = props;
        const fontProps = {
          "--n-font-weight": strong ? fontWeightStrong : fontWeight
        };
        let colorProps = {
          "--n-color": "initial",
          "--n-color-hover": "initial",
          "--n-color-pressed": "initial",
          "--n-color-focus": "initial",
          "--n-color-disabled": "initial",
          "--n-ripple-color": "initial",
          "--n-text-color": "initial",
          "--n-text-color-hover": "initial",
          "--n-text-color-pressed": "initial",
          "--n-text-color-focus": "initial",
          "--n-text-color-disabled": "initial"
        };
        const typeIsTertiary = type === "tertiary";
        const typeIsDefault = type === "default";
        const mergedType = typeIsTertiary ? "default" : type;
        if (text2) {
          const propTextColor = textColor || color;
          const mergedTextColor = propTextColor || self2[createKey("textColorText", mergedType)];
          colorProps = {
            "--n-color": "#0000",
            "--n-color-hover": "#0000",
            "--n-color-pressed": "#0000",
            "--n-color-focus": "#0000",
            "--n-color-disabled": "#0000",
            "--n-ripple-color": "#0000",
            "--n-text-color": mergedTextColor,
            "--n-text-color-hover": propTextColor ? createHoverColor(propTextColor) : self2[createKey("textColorTextHover", mergedType)],
            "--n-text-color-pressed": propTextColor ? createPressedColor(propTextColor) : self2[createKey("textColorTextPressed", mergedType)],
            "--n-text-color-focus": propTextColor ? createHoverColor(propTextColor) : self2[createKey("textColorTextHover", mergedType)],
            "--n-text-color-disabled": propTextColor || self2[createKey("textColorTextDisabled", mergedType)]
          };
        } else if (ghost || dashed) {
          const mergedTextColor = textColor || color;
          colorProps = {
            "--n-color": "#0000",
            "--n-color-hover": "#0000",
            "--n-color-pressed": "#0000",
            "--n-color-focus": "#0000",
            "--n-color-disabled": "#0000",
            "--n-ripple-color": color || self2[createKey("rippleColor", mergedType)],
            "--n-text-color": mergedTextColor || self2[createKey("textColorGhost", mergedType)],
            "--n-text-color-hover": mergedTextColor ? createHoverColor(mergedTextColor) : self2[createKey("textColorGhostHover", mergedType)],
            "--n-text-color-pressed": mergedTextColor ? createPressedColor(mergedTextColor) : self2[createKey("textColorGhostPressed", mergedType)],
            "--n-text-color-focus": mergedTextColor ? createHoverColor(mergedTextColor) : self2[createKey("textColorGhostHover", mergedType)],
            "--n-text-color-disabled": mergedTextColor || self2[createKey("textColorGhostDisabled", mergedType)]
          };
        } else if (secondary) {
          const typeTextColor = typeIsDefault ? self2.textColor : typeIsTertiary ? self2.textColorTertiary : self2[createKey("color", mergedType)];
          const mergedTextColor = color || typeTextColor;
          const isColoredType = type !== "default" && type !== "tertiary";
          colorProps = {
            "--n-color": isColoredType ? changeColor(mergedTextColor, {
              alpha: Number(self2.colorOpacitySecondary)
            }) : self2.colorSecondary,
            "--n-color-hover": isColoredType ? changeColor(mergedTextColor, {
              alpha: Number(self2.colorOpacitySecondaryHover)
            }) : self2.colorSecondaryHover,
            "--n-color-pressed": isColoredType ? changeColor(mergedTextColor, {
              alpha: Number(self2.colorOpacitySecondaryPressed)
            }) : self2.colorSecondaryPressed,
            "--n-color-focus": isColoredType ? changeColor(mergedTextColor, {
              alpha: Number(self2.colorOpacitySecondaryHover)
            }) : self2.colorSecondaryHover,
            "--n-color-disabled": self2.colorSecondary,
            "--n-ripple-color": "#0000",
            "--n-text-color": mergedTextColor,
            "--n-text-color-hover": mergedTextColor,
            "--n-text-color-pressed": mergedTextColor,
            "--n-text-color-focus": mergedTextColor,
            "--n-text-color-disabled": mergedTextColor
          };
        } else if (tertiary || quaternary) {
          const typeColor = typeIsDefault ? self2.textColor : typeIsTertiary ? self2.textColorTertiary : self2[createKey("color", mergedType)];
          const mergedColor = color || typeColor;
          if (tertiary) {
            colorProps["--n-color"] = self2.colorTertiary;
            colorProps["--n-color-hover"] = self2.colorTertiaryHover;
            colorProps["--n-color-pressed"] = self2.colorTertiaryPressed;
            colorProps["--n-color-focus"] = self2.colorSecondaryHover;
            colorProps["--n-color-disabled"] = self2.colorTertiary;
          } else {
            colorProps["--n-color"] = self2.colorQuaternary;
            colorProps["--n-color-hover"] = self2.colorQuaternaryHover;
            colorProps["--n-color-pressed"] = self2.colorQuaternaryPressed;
            colorProps["--n-color-focus"] = self2.colorQuaternaryHover;
            colorProps["--n-color-disabled"] = self2.colorQuaternary;
          }
          colorProps["--n-ripple-color"] = "#0000";
          colorProps["--n-text-color"] = mergedColor;
          colorProps["--n-text-color-hover"] = mergedColor;
          colorProps["--n-text-color-pressed"] = mergedColor;
          colorProps["--n-text-color-focus"] = mergedColor;
          colorProps["--n-text-color-disabled"] = mergedColor;
        } else {
          colorProps = {
            "--n-color": color || self2[createKey("color", mergedType)],
            "--n-color-hover": color ? createHoverColor(color) : self2[createKey("colorHover", mergedType)],
            "--n-color-pressed": color ? createPressedColor(color) : self2[createKey("colorPressed", mergedType)],
            "--n-color-focus": color ? createHoverColor(color) : self2[createKey("colorFocus", mergedType)],
            "--n-color-disabled": color || self2[createKey("colorDisabled", mergedType)],
            "--n-ripple-color": color || self2[createKey("rippleColor", mergedType)],
            "--n-text-color": textColor || (color ? self2.textColorPrimary : typeIsTertiary ? self2.textColorTertiary : self2[createKey("textColor", mergedType)]),
            "--n-text-color-hover": textColor || (color ? self2.textColorHoverPrimary : self2[createKey("textColorHover", mergedType)]),
            "--n-text-color-pressed": textColor || (color ? self2.textColorPressedPrimary : self2[createKey("textColorPressed", mergedType)]),
            "--n-text-color-focus": textColor || (color ? self2.textColorFocusPrimary : self2[createKey("textColorFocus", mergedType)]),
            "--n-text-color-disabled": textColor || (color ? self2.textColorDisabledPrimary : self2[createKey("textColorDisabled", mergedType)])
          };
        }
        let borderProps = {
          "--n-border": "initial",
          "--n-border-hover": "initial",
          "--n-border-pressed": "initial",
          "--n-border-focus": "initial",
          "--n-border-disabled": "initial"
        };
        if (text2) {
          borderProps = {
            "--n-border": "none",
            "--n-border-hover": "none",
            "--n-border-pressed": "none",
            "--n-border-focus": "none",
            "--n-border-disabled": "none"
          };
        } else {
          borderProps = {
            "--n-border": self2[createKey("border", mergedType)],
            "--n-border-hover": self2[createKey("borderHover", mergedType)],
            "--n-border-pressed": self2[createKey("borderPressed", mergedType)],
            "--n-border-focus": self2[createKey("borderFocus", mergedType)],
            "--n-border-disabled": self2[createKey("borderDisabled", mergedType)]
          };
        }
        const {
          [createKey("height", size2)]: height,
          [createKey("fontSize", size2)]: fontSize2,
          [createKey("padding", size2)]: padding,
          [createKey("paddingRound", size2)]: paddingRound,
          [createKey("iconSize", size2)]: iconSize,
          [createKey("borderRadius", size2)]: borderRadius,
          [createKey("iconMargin", size2)]: iconMargin,
          waveOpacity
        } = self2;
        const sizeProps = {
          "--n-width": circle && !text2 ? height : "initial",
          "--n-height": text2 ? "initial" : height,
          "--n-font-size": fontSize2,
          "--n-padding": circle ? "initial" : text2 ? "initial" : round2 ? paddingRound : padding,
          "--n-icon-size": iconSize,
          "--n-icon-margin": iconMargin,
          "--n-border-radius": text2 ? "initial" : circle || round2 ? height : borderRadius
        };
        return Object.assign(Object.assign(Object.assign(Object.assign({
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-bezier-ease-out": cubicBezierEaseOut2,
          "--n-ripple-duration": rippleDuration,
          "--n-opacity-disabled": opacityDisabled,
          "--n-wave-opacity": waveOpacity
        }, fontProps), colorProps), borderProps), sizeProps);
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("button", vue.computed(() => {
        let hash = "";
        const {
          dashed,
          type,
          ghost,
          text: text2,
          color,
          round: round2,
          circle,
          textColor,
          secondary,
          tertiary,
          quaternary,
          strong
        } = props;
        if (dashed)
          hash += "a";
        if (ghost)
          hash += "b";
        if (text2)
          hash += "c";
        if (round2)
          hash += "d";
        if (circle)
          hash += "e";
        if (secondary)
          hash += "f";
        if (tertiary)
          hash += "g";
        if (quaternary)
          hash += "h";
        if (strong)
          hash += "i";
        if (color)
          hash += `j${color2Class(color)}`;
        if (textColor)
          hash += `k${color2Class(textColor)}`;
        const {
          value: size2
        } = mergedSizeRef;
        hash += `l${size2[0]}`;
        hash += `m${type[0]}`;
        return hash;
      }), cssVarsRef, props) : void 0;
      return {
        selfElRef,
        waveElRef,
        mergedClsPrefix: mergedClsPrefixRef,
        mergedFocusable: mergedFocusableRef,
        mergedSize: mergedSizeRef,
        showBorder: showBorderRef,
        enterPressed: enterPressedRef,
        rtlEnabled: rtlEnabledRef,
        handleMousedown,
        handleKeydown,
        handleBlur,
        handleKeyup,
        handleClick: handleClick2,
        customColorCssVars: vue.computed(() => {
          const {
            color
          } = props;
          if (!color)
            return null;
          const hoverColor = createHoverColor(color);
          return {
            "--n-border-color": color,
            "--n-border-color-hover": hoverColor,
            "--n-border-color-pressed": createPressedColor(color),
            "--n-border-color-focus": hoverColor,
            "--n-border-color-disabled": color
          };
        }),
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      const {
        mergedClsPrefix,
        tag: Component,
        onRender
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      const children = resolveWrappedSlot(this.$slots.default, (children2) => children2 && vue.h("span", {
        class: `${mergedClsPrefix}-button__content`
      }, children2));
      return vue.h(Component, {
        ref: "selfElRef",
        class: [
          this.themeClass,
          `${mergedClsPrefix}-button`,
          `${mergedClsPrefix}-button--${this.type}-type`,
          `${mergedClsPrefix}-button--${this.mergedSize}-type`,
          this.rtlEnabled && `${mergedClsPrefix}-button--rtl`,
          this.disabled && `${mergedClsPrefix}-button--disabled`,
          this.block && `${mergedClsPrefix}-button--block`,
          this.enterPressed && `${mergedClsPrefix}-button--pressed`,
          !this.text && this.dashed && `${mergedClsPrefix}-button--dashed`,
          this.color && `${mergedClsPrefix}-button--color`,
          this.secondary && `${mergedClsPrefix}-button--secondary`,
          this.loading && `${mergedClsPrefix}-button--loading`,
          this.ghost && `${mergedClsPrefix}-button--ghost`
          // required for button group border collapse
        ],
        tabindex: this.mergedFocusable ? 0 : -1,
        type: this.attrType,
        style: this.cssVars,
        disabled: this.disabled,
        onClick: this.handleClick,
        onBlur: this.handleBlur,
        onMousedown: this.handleMousedown,
        onKeyup: this.handleKeyup,
        onKeydown: this.handleKeydown
      }, this.iconPlacement === "right" && children, vue.h(NFadeInExpandTransition, {
        width: true
      }, {
        default: () => resolveWrappedSlot(this.$slots.icon, (children2) => (this.loading || this.renderIcon || children2) && vue.h("span", {
          class: `${mergedClsPrefix}-button__icon`,
          style: {
            margin: isSlotEmpty(this.$slots.default) ? "0" : ""
          }
        }, vue.h(NIconSwitchTransition, null, {
          default: () => this.loading ? vue.h(NBaseLoading, {
            clsPrefix: mergedClsPrefix,
            key: "loading",
            class: `${mergedClsPrefix}-icon-slot`,
            strokeWidth: 20
          }) : vue.h("div", {
            key: "icon",
            class: `${mergedClsPrefix}-icon-slot`,
            role: "none"
          }, this.renderIcon ? this.renderIcon() : children2)
        })))
      }), this.iconPlacement === "left" && children, !this.text ? vue.h(NBaseWave, {
        ref: "waveElRef",
        clsPrefix: mergedClsPrefix
      }) : null, this.showBorder ? vue.h("div", {
        "aria-hidden": true,
        class: `${mergedClsPrefix}-button__border`,
        style: this.customColorCssVars
      }) : null, this.showBorder ? vue.h("div", {
        "aria-hidden": true,
        class: `${mergedClsPrefix}-button__state-border`,
        style: this.customColorCssVars
      }) : null);
    }
  });
  const NButton = Button;
  const XButton = Button;
  const zero = "0!important";
  const n1 = "-1px!important";
  function createLeftBorderStyle(type) {
    return cM(`${type}-type`, [c$1("& +", [cB("button", {}, [cM(`${type}-type`, [cE("border", {
      borderLeftWidth: zero
    }), cE("state-border", {
      left: n1
    })])])])]);
  }
  function createTopBorderStyle(type) {
    return cM(`${type}-type`, [c$1("& +", [cB("button", [cM(`${type}-type`, [cE("border", {
      borderTopWidth: zero
    }), cE("state-border", {
      top: n1
    })])])])]);
  }
  const style$1d = cB("button-group", `
 flex-wrap: nowrap;
 display: inline-flex;
 position: relative;
`, [cNotM("vertical", {
    flexDirection: "row"
  }, [cNotM("rtl", [cB("button", [c$1("&:first-child:not(:last-child)", `
 margin-right: ${zero};
 border-top-right-radius: ${zero};
 border-bottom-right-radius: ${zero};
 `), c$1("&:last-child:not(:first-child)", `
 margin-left: ${zero};
 border-top-left-radius: ${zero};
 border-bottom-left-radius: ${zero};
 `), c$1("&:not(:first-child):not(:last-child)", `
 margin-left: ${zero};
 margin-right: ${zero};
 border-radius: ${zero};
 `), createLeftBorderStyle("default"), cM("ghost", [createLeftBorderStyle("primary"), createLeftBorderStyle("info"), createLeftBorderStyle("success"), createLeftBorderStyle("warning"), createLeftBorderStyle("error")])])])]), cM("vertical", {
    flexDirection: "column"
  }, [cB("button", [c$1("&:first-child:not(:last-child)", `
 margin-bottom: ${zero};
 margin-left: ${zero};
 margin-right: ${zero};
 border-bottom-left-radius: ${zero};
 border-bottom-right-radius: ${zero};
 `), c$1("&:last-child:not(:first-child)", `
 margin-top: ${zero};
 margin-left: ${zero};
 margin-right: ${zero};
 border-top-left-radius: ${zero};
 border-top-right-radius: ${zero};
 `), c$1("&:not(:first-child):not(:last-child)", `
 margin: ${zero};
 border-radius: ${zero};
 `), createTopBorderStyle("default"), cM("ghost", [createTopBorderStyle("primary"), createTopBorderStyle("info"), createTopBorderStyle("success"), createTopBorderStyle("warning"), createTopBorderStyle("error")])])])]);
  const buttonGroupProps = {
    size: {
      type: String,
      default: void 0
    },
    vertical: Boolean
  };
  const NButtonGroup = vue.defineComponent({
    name: "ButtonGroup",
    props: buttonGroupProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        mergedRtlRef
      } = useConfig(props);
      useStyle("-button-group", style$1d, mergedClsPrefixRef);
      vue.provide(buttonGroupInjectionKey, props);
      const rtlEnabledRef = useRtl("ButtonGroup", mergedRtlRef, mergedClsPrefixRef);
      return {
        rtlEnabled: rtlEnabledRef,
        mergedClsPrefix: mergedClsPrefixRef
      };
    },
    render() {
      const {
        mergedClsPrefix
      } = this;
      return vue.h("div", {
        class: [`${mergedClsPrefix}-button-group`, this.rtlEnabled && `${mergedClsPrefix}-button-group--rtl`, this.vertical && `${mergedClsPrefix}-button-group--vertical`],
        role: "group"
      }, this.$slots);
    }
  });
  function constructFrom(date, value) {
    if (date instanceof Date) {
      return new date.constructor(value);
    } else {
      return new Date(value);
    }
  }
  function addDays(date, amount) {
    const _date = toDate$1(date);
    if (isNaN(amount))
      return constructFrom(date, NaN);
    if (!amount) {
      return _date;
    }
    _date.setDate(_date.getDate() + amount);
    return _date;
  }
  function addMonths(date, amount) {
    const _date = toDate$1(date);
    if (isNaN(amount))
      return constructFrom(date, NaN);
    if (!amount) {
      return _date;
    }
    const dayOfMonth = _date.getDate();
    const endOfDesiredMonth = constructFrom(date, _date.getTime());
    endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
    const daysInMonth = endOfDesiredMonth.getDate();
    if (dayOfMonth >= daysInMonth) {
      return endOfDesiredMonth;
    } else {
      _date.setFullYear(
        endOfDesiredMonth.getFullYear(),
        endOfDesiredMonth.getMonth(),
        dayOfMonth
      );
      return _date;
    }
  }
  const millisecondsInWeek = 6048e5;
  const millisecondsInDay = 864e5;
  const millisecondsInMinute = 6e4;
  const millisecondsInHour = 36e5;
  const millisecondsInSecond = 1e3;
  const minutesInYear = 525600;
  const minutesInMonth = 43200;
  const minutesInDay = 1440;
  function startOfISOWeek(date) {
    return startOfWeek(date, { weekStartsOn: 1 });
  }
  function getISOWeekYear(date) {
    const _date = toDate$1(date);
    const year = _date.getFullYear();
    const fourthOfJanuaryOfNextYear = constructFrom(date, 0);
    fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
    const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
    const fourthOfJanuaryOfThisYear = constructFrom(date, 0);
    fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
    const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
    if (_date.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (_date.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  }
  function startOfDay(date) {
    const _date = toDate$1(date);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }
  function getTimezoneOffsetInMilliseconds$1(date) {
    const _date = toDate$1(date);
    const utcDate = new Date(
      Date.UTC(
        _date.getFullYear(),
        _date.getMonth(),
        _date.getDate(),
        _date.getHours(),
        _date.getMinutes(),
        _date.getSeconds(),
        _date.getMilliseconds()
      )
    );
    utcDate.setUTCFullYear(_date.getFullYear());
    return +date - +utcDate;
  }
  function differenceInCalendarDays(dateLeft, dateRight) {
    const startOfDayLeft = startOfDay(dateLeft);
    const startOfDayRight = startOfDay(dateRight);
    const timestampLeft = +startOfDayLeft - getTimezoneOffsetInMilliseconds$1(startOfDayLeft);
    const timestampRight = +startOfDayRight - getTimezoneOffsetInMilliseconds$1(startOfDayRight);
    return Math.round((timestampLeft - timestampRight) / millisecondsInDay);
  }
  function startOfISOWeekYear(date) {
    const year = getISOWeekYear(date);
    const fourthOfJanuary = constructFrom(date, 0);
    fourthOfJanuary.setFullYear(year, 0, 4);
    fourthOfJanuary.setHours(0, 0, 0, 0);
    return startOfISOWeek(fourthOfJanuary);
  }
  function addQuarters(date, amount) {
    const months = amount * 3;
    return addMonths(date, months);
  }
  function addYears(date, amount) {
    return addMonths(date, amount * 12);
  }
  function compareAsc(dateLeft, dateRight) {
    const _dateLeft = toDate$1(dateLeft);
    const _dateRight = toDate$1(dateRight);
    const diff = _dateLeft.getTime() - _dateRight.getTime();
    if (diff < 0) {
      return -1;
    } else if (diff > 0) {
      return 1;
    } else {
      return diff;
    }
  }
  function isSameDay(dateLeft, dateRight) {
    const dateLeftStartOfDay = startOfDay(dateLeft);
    const dateRightStartOfDay = startOfDay(dateRight);
    return +dateLeftStartOfDay === +dateRightStartOfDay;
  }
  function isDate(value) {
    return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
  }
  function isValid(date) {
    if (!isDate(date) && typeof date !== "number") {
      return false;
    }
    const _date = toDate$1(date);
    return !isNaN(Number(_date));
  }
  function getQuarter(date) {
    const _date = toDate$1(date);
    const quarter = Math.trunc(_date.getMonth() / 3) + 1;
    return quarter;
  }
  function getRoundingMethod(method) {
    return (number) => {
      const round2 = method ? Math[method] : Math.trunc;
      const result = round2(number);
      return result === 0 ? 0 : result;
    };
  }
  function startOfMinute(date) {
    const _date = toDate$1(date);
    _date.setSeconds(0, 0);
    return _date;
  }
  function startOfQuarter(date) {
    const _date = toDate$1(date);
    const currentMonth = _date.getMonth();
    const month = currentMonth - currentMonth % 3;
    _date.setMonth(month, 1);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }
  function startOfMonth(date) {
    const _date = toDate$1(date);
    _date.setDate(1);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }
  function startOfYear(date) {
    const cleanDate = toDate$1(date);
    const _date = constructFrom(date, 0);
    _date.setFullYear(cleanDate.getFullYear(), 0, 1);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }
  function getDayOfYear(date) {
    const _date = toDate$1(date);
    const diff = differenceInCalendarDays(_date, startOfYear(_date));
    const dayOfYear = diff + 1;
    return dayOfYear;
  }
  function getISOWeek(date) {
    const _date = toDate$1(date);
    const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
    return Math.round(diff / millisecondsInWeek) + 1;
  }
  function getWeekYear(date, options) {
    var _a, _b, _c, _d;
    const _date = toDate$1(date);
    const year = _date.getFullYear();
    const defaultOptions2 = getDefaultOptions$1();
    const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions2.firstWeekContainsDate ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
    const firstWeekOfNextYear = constructFrom(date, 0);
    firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
    firstWeekOfNextYear.setHours(0, 0, 0, 0);
    const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
    const firstWeekOfThisYear = constructFrom(date, 0);
    firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
    firstWeekOfThisYear.setHours(0, 0, 0, 0);
    const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
    if (_date.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (_date.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  }
  function startOfWeekYear(date, options) {
    var _a, _b, _c, _d;
    const defaultOptions2 = getDefaultOptions$1();
    const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions2.firstWeekContainsDate ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
    const year = getWeekYear(date, options);
    const firstWeek = constructFrom(date, 0);
    firstWeek.setFullYear(year, 0, firstWeekContainsDate);
    firstWeek.setHours(0, 0, 0, 0);
    const _date = startOfWeek(firstWeek, options);
    return _date;
  }
  function getWeek(date, options) {
    const _date = toDate$1(date);
    const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);
    return Math.round(diff / millisecondsInWeek) + 1;
  }
  function addLeadingZeros$1(number, targetLength) {
    const sign = number < 0 ? "-" : "";
    const output = Math.abs(number).toString().padStart(targetLength, "0");
    return sign + output;
  }
  const lightFormatters = {
    // Year
    y(date, token) {
      const signedYear = date.getFullYear();
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return addLeadingZeros$1(token === "yy" ? year % 100 : year, token.length);
    },
    // Month
    M(date, token) {
      const month = date.getMonth();
      return token === "M" ? String(month + 1) : addLeadingZeros$1(month + 1, 2);
    },
    // Day of the month
    d(date, token) {
      return addLeadingZeros$1(date.getDate(), token.length);
    },
    // AM or PM
    a(date, token) {
      const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
      switch (token) {
        case "a":
        case "aa":
          return dayPeriodEnumValue.toUpperCase();
        case "aaa":
          return dayPeriodEnumValue;
        case "aaaaa":
          return dayPeriodEnumValue[0];
        case "aaaa":
        default:
          return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
      }
    },
    // Hour [1-12]
    h(date, token) {
      return addLeadingZeros$1(date.getHours() % 12 || 12, token.length);
    },
    // Hour [0-23]
    H(date, token) {
      return addLeadingZeros$1(date.getHours(), token.length);
    },
    // Minute
    m(date, token) {
      return addLeadingZeros$1(date.getMinutes(), token.length);
    },
    // Second
    s(date, token) {
      return addLeadingZeros$1(date.getSeconds(), token.length);
    },
    // Fraction of second
    S(date, token) {
      const numberOfDigits = token.length;
      const milliseconds = date.getMilliseconds();
      const fractionalSeconds = Math.trunc(
        milliseconds * Math.pow(10, numberOfDigits - 3)
      );
      return addLeadingZeros$1(fractionalSeconds, token.length);
    }
  };
  const dayPeriodEnum = {
    am: "am",
    pm: "pm",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  };
  const formatters$1 = {
    // Era
    G: function(date, token, localize2) {
      const era = date.getFullYear() > 0 ? 1 : 0;
      switch (token) {
        case "G":
        case "GG":
        case "GGG":
          return localize2.era(era, { width: "abbreviated" });
        case "GGGGG":
          return localize2.era(era, { width: "narrow" });
        case "GGGG":
        default:
          return localize2.era(era, { width: "wide" });
      }
    },
    // Year
    y: function(date, token, localize2) {
      if (token === "yo") {
        const signedYear = date.getFullYear();
        const year = signedYear > 0 ? signedYear : 1 - signedYear;
        return localize2.ordinalNumber(year, { unit: "year" });
      }
      return lightFormatters.y(date, token);
    },
    // Local week-numbering year
    Y: function(date, token, localize2, options) {
      const signedWeekYear = getWeekYear(date, options);
      const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
      if (token === "YY") {
        const twoDigitYear = weekYear % 100;
        return addLeadingZeros$1(twoDigitYear, 2);
      }
      if (token === "Yo") {
        return localize2.ordinalNumber(weekYear, { unit: "year" });
      }
      return addLeadingZeros$1(weekYear, token.length);
    },
    // ISO week-numbering year
    R: function(date, token) {
      const isoWeekYear = getISOWeekYear(date);
      return addLeadingZeros$1(isoWeekYear, token.length);
    },
    // Extended year. This is a single number designating the year of this calendar system.
    // The main difference between `y` and `u` localizers are B.C. years:
    // | Year | `y` | `u` |
    // |------|-----|-----|
    // | AC 1 |   1 |   1 |
    // | BC 1 |   1 |   0 |
    // | BC 2 |   2 |  -1 |
    // Also `yy` always returns the last two digits of a year,
    // while `uu` pads single digit years to 2 characters and returns other years unchanged.
    u: function(date, token) {
      const year = date.getFullYear();
      return addLeadingZeros$1(year, token.length);
    },
    // Quarter
    Q: function(date, token, localize2) {
      const quarter = Math.ceil((date.getMonth() + 1) / 3);
      switch (token) {
        case "Q":
          return String(quarter);
        case "QQ":
          return addLeadingZeros$1(quarter, 2);
        case "Qo":
          return localize2.ordinalNumber(quarter, { unit: "quarter" });
        case "QQQ":
          return localize2.quarter(quarter, {
            width: "abbreviated",
            context: "formatting"
          });
        case "QQQQQ":
          return localize2.quarter(quarter, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return localize2.quarter(quarter, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Stand-alone quarter
    q: function(date, token, localize2) {
      const quarter = Math.ceil((date.getMonth() + 1) / 3);
      switch (token) {
        case "q":
          return String(quarter);
        case "qq":
          return addLeadingZeros$1(quarter, 2);
        case "qo":
          return localize2.ordinalNumber(quarter, { unit: "quarter" });
        case "qqq":
          return localize2.quarter(quarter, {
            width: "abbreviated",
            context: "standalone"
          });
        case "qqqqq":
          return localize2.quarter(quarter, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return localize2.quarter(quarter, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    // Month
    M: function(date, token, localize2) {
      const month = date.getMonth();
      switch (token) {
        case "M":
        case "MM":
          return lightFormatters.M(date, token);
        case "Mo":
          return localize2.ordinalNumber(month + 1, { unit: "month" });
        case "MMM":
          return localize2.month(month, {
            width: "abbreviated",
            context: "formatting"
          });
        case "MMMMM":
          return localize2.month(month, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return localize2.month(month, { width: "wide", context: "formatting" });
      }
    },
    // Stand-alone month
    L: function(date, token, localize2) {
      const month = date.getMonth();
      switch (token) {
        case "L":
          return String(month + 1);
        case "LL":
          return addLeadingZeros$1(month + 1, 2);
        case "Lo":
          return localize2.ordinalNumber(month + 1, { unit: "month" });
        case "LLL":
          return localize2.month(month, {
            width: "abbreviated",
            context: "standalone"
          });
        case "LLLLL":
          return localize2.month(month, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return localize2.month(month, { width: "wide", context: "standalone" });
      }
    },
    // Local week of year
    w: function(date, token, localize2, options) {
      const week = getWeek(date, options);
      if (token === "wo") {
        return localize2.ordinalNumber(week, { unit: "week" });
      }
      return addLeadingZeros$1(week, token.length);
    },
    // ISO week of year
    I: function(date, token, localize2) {
      const isoWeek = getISOWeek(date);
      if (token === "Io") {
        return localize2.ordinalNumber(isoWeek, { unit: "week" });
      }
      return addLeadingZeros$1(isoWeek, token.length);
    },
    // Day of the month
    d: function(date, token, localize2) {
      if (token === "do") {
        return localize2.ordinalNumber(date.getDate(), { unit: "date" });
      }
      return lightFormatters.d(date, token);
    },
    // Day of year
    D: function(date, token, localize2) {
      const dayOfYear = getDayOfYear(date);
      if (token === "Do") {
        return localize2.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
      }
      return addLeadingZeros$1(dayOfYear, token.length);
    },
    // Day of week
    E: function(date, token, localize2) {
      const dayOfWeek = date.getDay();
      switch (token) {
        case "E":
        case "EE":
        case "EEE":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        case "EEEEE":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        case "EEEE":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Local day of week
    e: function(date, token, localize2, options) {
      const dayOfWeek = date.getDay();
      const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
      switch (token) {
        case "e":
          return String(localDayOfWeek);
        case "ee":
          return addLeadingZeros$1(localDayOfWeek, 2);
        case "eo":
          return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
        case "eee":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        case "eeeee":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        case "eeee":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Stand-alone local day of week
    c: function(date, token, localize2, options) {
      const dayOfWeek = date.getDay();
      const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
      switch (token) {
        case "c":
          return String(localDayOfWeek);
        case "cc":
          return addLeadingZeros$1(localDayOfWeek, token.length);
        case "co":
          return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
        case "ccc":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "standalone"
          });
        case "ccccc":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "standalone"
          });
        case "cccc":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    // ISO day of week
    i: function(date, token, localize2) {
      const dayOfWeek = date.getDay();
      const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
      switch (token) {
        case "i":
          return String(isoDayOfWeek);
        case "ii":
          return addLeadingZeros$1(isoDayOfWeek, token.length);
        case "io":
          return localize2.ordinalNumber(isoDayOfWeek, { unit: "day" });
        case "iii":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        case "iiiii":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        case "iiiiii":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        case "iiii":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // AM or PM
    a: function(date, token, localize2) {
      const hours = date.getHours();
      const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
      switch (token) {
        case "a":
        case "aa":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "aaa":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "aaaaa":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // AM, PM, midnight, noon
    b: function(date, token, localize2) {
      const hours = date.getHours();
      let dayPeriodEnumValue;
      if (hours === 12) {
        dayPeriodEnumValue = dayPeriodEnum.noon;
      } else if (hours === 0) {
        dayPeriodEnumValue = dayPeriodEnum.midnight;
      } else {
        dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
      }
      switch (token) {
        case "b":
        case "bb":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "bbb":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "bbbbb":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // in the morning, in the afternoon, in the evening, at night
    B: function(date, token, localize2) {
      const hours = date.getHours();
      let dayPeriodEnumValue;
      if (hours >= 17) {
        dayPeriodEnumValue = dayPeriodEnum.evening;
      } else if (hours >= 12) {
        dayPeriodEnumValue = dayPeriodEnum.afternoon;
      } else if (hours >= 4) {
        dayPeriodEnumValue = dayPeriodEnum.morning;
      } else {
        dayPeriodEnumValue = dayPeriodEnum.night;
      }
      switch (token) {
        case "B":
        case "BB":
        case "BBB":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "BBBBB":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Hour [1-12]
    h: function(date, token, localize2) {
      if (token === "ho") {
        let hours = date.getHours() % 12;
        if (hours === 0)
          hours = 12;
        return localize2.ordinalNumber(hours, { unit: "hour" });
      }
      return lightFormatters.h(date, token);
    },
    // Hour [0-23]
    H: function(date, token, localize2) {
      if (token === "Ho") {
        return localize2.ordinalNumber(date.getHours(), { unit: "hour" });
      }
      return lightFormatters.H(date, token);
    },
    // Hour [0-11]
    K: function(date, token, localize2) {
      const hours = date.getHours() % 12;
      if (token === "Ko") {
        return localize2.ordinalNumber(hours, { unit: "hour" });
      }
      return addLeadingZeros$1(hours, token.length);
    },
    // Hour [1-24]
    k: function(date, token, localize2) {
      let hours = date.getHours();
      if (hours === 0)
        hours = 24;
      if (token === "ko") {
        return localize2.ordinalNumber(hours, { unit: "hour" });
      }
      return addLeadingZeros$1(hours, token.length);
    },
    // Minute
    m: function(date, token, localize2) {
      if (token === "mo") {
        return localize2.ordinalNumber(date.getMinutes(), { unit: "minute" });
      }
      return lightFormatters.m(date, token);
    },
    // Second
    s: function(date, token, localize2) {
      if (token === "so") {
        return localize2.ordinalNumber(date.getSeconds(), { unit: "second" });
      }
      return lightFormatters.s(date, token);
    },
    // Fraction of second
    S: function(date, token) {
      return lightFormatters.S(date, token);
    },
    // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
    X: function(date, token, _localize) {
      const timezoneOffset = date.getTimezoneOffset();
      if (timezoneOffset === 0) {
        return "Z";
      }
      switch (token) {
        case "X":
          return formatTimezoneWithOptionalMinutes$1(timezoneOffset);
        case "XXXX":
        case "XX":
          return formatTimezone$1(timezoneOffset);
        case "XXXXX":
        case "XXX":
        default:
          return formatTimezone$1(timezoneOffset, ":");
      }
    },
    // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
    x: function(date, token, _localize) {
      const timezoneOffset = date.getTimezoneOffset();
      switch (token) {
        case "x":
          return formatTimezoneWithOptionalMinutes$1(timezoneOffset);
        case "xxxx":
        case "xx":
          return formatTimezone$1(timezoneOffset);
        case "xxxxx":
        case "xxx":
        default:
          return formatTimezone$1(timezoneOffset, ":");
      }
    },
    // Timezone (GMT)
    O: function(date, token, _localize) {
      const timezoneOffset = date.getTimezoneOffset();
      switch (token) {
        case "O":
        case "OO":
        case "OOO":
          return "GMT" + formatTimezoneShort$1(timezoneOffset, ":");
        case "OOOO":
        default:
          return "GMT" + formatTimezone$1(timezoneOffset, ":");
      }
    },
    // Timezone (specific non-location)
    z: function(date, token, _localize) {
      const timezoneOffset = date.getTimezoneOffset();
      switch (token) {
        case "z":
        case "zz":
        case "zzz":
          return "GMT" + formatTimezoneShort$1(timezoneOffset, ":");
        case "zzzz":
        default:
          return "GMT" + formatTimezone$1(timezoneOffset, ":");
      }
    },
    // Seconds timestamp
    t: function(date, token, _localize) {
      const timestamp = Math.trunc(date.getTime() / 1e3);
      return addLeadingZeros$1(timestamp, token.length);
    },
    // Milliseconds timestamp
    T: function(date, token, _localize) {
      const timestamp = date.getTime();
      return addLeadingZeros$1(timestamp, token.length);
    }
  };
  function formatTimezoneShort$1(offset, delimiter = "") {
    const sign = offset > 0 ? "-" : "+";
    const absOffset = Math.abs(offset);
    const hours = Math.trunc(absOffset / 60);
    const minutes = absOffset % 60;
    if (minutes === 0) {
      return sign + String(hours);
    }
    return sign + String(hours) + delimiter + addLeadingZeros$1(minutes, 2);
  }
  function formatTimezoneWithOptionalMinutes$1(offset, delimiter) {
    if (offset % 60 === 0) {
      const sign = offset > 0 ? "-" : "+";
      return sign + addLeadingZeros$1(Math.abs(offset) / 60, 2);
    }
    return formatTimezone$1(offset, delimiter);
  }
  function formatTimezone$1(offset, delimiter = "") {
    const sign = offset > 0 ? "-" : "+";
    const absOffset = Math.abs(offset);
    const hours = addLeadingZeros$1(Math.trunc(absOffset / 60), 2);
    const minutes = addLeadingZeros$1(absOffset % 60, 2);
    return sign + hours + delimiter + minutes;
  }
  const dateLongFormatter = (pattern, formatLong2) => {
    switch (pattern) {
      case "P":
        return formatLong2.date({ width: "short" });
      case "PP":
        return formatLong2.date({ width: "medium" });
      case "PPP":
        return formatLong2.date({ width: "long" });
      case "PPPP":
      default:
        return formatLong2.date({ width: "full" });
    }
  };
  const timeLongFormatter = (pattern, formatLong2) => {
    switch (pattern) {
      case "p":
        return formatLong2.time({ width: "short" });
      case "pp":
        return formatLong2.time({ width: "medium" });
      case "ppp":
        return formatLong2.time({ width: "long" });
      case "pppp":
      default:
        return formatLong2.time({ width: "full" });
    }
  };
  const dateTimeLongFormatter = (pattern, formatLong2) => {
    const matchResult = pattern.match(/(P+)(p+)?/) || [];
    const datePattern = matchResult[1];
    const timePattern = matchResult[2];
    if (!timePattern) {
      return dateLongFormatter(pattern, formatLong2);
    }
    let dateTimeFormat;
    switch (datePattern) {
      case "P":
        dateTimeFormat = formatLong2.dateTime({ width: "short" });
        break;
      case "PP":
        dateTimeFormat = formatLong2.dateTime({ width: "medium" });
        break;
      case "PPP":
        dateTimeFormat = formatLong2.dateTime({ width: "long" });
        break;
      case "PPPP":
      default:
        dateTimeFormat = formatLong2.dateTime({ width: "full" });
        break;
    }
    return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
  };
  const longFormatters = {
    p: timeLongFormatter,
    P: dateTimeLongFormatter
  };
  const dayOfYearTokenRE = /^D+$/;
  const weekYearTokenRE = /^Y+$/;
  const throwTokens = ["D", "DD", "YY", "YYYY"];
  function isProtectedDayOfYearToken(token) {
    return dayOfYearTokenRE.test(token);
  }
  function isProtectedWeekYearToken(token) {
    return weekYearTokenRE.test(token);
  }
  function warnOrThrowProtectedError(token, format2, input) {
    const _message = message(token, format2, input);
    console.warn(_message);
    if (throwTokens.includes(token))
      throw new RangeError(_message);
  }
  function message(token, format2, input) {
    const subject = token[0] === "Y" ? "years" : "days of the month";
    return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
  }
  const formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
  const longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
  const escapedStringRegExp$1 = /^'([^]*?)'?$/;
  const doubleQuoteRegExp$1 = /''/g;
  const unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
  function format$3(date, formatStr, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const defaultOptions2 = getDefaultOptions$1();
    const locale = (options == null ? void 0 : options.locale) ?? defaultOptions2.locale ?? enUS;
    const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions2.firstWeekContainsDate ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
    const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_f = (_e = options == null ? void 0 : options.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.weekStartsOn) ?? defaultOptions2.weekStartsOn ?? ((_h = (_g = defaultOptions2.locale) == null ? void 0 : _g.options) == null ? void 0 : _h.weekStartsOn) ?? 0;
    const originalDate = toDate$1(date);
    if (!isValid(originalDate)) {
      throw new RangeError("Invalid time value");
    }
    let parts = formatStr.match(longFormattingTokensRegExp$1).map((substring) => {
      const firstCharacter = substring[0];
      if (firstCharacter === "p" || firstCharacter === "P") {
        const longFormatter = longFormatters[firstCharacter];
        return longFormatter(substring, locale.formatLong);
      }
      return substring;
    }).join("").match(formattingTokensRegExp$1).map((substring) => {
      if (substring === "''") {
        return { isToken: false, value: "'" };
      }
      const firstCharacter = substring[0];
      if (firstCharacter === "'") {
        return { isToken: false, value: cleanEscapedString$1(substring) };
      }
      if (formatters$1[firstCharacter]) {
        return { isToken: true, value: substring };
      }
      if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
        );
      }
      return { isToken: false, value: substring };
    });
    if (locale.localize.preprocessor) {
      parts = locale.localize.preprocessor(originalDate, parts);
    }
    const formatterOptions = {
      firstWeekContainsDate,
      weekStartsOn,
      locale
    };
    return parts.map((part) => {
      if (!part.isToken)
        return part.value;
      const token = part.value;
      if (!(options == null ? void 0 : options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token) || !(options == null ? void 0 : options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
        warnOrThrowProtectedError(token, formatStr, String(date));
      }
      const formatter = formatters$1[token[0]];
      return formatter(originalDate, token, locale.localize, formatterOptions);
    }).join("");
  }
  function cleanEscapedString$1(input) {
    const matched = input.match(escapedStringRegExp$1);
    if (!matched) {
      return input;
    }
    return matched[1].replace(doubleQuoteRegExp$1, "'");
  }
  function formatDistanceStrict(date, baseDate, options) {
    const defaultOptions2 = getDefaultOptions$1();
    const locale = (options == null ? void 0 : options.locale) ?? defaultOptions2.locale ?? enUS;
    const comparison = compareAsc(date, baseDate);
    if (isNaN(comparison)) {
      throw new RangeError("Invalid time value");
    }
    const localizeOptions = Object.assign({}, options, {
      addSuffix: options == null ? void 0 : options.addSuffix,
      comparison
    });
    let dateLeft;
    let dateRight;
    if (comparison > 0) {
      dateLeft = toDate$1(baseDate);
      dateRight = toDate$1(date);
    } else {
      dateLeft = toDate$1(date);
      dateRight = toDate$1(baseDate);
    }
    const roundingMethod = getRoundingMethod((options == null ? void 0 : options.roundingMethod) ?? "round");
    const milliseconds = dateRight.getTime() - dateLeft.getTime();
    const minutes = milliseconds / millisecondsInMinute;
    const timezoneOffset = getTimezoneOffsetInMilliseconds$1(dateRight) - getTimezoneOffsetInMilliseconds$1(dateLeft);
    const dstNormalizedMinutes = (milliseconds - timezoneOffset) / millisecondsInMinute;
    const defaultUnit = options == null ? void 0 : options.unit;
    let unit;
    if (!defaultUnit) {
      if (minutes < 1) {
        unit = "second";
      } else if (minutes < 60) {
        unit = "minute";
      } else if (minutes < minutesInDay) {
        unit = "hour";
      } else if (dstNormalizedMinutes < minutesInMonth) {
        unit = "day";
      } else if (dstNormalizedMinutes < minutesInYear) {
        unit = "month";
      } else {
        unit = "year";
      }
    } else {
      unit = defaultUnit;
    }
    if (unit === "second") {
      const seconds = roundingMethod(milliseconds / 1e3);
      return locale.formatDistance("xSeconds", seconds, localizeOptions);
    } else if (unit === "minute") {
      const roundedMinutes = roundingMethod(minutes);
      return locale.formatDistance("xMinutes", roundedMinutes, localizeOptions);
    } else if (unit === "hour") {
      const hours = roundingMethod(minutes / 60);
      return locale.formatDistance("xHours", hours, localizeOptions);
    } else if (unit === "day") {
      const days = roundingMethod(dstNormalizedMinutes / minutesInDay);
      return locale.formatDistance("xDays", days, localizeOptions);
    } else if (unit === "month") {
      const months = roundingMethod(dstNormalizedMinutes / minutesInMonth);
      return months === 12 && defaultUnit !== "month" ? locale.formatDistance("xYears", 1, localizeOptions) : locale.formatDistance("xMonths", months, localizeOptions);
    } else {
      const years = roundingMethod(dstNormalizedMinutes / minutesInYear);
      return locale.formatDistance("xYears", years, localizeOptions);
    }
  }
  function fromUnixTime(unixTime) {
    return toDate$1(unixTime * 1e3);
  }
  function getDate(date) {
    const _date = toDate$1(date);
    const dayOfMonth = _date.getDate();
    return dayOfMonth;
  }
  function getDay(date) {
    const _date = toDate$1(date);
    const day = _date.getDay();
    return day;
  }
  function getDaysInMonth(date) {
    const _date = toDate$1(date);
    const year = _date.getFullYear();
    const monthIndex = _date.getMonth();
    const lastDayOfMonth = constructFrom(date, 0);
    lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
    lastDayOfMonth.setHours(0, 0, 0, 0);
    return lastDayOfMonth.getDate();
  }
  function getDefaultOptions() {
    return Object.assign({}, getDefaultOptions$1());
  }
  function getHours(date) {
    const _date = toDate$1(date);
    const hours = _date.getHours();
    return hours;
  }
  function getISODay(date) {
    const _date = toDate$1(date);
    let day = _date.getDay();
    if (day === 0) {
      day = 7;
    }
    return day;
  }
  function getMilliseconds(date) {
    const _date = toDate$1(date);
    const milliseconds = _date.getMilliseconds();
    return milliseconds;
  }
  function getMinutes(date) {
    const _date = toDate$1(date);
    const minutes = _date.getMinutes();
    return minutes;
  }
  function getMonth(date) {
    const _date = toDate$1(date);
    const month = _date.getMonth();
    return month;
  }
  function getSeconds(date) {
    const _date = toDate$1(date);
    const seconds = _date.getSeconds();
    return seconds;
  }
  function getTime(date) {
    const _date = toDate$1(date);
    const timestamp = _date.getTime();
    return timestamp;
  }
  function getYear(date) {
    return toDate$1(date).getFullYear();
  }
  function transpose(fromDate, constructor) {
    const date = constructor instanceof Date ? constructFrom(constructor, 0) : new constructor(0);
    date.setFullYear(
      fromDate.getFullYear(),
      fromDate.getMonth(),
      fromDate.getDate()
    );
    date.setHours(
      fromDate.getHours(),
      fromDate.getMinutes(),
      fromDate.getSeconds(),
      fromDate.getMilliseconds()
    );
    return date;
  }
  const TIMEZONE_UNIT_PRIORITY = 10;
  class Setter {
    constructor() {
      __publicField(this, "subPriority", 0);
    }
    validate(_utcDate, _options) {
      return true;
    }
  }
  class ValueSetter extends Setter {
    constructor(value, validateValue, setValue, priority, subPriority) {
      super();
      this.value = value;
      this.validateValue = validateValue;
      this.setValue = setValue;
      this.priority = priority;
      if (subPriority) {
        this.subPriority = subPriority;
      }
    }
    validate(date, options) {
      return this.validateValue(date, this.value, options);
    }
    set(date, flags, options) {
      return this.setValue(date, flags, this.value, options);
    }
  }
  class DateToSystemTimezoneSetter extends Setter {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", TIMEZONE_UNIT_PRIORITY);
      __publicField(this, "subPriority", -1);
    }
    set(date, flags) {
      if (flags.timestampIsSet)
        return date;
      return constructFrom(date, transpose(date, Date));
    }
  }
  class Parser {
    run(dateString, token, match2, options) {
      const result = this.parse(dateString, token, match2, options);
      if (!result) {
        return null;
      }
      return {
        setter: new ValueSetter(
          result.value,
          this.validate,
          this.set,
          this.priority,
          this.subPriority
        ),
        rest: result.rest
      };
    }
    validate(_utcDate, _value, _options) {
      return true;
    }
  }
  class EraParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 140);
      __publicField(this, "incompatibleTokens", ["R", "u", "t", "T"]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "G":
        case "GG":
        case "GGG":
          return match2.era(dateString, { width: "abbreviated" }) || match2.era(dateString, { width: "narrow" });
        case "GGGGG":
          return match2.era(dateString, { width: "narrow" });
        case "GGGG":
        default:
          return match2.era(dateString, { width: "wide" }) || match2.era(dateString, { width: "abbreviated" }) || match2.era(dateString, { width: "narrow" });
      }
    }
    set(date, flags, value) {
      flags.era = value;
      date.setFullYear(value, 0, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }
  }
  const numericPatterns = {
    month: /^(1[0-2]|0?\d)/,
    // 0 to 12
    date: /^(3[0-1]|[0-2]?\d)/,
    // 0 to 31
    dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
    // 0 to 366
    week: /^(5[0-3]|[0-4]?\d)/,
    // 0 to 53
    hour23h: /^(2[0-3]|[0-1]?\d)/,
    // 0 to 23
    hour24h: /^(2[0-4]|[0-1]?\d)/,
    // 0 to 24
    hour11h: /^(1[0-1]|0?\d)/,
    // 0 to 11
    hour12h: /^(1[0-2]|0?\d)/,
    // 0 to 12
    minute: /^[0-5]?\d/,
    // 0 to 59
    second: /^[0-5]?\d/,
    // 0 to 59
    singleDigit: /^\d/,
    // 0 to 9
    twoDigits: /^\d{1,2}/,
    // 0 to 99
    threeDigits: /^\d{1,3}/,
    // 0 to 999
    fourDigits: /^\d{1,4}/,
    // 0 to 9999
    anyDigitsSigned: /^-?\d+/,
    singleDigitSigned: /^-?\d/,
    // 0 to 9, -0 to -9
    twoDigitsSigned: /^-?\d{1,2}/,
    // 0 to 99, -0 to -99
    threeDigitsSigned: /^-?\d{1,3}/,
    // 0 to 999, -0 to -999
    fourDigitsSigned: /^-?\d{1,4}/
    // 0 to 9999, -0 to -9999
  };
  const timezonePatterns = {
    basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
    basic: /^([+-])(\d{2})(\d{2})|Z/,
    basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
    extended: /^([+-])(\d{2}):(\d{2})|Z/,
    extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
  };
  function mapValue(parseFnResult, mapFn) {
    if (!parseFnResult) {
      return parseFnResult;
    }
    return {
      value: mapFn(parseFnResult.value),
      rest: parseFnResult.rest
    };
  }
  function parseNumericPattern(pattern, dateString) {
    const matchResult = dateString.match(pattern);
    if (!matchResult) {
      return null;
    }
    return {
      value: parseInt(matchResult[0], 10),
      rest: dateString.slice(matchResult[0].length)
    };
  }
  function parseTimezonePattern(pattern, dateString) {
    const matchResult = dateString.match(pattern);
    if (!matchResult) {
      return null;
    }
    if (matchResult[0] === "Z") {
      return {
        value: 0,
        rest: dateString.slice(1)
      };
    }
    const sign = matchResult[1] === "+" ? 1 : -1;
    const hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
    const minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
    const seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
    return {
      value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
      rest: dateString.slice(matchResult[0].length)
    };
  }
  function parseAnyDigitsSigned(dateString) {
    return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
  }
  function parseNDigits(n, dateString) {
    switch (n) {
      case 1:
        return parseNumericPattern(numericPatterns.singleDigit, dateString);
      case 2:
        return parseNumericPattern(numericPatterns.twoDigits, dateString);
      case 3:
        return parseNumericPattern(numericPatterns.threeDigits, dateString);
      case 4:
        return parseNumericPattern(numericPatterns.fourDigits, dateString);
      default:
        return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
    }
  }
  function parseNDigitsSigned(n, dateString) {
    switch (n) {
      case 1:
        return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
      case 2:
        return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
      case 3:
        return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
      case 4:
        return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
      default:
        return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
    }
  }
  function dayPeriodEnumToHours(dayPeriod) {
    switch (dayPeriod) {
      case "morning":
        return 4;
      case "evening":
        return 17;
      case "pm":
      case "noon":
      case "afternoon":
        return 12;
      case "am":
      case "midnight":
      case "night":
      default:
        return 0;
    }
  }
  function normalizeTwoDigitYear(twoDigitYear, currentYear) {
    const isCommonEra = currentYear > 0;
    const absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
    let result;
    if (absCurrentYear <= 50) {
      result = twoDigitYear || 100;
    } else {
      const rangeEnd = absCurrentYear + 50;
      const rangeEndCentury = Math.trunc(rangeEnd / 100) * 100;
      const isPreviousCentury = twoDigitYear >= rangeEnd % 100;
      result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
    }
    return isCommonEra ? result : 1 - result;
  }
  function isLeapYearIndex$1(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
  }
  class YearParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 130);
      __publicField(this, "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
    }
    parse(dateString, token, match2) {
      const valueCallback = (year) => ({
        year,
        isTwoDigitYear: token === "yy"
      });
      switch (token) {
        case "y":
          return mapValue(parseNDigits(4, dateString), valueCallback);
        case "yo":
          return mapValue(
            match2.ordinalNumber(dateString, {
              unit: "year"
            }),
            valueCallback
          );
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
      }
    }
    validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
    set(date, flags, value) {
      const currentYear = date.getFullYear();
      if (value.isTwoDigitYear) {
        const normalizedTwoDigitYear = normalizeTwoDigitYear(
          value.year,
          currentYear
        );
        date.setFullYear(normalizedTwoDigitYear, 0, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      }
      const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setFullYear(year, 0, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }
  }
  class LocalWeekYearParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 130);
      __publicField(this, "incompatibleTokens", [
        "y",
        "R",
        "u",
        "Q",
        "q",
        "M",
        "L",
        "I",
        "d",
        "D",
        "i",
        "t",
        "T"
      ]);
    }
    parse(dateString, token, match2) {
      const valueCallback = (year) => ({
        year,
        isTwoDigitYear: token === "YY"
      });
      switch (token) {
        case "Y":
          return mapValue(parseNDigits(4, dateString), valueCallback);
        case "Yo":
          return mapValue(
            match2.ordinalNumber(dateString, {
              unit: "year"
            }),
            valueCallback
          );
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
      }
    }
    validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
    set(date, flags, value, options) {
      const currentYear = getWeekYear(date, options);
      if (value.isTwoDigitYear) {
        const normalizedTwoDigitYear = normalizeTwoDigitYear(
          value.year,
          currentYear
        );
        date.setFullYear(
          normalizedTwoDigitYear,
          0,
          options.firstWeekContainsDate
        );
        date.setHours(0, 0, 0, 0);
        return startOfWeek(date, options);
      }
      const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setFullYear(year, 0, options.firstWeekContainsDate);
      date.setHours(0, 0, 0, 0);
      return startOfWeek(date, options);
    }
  }
  class ISOWeekYearParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 130);
      __publicField(this, "incompatibleTokens", [
        "G",
        "y",
        "Y",
        "u",
        "Q",
        "q",
        "M",
        "L",
        "w",
        "d",
        "D",
        "e",
        "c",
        "t",
        "T"
      ]);
    }
    parse(dateString, token) {
      if (token === "R") {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token.length, dateString);
    }
    set(date, _flags, value) {
      const firstWeekOfYear = constructFrom(date, 0);
      firstWeekOfYear.setFullYear(value, 0, 4);
      firstWeekOfYear.setHours(0, 0, 0, 0);
      return startOfISOWeek(firstWeekOfYear);
    }
  }
  class ExtendedYearParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 130);
      __publicField(this, "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
    }
    parse(dateString, token) {
      if (token === "u") {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token.length, dateString);
    }
    set(date, _flags, value) {
      date.setFullYear(value, 0, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }
  }
  class QuarterParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 120);
      __publicField(this, "incompatibleTokens", [
        "Y",
        "R",
        "q",
        "M",
        "L",
        "w",
        "I",
        "d",
        "D",
        "i",
        "e",
        "c",
        "t",
        "T"
      ]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "Q":
        case "QQ":
          return parseNDigits(token.length, dateString);
        case "Qo":
          return match2.ordinalNumber(dateString, { unit: "quarter" });
        case "QQQ":
          return match2.quarter(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQQ":
          return match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return match2.quarter(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
    validate(_date, value) {
      return value >= 1 && value <= 4;
    }
    set(date, _flags, value) {
      date.setMonth((value - 1) * 3, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }
  }
  class StandAloneQuarterParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 120);
      __publicField(this, "incompatibleTokens", [
        "Y",
        "R",
        "Q",
        "M",
        "L",
        "w",
        "I",
        "d",
        "D",
        "i",
        "e",
        "c",
        "t",
        "T"
      ]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "q":
        case "qq":
          return parseNDigits(token.length, dateString);
        case "qo":
          return match2.ordinalNumber(dateString, { unit: "quarter" });
        case "qqq":
          return match2.quarter(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqqq":
          return match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return match2.quarter(dateString, {
            width: "wide",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
    validate(_date, value) {
      return value >= 1 && value <= 4;
    }
    set(date, _flags, value) {
      date.setMonth((value - 1) * 3, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }
  }
  class MonthParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "incompatibleTokens", [
        "Y",
        "R",
        "q",
        "Q",
        "L",
        "w",
        "I",
        "D",
        "i",
        "e",
        "c",
        "t",
        "T"
      ]);
      __publicField(this, "priority", 110);
    }
    parse(dateString, token, match2) {
      const valueCallback = (value) => value - 1;
      switch (token) {
        case "M":
          return mapValue(
            parseNumericPattern(numericPatterns.month, dateString),
            valueCallback
          );
        case "MM":
          return mapValue(parseNDigits(2, dateString), valueCallback);
        case "Mo":
          return mapValue(
            match2.ordinalNumber(dateString, {
              unit: "month"
            }),
            valueCallback
          );
        case "MMM":
          return match2.month(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.month(dateString, { width: "narrow", context: "formatting" });
        case "MMMMM":
          return match2.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return match2.month(dateString, { width: "wide", context: "formatting" }) || match2.month(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.month(dateString, { width: "narrow", context: "formatting" });
      }
    }
    validate(_date, value) {
      return value >= 0 && value <= 11;
    }
    set(date, _flags, value) {
      date.setMonth(value, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }
  }
  class StandAloneMonthParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 110);
      __publicField(this, "incompatibleTokens", [
        "Y",
        "R",
        "q",
        "Q",
        "M",
        "w",
        "I",
        "D",
        "i",
        "e",
        "c",
        "t",
        "T"
      ]);
    }
    parse(dateString, token, match2) {
      const valueCallback = (value) => value - 1;
      switch (token) {
        case "L":
          return mapValue(
            parseNumericPattern(numericPatterns.month, dateString),
            valueCallback
          );
        case "LL":
          return mapValue(parseNDigits(2, dateString), valueCallback);
        case "Lo":
          return mapValue(
            match2.ordinalNumber(dateString, {
              unit: "month"
            }),
            valueCallback
          );
        case "LLL":
          return match2.month(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.month(dateString, { width: "narrow", context: "standalone" });
        case "LLLLL":
          return match2.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return match2.month(dateString, { width: "wide", context: "standalone" }) || match2.month(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.month(dateString, { width: "narrow", context: "standalone" });
      }
    }
    validate(_date, value) {
      return value >= 0 && value <= 11;
    }
    set(date, _flags, value) {
      date.setMonth(value, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }
  }
  function setWeek(date, week, options) {
    const _date = toDate$1(date);
    const diff = getWeek(_date, options) - week;
    _date.setDate(_date.getDate() - diff * 7);
    return _date;
  }
  class LocalWeekParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 100);
      __publicField(this, "incompatibleTokens", [
        "y",
        "R",
        "u",
        "q",
        "Q",
        "M",
        "L",
        "I",
        "d",
        "D",
        "i",
        "t",
        "T"
      ]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "w":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "wo":
          return match2.ordinalNumber(dateString, { unit: "week" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
    validate(_date, value) {
      return value >= 1 && value <= 53;
    }
    set(date, _flags, value, options) {
      return startOfWeek(setWeek(date, value, options), options);
    }
  }
  function setISOWeek(date, week) {
    const _date = toDate$1(date);
    const diff = getISOWeek(_date) - week;
    _date.setDate(_date.getDate() - diff * 7);
    return _date;
  }
  class ISOWeekParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 100);
      __publicField(this, "incompatibleTokens", [
        "y",
        "Y",
        "u",
        "q",
        "Q",
        "M",
        "L",
        "w",
        "d",
        "D",
        "e",
        "c",
        "t",
        "T"
      ]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "I":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "Io":
          return match2.ordinalNumber(dateString, { unit: "week" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
    validate(_date, value) {
      return value >= 1 && value <= 53;
    }
    set(date, _flags, value) {
      return startOfISOWeek(setISOWeek(date, value));
    }
  }
  const DAYS_IN_MONTH$1 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  const DAYS_IN_MONTH_LEAP_YEAR$1 = [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ];
  class DateParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 90);
      __publicField(this, "subPriority", 1);
      __publicField(this, "incompatibleTokens", [
        "Y",
        "R",
        "q",
        "Q",
        "w",
        "I",
        "D",
        "i",
        "e",
        "c",
        "t",
        "T"
      ]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "d":
          return parseNumericPattern(numericPatterns.date, dateString);
        case "do":
          return match2.ordinalNumber(dateString, { unit: "date" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
    validate(date, value) {
      const year = date.getFullYear();
      const isLeapYear = isLeapYearIndex$1(year);
      const month = date.getMonth();
      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR$1[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH$1[month];
      }
    }
    set(date, _flags, value) {
      date.setDate(value);
      date.setHours(0, 0, 0, 0);
      return date;
    }
  }
  class DayOfYearParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 90);
      __publicField(this, "subpriority", 1);
      __publicField(this, "incompatibleTokens", [
        "Y",
        "R",
        "q",
        "Q",
        "M",
        "L",
        "w",
        "I",
        "d",
        "E",
        "i",
        "e",
        "c",
        "t",
        "T"
      ]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "D":
        case "DD":
          return parseNumericPattern(numericPatterns.dayOfYear, dateString);
        case "Do":
          return match2.ordinalNumber(dateString, { unit: "date" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
    validate(date, value) {
      const year = date.getFullYear();
      const isLeapYear = isLeapYearIndex$1(year);
      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    }
    set(date, _flags, value) {
      date.setMonth(0, value);
      date.setHours(0, 0, 0, 0);
      return date;
    }
  }
  function setDay(date, day, options) {
    var _a, _b, _c, _d;
    const defaultOptions2 = getDefaultOptions$1();
    const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.weekStartsOn) ?? defaultOptions2.weekStartsOn ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.weekStartsOn) ?? 0;
    const _date = toDate$1(date);
    const currentDay = _date.getDay();
    const remainder = day % 7;
    const dayIndex = (remainder + 7) % 7;
    const delta = 7 - weekStartsOn;
    const diff = day < 0 || day > 6 ? day - (currentDay + delta) % 7 : (dayIndex + delta) % 7 - (currentDay + delta) % 7;
    return addDays(_date, diff);
  }
  class DayParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 90);
      __publicField(this, "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "E":
        case "EE":
        case "EEE":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
        case "EEEEE":
          return match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
        case "EEEE":
        default:
          return match2.day(dateString, { width: "wide", context: "formatting" }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      }
    }
    validate(_date, value) {
      return value >= 0 && value <= 6;
    }
    set(date, _flags, value, options) {
      date = setDay(date, value, options);
      date.setHours(0, 0, 0, 0);
      return date;
    }
  }
  class LocalDayParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 90);
      __publicField(this, "incompatibleTokens", [
        "y",
        "R",
        "u",
        "q",
        "Q",
        "M",
        "L",
        "I",
        "d",
        "D",
        "E",
        "i",
        "c",
        "t",
        "T"
      ]);
    }
    parse(dateString, token, match2, options) {
      const valueCallback = (value) => {
        const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        case "e":
        case "ee":
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
        case "eo":
          return mapValue(
            match2.ordinalNumber(dateString, {
              unit: "day"
            }),
            valueCallback
          );
        case "eee":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
        case "eeeee":
          return match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
        case "eeee":
        default:
          return match2.day(dateString, { width: "wide", context: "formatting" }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      }
    }
    validate(_date, value) {
      return value >= 0 && value <= 6;
    }
    set(date, _flags, value, options) {
      date = setDay(date, value, options);
      date.setHours(0, 0, 0, 0);
      return date;
    }
  }
  class StandAloneLocalDayParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 90);
      __publicField(this, "incompatibleTokens", [
        "y",
        "R",
        "u",
        "q",
        "Q",
        "M",
        "L",
        "I",
        "d",
        "D",
        "E",
        "i",
        "e",
        "t",
        "T"
      ]);
    }
    parse(dateString, token, match2, options) {
      const valueCallback = (value) => {
        const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        case "c":
        case "cc":
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
        case "co":
          return mapValue(
            match2.ordinalNumber(dateString, {
              unit: "day"
            }),
            valueCallback
          );
        case "ccc":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
        case "ccccc":
          return match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
        case "cccc":
        default:
          return match2.day(dateString, { width: "wide", context: "standalone" }) || match2.day(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
      }
    }
    validate(_date, value) {
      return value >= 0 && value <= 6;
    }
    set(date, _flags, value, options) {
      date = setDay(date, value, options);
      date.setHours(0, 0, 0, 0);
      return date;
    }
  }
  function setISODay(date, day) {
    const _date = toDate$1(date);
    const currentDay = getISODay(_date);
    const diff = day - currentDay;
    return addDays(_date, diff);
  }
  class ISODayParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 90);
      __publicField(this, "incompatibleTokens", [
        "y",
        "Y",
        "u",
        "q",
        "Q",
        "M",
        "L",
        "w",
        "d",
        "D",
        "E",
        "e",
        "c",
        "t",
        "T"
      ]);
    }
    parse(dateString, token, match2) {
      const valueCallback = (value) => {
        if (value === 0) {
          return 7;
        }
        return value;
      };
      switch (token) {
        case "i":
        case "ii":
          return parseNDigits(token.length, dateString);
        case "io":
          return match2.ordinalNumber(dateString, { unit: "day" });
        case "iii":
          return mapValue(
            match2.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            }),
            valueCallback
          );
        case "iiiii":
          return mapValue(
            match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            }),
            valueCallback
          );
        case "iiiiii":
          return mapValue(
            match2.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            }),
            valueCallback
          );
        case "iiii":
        default:
          return mapValue(
            match2.day(dateString, {
              width: "wide",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            }),
            valueCallback
          );
      }
    }
    validate(_date, value) {
      return value >= 1 && value <= 7;
    }
    set(date, _flags, value) {
      date = setISODay(date, value);
      date.setHours(0, 0, 0, 0);
      return date;
    }
  }
  class AMPMParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 80);
      __publicField(this, "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "a":
        case "aa":
        case "aaa":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaaa":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
    set(date, _flags, value) {
      date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }
  class AMPMMidnightParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 80);
      __publicField(this, "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "b":
        case "bb":
        case "bbb":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbbb":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
    set(date, _flags, value) {
      date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }
  class DayPeriodParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 80);
      __publicField(this, "incompatibleTokens", ["a", "b", "t", "T"]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "B":
        case "BB":
        case "BBB":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBBB":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
    set(date, _flags, value) {
      date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }
  class Hour1to12Parser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 70);
      __publicField(this, "incompatibleTokens", ["H", "K", "k", "t", "T"]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "h":
          return parseNumericPattern(numericPatterns.hour12h, dateString);
        case "ho":
          return match2.ordinalNumber(dateString, { unit: "hour" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
    validate(_date, value) {
      return value >= 1 && value <= 12;
    }
    set(date, _flags, value) {
      const isPM = date.getHours() >= 12;
      if (isPM && value < 12) {
        date.setHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setHours(0, 0, 0, 0);
      } else {
        date.setHours(value, 0, 0, 0);
      }
      return date;
    }
  }
  class Hour0to23Parser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 70);
      __publicField(this, "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "H":
          return parseNumericPattern(numericPatterns.hour23h, dateString);
        case "Ho":
          return match2.ordinalNumber(dateString, { unit: "hour" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
    validate(_date, value) {
      return value >= 0 && value <= 23;
    }
    set(date, _flags, value) {
      date.setHours(value, 0, 0, 0);
      return date;
    }
  }
  class Hour0To11Parser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 70);
      __publicField(this, "incompatibleTokens", ["h", "H", "k", "t", "T"]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "K":
          return parseNumericPattern(numericPatterns.hour11h, dateString);
        case "Ko":
          return match2.ordinalNumber(dateString, { unit: "hour" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
    validate(_date, value) {
      return value >= 0 && value <= 11;
    }
    set(date, _flags, value) {
      const isPM = date.getHours() >= 12;
      if (isPM && value < 12) {
        date.setHours(value + 12, 0, 0, 0);
      } else {
        date.setHours(value, 0, 0, 0);
      }
      return date;
    }
  }
  class Hour1To24Parser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 70);
      __publicField(this, "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "k":
          return parseNumericPattern(numericPatterns.hour24h, dateString);
        case "ko":
          return match2.ordinalNumber(dateString, { unit: "hour" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
    validate(_date, value) {
      return value >= 1 && value <= 24;
    }
    set(date, _flags, value) {
      const hours = value <= 24 ? value % 24 : value;
      date.setHours(hours, 0, 0, 0);
      return date;
    }
  }
  class MinuteParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 60);
      __publicField(this, "incompatibleTokens", ["t", "T"]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "m":
          return parseNumericPattern(numericPatterns.minute, dateString);
        case "mo":
          return match2.ordinalNumber(dateString, { unit: "minute" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
    validate(_date, value) {
      return value >= 0 && value <= 59;
    }
    set(date, _flags, value) {
      date.setMinutes(value, 0, 0);
      return date;
    }
  }
  class SecondParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 50);
      __publicField(this, "incompatibleTokens", ["t", "T"]);
    }
    parse(dateString, token, match2) {
      switch (token) {
        case "s":
          return parseNumericPattern(numericPatterns.second, dateString);
        case "so":
          return match2.ordinalNumber(dateString, { unit: "second" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
    validate(_date, value) {
      return value >= 0 && value <= 59;
    }
    set(date, _flags, value) {
      date.setSeconds(value, 0);
      return date;
    }
  }
  class FractionOfSecondParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 30);
      __publicField(this, "incompatibleTokens", ["t", "T"]);
    }
    parse(dateString, token) {
      const valueCallback = (value) => Math.trunc(value * Math.pow(10, -token.length + 3));
      return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
    set(date, _flags, value) {
      date.setMilliseconds(value);
      return date;
    }
  }
  class ISOTimezoneWithZParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 10);
      __publicField(this, "incompatibleTokens", ["t", "T", "x"]);
    }
    parse(dateString, token) {
      switch (token) {
        case "X":
          return parseTimezonePattern(
            timezonePatterns.basicOptionalMinutes,
            dateString
          );
        case "XX":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "XXXX":
          return parseTimezonePattern(
            timezonePatterns.basicOptionalSeconds,
            dateString
          );
        case "XXXXX":
          return parseTimezonePattern(
            timezonePatterns.extendedOptionalSeconds,
            dateString
          );
        case "XXX":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
    set(date, flags, value) {
      if (flags.timestampIsSet)
        return date;
      return constructFrom(
        date,
        date.getTime() - getTimezoneOffsetInMilliseconds$1(date) - value
      );
    }
  }
  class ISOTimezoneParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 10);
      __publicField(this, "incompatibleTokens", ["t", "T", "X"]);
    }
    parse(dateString, token) {
      switch (token) {
        case "x":
          return parseTimezonePattern(
            timezonePatterns.basicOptionalMinutes,
            dateString
          );
        case "xx":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "xxxx":
          return parseTimezonePattern(
            timezonePatterns.basicOptionalSeconds,
            dateString
          );
        case "xxxxx":
          return parseTimezonePattern(
            timezonePatterns.extendedOptionalSeconds,
            dateString
          );
        case "xxx":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
    set(date, flags, value) {
      if (flags.timestampIsSet)
        return date;
      return constructFrom(
        date,
        date.getTime() - getTimezoneOffsetInMilliseconds$1(date) - value
      );
    }
  }
  class TimestampSecondsParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 40);
      __publicField(this, "incompatibleTokens", "*");
    }
    parse(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
    set(date, _flags, value) {
      return [constructFrom(date, value * 1e3), { timestampIsSet: true }];
    }
  }
  class TimestampMillisecondsParser extends Parser {
    constructor() {
      super(...arguments);
      __publicField(this, "priority", 20);
      __publicField(this, "incompatibleTokens", "*");
    }
    parse(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
    set(date, _flags, value) {
      return [constructFrom(date, value), { timestampIsSet: true }];
    }
  }
  const parsers = {
    G: new EraParser(),
    y: new YearParser(),
    Y: new LocalWeekYearParser(),
    R: new ISOWeekYearParser(),
    u: new ExtendedYearParser(),
    Q: new QuarterParser(),
    q: new StandAloneQuarterParser(),
    M: new MonthParser(),
    L: new StandAloneMonthParser(),
    w: new LocalWeekParser(),
    I: new ISOWeekParser(),
    d: new DateParser(),
    D: new DayOfYearParser(),
    E: new DayParser(),
    e: new LocalDayParser(),
    c: new StandAloneLocalDayParser(),
    i: new ISODayParser(),
    a: new AMPMParser(),
    b: new AMPMMidnightParser(),
    B: new DayPeriodParser(),
    h: new Hour1to12Parser(),
    H: new Hour0to23Parser(),
    K: new Hour0To11Parser(),
    k: new Hour1To24Parser(),
    m: new MinuteParser(),
    s: new SecondParser(),
    S: new FractionOfSecondParser(),
    X: new ISOTimezoneWithZParser(),
    x: new ISOTimezoneParser(),
    t: new TimestampSecondsParser(),
    T: new TimestampMillisecondsParser()
  };
  const formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
  const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
  const escapedStringRegExp = /^'([^]*?)'?$/;
  const doubleQuoteRegExp = /''/g;
  const notWhitespaceRegExp = /\S/;
  const unescapedLatinCharacterRegExp = /[a-zA-Z]/;
  function parse$1(dateStr, formatStr, referenceDate, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const defaultOptions2 = getDefaultOptions();
    const locale = (options == null ? void 0 : options.locale) ?? defaultOptions2.locale ?? enUS;
    const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b = (_a = options == null ? void 0 : options.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions2.firstWeekContainsDate ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
    const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_f = (_e = options == null ? void 0 : options.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.weekStartsOn) ?? defaultOptions2.weekStartsOn ?? ((_h = (_g = defaultOptions2.locale) == null ? void 0 : _g.options) == null ? void 0 : _h.weekStartsOn) ?? 0;
    if (formatStr === "") {
      if (dateStr === "") {
        return toDate$1(referenceDate);
      } else {
        return constructFrom(referenceDate, NaN);
      }
    }
    const subFnOptions = {
      firstWeekContainsDate,
      weekStartsOn,
      locale
    };
    const setters = [new DateToSystemTimezoneSetter()];
    const tokens = formatStr.match(longFormattingTokensRegExp).map((substring) => {
      const firstCharacter = substring[0];
      if (firstCharacter in longFormatters) {
        const longFormatter = longFormatters[firstCharacter];
        return longFormatter(substring, locale.formatLong);
      }
      return substring;
    }).join("").match(formattingTokensRegExp);
    const usedTokens = [];
    for (let token of tokens) {
      if (!(options == null ? void 0 : options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token)) {
        warnOrThrowProtectedError(token, formatStr, dateStr);
      }
      if (!(options == null ? void 0 : options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
        warnOrThrowProtectedError(token, formatStr, dateStr);
      }
      const firstCharacter = token[0];
      const parser = parsers[firstCharacter];
      if (parser) {
        const { incompatibleTokens } = parser;
        if (Array.isArray(incompatibleTokens)) {
          const incompatibleToken = usedTokens.find(
            (usedToken) => incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter
          );
          if (incompatibleToken) {
            throw new RangeError(
              `The format string mustn't contain \`${incompatibleToken.fullToken}\` and \`${token}\` at the same time`
            );
          }
        } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
          throw new RangeError(
            `The format string mustn't contain \`${token}\` and any other token at the same time`
          );
        }
        usedTokens.push({ token: firstCharacter, fullToken: token });
        const parseResult = parser.run(
          dateStr,
          token,
          locale.match,
          subFnOptions
        );
        if (!parseResult) {
          return constructFrom(referenceDate, NaN);
        }
        setters.push(parseResult.setter);
        dateStr = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError(
            "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
          );
        }
        if (token === "''") {
          token = "'";
        } else if (firstCharacter === "'") {
          token = cleanEscapedString(token);
        }
        if (dateStr.indexOf(token) === 0) {
          dateStr = dateStr.slice(token.length);
        } else {
          return constructFrom(referenceDate, NaN);
        }
      }
    }
    if (dateStr.length > 0 && notWhitespaceRegExp.test(dateStr)) {
      return constructFrom(referenceDate, NaN);
    }
    const uniquePrioritySetters = setters.map((setter) => setter.priority).sort((a2, b) => b - a2).filter((priority, index, array) => array.indexOf(priority) === index).map(
      (priority) => setters.filter((setter) => setter.priority === priority).sort((a2, b) => b.subPriority - a2.subPriority)
    ).map((setterArray) => setterArray[0]);
    let date = toDate$1(referenceDate);
    if (isNaN(date.getTime())) {
      return constructFrom(referenceDate, NaN);
    }
    const flags = {};
    for (const setter of uniquePrioritySetters) {
      if (!setter.validate(date, subFnOptions)) {
        return constructFrom(referenceDate, NaN);
      }
      const result = setter.set(date, flags, subFnOptions);
      if (Array.isArray(result)) {
        date = result[0];
        Object.assign(flags, result[1]);
      } else {
        date = result;
      }
    }
    return constructFrom(referenceDate, date);
  }
  function cleanEscapedString(input) {
    return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
  }
  function startOfHour(date) {
    const _date = toDate$1(date);
    _date.setMinutes(0, 0, 0);
    return _date;
  }
  function isSameMonth(dateLeft, dateRight) {
    const _dateLeft = toDate$1(dateLeft);
    const _dateRight = toDate$1(dateRight);
    return _dateLeft.getFullYear() === _dateRight.getFullYear() && _dateLeft.getMonth() === _dateRight.getMonth();
  }
  function isSameQuarter(dateLeft, dateRight) {
    const dateLeftStartOfQuarter = startOfQuarter(dateLeft);
    const dateRightStartOfQuarter = startOfQuarter(dateRight);
    return +dateLeftStartOfQuarter === +dateRightStartOfQuarter;
  }
  function startOfSecond(date) {
    const _date = toDate$1(date);
    _date.setMilliseconds(0);
    return _date;
  }
  function isSameYear(dateLeft, dateRight) {
    const _dateLeft = toDate$1(dateLeft);
    const _dateRight = toDate$1(dateRight);
    return _dateLeft.getFullYear() === _dateRight.getFullYear();
  }
  function setMonth(date, month) {
    const _date = toDate$1(date);
    const year = _date.getFullYear();
    const day = _date.getDate();
    const dateWithDesiredMonth = constructFrom(date, 0);
    dateWithDesiredMonth.setFullYear(year, month, 15);
    dateWithDesiredMonth.setHours(0, 0, 0, 0);
    const daysInMonth = getDaysInMonth(dateWithDesiredMonth);
    _date.setMonth(month, Math.min(day, daysInMonth));
    return _date;
  }
  function set(date, values) {
    let _date = toDate$1(date);
    if (isNaN(+_date)) {
      return constructFrom(date, NaN);
    }
    if (values.year != null) {
      _date.setFullYear(values.year);
    }
    if (values.month != null) {
      _date = setMonth(_date, values.month);
    }
    if (values.date != null) {
      _date.setDate(values.date);
    }
    if (values.hours != null) {
      _date.setHours(values.hours);
    }
    if (values.minutes != null) {
      _date.setMinutes(values.minutes);
    }
    if (values.seconds != null) {
      _date.setSeconds(values.seconds);
    }
    if (values.milliseconds != null) {
      _date.setMilliseconds(values.milliseconds);
    }
    return _date;
  }
  function setHours(date, hours) {
    const _date = toDate$1(date);
    _date.setHours(hours);
    return _date;
  }
  function setMinutes(date, minutes) {
    const _date = toDate$1(date);
    _date.setMinutes(minutes);
    return _date;
  }
  function setQuarter(date, quarter) {
    const _date = toDate$1(date);
    const oldQuarter = Math.trunc(_date.getMonth() / 3) + 1;
    const diff = quarter - oldQuarter;
    return setMonth(_date, _date.getMonth() + diff * 3);
  }
  function setSeconds(date, seconds) {
    const _date = toDate$1(date);
    _date.setSeconds(seconds);
    return _date;
  }
  function setYear(date, year) {
    const _date = toDate$1(date);
    if (isNaN(+_date)) {
      return constructFrom(date, NaN);
    }
    _date.setFullYear(year);
    return _date;
  }
  const matcherMap = {
    date: isSameDay,
    month: isSameMonth,
    year: isSameYear,
    quarter: isSameQuarter
  };
  function makeWeekMatcher(firstDayOfWeek) {
    return (sourceTime, patternTime) => {
      const weekStartsOn = (firstDayOfWeek + 1) % 7;
      return isSameWeek(sourceTime, patternTime, {
        weekStartsOn
      });
    };
  }
  function matchDate(sourceTime, patternTime, type, firstDayOfWeek = 0) {
    const matcher = type === "week" ? makeWeekMatcher(firstDayOfWeek) : matcherMap[type];
    return matcher(sourceTime, patternTime);
  }
  function dateOrWeekItem(time2, monthTs, valueTs, currentTs, mode, firstDayOfWeek) {
    if (mode === "date") {
      return dateItem(time2, monthTs, valueTs, currentTs);
    } else {
      return weekItem(time2, monthTs, valueTs, currentTs, firstDayOfWeek);
    }
  }
  function dateItem(time2, monthTs, valueTs, currentTs) {
    let inSpan = false;
    let startOfSpan = false;
    let endOfSpan = false;
    if (Array.isArray(valueTs)) {
      if (valueTs[0] < time2 && time2 < valueTs[1]) {
        inSpan = true;
      }
      if (matchDate(valueTs[0], time2, "date"))
        startOfSpan = true;
      if (matchDate(valueTs[1], time2, "date"))
        endOfSpan = true;
    }
    const selected = valueTs !== null && (Array.isArray(valueTs) ? matchDate(valueTs[0], time2, "date") || matchDate(valueTs[1], time2, "date") : matchDate(valueTs, time2, "date"));
    return {
      type: "date",
      dateObject: {
        date: getDate(time2),
        month: getMonth(time2),
        year: getYear(time2)
      },
      inCurrentMonth: isSameMonth(time2, monthTs),
      isCurrentDate: matchDate(currentTs, time2, "date"),
      inSpan,
      inSelectedWeek: false,
      startOfSpan,
      endOfSpan,
      selected,
      ts: getTime(time2)
    };
  }
  function getMonthString(month, monthFormat, locale) {
    const date = new Date(2e3, month, 1).getTime();
    return format$3(date, monthFormat, {
      locale
    });
  }
  function getYearString(year, yearFormat, locale) {
    const date = new Date(year, 1, 1).getTime();
    return format$3(date, yearFormat, {
      locale
    });
  }
  function getQuarterString(quarter, quarterFormat, locale) {
    const date = new Date(2e3, quarter * 3 - 2, 1).getTime();
    return format$3(date, quarterFormat, {
      locale
    });
  }
  function weekItem(time2, monthTs, valueTs, currentTs, firstDayOfWeek) {
    let inSpan = false;
    let startOfSpan = false;
    let endOfSpan = false;
    if (Array.isArray(valueTs)) {
      if (valueTs[0] < time2 && time2 < valueTs[1]) {
        inSpan = true;
      }
      if (matchDate(valueTs[0], time2, "week", firstDayOfWeek))
        startOfSpan = true;
      if (matchDate(valueTs[1], time2, "week", firstDayOfWeek))
        endOfSpan = true;
    }
    const inSelectedWeek = valueTs !== null && (Array.isArray(valueTs) ? matchDate(valueTs[0], time2, "week", firstDayOfWeek) || matchDate(valueTs[1], time2, "week", firstDayOfWeek) : matchDate(valueTs, time2, "week", firstDayOfWeek));
    return {
      type: "date",
      dateObject: {
        date: getDate(time2),
        month: getMonth(time2),
        year: getYear(time2)
      },
      inCurrentMonth: isSameMonth(time2, monthTs),
      isCurrentDate: matchDate(currentTs, time2, "date"),
      inSpan,
      startOfSpan,
      endOfSpan,
      selected: false,
      inSelectedWeek,
      ts: getTime(time2)
    };
  }
  function monthItem(monthTs, valueTs, currentTs, {
    monthFormat
  }) {
    return {
      type: "month",
      monthFormat,
      dateObject: {
        month: getMonth(monthTs),
        year: getYear(monthTs)
      },
      isCurrent: isSameMonth(currentTs, monthTs),
      selected: valueTs !== null && matchDate(valueTs, monthTs, "month"),
      ts: getTime(monthTs)
    };
  }
  function yearItem(yearTs, valueTs, currentTs, {
    yearFormat
  }) {
    return {
      type: "year",
      yearFormat,
      dateObject: {
        year: getYear(yearTs)
      },
      isCurrent: isSameYear(currentTs, yearTs),
      selected: valueTs !== null && matchDate(valueTs, yearTs, "year"),
      ts: getTime(yearTs)
    };
  }
  function quarterItem(quarterTs, valueTs, currentTs, {
    quarterFormat
  }) {
    return {
      type: "quarter",
      quarterFormat,
      dateObject: {
        quarter: getQuarter(quarterTs),
        year: getYear(quarterTs)
      },
      isCurrent: isSameQuarter(currentTs, quarterTs),
      selected: valueTs !== null && matchDate(valueTs, quarterTs, "quarter"),
      ts: getTime(quarterTs)
    };
  }
  function dateArray(monthTs, valueTs, currentTs, startDay, strip = false, weekMode = false) {
    const granularity = weekMode ? "week" : "date";
    const displayMonth = getMonth(monthTs);
    let displayMonthIterator = getTime(startOfMonth(monthTs));
    let lastMonthIterator = getTime(addDays(displayMonthIterator, -1));
    const calendarDays = [];
    let protectLastMonthDateIsShownFlag = !strip;
    while (getDay(lastMonthIterator) !== startDay || protectLastMonthDateIsShownFlag) {
      calendarDays.unshift(dateOrWeekItem(lastMonthIterator, monthTs, valueTs, currentTs, granularity, startDay));
      lastMonthIterator = getTime(addDays(lastMonthIterator, -1));
      protectLastMonthDateIsShownFlag = false;
    }
    while (getMonth(displayMonthIterator) === displayMonth) {
      calendarDays.push(dateOrWeekItem(displayMonthIterator, monthTs, valueTs, currentTs, granularity, startDay));
      displayMonthIterator = getTime(addDays(displayMonthIterator, 1));
    }
    const endIndex = strip ? calendarDays.length <= 28 ? 28 : calendarDays.length <= 35 ? 35 : 42 : 42;
    while (calendarDays.length < endIndex) {
      calendarDays.push(dateOrWeekItem(displayMonthIterator, monthTs, valueTs, currentTs, granularity, startDay));
      displayMonthIterator = getTime(addDays(displayMonthIterator, 1));
    }
    return calendarDays;
  }
  function monthArray(yearAnchorTs, valueTs, currentTs, format2) {
    const calendarMonths = [];
    const yearStart = startOfYear(yearAnchorTs);
    for (let i = 0; i < 12; i++) {
      calendarMonths.push(monthItem(getTime(addMonths(yearStart, i)), valueTs, currentTs, format2));
    }
    return calendarMonths;
  }
  function quarterArray(yearAnchorTs, valueTs, currentTs, format2) {
    const calendarQuarters = [];
    const yearStart = startOfYear(yearAnchorTs);
    for (let i = 0; i < 4; i++) {
      calendarQuarters.push(quarterItem(getTime(addQuarters(yearStart, i)), valueTs, currentTs, format2));
    }
    return calendarQuarters;
  }
  function yearArray(valueTs, currentTs, format2, rangeRef) {
    const range2 = rangeRef.value;
    const calendarYears = [];
    const startTime = startOfYear(setYear(/* @__PURE__ */ new Date(), range2[0]));
    for (let i = 0; i < range2[1] - range2[0]; i++) {
      calendarYears.push(yearItem(getTime(addYears(startTime, i)), valueTs, currentTs, format2));
    }
    return calendarYears;
  }
  function strictParse(string2, pattern, backup, option) {
    const result = parse$1(string2, pattern, backup, option);
    if (!isValid(result))
      return result;
    else if (format$3(result, pattern, option) === string2)
      return result;
    else
      return new Date(Number.NaN);
  }
  function getDefaultTime(timeValue) {
    if (timeValue === void 0) {
      return void 0;
    }
    if (typeof timeValue === "number") {
      return timeValue;
    }
    const [hour, minute, second] = timeValue.split(":");
    return {
      hours: Number(hour),
      minutes: Number(minute),
      seconds: Number(second)
    };
  }
  function pluckValueFromRange(value, type) {
    return Array.isArray(value) ? value[type === "start" ? 0 : 1] : null;
  }
  const commonVariables$e = {
    titleFontSize: "22px"
  };
  function self$11(vars) {
    const {
      borderRadius,
      fontSize: fontSize2,
      lineHeight: lineHeight2,
      textColor2,
      textColor1,
      textColorDisabled,
      dividerColor,
      fontWeightStrong,
      primaryColor,
      baseColor,
      hoverColor,
      cardColor,
      modalColor,
      popoverColor
    } = vars;
    return Object.assign(Object.assign({}, commonVariables$e), {
      borderRadius,
      borderColor: composite(cardColor, dividerColor),
      borderColorModal: composite(modalColor, dividerColor),
      borderColorPopover: composite(popoverColor, dividerColor),
      textColor: textColor2,
      titleFontWeight: fontWeightStrong,
      titleTextColor: textColor1,
      dayTextColor: textColorDisabled,
      fontSize: fontSize2,
      lineHeight: lineHeight2,
      dateColorCurrent: primaryColor,
      dateTextColorCurrent: baseColor,
      cellColorHover: composite(cardColor, hoverColor),
      cellColorHoverModal: composite(modalColor, hoverColor),
      cellColorHoverPopover: composite(popoverColor, hoverColor),
      cellColor: cardColor,
      cellColorModal: modalColor,
      cellColorPopover: popoverColor,
      barColor: primaryColor
    });
  }
  const calendarLight = createTheme({
    name: "Calendar",
    common: commonLight,
    peers: {
      Button: buttonLight$1
    },
    self: self$11
  });
  const calendarLight$1 = calendarLight;
  const style$1c = c$1([cB("calendar", `
 line-height: var(--n-line-height);
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 height: 720px;
 display: flex;
 flex-direction: column;
 `, [cB("calendar-prev-btn", `
 cursor: pointer;
 `), cB("calendar-next-btn", `
 cursor: pointer;
 `), cB("calendar-header", `
 display: flex;
 align-items: center;
 line-height: 1;
 font-size: var(--n-title-font-size);
 padding: 0 0 18px 0;
 justify-content: space-between;
 `, [cE("title", `
 color: var(--n-title-text-color);
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 `), cE("extra", `
 display: flex;
 align-items: center;
 `)]), cB("calendar-dates", `
 display: grid;
 grid-template-columns: repeat(7, minmax(0, 1fr));
 grid-auto-rows: 1fr;
 border-radius: var(--n-border-radius);
 flex: 1;
 border-top: 1px solid;
 border-left: 1px solid;
 border-color: var(--n-border-color);
 transition: border-color .3s var(--n-bezier);
 `), cB("calendar-cell", `
 box-sizing: border-box;
 padding: 10px;
 border-right: 1px solid;
 border-bottom: 1px solid;
 border-color: var(--n-border-color);
 cursor: pointer;
 position: relative;
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [c$1("&:nth-child(7)", `
 border-top-right-radius: var(--n-border-radius);
 `), c$1("&:nth-last-child(7)", `
 border-bottom-left-radius: var(--n-border-radius);
 `), c$1("&:last-child", `
 border-bottom-right-radius: var(--n-border-radius);
 `), c$1("&:hover", `
 background-color: var(--n-cell-color-hover);
 `), cE("bar", `
 position: absolute;
 left: 0;
 right: 0;
 bottom: -1px;
 height: 3px;
 background-color: #0000;
 transition: background-color .3s var(--n-bezier);
 `), cM("selected", [cE("bar", `
 background-color: var(--n-bar-color);
 `)]), cB("calendar-date", `
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 color: var(--n-text-color);
 `, [cE("date", `
 color: var(--n-text-color);
 `)]), cM("disabled, other-month", `
 color: var(--n-day-text-color);
 `, [cB("calendar-date", [cE("date", `
 color: var(--n-day-text-color);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 `), cM("current", [cB("calendar-date", [cE("date", `
 color: var(--n-date-text-color-current);
 background-color: var(--n-date-color-current);
 `)])]), cB("calendar-date", `
 position: relative;
 line-height: 1;
 display: flex;
 align-items: center;
 height: 1em;
 justify-content: space-between;
 padding-bottom: .75em;
 `, [cE("date", `
 border-radius: 50%;
 display: flex;
 align-items: center;
 justify-content: center;
 margin-left: -0.4em;
 width: 1.8em;
 height: 1.8em;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), cE("day", `
 color: var(--n-day-text-color);
 transition: color .3s var(--n-bezier);
 `)])])]), insideModal(cB("calendar", [cB("calendar-dates", `
 border-color: var(--n-border-color-modal);
 `), cB("calendar-cell", `
 border-color: var(--n-border-color-modal);
 `, [c$1("&:hover", `
 background-color: var(--n-cell-color-hover-modal);
 `)])])), insidePopover(cB("calendar", [cB("calendar-dates", `
 border-color: var(--n-border-color-popover);
 `), cB("calendar-cell", `
 border-color: var(--n-border-color-popover);
 `, [c$1("&:hover", `
 background-color: var(--n-cell-color-hover-popover);
 `)])]))]);
  const calendarProps = Object.assign(Object.assign({}, useTheme.props), {
    isDateDisabled: Function,
    value: Number,
    defaultValue: {
      type: Number,
      default: null
    },
    onPanelChange: Function,
    "onUpdate:value": [Function, Array],
    onUpdateValue: [Function, Array]
  });
  const Calendar = vue.defineComponent({
    name: "Calendar",
    props: calendarProps,
    setup(props) {
      var _a;
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Calendar", "-calendar", style$1c, calendarLight$1, props, mergedClsPrefixRef);
      const {
        localeRef,
        dateLocaleRef
      } = useLocale("DatePicker");
      const now2 = Date.now();
      const monthTsRef = vue.ref(startOfMonth((_a = props.defaultValue) !== null && _a !== void 0 ? _a : now2).valueOf());
      const uncontrolledValueRef = vue.ref(props.defaultValue || null);
      const mergedValueRef = useMergedState(vue.toRef(props, "value"), uncontrolledValueRef);
      function doUpdateValue(value, time2) {
        const {
          onUpdateValue,
          "onUpdate:value": _onUpdateValue
        } = props;
        if (onUpdateValue) {
          call(onUpdateValue, value, time2);
        }
        if (_onUpdateValue) {
          call(_onUpdateValue, value, time2);
        }
        uncontrolledValueRef.value = value;
      }
      function handlePrevClick() {
        var _a2;
        const monthTs = addMonths(monthTsRef.value, -1).valueOf();
        monthTsRef.value = monthTs;
        (_a2 = props.onPanelChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, {
          year: getYear(monthTs),
          month: getMonth(monthTs) + 1
        });
      }
      function handleNextClick() {
        var _a2;
        const monthTs = addMonths(monthTsRef.value, 1).valueOf();
        monthTsRef.value = monthTs;
        (_a2 = props.onPanelChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, {
          year: getYear(monthTs),
          month: getMonth(monthTs) + 1
        });
      }
      function handleTodayClick() {
        var _a2;
        const {
          value: monthTs
        } = monthTsRef;
        const oldYear = getYear(monthTs);
        const oldMonth = getMonth(monthTs);
        const newMonthTs = startOfMonth(now2).valueOf();
        monthTsRef.value = newMonthTs;
        const newYear = getYear(newMonthTs);
        const newMonth = getMonth(newMonthTs);
        if (oldYear !== newYear || oldMonth !== newMonth) {
          (_a2 = props.onPanelChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, {
            year: newYear,
            month: newMonth + 1
          });
        }
      }
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            borderColor,
            borderColorModal,
            borderColorPopover,
            borderRadius,
            titleFontSize,
            textColor,
            titleFontWeight,
            titleTextColor,
            dayTextColor,
            fontSize: fontSize2,
            lineHeight: lineHeight2,
            dateColorCurrent,
            dateTextColorCurrent,
            cellColorHover,
            cellColor,
            cellColorModal,
            barColor,
            cellColorPopover,
            cellColorHoverModal,
            cellColorHoverPopover
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-border-color": borderColor,
          "--n-border-color-modal": borderColorModal,
          "--n-border-color-popover": borderColorPopover,
          "--n-border-radius": borderRadius,
          "--n-text-color": textColor,
          "--n-title-font-weight": titleFontWeight,
          "--n-title-font-size": titleFontSize,
          "--n-title-text-color": titleTextColor,
          "--n-day-text-color": dayTextColor,
          "--n-font-size": fontSize2,
          "--n-line-height": lineHeight2,
          "--n-date-color-current": dateColorCurrent,
          "--n-date-text-color-current": dateTextColorCurrent,
          "--n-cell-color": cellColor,
          "--n-cell-color-modal": cellColorModal,
          "--n-cell-color-popover": cellColorPopover,
          "--n-cell-color-hover": cellColorHover,
          "--n-cell-color-hover-modal": cellColorHoverModal,
          "--n-cell-color-hover-popover": cellColorHoverPopover,
          "--n-bar-color": barColor
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("calendar", void 0, cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        locale: localeRef,
        dateLocale: dateLocaleRef,
        now: now2,
        mergedValue: mergedValueRef,
        monthTs: monthTsRef,
        dateItems: vue.computed(() => {
          return dateArray(monthTsRef.value, mergedValueRef.value, now2, localeRef.value.firstDayOfWeek, true);
        }),
        doUpdateValue,
        handleTodayClick,
        handlePrevClick,
        handleNextClick,
        mergedTheme: themeRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      const {
        isDateDisabled,
        mergedClsPrefix,
        monthTs,
        cssVars,
        mergedValue,
        mergedTheme,
        $slots,
        locale: {
          monthBeforeYear,
          today
        },
        dateLocale: {
          locale
        },
        handleTodayClick,
        handlePrevClick,
        handleNextClick,
        onRender
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      const normalizedValue = mergedValue && startOfDay(mergedValue).valueOf();
      const year = getYear(monthTs);
      const calendarMonth = getMonth(monthTs) + 1;
      return vue.h("div", {
        class: [`${mergedClsPrefix}-calendar`, this.themeClass],
        style: cssVars
      }, vue.h("div", {
        class: `${mergedClsPrefix}-calendar-header`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-calendar-header__title`
      }, resolveSlotWithProps($slots.header, {
        year,
        month: calendarMonth
      }, () => {
        const localeMonth = format$3(monthTs, "MMMM", {
          locale
        });
        return [monthBeforeYear ? `${localeMonth} ${year}` : `${year} ${localeMonth}`];
      })), vue.h("div", {
        class: `${mergedClsPrefix}-calendar-header__extra`
      }, vue.h(NButtonGroup, null, {
        default: () => vue.h(vue.Fragment, null, vue.h(NButton, {
          size: "small",
          onClick: handlePrevClick,
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button
        }, {
          icon: () => vue.h(NBaseIcon, {
            clsPrefix: mergedClsPrefix,
            class: `${mergedClsPrefix}-calendar-prev-btn`
          }, {
            default: () => vue.h(ChevronLeftIcon, null)
          })
        }), vue.h(NButton, {
          size: "small",
          onClick: handleTodayClick,
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button
        }, {
          default: () => today
        }), vue.h(NButton, {
          size: "small",
          onClick: handleNextClick,
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button
        }, {
          icon: () => vue.h(NBaseIcon, {
            clsPrefix: mergedClsPrefix,
            class: `${mergedClsPrefix}-calendar-next-btn`
          }, {
            default: () => vue.h(ChevronRightIcon, null)
          })
        }))
      }))), vue.h("div", {
        class: `${mergedClsPrefix}-calendar-dates`
      }, this.dateItems.map(({
        dateObject,
        ts,
        inCurrentMonth,
        isCurrentDate
      }, index) => {
        var _a;
        const {
          year: year2,
          month,
          date
        } = dateObject;
        const fullDate = format$3(ts, "yyyy-MM-dd");
        const notInCurrentMonth = !inCurrentMonth;
        const disabled = (isDateDisabled === null || isDateDisabled === void 0 ? void 0 : isDateDisabled(ts)) === true;
        const selected = normalizedValue === startOfDay(ts).valueOf();
        return vue.h("div", {
          key: `${calendarMonth}-${index}`,
          class: [`${mergedClsPrefix}-calendar-cell`, disabled && `${mergedClsPrefix}-calendar-cell--disabled`, notInCurrentMonth && `${mergedClsPrefix}-calendar-cell--other-month`, disabled && `${mergedClsPrefix}-calendar-cell--not-allowed`, isCurrentDate && `${mergedClsPrefix}-calendar-cell--current`, selected && `${mergedClsPrefix}-calendar-cell--selected`],
          onClick: () => {
            var _a2;
            if (disabled)
              return;
            const monthTs2 = startOfMonth(ts).valueOf();
            this.monthTs = monthTs2;
            if (notInCurrentMonth) {
              (_a2 = this.onPanelChange) === null || _a2 === void 0 ? void 0 : _a2.call(this, {
                year: getYear(monthTs2),
                month: getMonth(monthTs2) + 1
              });
            }
            this.doUpdateValue(ts, {
              year: year2,
              month: month + 1,
              date
            });
          }
        }, vue.h("div", {
          class: `${mergedClsPrefix}-calendar-date`
        }, vue.h("div", {
          class: `${mergedClsPrefix}-calendar-date__date`,
          title: fullDate
        }, date), index < 7 && vue.h("div", {
          class: `${mergedClsPrefix}-calendar-date__day`,
          title: fullDate
        }, format$3(ts, "EEE", {
          locale
        }))), (_a = $slots.default) === null || _a === void 0 ? void 0 : _a.call($slots, {
          year: year2,
          month: month + 1,
          date
        }), vue.h("div", {
          class: `${mergedClsPrefix}-calendar-cell__bar`
        }));
      })));
    }
  });
  function self$10(vars) {
    const {
      fontSize: fontSize2,
      boxShadow2,
      popoverColor,
      textColor2,
      borderRadius,
      borderColor,
      heightSmall,
      heightMedium,
      heightLarge,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      dividerColor
    } = vars;
    return {
      panelFontSize: fontSize2,
      boxShadow: boxShadow2,
      color: popoverColor,
      textColor: textColor2,
      borderRadius,
      border: `1px solid ${borderColor}`,
      heightSmall,
      heightMedium,
      heightLarge,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      dividerColor
    };
  }
  const colorPickerLight = createTheme({
    name: "ColorPicker",
    common: commonLight,
    peers: {
      Input: inputLight$1,
      Button: buttonLight$1
    },
    self: self$10
  });
  const colorPickerLight$1 = colorPickerLight;
  function deriveDefaultValue(modes, showAlpha) {
    const mode = modes[0];
    switch (mode) {
      case "hex":
        return showAlpha ? "#000000FF" : "#000000";
      case "rgb":
        return showAlpha ? "rgba(0, 0, 0, 1)" : "rgb(0, 0, 0)";
      case "hsl":
        return showAlpha ? "hsla(0, 0%, 0%, 1)" : "hsl(0, 0%, 0%)";
      case "hsv":
        return showAlpha ? "hsva(0, 0%, 0%, 1)" : "hsv(0, 0%, 0%)";
    }
    warn$2("color-picker", "props.modes is invalid.");
    return "#000000";
  }
  function getModeFromValue(color) {
    if (color === null)
      return null;
    if (/^ *#/.test(color))
      return "hex";
    if (color.includes("rgb"))
      return "rgb";
    if (color.includes("hsl"))
      return "hsl";
    if (color.includes("hsv"))
      return "hsv";
    return null;
  }
  function normalizeHue(hue) {
    hue = Math.round(hue);
    return hue >= 360 ? 359 : hue < 0 ? 0 : hue;
  }
  function normalizeAlpha(alpha) {
    alpha = Math.round(alpha * 100) / 100;
    return alpha > 1 ? 1 : alpha < 0 ? 0 : alpha;
  }
  const convert = {
    rgb: {
      hex(value) {
        return toHexaString(rgba(value));
      },
      hsl(value) {
        const [r, g, b, a2] = rgba(value);
        return toHslaString([...rgb2hsl(r, g, b), a2]);
      },
      hsv(value) {
        const [r, g, b, a2] = rgba(value);
        return toHsvaString([...rgb2hsv(r, g, b), a2]);
      }
    },
    hex: {
      rgb(value) {
        return toRgbaString(rgba(value));
      },
      hsl(value) {
        const [r, g, b, a2] = rgba(value);
        return toHslaString([...rgb2hsl(r, g, b), a2]);
      },
      hsv(value) {
        const [r, g, b, a2] = rgba(value);
        return toHsvaString([...rgb2hsv(r, g, b), a2]);
      }
    },
    hsl: {
      hex(value) {
        const [h, s, l, a2] = hsla(value);
        return toHexaString([...hsl2rgb(h, s, l), a2]);
      },
      rgb(value) {
        const [h, s, l, a2] = hsla(value);
        return toRgbaString([...hsl2rgb(h, s, l), a2]);
      },
      hsv(value) {
        const [h, s, l, a2] = hsla(value);
        return toHsvaString([...hsl2hsv(h, s, l), a2]);
      }
    },
    hsv: {
      hex(value) {
        const [h, s, v, a2] = hsva(value);
        return toHexaString([...hsv2rgb(h, s, v), a2]);
      },
      rgb(value) {
        const [h, s, v, a2] = hsva(value);
        return toRgbaString([...hsv2rgb(h, s, v), a2]);
      },
      hsl(value) {
        const [h, s, v, a2] = hsva(value);
        return toHslaString([...hsv2hsl(h, s, v), a2]);
      }
    }
  };
  function convertColor(value, mode, originalMode) {
    originalMode = originalMode || getModeFromValue(value);
    if (!originalMode)
      return null;
    if (originalMode === mode)
      return value;
    const conversions = convert[originalMode];
    return conversions[mode](value);
  }
  const HANDLE_SIZE$2 = "12px";
  const HANDLE_SIZE_NUM$1 = 12;
  const RADIUS$2 = "6px";
  const RADIUS_NUM = 6;
  const GRADIENT = "linear-gradient(90deg,red,#ff0 16.66%,#0f0 33.33%,#0ff 50%,#00f 66.66%,#f0f 83.33%,red)";
  const HueSlider = vue.defineComponent({
    name: "HueSlider",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      hue: {
        type: Number,
        required: true
      },
      onUpdateHue: {
        type: Function,
        required: true
      },
      onComplete: Function
    },
    setup(props) {
      const railRef = vue.ref(null);
      function handleMouseDown(e) {
        if (!railRef.value)
          return;
        on("mousemove", document, handleMouseMove);
        on("mouseup", document, handleMouseUp);
        handleMouseMove(e);
      }
      function handleMouseMove(e) {
        const {
          value: railEl
        } = railRef;
        if (!railEl)
          return;
        const {
          width,
          left
        } = railEl.getBoundingClientRect();
        const newHue = normalizeHue((e.clientX - left - RADIUS_NUM) / (width - HANDLE_SIZE_NUM$1) * 360);
        props.onUpdateHue(newHue);
      }
      function handleMouseUp() {
        var _a;
        off("mousemove", document, handleMouseMove);
        off("mouseup", document, handleMouseUp);
        (_a = props.onComplete) === null || _a === void 0 ? void 0 : _a.call(props);
      }
      return {
        railRef,
        handleMouseDown
      };
    },
    render() {
      const {
        clsPrefix
      } = this;
      return vue.h("div", {
        class: `${clsPrefix}-color-picker-slider`,
        style: {
          height: HANDLE_SIZE$2,
          borderRadius: RADIUS$2
        }
      }, vue.h("div", {
        ref: "railRef",
        style: {
          boxShadow: "inset 0 0 2px 0 rgba(0, 0, 0, .24)",
          boxSizing: "border-box",
          backgroundImage: GRADIENT,
          height: HANDLE_SIZE$2,
          borderRadius: RADIUS$2,
          position: "relative"
        },
        onMousedown: this.handleMouseDown
      }, vue.h("div", {
        style: {
          position: "absolute",
          left: RADIUS$2,
          right: RADIUS$2,
          top: 0,
          bottom: 0
        }
      }, vue.h("div", {
        class: `${clsPrefix}-color-picker-handle`,
        style: {
          left: `calc((${this.hue}%) / 359 * 100 - ${RADIUS$2})`,
          borderRadius: RADIUS$2,
          width: HANDLE_SIZE$2,
          height: HANDLE_SIZE$2
        }
      }, vue.h("div", {
        class: `${clsPrefix}-color-picker-handle__fill`,
        style: {
          backgroundColor: `hsl(${this.hue}, 100%, 50%)`,
          borderRadius: RADIUS$2,
          width: HANDLE_SIZE$2,
          height: HANDLE_SIZE$2
        }
      })))));
    }
  });
  const HANDLE_SIZE$1 = "12px";
  const HANDLE_SIZE_NUM = 12;
  const RADIUS$1 = "6px";
  const AlphaSlider = vue.defineComponent({
    name: "AlphaSlider",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      rgba: {
        type: Array,
        default: null
      },
      alpha: {
        type: Number,
        default: 0
      },
      onUpdateAlpha: {
        type: Function,
        required: true
      },
      onComplete: Function
    },
    setup(props) {
      const railRef = vue.ref(null);
      function handleMouseDown(e) {
        if (!railRef.value || !props.rgba)
          return;
        on("mousemove", document, handleMouseMove);
        on("mouseup", document, handleMouseUp);
        handleMouseMove(e);
      }
      function handleMouseMove(e) {
        const {
          value: railEl
        } = railRef;
        if (!railEl)
          return;
        const {
          width,
          left
        } = railEl.getBoundingClientRect();
        const newAlpha = (e.clientX - left) / (width - HANDLE_SIZE_NUM);
        props.onUpdateAlpha(normalizeAlpha(newAlpha));
      }
      function handleMouseUp() {
        var _a;
        off("mousemove", document, handleMouseMove);
        off("mouseup", document, handleMouseUp);
        (_a = props.onComplete) === null || _a === void 0 ? void 0 : _a.call(props);
      }
      return {
        railRef,
        railBackgroundImage: vue.computed(() => {
          const {
            rgba: rgba2
          } = props;
          if (!rgba2)
            return "";
          return `linear-gradient(to right, rgba(${rgba2[0]}, ${rgba2[1]}, ${rgba2[2]}, 0) 0%, rgba(${rgba2[0]}, ${rgba2[1]}, ${rgba2[2]}, 1) 100%)`;
        }),
        handleMouseDown
      };
    },
    render() {
      const {
        clsPrefix
      } = this;
      return vue.h("div", {
        class: `${clsPrefix}-color-picker-slider`,
        ref: "railRef",
        style: {
          height: HANDLE_SIZE$1,
          borderRadius: RADIUS$1
        },
        onMousedown: this.handleMouseDown
      }, vue.h("div", {
        style: {
          borderRadius: RADIUS$1,
          position: "absolute",
          left: 0,
          right: 0,
          top: 0,
          bottom: 0,
          overflow: "hidden"
        }
      }, vue.h("div", {
        class: `${clsPrefix}-color-picker-checkboard`
      }), vue.h("div", {
        class: `${clsPrefix}-color-picker-slider__image`,
        style: {
          backgroundImage: this.railBackgroundImage
        }
      })), this.rgba && vue.h("div", {
        style: {
          position: "absolute",
          left: RADIUS$1,
          right: RADIUS$1,
          top: 0,
          bottom: 0
        }
      }, vue.h("div", {
        class: `${clsPrefix}-color-picker-handle`,
        style: {
          left: `calc(${this.alpha * 100}% - ${RADIUS$1})`,
          borderRadius: RADIUS$1,
          width: HANDLE_SIZE$1,
          height: HANDLE_SIZE$1
        }
      }, vue.h("div", {
        class: `${clsPrefix}-color-picker-handle__fill`,
        style: {
          backgroundColor: toRgbaString(this.rgba),
          borderRadius: RADIUS$1,
          width: HANDLE_SIZE$1,
          height: HANDLE_SIZE$1
        }
      }))));
    }
  });
  const HANDLE_SIZE = "12px";
  const RADIUS = "6px";
  const Pallete = vue.defineComponent({
    name: "Pallete",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      rgba: {
        type: Array,
        default: null
      },
      // 0 - 360
      displayedHue: {
        type: Number,
        required: true
      },
      displayedSv: {
        type: Array,
        required: true
      },
      onUpdateSV: {
        type: Function,
        required: true
      },
      onComplete: Function
    },
    setup(props) {
      const palleteRef = vue.ref(null);
      function handleMouseDown(e) {
        if (!palleteRef.value)
          return;
        on("mousemove", document, handleMouseMove);
        on("mouseup", document, handleMouseUp);
        handleMouseMove(e);
      }
      function handleMouseMove(e) {
        const {
          value: palleteEl
        } = palleteRef;
        if (!palleteEl)
          return;
        const {
          width,
          height,
          left,
          bottom
        } = palleteEl.getBoundingClientRect();
        const newV = (bottom - e.clientY) / height;
        const newS = (e.clientX - left) / width;
        const normalizedNewS = 100 * (newS > 1 ? 1 : newS < 0 ? 0 : newS);
        const normalizedNewV = 100 * (newV > 1 ? 1 : newV < 0 ? 0 : newV);
        props.onUpdateSV(normalizedNewS, normalizedNewV);
      }
      function handleMouseUp() {
        var _a;
        off("mousemove", document, handleMouseMove);
        off("mouseup", document, handleMouseUp);
        (_a = props.onComplete) === null || _a === void 0 ? void 0 : _a.call(props);
      }
      return {
        palleteRef,
        handleColor: vue.computed(() => {
          const {
            rgba: rgba2
          } = props;
          if (!rgba2)
            return "";
          return `rgb(${rgba2[0]}, ${rgba2[1]}, ${rgba2[2]})`;
        }),
        handleMouseDown
      };
    },
    render() {
      const {
        clsPrefix
      } = this;
      return vue.h("div", {
        class: `${clsPrefix}-color-picker-pallete`,
        onMousedown: this.handleMouseDown,
        ref: "palleteRef"
      }, vue.h("div", {
        class: `${clsPrefix}-color-picker-pallete__layer`,
        style: {
          backgroundImage: `linear-gradient(90deg, white, hsl(${this.displayedHue}, 100%, 50%))`
        }
      }), vue.h("div", {
        class: `${clsPrefix}-color-picker-pallete__layer ${clsPrefix}-color-picker-pallete__layer--shadowed`,
        style: {
          backgroundImage: "linear-gradient(180deg, rgba(0, 0, 0, 0%), rgba(0, 0, 0, 100%))"
        }
      }), this.rgba && vue.h("div", {
        class: `${clsPrefix}-color-picker-handle`,
        style: {
          width: HANDLE_SIZE,
          height: HANDLE_SIZE,
          borderRadius: RADIUS,
          left: `calc(${this.displayedSv[0]}% - ${RADIUS})`,
          bottom: `calc(${this.displayedSv[1]}% - ${RADIUS})`
        }
      }, vue.h("div", {
        class: `${clsPrefix}-color-picker-handle__fill`,
        style: {
          backgroundColor: this.handleColor,
          borderRadius: RADIUS,
          width: HANDLE_SIZE,
          height: HANDLE_SIZE
        }
      })));
    }
  });
  const colorPickerInjectionKey = createInjectionKey("n-color-picker");
  function normalizeRgbUnit(value) {
    if (/^\d{1,3}\.?\d*$/.test(value.trim())) {
      return Math.max(0, Math.min(Number.parseInt(value), 255));
    }
    return false;
  }
  function normalizeHueUnit(value) {
    if (/^\d{1,3}\.?\d*$/.test(value.trim())) {
      return Math.max(0, Math.min(Number.parseInt(value), 360));
    }
    return false;
  }
  function normalizeSlvUnit(value) {
    if (/^\d{1,3}\.?\d*$/.test(value.trim())) {
      return Math.max(0, Math.min(Number.parseInt(value), 100));
    }
    return false;
  }
  function normalizeHexaUnit(value) {
    const trimmedValue = value.trim();
    if (/^#[0-9a-fA-F]+$/.test(trimmedValue)) {
      return [4, 5, 7, 9].includes(trimmedValue.length);
    }
    return false;
  }
  function normalizeAlphaUnit(value) {
    if (/^\d{1,3}\.?\d*%$/.test(value.trim())) {
      return Math.max(0, Math.min(Number.parseInt(value) / 100, 100));
    }
    return false;
  }
  const inputThemeOverrides = {
    paddingSmall: "0 4px"
  };
  const ColorInputUnit = vue.defineComponent({
    name: "ColorInputUnit",
    props: {
      label: {
        type: String,
        required: true
      },
      value: {
        type: [Number, String],
        default: null
      },
      showAlpha: Boolean,
      onUpdateValue: {
        type: Function,
        required: true
      }
    },
    setup(props) {
      const inputValueRef = vue.ref("");
      const {
        themeRef
      } = vue.inject(colorPickerInjectionKey, null);
      vue.watchEffect(() => {
        inputValueRef.value = getInputString();
      });
      function getInputString() {
        const {
          value
        } = props;
        if (value === null)
          return "";
        const {
          label
        } = props;
        if (label === "HEX") {
          return value;
        }
        if (label === "A") {
          return `${Math.floor(value * 100)}%`;
        }
        return String(Math.floor(value));
      }
      function handleInputUpdateValue(value) {
        inputValueRef.value = value;
      }
      function handleInputChange(value) {
        let unit;
        let valid;
        switch (props.label) {
          case "HEX":
            valid = normalizeHexaUnit(value);
            if (valid) {
              props.onUpdateValue(value);
            }
            inputValueRef.value = getInputString();
            break;
          case "H":
            unit = normalizeHueUnit(value);
            if (unit === false) {
              inputValueRef.value = getInputString();
            } else {
              props.onUpdateValue(unit);
            }
            break;
          case "S":
          case "L":
          case "V":
            unit = normalizeSlvUnit(value);
            if (unit === false) {
              inputValueRef.value = getInputString();
            } else {
              props.onUpdateValue(unit);
            }
            break;
          case "A":
            unit = normalizeAlphaUnit(value);
            if (unit === false) {
              inputValueRef.value = getInputString();
            } else {
              props.onUpdateValue(unit);
            }
            break;
          case "R":
          case "G":
          case "B":
            unit = normalizeRgbUnit(value);
            if (unit === false) {
              inputValueRef.value = getInputString();
            } else {
              props.onUpdateValue(unit);
            }
            break;
        }
      }
      return {
        mergedTheme: themeRef,
        inputValue: inputValueRef,
        handleInputChange,
        handleInputUpdateValue
      };
    },
    render() {
      const {
        mergedTheme
      } = this;
      return vue.h(NInput, {
        size: "small",
        placeholder: this.label,
        theme: mergedTheme.peers.Input,
        themeOverrides: mergedTheme.peerOverrides.Input,
        builtinThemeOverrides: inputThemeOverrides,
        value: this.inputValue,
        onUpdateValue: this.handleInputUpdateValue,
        onChange: this.handleInputChange,
        // add more space for xxx% input
        style: this.label === "A" ? "flex-grow: 1.25;" : ""
      });
    }
  });
  const ColorInput = vue.defineComponent({
    name: "ColorInput",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      mode: {
        type: String,
        required: true
      },
      modes: {
        type: Array,
        required: true
      },
      showAlpha: {
        type: Boolean,
        required: true
      },
      value: {
        // for hex to get percise value
        type: String,
        default: null
      },
      valueArr: {
        type: Array,
        default: null
      },
      onUpdateValue: {
        type: Function,
        required: true
      },
      onUpdateMode: {
        type: Function,
        required: true
      }
    },
    setup(props) {
      return {
        handleUnitUpdateValue(index, value) {
          const {
            showAlpha
          } = props;
          if (props.mode === "hex") {
            props.onUpdateValue((showAlpha ? toHexaString : toHexString)(value));
            return;
          }
          let nextValueArr;
          if (props.valueArr === null) {
            nextValueArr = [0, 0, 0, 0];
          } else {
            nextValueArr = Array.from(props.valueArr);
          }
          switch (props.mode) {
            case "hsv":
              nextValueArr[index] = value;
              props.onUpdateValue((showAlpha ? toHsvaString : toHsvString)(nextValueArr));
              break;
            case "rgb":
              nextValueArr[index] = value;
              props.onUpdateValue((showAlpha ? toRgbaString : toRgbString)(nextValueArr));
              break;
            case "hsl":
              nextValueArr[index] = value;
              props.onUpdateValue((showAlpha ? toHslaString : toHslString)(nextValueArr));
              break;
          }
        }
      };
    },
    render() {
      const {
        clsPrefix,
        modes
      } = this;
      return vue.h("div", {
        class: `${clsPrefix}-color-picker-input`
      }, vue.h("div", {
        class: `${clsPrefix}-color-picker-input__mode`,
        onClick: this.onUpdateMode,
        style: {
          cursor: modes.length === 1 ? "" : "pointer"
        }
      }, this.mode.toUpperCase() + (this.showAlpha ? "A" : "")), vue.h(NInputGroup, null, {
        default: () => {
          const {
            mode,
            valueArr,
            showAlpha
          } = this;
          if (mode === "hex") {
            let hexValue = null;
            try {
              hexValue = valueArr === null ? null : (showAlpha ? toHexaString : toHexString)(valueArr);
            } catch (_a) {
            }
            return vue.h(ColorInputUnit, {
              label: "HEX",
              showAlpha,
              value: hexValue,
              onUpdateValue: (unitValue) => {
                this.handleUnitUpdateValue(0, unitValue);
              }
            });
          }
          return (mode + (showAlpha ? "a" : "")).split("").map((v, i) => vue.h(ColorInputUnit, {
            label: v.toUpperCase(),
            value: valueArr === null ? null : valueArr[i],
            onUpdateValue: (unitValue) => {
              this.handleUnitUpdateValue(i, unitValue);
            }
          }));
        }
      }));
    }
  });
  const ColorPickerTrigger = vue.defineComponent({
    name: "ColorPickerTrigger",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      value: {
        type: String,
        default: null
      },
      hsla: {
        type: Array,
        default: null
      },
      disabled: Boolean,
      onClick: Function
    },
    setup(props) {
      const {
        colorPickerSlots,
        renderLabelRef
      } = vue.inject(colorPickerInjectionKey, null);
      return () => {
        const {
          hsla: hsla2,
          value,
          clsPrefix,
          onClick,
          disabled
        } = props;
        const renderLabel = colorPickerSlots.label || renderLabelRef.value;
        return vue.h("div", {
          class: [`${clsPrefix}-color-picker-trigger`, disabled && `${clsPrefix}-color-picker-trigger--disabled`],
          onClick: disabled ? void 0 : onClick
        }, vue.h("div", {
          class: `${clsPrefix}-color-picker-trigger__fill`
        }, vue.h("div", {
          class: `${clsPrefix}-color-picker-checkboard`
        }), vue.h("div", {
          style: {
            position: "absolute",
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
            backgroundColor: hsla2 ? toHslaString(hsla2) : ""
          }
        }), value && hsla2 ? vue.h("div", {
          class: `${clsPrefix}-color-picker-trigger__value`,
          style: {
            color: hsla2[2] > 50 || hsla2[3] < 0.5 ? "black" : "white"
          }
        }, renderLabel ? renderLabel(value) : value) : null));
      };
    }
  });
  function normalizeColor(color, mode) {
    if (mode === "hsv") {
      const [h, s, v, a2] = hsva(color);
      return toRgbaString([...hsv2rgb(h, s, v), a2]);
    }
    return color;
  }
  function getHexFromName(color) {
    const ctx2 = document.createElement("canvas").getContext("2d");
    if (!ctx2) {
      return "#000000";
    }
    ctx2.fillStyle = color;
    return ctx2.fillStyle;
  }
  const ColorPickerSwatches = vue.defineComponent({
    name: "ColorPickerSwatches",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      mode: {
        type: String,
        required: true
      },
      swatches: {
        type: Array,
        required: true
      },
      onUpdateColor: {
        type: Function,
        required: true
      }
    },
    setup(props) {
      const parsedSwatchesRef = vue.computed(() => props.swatches.map((value) => {
        const mode = getModeFromValue(value);
        return {
          value,
          mode,
          legalValue: normalizeColor(value, mode)
        };
      }));
      function normalizeOutput(parsed) {
        const {
          mode: modeProp
        } = props;
        let {
          value,
          mode: swatchColorMode
        } = parsed;
        if (!swatchColorMode) {
          swatchColorMode = "hex";
          if (/^[a-zA-Z]+$/.test(value)) {
            value = getHexFromName(value);
          } else {
            warn$2("color-picker", `color ${value} in swatches is invalid.`);
            value = "#000000";
          }
        }
        if (swatchColorMode === modeProp)
          return value;
        return convertColor(value, modeProp, swatchColorMode);
      }
      function handleSwatchSelect(parsed) {
        props.onUpdateColor(normalizeOutput(parsed));
      }
      function handleSwatchKeyDown(e, parsed) {
        if (e.key === "Enter")
          handleSwatchSelect(parsed);
      }
      return {
        parsedSwatchesRef,
        handleSwatchSelect,
        handleSwatchKeyDown
      };
    },
    render() {
      const {
        clsPrefix
      } = this;
      return vue.h("div", {
        class: `${clsPrefix}-color-picker-swatches`
      }, this.parsedSwatchesRef.map((swatch) => vue.h("div", {
        class: `${clsPrefix}-color-picker-swatch`,
        tabindex: 0,
        onClick: () => {
          this.handleSwatchSelect(swatch);
        },
        onKeydown: (e) => {
          this.handleSwatchKeyDown(e, swatch);
        }
      }, vue.h("div", {
        class: `${clsPrefix}-color-picker-swatch__fill`,
        style: {
          background: swatch.legalValue
        }
      }))));
    }
  });
  const ColorPreview = vue.defineComponent({
    name: "ColorPreview",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      mode: {
        type: String,
        required: true
      },
      color: {
        type: String,
        default: null,
        validator: (value) => {
          const mode = getModeFromValue(value);
          return Boolean(!value || mode && mode !== "hsv");
        }
      },
      onUpdateColor: {
        type: Function,
        required: true
      }
    },
    setup(props) {
      function handleChange(e) {
        var _a;
        const value = e.target.value;
        (_a = props.onUpdateColor) === null || _a === void 0 ? void 0 : _a.call(props, convertColor(value.toUpperCase(), props.mode, "hex"));
        e.stopPropagation();
      }
      return {
        handleChange
      };
    },
    render() {
      const {
        clsPrefix
      } = this;
      return vue.h("div", {
        class: `${clsPrefix}-color-picker-preview__preview`
      }, vue.h("span", {
        class: `${clsPrefix}-color-picker-preview__fill`,
        style: {
          background: this.color || "#000000"
        }
      }), vue.h("input", {
        class: `${clsPrefix}-color-picker-preview__input`,
        type: "color",
        value: this.color,
        onChange: this.handleChange
      }));
    }
  });
  const style$1b = c$1([cB("color-picker", `
 display: inline-block;
 box-sizing: border-box;
 height: var(--n-height);
 font-size: var(--n-font-size);
 width: 100%;
 position: relative;
 `), cB("color-picker-panel", `
 margin: 4px 0;
 width: 240px;
 font-size: var(--n-panel-font-size);
 color: var(--n-text-color);
 background-color: var(--n-color);
 transition:
 box-shadow .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 box-shadow: var(--n-box-shadow);
 `, [fadeInScaleUpTransition(), cB("input", `
 text-align: center;
 `)]), cB("color-picker-checkboard", `
 background: white; 
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [c$1("&::after", `
 background-image: linear-gradient(45deg, #DDD 25%, #0000 25%), linear-gradient(-45deg, #DDD 25%, #0000 25%), linear-gradient(45deg, #0000 75%, #DDD 75%), linear-gradient(-45deg, #0000 75%, #DDD 75%);
 background-size: 12px 12px;
 background-position: 0 0, 0 6px, 6px -6px, -6px 0px;
 background-repeat: repeat;
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]), cB("color-picker-slider", `
 margin-bottom: 8px;
 position: relative;
 box-sizing: border-box;
 `, [cE("image", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `), c$1("&::after", `
 content: "";
 position: absolute;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 box-shadow: inset 0 0 2px 0 rgba(0, 0, 0, .24);
 pointer-events: none;
 `)]), cB("color-picker-handle", `
 z-index: 1;
 box-shadow: 0 0 2px 0 rgba(0, 0, 0, .45);
 position: absolute;
 background-color: white;
 overflow: hidden;
 `, [cE("fill", `
 box-sizing: border-box;
 border: 2px solid white;
 `)]), cB("color-picker-pallete", `
 height: 180px;
 position: relative;
 margin-bottom: 8px;
 cursor: crosshair;
 `, [cE("layer", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [cM("shadowed", `
 box-shadow: inset 0 0 2px 0 rgba(0, 0, 0, .24);
 `)])]), cB("color-picker-preview", `
 display: flex;
 `, [cE("sliders", `
 flex: 1 0 auto;
 `), cE("preview", `
 position: relative;
 height: 30px;
 width: 30px;
 margin: 0 0 8px 6px;
 border-radius: 50%;
 box-shadow: rgba(0, 0, 0, .15) 0px 0px 0px 1px inset;
 overflow: hidden;
 `), cE("fill", `
 display: block;
 width: 30px;
 height: 30px;
 `), cE("input", `
 position: absolute;
 top: 0;
 left: 0;
 width: 30px;
 height: 30px;
 opacity: 0;
 z-index: 1;
 `)]), cB("color-picker-input", `
 display: flex;
 align-items: center;
 `, [cB("input", `
 flex-grow: 1;
 flex-basis: 0;
 `), cE("mode", `
 width: 72px;
 text-align: center;
 `)]), cB("color-picker-control", `
 padding: 12px;
 `), cB("color-picker-action", `
 display: flex;
 margin-top: -4px;
 border-top: 1px solid var(--n-divider-color);
 padding: 8px 12px;
 justify-content: flex-end;
 `, [cB("button", "margin-left: 8px;")]), cB("color-picker-trigger", `
 border: var(--n-border);
 height: 100%;
 box-sizing: border-box;
 border-radius: var(--n-border-radius);
 transition: border-color .3s var(--n-bezier);
 cursor: pointer;
 `, [cE("value", `
 white-space: nowrap;
 position: relative;
 `), cE("fill", `
 border-radius: var(--n-border-radius);
 position: absolute;
 display: flex;
 align-items: center;
 justify-content: center;
 left: 4px;
 right: 4px;
 top: 4px;
 bottom: 4px;
 `), cM("disabled", "cursor: not-allowed"), cB("color-picker-checkboard", `
 border-radius: var(--n-border-radius);
 `, [c$1("&::after", `
 --n-block-size: calc((var(--n-height) - 8px) / 3);
 background-size: calc(var(--n-block-size) * 2) calc(var(--n-block-size) * 2);
 background-position: 0 0, 0 var(--n-block-size), var(--n-block-size) calc(-1 * var(--n-block-size)), calc(-1 * var(--n-block-size)) 0px; 
 `)])]), cB("color-picker-swatches", `
 display: grid;
 grid-gap: 8px;
 flex-wrap: wrap;
 position: relative;
 grid-template-columns: repeat(auto-fill, 18px);
 margin-top: 10px;
 `, [cB("color-picker-swatch", `
 width: 18px;
 height: 18px;
 background-image: linear-gradient(45deg, #DDD 25%, #0000 25%), linear-gradient(-45deg, #DDD 25%, #0000 25%), linear-gradient(45deg, #0000 75%, #DDD 75%), linear-gradient(-45deg, #0000 75%, #DDD 75%);
 background-size: 8px 8px;
 background-position: 0px 0, 0px 4px, 4px -4px, -4px 0px;
 background-repeat: repeat;
 `, [cE("fill", `
 position: relative;
 width: 100%;
 height: 100%;
 border-radius: 3px;
 box-shadow: rgba(0, 0, 0, .15) 0px 0px 0px 1px inset;
 cursor: pointer;
 `), c$1("&:focus", `
 outline: none;
 `, [cE("fill", [c$1("&::after", `
 position: absolute;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 background: inherit;
 filter: blur(2px);
 content: "";
 `)])])])])]);
  const colorPickerProps = Object.assign(Object.assign({}, useTheme.props), {
    value: String,
    show: {
      type: Boolean,
      default: void 0
    },
    defaultShow: Boolean,
    defaultValue: String,
    modes: {
      type: Array,
      // no hsva by default since browser doesn't support it
      default: () => ["rgb", "hex", "hsl"]
    },
    placement: {
      type: String,
      default: "bottom-start"
    },
    to: useAdjustedTo.propTo,
    showAlpha: {
      type: Boolean,
      default: true
    },
    showPreview: Boolean,
    swatches: Array,
    disabled: {
      type: Boolean,
      default: void 0
    },
    actions: {
      type: Array,
      default: null
    },
    internalActions: Array,
    size: String,
    renderLabel: Function,
    onComplete: Function,
    onConfirm: Function,
    onClear: Function,
    "onUpdate:show": [Function, Array],
    onUpdateShow: [Function, Array],
    "onUpdate:value": [Function, Array],
    onUpdateValue: [Function, Array]
  });
  const NColorPicker = vue.defineComponent({
    name: "ColorPicker",
    props: colorPickerProps,
    setup(props, {
      slots
    }) {
      const selfRef = vue.ref(null);
      let upcomingValue = null;
      const formItem = useFormItem(props);
      const {
        mergedSizeRef,
        mergedDisabledRef
      } = formItem;
      const {
        localeRef
      } = useLocale("global");
      const {
        mergedClsPrefixRef,
        namespaceRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("ColorPicker", "-color-picker", style$1b, colorPickerLight$1, props, mergedClsPrefixRef);
      vue.provide(colorPickerInjectionKey, {
        themeRef,
        renderLabelRef: vue.toRef(props, "renderLabel"),
        colorPickerSlots: slots
      });
      const uncontrolledShowRef = vue.ref(props.defaultShow);
      const mergedShowRef = useMergedState(vue.toRef(props, "show"), uncontrolledShowRef);
      function doUpdateShow(value) {
        const {
          onUpdateShow,
          "onUpdate:show": _onUpdateShow
        } = props;
        if (onUpdateShow)
          call(onUpdateShow, value);
        if (_onUpdateShow)
          call(_onUpdateShow, value);
        uncontrolledShowRef.value = value;
      }
      const {
        defaultValue
      } = props;
      const uncontrolledValueRef = vue.ref(defaultValue === void 0 ? deriveDefaultValue(props.modes, props.showAlpha) : defaultValue);
      const mergedValueRef = useMergedState(vue.toRef(props, "value"), uncontrolledValueRef);
      const undoStackRef = vue.ref([mergedValueRef.value]);
      const valueIndexRef = vue.ref(0);
      const valueModeRef = vue.computed(() => getModeFromValue(mergedValueRef.value));
      const {
        modes
      } = props;
      const displayedModeRef = vue.ref(getModeFromValue(mergedValueRef.value) || modes[0] || "rgb");
      function handleUpdateDisplayedMode() {
        const {
          modes: modes2
        } = props;
        const {
          value: displayedMode
        } = displayedModeRef;
        const currentModeIndex = modes2.findIndex((mode) => mode === displayedMode);
        if (~currentModeIndex) {
          displayedModeRef.value = modes2[(currentModeIndex + 1) % modes2.length];
        } else {
          displayedModeRef.value = "rgb";
        }
      }
      let _h, s, l, v, r, g, b, a2;
      const hsvaRef = vue.computed(() => {
        const {
          value: mergedValue
        } = mergedValueRef;
        if (!mergedValue)
          return null;
        switch (valueModeRef.value) {
          case "hsv":
            return hsva(mergedValue);
          case "hsl":
            [_h, s, l, a2] = hsla(mergedValue);
            return [...hsl2hsv(_h, s, l), a2];
          case "rgb":
          case "hex":
            [r, g, b, a2] = rgba(mergedValue);
            return [...rgb2hsv(r, g, b), a2];
        }
      });
      const rgbaRef = vue.computed(() => {
        const {
          value: mergedValue
        } = mergedValueRef;
        if (!mergedValue)
          return null;
        switch (valueModeRef.value) {
          case "rgb":
          case "hex":
            return rgba(mergedValue);
          case "hsv":
            [_h, s, v, a2] = hsva(mergedValue);
            return [...hsv2rgb(_h, s, v), a2];
          case "hsl":
            [_h, s, l, a2] = hsla(mergedValue);
            return [...hsl2rgb(_h, s, l), a2];
        }
      });
      const hslaRef = vue.computed(() => {
        const {
          value: mergedValue
        } = mergedValueRef;
        if (!mergedValue)
          return null;
        switch (valueModeRef.value) {
          case "hsl":
            return hsla(mergedValue);
          case "hsv":
            [_h, s, v, a2] = hsva(mergedValue);
            return [...hsv2hsl(_h, s, v), a2];
          case "rgb":
          case "hex":
            [r, g, b, a2] = rgba(mergedValue);
            return [...rgb2hsl(r, g, b), a2];
        }
      });
      const mergedValueArrRef = vue.computed(() => {
        switch (displayedModeRef.value) {
          case "rgb":
          case "hex":
            return rgbaRef.value;
          case "hsv":
            return hsvaRef.value;
          case "hsl":
            return hslaRef.value;
        }
      });
      const displayedHueRef = vue.ref(0);
      const displayedAlphaRef = vue.ref(1);
      const displayedSvRef = vue.ref([0, 0]);
      function handleUpdateSv(s2, v2) {
        const {
          value: hsvaArr
        } = hsvaRef;
        const hue = displayedHueRef.value;
        const alpha = hsvaArr ? hsvaArr[3] : 1;
        displayedSvRef.value = [s2, v2];
        const {
          showAlpha
        } = props;
        switch (displayedModeRef.value) {
          case "hsv":
            doUpdateValue((showAlpha ? toHsvaString : toHsvString)([hue, s2, v2, alpha]), "cursor");
            break;
          case "hsl":
            doUpdateValue((showAlpha ? toHslaString : toHslString)([...hsv2hsl(hue, s2, v2), alpha]), "cursor");
            break;
          case "rgb":
            doUpdateValue((showAlpha ? toRgbaString : toRgbString)([...hsv2rgb(hue, s2, v2), alpha]), "cursor");
            break;
          case "hex":
            doUpdateValue((showAlpha ? toHexaString : toHexString)([...hsv2rgb(hue, s2, v2), alpha]), "cursor");
            break;
        }
      }
      function handleUpdateHue(hue) {
        displayedHueRef.value = hue;
        const {
          value: hsvaArr
        } = hsvaRef;
        if (!hsvaArr) {
          return;
        }
        const [, s2, v2, a3] = hsvaArr;
        const {
          showAlpha
        } = props;
        switch (displayedModeRef.value) {
          case "hsv":
            doUpdateValue((showAlpha ? toHsvaString : toHsvString)([hue, s2, v2, a3]), "cursor");
            break;
          case "rgb":
            doUpdateValue((showAlpha ? toRgbaString : toRgbString)([...hsv2rgb(hue, s2, v2), a3]), "cursor");
            break;
          case "hex":
            doUpdateValue((showAlpha ? toHexaString : toHexString)([...hsv2rgb(hue, s2, v2), a3]), "cursor");
            break;
          case "hsl":
            doUpdateValue((showAlpha ? toHslaString : toHslString)([...hsv2hsl(hue, s2, v2), a3]), "cursor");
            break;
        }
      }
      function handleUpdateAlpha(alpha) {
        switch (displayedModeRef.value) {
          case "hsv":
            [_h, s, v] = hsvaRef.value;
            doUpdateValue(toHsvaString([_h, s, v, alpha]), "cursor");
            break;
          case "rgb":
            [r, g, b] = rgbaRef.value;
            doUpdateValue(toRgbaString([r, g, b, alpha]), "cursor");
            break;
          case "hex":
            [r, g, b] = rgbaRef.value;
            doUpdateValue(toHexaString([r, g, b, alpha]), "cursor");
            break;
          case "hsl":
            [_h, s, l] = hslaRef.value;
            doUpdateValue(toHslaString([_h, s, l, alpha]), "cursor");
            break;
        }
        displayedAlphaRef.value = alpha;
      }
      function doUpdateValue(value, updateSource) {
        if (updateSource === "cursor") {
          upcomingValue = value;
        } else {
          upcomingValue = null;
        }
        const {
          nTriggerFormChange,
          nTriggerFormInput
        } = formItem;
        const {
          onUpdateValue,
          "onUpdate:value": _onUpdateValue
        } = props;
        if (onUpdateValue)
          call(onUpdateValue, value);
        if (_onUpdateValue)
          call(_onUpdateValue, value);
        nTriggerFormChange();
        nTriggerFormInput();
        uncontrolledValueRef.value = value;
      }
      function handleInputUpdateValue(value) {
        doUpdateValue(value, "input");
        void vue.nextTick(handleComplete);
      }
      function handleComplete(pushStack = true) {
        const {
          value
        } = mergedValueRef;
        if (value) {
          const {
            nTriggerFormChange,
            nTriggerFormInput
          } = formItem;
          const {
            onComplete
          } = props;
          if (onComplete) {
            onComplete(value);
          }
          const {
            value: undoStack
          } = undoStackRef;
          const {
            value: valueIndex
          } = valueIndexRef;
          if (pushStack) {
            undoStack.splice(valueIndex + 1, undoStack.length, value);
            valueIndexRef.value = valueIndex + 1;
          }
          nTriggerFormChange();
          nTriggerFormInput();
        }
      }
      function undo() {
        const {
          value: valueIndex
        } = valueIndexRef;
        if (valueIndex - 1 < 0)
          return;
        doUpdateValue(undoStackRef.value[valueIndex - 1], "input");
        handleComplete(false);
        valueIndexRef.value = valueIndex - 1;
      }
      function redo() {
        const {
          value: valueIndex
        } = valueIndexRef;
        if (valueIndex < 0 || valueIndex + 1 >= undoStackRef.value.length)
          return;
        doUpdateValue(undoStackRef.value[valueIndex + 1], "input");
        handleComplete(false);
        valueIndexRef.value = valueIndex + 1;
      }
      function handleClear() {
        doUpdateValue(null, "input");
        const {
          onClear
        } = props;
        if (onClear) {
          onClear();
        }
        doUpdateShow(false);
      }
      function handleConfirm() {
        const {
          value
        } = mergedValueRef;
        const {
          onConfirm
        } = props;
        if (onConfirm) {
          onConfirm(value);
        }
        doUpdateShow(false);
      }
      const undoableRef = vue.computed(() => valueIndexRef.value >= 1);
      const redoableRef = vue.computed(() => {
        const {
          value: undoStack
        } = undoStackRef;
        return undoStack.length > 1 && valueIndexRef.value < undoStack.length - 1;
      });
      vue.watch(mergedShowRef, (value) => {
        if (!value) {
          undoStackRef.value = [mergedValueRef.value];
          valueIndexRef.value = 0;
        }
      });
      vue.watchEffect(() => {
        if (upcomingValue && upcomingValue === mergedValueRef.value)
          ;
        else {
          const {
            value
          } = hsvaRef;
          if (value) {
            displayedHueRef.value = value[0];
            displayedAlphaRef.value = value[3];
            displayedSvRef.value = [value[1], value[2]];
          }
        }
        upcomingValue = null;
      });
      const cssVarsRef = vue.computed(() => {
        const {
          value: mergedSize
        } = mergedSizeRef;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            textColor,
            color,
            panelFontSize,
            boxShadow,
            border,
            borderRadius,
            dividerColor,
            [createKey("height", mergedSize)]: height,
            [createKey("fontSize", mergedSize)]: fontSize2
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-text-color": textColor,
          "--n-color": color,
          "--n-panel-font-size": panelFontSize,
          "--n-font-size": fontSize2,
          "--n-box-shadow": boxShadow,
          "--n-border": border,
          "--n-border-radius": borderRadius,
          "--n-height": height,
          "--n-divider-color": dividerColor
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("color-picker", vue.computed(() => {
        return mergedSizeRef.value[0];
      }), cssVarsRef, props) : void 0;
      function renderPanel() {
        var _a;
        const {
          value: rgba2
        } = rgbaRef;
        const {
          value: displayedHue
        } = displayedHueRef;
        const {
          internalActions,
          modes: modes2,
          actions
        } = props;
        const {
          value: mergedTheme
        } = themeRef;
        const {
          value: mergedClsPrefix
        } = mergedClsPrefixRef;
        return vue.h("div", {
          class: [`${mergedClsPrefix}-color-picker-panel`, themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value],
          onDragstart: (e) => {
            e.preventDefault();
          },
          style: inlineThemeDisabled ? void 0 : cssVarsRef.value
        }, vue.h("div", {
          class: `${mergedClsPrefix}-color-picker-control`
        }, vue.h(Pallete, {
          clsPrefix: mergedClsPrefix,
          rgba: rgba2,
          displayedHue,
          displayedSv: displayedSvRef.value,
          onUpdateSV: handleUpdateSv,
          onComplete: handleComplete
        }), vue.h("div", {
          class: `${mergedClsPrefix}-color-picker-preview`
        }, vue.h("div", {
          class: `${mergedClsPrefix}-color-picker-preview__sliders`
        }, vue.h(HueSlider, {
          clsPrefix: mergedClsPrefix,
          hue: displayedHue,
          onUpdateHue: handleUpdateHue,
          onComplete: handleComplete
        }), props.showAlpha ? vue.h(AlphaSlider, {
          clsPrefix: mergedClsPrefix,
          rgba: rgba2,
          alpha: displayedAlphaRef.value,
          onUpdateAlpha: handleUpdateAlpha,
          onComplete: handleComplete
        }) : null), props.showPreview ? vue.h(ColorPreview, {
          clsPrefix: mergedClsPrefix,
          mode: displayedModeRef.value,
          color: rgbaRef.value && toHexString(rgbaRef.value),
          onUpdateColor: (color) => {
            doUpdateValue(color, "input");
          }
        }) : null), vue.h(ColorInput, {
          clsPrefix: mergedClsPrefix,
          showAlpha: props.showAlpha,
          mode: displayedModeRef.value,
          modes: modes2,
          onUpdateMode: handleUpdateDisplayedMode,
          value: mergedValueRef.value,
          valueArr: mergedValueArrRef.value,
          onUpdateValue: handleInputUpdateValue
        }), ((_a = props.swatches) === null || _a === void 0 ? void 0 : _a.length) && vue.h(ColorPickerSwatches, {
          clsPrefix: mergedClsPrefix,
          mode: displayedModeRef.value,
          swatches: props.swatches,
          onUpdateColor: (color) => {
            doUpdateValue(color, "input");
          }
        })), (actions === null || actions === void 0 ? void 0 : actions.length) ? vue.h("div", {
          class: `${mergedClsPrefix}-color-picker-action`
        }, actions.includes("confirm") && vue.h(NButton, {
          size: "small",
          onClick: handleConfirm,
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button
        }, {
          default: () => localeRef.value.confirm
        }), actions.includes("clear") && vue.h(NButton, {
          size: "small",
          onClick: handleClear,
          disabled: !mergedValueRef.value,
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button
        }, {
          default: () => localeRef.value.clear
        })) : null, slots.action ? vue.h("div", {
          class: `${mergedClsPrefix}-color-picker-action`
        }, {
          default: slots.action
        }) : internalActions ? vue.h("div", {
          class: `${mergedClsPrefix}-color-picker-action`
        }, internalActions.includes("undo") && vue.h(NButton, {
          size: "small",
          onClick: undo,
          disabled: !undoableRef.value,
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button
        }, {
          default: () => localeRef.value.undo
        }), internalActions.includes("redo") && vue.h(NButton, {
          size: "small",
          onClick: redo,
          disabled: !redoableRef.value,
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button
        }, {
          default: () => localeRef.value.redo
        })) : null);
      }
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        namespace: namespaceRef,
        selfRef,
        hsla: hslaRef,
        rgba: rgbaRef,
        mergedShow: mergedShowRef,
        mergedDisabled: mergedDisabledRef,
        isMounted: isMounted(),
        adjustedTo: useAdjustedTo(props),
        mergedValue: mergedValueRef,
        handleTriggerClick() {
          doUpdateShow(true);
        },
        handleClickOutside(e) {
          var _a;
          if ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(e))) {
            return;
          }
          doUpdateShow(false);
        },
        renderPanel,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      const {
        $slots,
        mergedClsPrefix,
        onRender
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h("div", {
        class: [this.themeClass, `${mergedClsPrefix}-color-picker`],
        ref: "selfRef",
        style: this.cssVars
      }, vue.h(VBinder, null, {
        default: () => [vue.h(VTarget, null, {
          default: () => vue.h(ColorPickerTrigger, {
            clsPrefix: mergedClsPrefix,
            value: this.mergedValue,
            hsla: this.hsla,
            disabled: this.mergedDisabled,
            onClick: this.handleTriggerClick
          }, {
            label: $slots.label
          })
        }), vue.h(VFollower, {
          placement: this.placement,
          show: this.mergedShow,
          containerClass: this.namespace,
          teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey,
          to: this.adjustedTo
        }, {
          default: () => vue.h(vue.Transition, {
            name: "fade-in-scale-up-transition",
            appear: this.isMounted
          }, {
            default: () => this.mergedShow ? vue.withDirectives(this.renderPanel(), [[clickoutside$1, this.handleClickOutside, void 0, {
              capture: true
            }]]) : null
          })
        })]
      }));
    }
  });
  const commonVariables$d = {
    paddingSmall: "12px 16px 12px",
    paddingMedium: "19px 24px 20px",
    paddingLarge: "23px 32px 24px",
    paddingHuge: "27px 40px 28px",
    titleFontSizeSmall: "16px",
    titleFontSizeMedium: "18px",
    titleFontSizeLarge: "18px",
    titleFontSizeHuge: "18px",
    closeIconSize: "18px",
    closeSize: "22px"
  };
  function self$$(vars) {
    const {
      primaryColor,
      borderRadius,
      lineHeight: lineHeight2,
      fontSize: fontSize2,
      cardColor,
      textColor2,
      textColor1,
      dividerColor,
      fontWeightStrong,
      closeIconColor,
      closeIconColorHover,
      closeIconColorPressed,
      closeColorHover,
      closeColorPressed,
      modalColor,
      boxShadow1,
      popoverColor,
      actionColor
    } = vars;
    return Object.assign(Object.assign({}, commonVariables$d), {
      lineHeight: lineHeight2,
      color: cardColor,
      colorModal: modalColor,
      colorPopover: popoverColor,
      colorTarget: primaryColor,
      colorEmbedded: actionColor,
      colorEmbeddedModal: actionColor,
      colorEmbeddedPopover: actionColor,
      textColor: textColor2,
      titleTextColor: textColor1,
      borderColor: dividerColor,
      actionColor,
      titleFontWeight: fontWeightStrong,
      closeColorHover,
      closeColorPressed,
      closeBorderRadius: borderRadius,
      closeIconColor,
      closeIconColorHover,
      closeIconColorPressed,
      fontSizeSmall: fontSize2,
      fontSizeMedium: fontSize2,
      fontSizeLarge: fontSize2,
      fontSizeHuge: fontSize2,
      boxShadow: boxShadow1,
      borderRadius
    });
  }
  const cardLight = {
    name: "Card",
    common: commonLight,
    self: self$$
  };
  const cardLight$1 = cardLight;
  const style$1a = c$1([cB("card", `
 font-size: var(--n-font-size);
 line-height: var(--n-line-height);
 display: flex;
 flex-direction: column;
 width: 100%;
 box-sizing: border-box;
 position: relative;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 color: var(--n-text-color);
 word-break: break-word;
 transition: 
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [asModal({
    background: "var(--n-color-modal)"
  }), cM("hoverable", [c$1("&:hover", "box-shadow: var(--n-box-shadow);")]), cM("content-segmented", [c$1(">", [cE("content", {
    paddingTop: "var(--n-padding-bottom)"
  })])]), cM("content-soft-segmented", [c$1(">", [cE("content", `
 margin: 0 var(--n-padding-left);
 padding: var(--n-padding-bottom) 0;
 `)])]), cM("footer-segmented", [c$1(">", [cE("footer", {
    paddingTop: "var(--n-padding-bottom)"
  })])]), cM("footer-soft-segmented", [c$1(">", [cE("footer", `
 padding: var(--n-padding-bottom) 0;
 margin: 0 var(--n-padding-left);
 `)])]), c$1(">", [cB("card-header", `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 font-size: var(--n-title-font-size);
 padding:
 var(--n-padding-top)
 var(--n-padding-left)
 var(--n-padding-bottom)
 var(--n-padding-left);
 `, [cE("main", `
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 flex: 1;
 min-width: 0;
 color: var(--n-title-text-color);
 `), cE("extra", `
 display: flex;
 align-items: center;
 font-size: var(--n-font-size);
 font-weight: 400;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), cE("close", `
 margin: 0 0 0 8px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), cE("action", `
 box-sizing: border-box;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 background-clip: padding-box;
 background-color: var(--n-action-color);
 `), cE("content", "flex: 1; min-width: 0;"), cE("content, footer", `
 box-sizing: border-box;
 padding: 0 var(--n-padding-left) var(--n-padding-bottom) var(--n-padding-left);
 font-size: var(--n-font-size);
 `, [c$1("&:first-child", {
    paddingTop: "var(--n-padding-bottom)"
  })]), cE("action", `
 background-color: var(--n-action-color);
 padding: var(--n-padding-bottom) var(--n-padding-left);
 border-bottom-left-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `)]), cB("card-cover", `
 overflow: hidden;
 width: 100%;
 border-radius: var(--n-border-radius) var(--n-border-radius) 0 0;
 `, [c$1("img", `
 display: block;
 width: 100%;
 `)]), cM("bordered", `
 border: 1px solid var(--n-border-color);
 `, [c$1("&:target", "border-color: var(--n-color-target);")]), cM("action-segmented", [c$1(">", [cE("action", [c$1("&:not(:first-child)", {
    borderTop: "1px solid var(--n-border-color)"
  })])])]), cM("content-segmented, content-soft-segmented", [c$1(">", [cE("content", {
    transition: "border-color 0.3s var(--n-bezier)"
  }, [c$1("&:not(:first-child)", {
    borderTop: "1px solid var(--n-border-color)"
  })])])]), cM("footer-segmented, footer-soft-segmented", [c$1(">", [cE("footer", {
    transition: "border-color 0.3s var(--n-bezier)"
  }, [c$1("&:not(:first-child)", {
    borderTop: "1px solid var(--n-border-color)"
  })])])]), cM("embedded", `
 background-color: var(--n-color-embedded);
 `)]), insideModal(cB("card", `
 background: var(--n-color-modal);
 `, [cM("embedded", `
 background-color: var(--n-color-embedded-modal);
 `)])), insidePopover(cB("card", `
 background: var(--n-color-popover);
 `, [cM("embedded", `
 background-color: var(--n-color-embedded-popover);
 `)]))]);
  const cardBaseProps = {
    title: [String, Function],
    contentClass: String,
    contentStyle: [Object, String],
    headerClass: String,
    headerStyle: [Object, String],
    headerExtraClass: String,
    headerExtraStyle: [Object, String],
    footerClass: String,
    footerStyle: [Object, String],
    embedded: Boolean,
    segmented: {
      type: [Boolean, Object],
      default: false
    },
    size: {
      type: String,
      default: "medium"
    },
    bordered: {
      type: Boolean,
      default: true
    },
    closable: Boolean,
    hoverable: Boolean,
    role: String,
    onClose: [Function, Array],
    tag: {
      type: String,
      default: "div"
    },
    cover: Function,
    content: [String, Function],
    footer: Function,
    action: Function,
    headerExtra: Function
  };
  const cardBasePropKeys = keysOf(cardBaseProps);
  const cardProps = Object.assign(Object.assign({}, useTheme.props), cardBaseProps);
  const NCard = vue.defineComponent({
    name: "Card",
    props: cardProps,
    setup(props) {
      const handleCloseClick = () => {
        const {
          onClose
        } = props;
        if (onClose)
          call(onClose);
      };
      const {
        inlineThemeDisabled,
        mergedClsPrefixRef,
        mergedRtlRef
      } = useConfig(props);
      const themeRef = useTheme("Card", "-card", style$1a, cardLight$1, props, mergedClsPrefixRef);
      const rtlEnabledRef = useRtl("Card", mergedRtlRef, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          size: size2
        } = props;
        const {
          self: {
            color,
            colorModal,
            colorTarget,
            textColor,
            titleTextColor,
            titleFontWeight,
            borderColor,
            actionColor,
            borderRadius,
            lineHeight: lineHeight2,
            closeIconColor,
            closeIconColorHover,
            closeIconColorPressed,
            closeColorHover,
            closeColorPressed,
            closeBorderRadius,
            closeIconSize,
            closeSize,
            boxShadow,
            colorPopover,
            colorEmbedded,
            colorEmbeddedModal,
            colorEmbeddedPopover,
            [createKey("padding", size2)]: padding,
            [createKey("fontSize", size2)]: fontSize2,
            [createKey("titleFontSize", size2)]: titleFontSize
          },
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          }
        } = themeRef.value;
        const {
          top: paddingTop,
          left: paddingLeft,
          bottom: paddingBottom
        } = getMargin(padding);
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-border-radius": borderRadius,
          "--n-color": color,
          "--n-color-modal": colorModal,
          "--n-color-popover": colorPopover,
          "--n-color-embedded": colorEmbedded,
          "--n-color-embedded-modal": colorEmbeddedModal,
          "--n-color-embedded-popover": colorEmbeddedPopover,
          "--n-color-target": colorTarget,
          "--n-text-color": textColor,
          "--n-line-height": lineHeight2,
          "--n-action-color": actionColor,
          "--n-title-text-color": titleTextColor,
          "--n-title-font-weight": titleFontWeight,
          "--n-close-icon-color": closeIconColor,
          "--n-close-icon-color-hover": closeIconColorHover,
          "--n-close-icon-color-pressed": closeIconColorPressed,
          "--n-close-color-hover": closeColorHover,
          "--n-close-color-pressed": closeColorPressed,
          "--n-border-color": borderColor,
          "--n-box-shadow": boxShadow,
          // size
          "--n-padding-top": paddingTop,
          "--n-padding-bottom": paddingBottom,
          "--n-padding-left": paddingLeft,
          "--n-font-size": fontSize2,
          "--n-title-font-size": titleFontSize,
          "--n-close-size": closeSize,
          "--n-close-icon-size": closeIconSize,
          "--n-close-border-radius": closeBorderRadius
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("card", vue.computed(() => {
        return props.size[0];
      }), cssVarsRef, props) : void 0;
      return {
        rtlEnabled: rtlEnabledRef,
        mergedClsPrefix: mergedClsPrefixRef,
        mergedTheme: themeRef,
        handleCloseClick,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      const {
        segmented,
        bordered,
        hoverable,
        mergedClsPrefix,
        rtlEnabled,
        onRender,
        embedded,
        tag: Component,
        $slots
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h(Component, {
        class: [`${mergedClsPrefix}-card`, this.themeClass, embedded && `${mergedClsPrefix}-card--embedded`, {
          [`${mergedClsPrefix}-card--rtl`]: rtlEnabled,
          [`${mergedClsPrefix}-card--content${typeof segmented !== "boolean" && segmented.content === "soft" ? "-soft" : ""}-segmented`]: segmented === true || segmented !== false && segmented.content,
          [`${mergedClsPrefix}-card--footer${typeof segmented !== "boolean" && segmented.footer === "soft" ? "-soft" : ""}-segmented`]: segmented === true || segmented !== false && segmented.footer,
          [`${mergedClsPrefix}-card--action-segmented`]: segmented === true || segmented !== false && segmented.action,
          [`${mergedClsPrefix}-card--bordered`]: bordered,
          [`${mergedClsPrefix}-card--hoverable`]: hoverable
        }],
        style: this.cssVars,
        role: this.role
      }, resolveWrappedSlot($slots.cover, (children) => {
        const mergedChildren = this.cover ? ensureValidVNode([this.cover()]) : children;
        return mergedChildren && vue.h("div", {
          class: `${mergedClsPrefix}-card-cover`,
          role: "none"
        }, mergedChildren);
      }), resolveWrappedSlot($slots.header, (children) => {
        const {
          title
        } = this;
        const mergedChildren = title ? ensureValidVNode(typeof title === "function" ? [title()] : [title]) : children;
        return mergedChildren || this.closable ? vue.h("div", {
          class: [`${mergedClsPrefix}-card-header`, this.headerClass],
          style: this.headerStyle,
          role: "heading"
        }, vue.h("div", {
          class: `${mergedClsPrefix}-card-header__main`,
          role: "heading"
        }, mergedChildren), resolveWrappedSlot($slots["header-extra"], (children2) => {
          const mergedChildren2 = this.headerExtra ? ensureValidVNode([this.headerExtra()]) : children2;
          return mergedChildren2 && vue.h("div", {
            class: [`${mergedClsPrefix}-card-header__extra`, this.headerExtraClass],
            style: this.headerExtraStyle
          }, mergedChildren2);
        }), this.closable && vue.h(NBaseClose, {
          clsPrefix: mergedClsPrefix,
          class: `${mergedClsPrefix}-card-header__close`,
          onClick: this.handleCloseClick,
          absolute: true
        })) : null;
      }), resolveWrappedSlot($slots.default, (children) => {
        const {
          content
        } = this;
        const mergedChildren = content ? ensureValidVNode(typeof content === "function" ? [content()] : [content]) : children;
        return mergedChildren && vue.h("div", {
          class: [`${mergedClsPrefix}-card__content`, this.contentClass],
          style: this.contentStyle,
          role: "none"
        }, mergedChildren);
      }), resolveWrappedSlot($slots.footer, (children) => {
        const mergedChildren = this.footer ? ensureValidVNode([this.footer()]) : children;
        return mergedChildren && vue.h("div", {
          class: [`${mergedClsPrefix}-card__footer`, this.footerClass],
          style: this.footerStyle,
          role: "none"
        }, mergedChildren);
      }), resolveWrappedSlot($slots.action, (children) => {
        const mergedChildren = this.action ? ensureValidVNode([this.action()]) : children;
        return mergedChildren && vue.h("div", {
          class: `${mergedClsPrefix}-card__action`,
          role: "none"
        }, mergedChildren);
      }));
    }
  });
  function self$_() {
    return {
      dotSize: "8px",
      dotColor: "rgba(255, 255, 255, .3)",
      dotColorActive: "rgba(255, 255, 255, 1)",
      dotColorFocus: "rgba(255, 255, 255, .5)",
      dotLineWidth: "16px",
      dotLineWidthActive: "24px",
      arrowColor: "#eee"
    };
  }
  const carouselLight = {
    name: "Carousel",
    common: commonLight,
    self: self$_
  };
  const carouselLight$1 = carouselLight;
  function addDuplicateSlides(slides) {
    const {
      length
    } = slides;
    if (length > 1) {
      slides.push(duplicateSlide(slides[0], 0, "append"));
      slides.unshift(duplicateSlide(slides[length - 1], length - 1, "prepend"));
      return slides;
    }
    return slides;
  }
  function duplicateSlide(child, index, position) {
    return vue.cloneVNode(child, {
      // for patch
      key: `carousel-item-duplicate-${index}-${position}`
    });
  }
  function getDisplayIndex(current, length, duplicatedable) {
    if (length === 1)
      return 0;
    return !duplicatedable ? current : current === 0 ? length - 3 : current === length - 1 ? 0 : current - 1;
  }
  function getRealIndex(current, duplicatedable) {
    return !duplicatedable ? current : current + 1;
  }
  function getPrevIndex(current, length, duplicatedable) {
    if (current < 0)
      return null;
    return current === 0 ? duplicatedable ? length - 1 : null : current - 1;
  }
  function getNextIndex(current, length, duplicatedable) {
    if (current > length - 1)
      return null;
    return current === length - 1 ? duplicatedable ? 0 : null : current + 1;
  }
  function getDisplayTotalView(total, duplicatedable) {
    return duplicatedable && total > 3 ? total - 2 : total;
  }
  function isTouchEvent$1(e) {
    return window.TouchEvent && e instanceof window.TouchEvent;
  }
  function calculateSize(element, innerOnly) {
    let {
      offsetWidth: width,
      offsetHeight: height
    } = element;
    if (innerOnly) {
      const style2 = getComputedStyle(element);
      width = width - Number.parseFloat(style2.getPropertyValue("padding-left")) - Number.parseFloat(style2.getPropertyValue("padding-right"));
      height = height - Number.parseFloat(style2.getPropertyValue("padding-top")) - Number.parseFloat(style2.getPropertyValue("padding-bottom"));
    }
    return {
      width,
      height
    };
  }
  function clampValue(value, min, max) {
    return value < min ? min : value > max ? max : value;
  }
  function resolveSpeed(value) {
    if (value === void 0)
      return 0;
    if (typeof value === "number")
      return value;
    const timeRE = /^((\d+)?\.?\d+?)(ms|s)?$/;
    const match2 = value.match(timeRE);
    if (match2) {
      const [, number, , unit = "ms"] = match2;
      return Number(number) * (unit === "ms" ? 1 : 1e3);
    }
    return 0;
  }
  const carouselMethodsInjectionKey = createInjectionKey("n-carousel-methods");
  function provideCarouselContext(contextValue) {
    vue.provide(carouselMethodsInjectionKey, contextValue);
  }
  function useCarouselContext(location = "unknown", component = "component") {
    const CarouselContext = vue.inject(carouselMethodsInjectionKey);
    if (!CarouselContext) {
      throwError(location, `\`${component}\` must be placed inside \`n-carousel\`.`);
    }
    return CarouselContext;
  }
  const carouselDotsProps = {
    total: {
      type: Number,
      default: 0
    },
    currentIndex: {
      type: Number,
      default: 0
    },
    dotType: {
      type: String,
      default: "dot"
    },
    trigger: {
      type: String,
      default: "click"
    },
    keyboard: Boolean
  };
  const NCarouselDots = vue.defineComponent({
    name: "CarouselDots",
    props: carouselDotsProps,
    setup(props) {
      const {
        mergedClsPrefixRef
      } = useConfig(props);
      const dotElsRef = vue.ref([]);
      const NCarousel = useCarouselContext();
      function handleKeydown(e, current) {
        switch (e.key) {
          case "Enter":
          case " ":
            e.preventDefault();
            NCarousel.to(current);
            return;
        }
        if (props.keyboard) {
          handleKeyboard(e);
        }
      }
      function handleMouseenter(current) {
        if (props.trigger === "hover") {
          NCarousel.to(current);
        }
      }
      function handleClick2(current) {
        if (props.trigger === "click") {
          NCarousel.to(current);
        }
      }
      function handleKeyboard(e) {
        var _a;
        if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
          return;
        }
        const nodeName = (_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase();
        if (nodeName === "input" || nodeName === "textarea") {
          return;
        }
        const {
          code: keycode
        } = e;
        const isVerticalNext = keycode === "PageUp" || keycode === "ArrowUp";
        const isVerticalPrev = keycode === "PageDown" || keycode === "ArrowDown";
        const isHorizontalNext = keycode === "PageUp" || keycode === "ArrowRight";
        const isHorizontalPrev = keycode === "PageDown" || keycode === "ArrowLeft";
        const vertical = NCarousel.isVertical();
        const wantToNext = vertical ? isVerticalNext : isHorizontalNext;
        const wantToPrev = vertical ? isVerticalPrev : isHorizontalPrev;
        if (!wantToNext && !wantToPrev) {
          return;
        }
        e.preventDefault();
        if (wantToNext && !NCarousel.isNextDisabled()) {
          NCarousel.next();
          focusDot(NCarousel.currentIndexRef.value);
        } else if (wantToPrev && !NCarousel.isPrevDisabled()) {
          NCarousel.prev();
          focusDot(NCarousel.currentIndexRef.value);
        }
      }
      function focusDot(index) {
        var _a;
        (_a = dotElsRef.value[index]) === null || _a === void 0 ? void 0 : _a.focus();
      }
      vue.onBeforeUpdate(() => dotElsRef.value.length = 0);
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        dotEls: dotElsRef,
        handleKeydown,
        handleMouseenter,
        handleClick: handleClick2
      };
    },
    render() {
      const {
        mergedClsPrefix,
        dotEls
      } = this;
      return vue.h("div", {
        class: [`${mergedClsPrefix}-carousel__dots`, `${mergedClsPrefix}-carousel__dots--${this.dotType}`],
        role: "tablist"
      }, indexMap(this.total, (i) => {
        const selected = i === this.currentIndex;
        return vue.h("div", {
          "aria-selected": selected,
          ref: (el) => dotEls.push(el),
          role: "button",
          tabindex: "0",
          class: [`${mergedClsPrefix}-carousel__dot`, selected && `${mergedClsPrefix}-carousel__dot--active`],
          key: i,
          onClick: () => {
            this.handleClick(i);
          },
          onMouseenter: () => {
            this.handleMouseenter(i);
          },
          onKeydown: (e) => {
            this.handleKeydown(e, i);
          }
        });
      }));
    }
  });
  const backwardIcon = vue.h("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 16 16"
  }, vue.h("g", {
    fill: "none"
  }, vue.h("path", {
    d: "M10.26 3.2a.75.75 0 0 1 .04 1.06L6.773 8l3.527 3.74a.75.75 0 1 1-1.1 1.02l-4-4.25a.75.75 0 0 1 0-1.02l4-4.25a.75.75 0 0 1 1.06-.04z",
    fill: "currentColor"
  })));
  const forwardIcon = vue.h("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 16 16"
  }, vue.h("g", {
    fill: "none"
  }, vue.h("path", {
    d: "M5.74 3.2a.75.75 0 0 0-.04 1.06L9.227 8L5.7 11.74a.75.75 0 1 0 1.1 1.02l4-4.25a.75.75 0 0 0 0-1.02l-4-4.25a.75.75 0 0 0-1.06-.04z",
    fill: "currentColor"
  })));
  const NCarouselArrow = vue.defineComponent({
    name: "CarouselArrow",
    setup(props) {
      const {
        mergedClsPrefixRef
      } = useConfig(props);
      const {
        isVertical,
        isPrevDisabled,
        isNextDisabled,
        prev,
        next
      } = useCarouselContext();
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        isVertical,
        isPrevDisabled,
        isNextDisabled,
        prev,
        next
      };
    },
    render() {
      const {
        mergedClsPrefix
      } = this;
      return vue.h("div", {
        class: `${mergedClsPrefix}-carousel__arrow-group`
      }, vue.h("div", {
        class: [`${mergedClsPrefix}-carousel__arrow`, this.isPrevDisabled() && `${mergedClsPrefix}-carousel__arrow--disabled`],
        role: "button",
        onClick: this.prev
      }, backwardIcon), vue.h("div", {
        class: [`${mergedClsPrefix}-carousel__arrow`, this.isNextDisabled() && `${mergedClsPrefix}-carousel__arrow--disabled`],
        role: "button",
        onClick: this.next
      }, forwardIcon));
    }
  });
  const CarouselItemName = "CarouselItem";
  function isCarouselItem(child) {
    var _a;
    return ((_a = child.type) === null || _a === void 0 ? void 0 : _a.name) === CarouselItemName;
  }
  const NCarouselItem = vue.defineComponent({
    name: CarouselItemName,
    setup(props) {
      const {
        mergedClsPrefixRef
      } = useConfig(props);
      const NCarousel = useCarouselContext(camelCase(CarouselItemName), `n-${camelCase(CarouselItemName)}`);
      const selfElRef = vue.ref();
      const indexRef = vue.computed(() => {
        const {
          value: selfEl
        } = selfElRef;
        return selfEl ? NCarousel.getSlideIndex(selfEl) : -1;
      });
      const isPrevRef = vue.computed(() => NCarousel.isPrev(indexRef.value));
      const isNextRef = vue.computed(() => NCarousel.isNext(indexRef.value));
      const isActiveRef = vue.computed(() => NCarousel.isActive(indexRef.value));
      const styleRef = vue.computed(() => NCarousel.getSlideStyle(indexRef.value));
      vue.onMounted(() => {
        NCarousel.addSlide(selfElRef.value);
      });
      vue.onBeforeUnmount(() => {
        NCarousel.removeSlide(selfElRef.value);
      });
      function handleClick2(event) {
        const {
          value: index
        } = indexRef;
        if (index !== void 0) {
          NCarousel === null || NCarousel === void 0 ? void 0 : NCarousel.onCarouselItemClick(index, event);
        }
      }
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        selfElRef,
        isPrev: isPrevRef,
        isNext: isNextRef,
        isActive: isActiveRef,
        index: indexRef,
        style: styleRef,
        handleClick: handleClick2
      };
    },
    render() {
      var _a;
      const {
        $slots: slots,
        mergedClsPrefix,
        isPrev,
        isNext,
        isActive,
        index,
        style: style2
      } = this;
      const className = [`${mergedClsPrefix}-carousel__slide`, {
        [`${mergedClsPrefix}-carousel__slide--current`]: isActive,
        [`${mergedClsPrefix}-carousel__slide--prev`]: isPrev,
        [`${mergedClsPrefix}-carousel__slide--next`]: isNext
      }];
      return vue.h("div", {
        ref: "selfElRef",
        class: className,
        role: "option",
        tabindex: "-1",
        "data-index": index,
        "aria-hidden": !isActive,
        style: style2,
        // We use ts-ignore for vue-tsc, since it seems to patch native event
        // for vue components
        // @ts-expect-error vue's tsx has type for capture events
        onClickCapture: this.handleClick
      }, (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots, {
        isPrev,
        isNext,
        isActive,
        index
      }));
    }
  });
  const style$19 = cB("carousel", `
 position: relative;
 width: 100%;
 height: 100%;
 touch-action: pan-y;
 overflow: hidden;
`, [cE("slides", `
 display: flex;
 width: 100%;
 height: 100%;
 transition-timing-function: var(--n-bezier);
 transition-property: transform;
 `, [cE("slide", `
 flex-shrink: 0;
 position: relative;
 width: 100%;
 height: 100%;
 outline: none;
 overflow: hidden;
 `, [c$1("> img", `
 display: block;
 `)])]), cE("dots", `
 position: absolute;
 display: flex;
 flex-wrap: nowrap;
 `, [cM("dot", [cE("dot", `
 height: var(--n-dot-size);
 width: var(--n-dot-size);
 background-color: var(--n-dot-color);
 border-radius: 50%;
 cursor: pointer;
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 outline: none;
 `, [c$1("&:focus", `
 background-color: var(--n-dot-color-focus);
 `), cM("active", `
 background-color: var(--n-dot-color-active);
 `)])]), cM("line", [cE("dot", `
 border-radius: 9999px;
 width: var(--n-dot-line-width);
 height: 4px;
 background-color: var(--n-dot-color);
 cursor: pointer;
 transition:
 width .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 outline: none;
 `, [c$1("&:focus", `
 background-color: var(--n-dot-color-focus);
 `), cM("active", `
 width: var(--n-dot-line-width-active);
 background-color: var(--n-dot-color-active);
 `)])])]), cE("arrow", `
 transition: background-color .3s var(--n-bezier);
 cursor: pointer;
 height: 28px;
 width: 28px;
 display: flex;
 align-items: center;
 justify-content: center;
 background-color: rgba(255, 255, 255, .2);
 color: var(--n-arrow-color);
 border-radius: 8px;
 user-select: none;
 -webkit-user-select: none;
 font-size: 18px;
 `, [c$1("svg", `
 height: 1em;
 width: 1em;
 `), c$1("&:hover", `
 background-color: rgba(255, 255, 255, .3);
 `)]), cM("vertical", `
 touch-action: pan-x;
 `, [cE("slides", `
 flex-direction: column;
 `), cM("fade", [cE("slide", `
 top: 50%;
 left: unset;
 transform: translateY(-50%);
 `)]), cM("card", [cE("slide", `
 top: 50%;
 left: unset;
 transform: translateY(-50%) translateZ(-400px);
 `, [cM("current", `
 transform: translateY(-50%) translateZ(0);
 `), cM("prev", `
 transform: translateY(-100%) translateZ(-200px);
 `), cM("next", `
 transform: translateY(0%) translateZ(-200px);
 `)])])]), cM("usercontrol", [cE("slides", [c$1(">", [c$1("div", `
 position: absolute;
 top: 50%;
 left: 50%;
 width: 100%;
 height: 100%;
 transform: translate(-50%, -50%);
 `)])])]), cM("left", [cE("dots", `
 transform: translateY(-50%);
 top: 50%;
 left: 12px;
 flex-direction: column;
 `, [cM("line", [cE("dot", `
 width: 4px;
 height: var(--n-dot-line-width);
 margin: 4px 0;
 transition:
 height .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 outline: none;
 `, [cM("active", `
 height: var(--n-dot-line-width-active);
 `)])])]), cE("dot", `
 margin: 4px 0;
 `)]), cE("arrow-group", `
 position: absolute;
 display: flex;
 flex-wrap: nowrap;
 `), cM("vertical", [cE("arrow", `
 transform: rotate(90deg);
 `)]), cM("show-arrow", [cM("bottom", [cE("dots", `
 transform: translateX(0);
 bottom: 18px;
 left: 18px;
 `)]), cM("top", [cE("dots", `
 transform: translateX(0);
 top: 18px;
 left: 18px;
 `)]), cM("left", [cE("dots", `
 transform: translateX(0);
 top: 18px;
 left: 18px;
 `)]), cM("right", [cE("dots", `
 transform: translateX(0);
 top: 18px;
 right: 18px;
 `)])]), cM("left", [cE("arrow-group", `
 bottom: 12px;
 left: 12px;
 flex-direction: column;
 `, [c$1("> *:first-child", `
 margin-bottom: 12px;
 `)])]), cM("right", [cE("dots", `
 transform: translateY(-50%);
 top: 50%;
 right: 12px;
 flex-direction: column;
 `, [cM("line", [cE("dot", `
 width: 4px;
 height: var(--n-dot-line-width);
 margin: 4px 0;
 transition:
 height .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 outline: none;
 `, [cM("active", `
 height: var(--n-dot-line-width-active);
 `)])])]), cE("dot", `
 margin: 4px 0;
 `), cE("arrow-group", `
 bottom: 12px;
 right: 12px;
 flex-direction: column;
 `, [c$1("> *:first-child", `
 margin-bottom: 12px;
 `)])]), cM("top", [cE("dots", `
 transform: translateX(-50%);
 top: 12px;
 left: 50%;
 `, [cM("line", [cE("dot", `
 margin: 0 4px;
 `)])]), cE("dot", `
 margin: 0 4px;
 `), cE("arrow-group", `
 top: 12px;
 right: 12px;
 `, [c$1("> *:first-child", `
 margin-right: 12px;
 `)])]), cM("bottom", [cE("dots", `
 transform: translateX(-50%);
 bottom: 12px;
 left: 50%;
 `, [cM("line", [cE("dot", `
 margin: 0 4px;
 `)])]), cE("dot", `
 margin: 0 4px;
 `), cE("arrow-group", `
 bottom: 12px;
 right: 12px;
 `, [c$1("> *:first-child", `
 margin-right: 12px;
 `)])]), cM("fade", [cE("slide", `
 position: absolute;
 opacity: 0;
 transition-property: opacity;
 pointer-events: none;
 `, [cM("current", `
 opacity: 1;
 pointer-events: auto;
 `)])]), cM("card", [cE("slides", `
 perspective: 1000px;
 `), cE("slide", `
 position: absolute;
 left: 50%;
 opacity: 0;
 transform: translateX(-50%) translateZ(-400px);
 transition-property: opacity, transform;
 `, [cM("current", `
 opacity: 1;
 transform: translateX(-50%) translateZ(0);
 z-index: 1;
 `), cM("prev", `
 opacity: 0.4;
 transform: translateX(-100%) translateZ(-200px);
 `), cM("next", `
 opacity: 0.4;
 transform: translateX(0%) translateZ(-200px);
 `)])])]);
  const transitionProperties = ["transitionDuration", "transitionTimingFunction"];
  const carouselProps = Object.assign(Object.assign({}, useTheme.props), {
    defaultIndex: {
      type: Number,
      default: 0
    },
    currentIndex: Number,
    showArrow: Boolean,
    dotType: {
      type: String,
      default: "dot"
    },
    dotPlacement: {
      type: String,
      default: "bottom"
    },
    slidesPerView: {
      type: [Number, String],
      default: 1
    },
    spaceBetween: {
      type: Number,
      default: 0
    },
    centeredSlides: Boolean,
    direction: {
      type: String,
      default: "horizontal"
    },
    autoplay: Boolean,
    interval: {
      type: Number,
      default: 5e3
    },
    loop: {
      type: Boolean,
      default: true
    },
    effect: {
      type: String,
      default: "slide"
    },
    showDots: {
      type: Boolean,
      default: true
    },
    trigger: {
      type: String,
      default: "click"
    },
    transitionStyle: {
      type: Object,
      default: () => ({
        transitionDuration: "300ms"
      })
    },
    transitionProps: Object,
    draggable: Boolean,
    prevSlideStyle: [Object, String],
    nextSlideStyle: [Object, String],
    touchable: {
      type: Boolean,
      default: true
    },
    mousewheel: Boolean,
    keyboard: Boolean,
    "onUpdate:currentIndex": Function,
    onUpdateCurrentIndex: Function
  });
  let globalDragging = false;
  const Carousel = vue.defineComponent({
    name: "Carousel",
    props: carouselProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const selfElRef = vue.ref(null);
      const slidesElRef = vue.ref(null);
      const slideElsRef = vue.ref([]);
      const slideVNodesRef = {
        value: []
      };
      const verticalRef = vue.computed(() => props.direction === "vertical");
      const sizeAxisRef = vue.computed(() => verticalRef.value ? "height" : "width");
      const spaceAxisRef = vue.computed(() => verticalRef.value ? "bottom" : "right");
      const sequenceLayoutRef = vue.computed(() => props.effect === "slide");
      const duplicatedableRef = vue.computed(
        // duplicate the copy operation in `slide` mode,
        // because only its DOM is sequence layout
        () => props.loop && props.slidesPerView === 1 && sequenceLayoutRef.value
      );
      const userWantsControlRef = vue.computed(() => props.effect === "custom");
      const displaySlidesPerViewRef = vue.computed(() => !sequenceLayoutRef.value || props.centeredSlides ? 1 : props.slidesPerView);
      const realSlidesPerViewRef = vue.computed(() => userWantsControlRef.value ? 1 : props.slidesPerView);
      const autoSlideSizeRef = vue.computed(() => displaySlidesPerViewRef.value === "auto" || props.slidesPerView === "auto" && props.centeredSlides);
      const perViewSizeRef = vue.ref({
        width: 0,
        height: 0
      });
      const slideSizesRef = vue.computed(() => {
        const {
          value: slidesEls
        } = slideElsRef;
        if (!slidesEls.length)
          return [];
        const {
          value: autoSlideSize
        } = autoSlideSizeRef;
        if (autoSlideSize) {
          return slidesEls.map((slide) => calculateSize(slide));
        }
        const {
          value: slidesPerView
        } = realSlidesPerViewRef;
        const {
          value: perViewSize
        } = perViewSizeRef;
        const {
          value: axis
        } = sizeAxisRef;
        let axisSize = perViewSize[axis];
        if (slidesPerView !== "auto") {
          const {
            spaceBetween
          } = props;
          const remaining = axisSize - (slidesPerView - 1) * spaceBetween;
          const percentage = 1 / Math.max(1, slidesPerView);
          axisSize = remaining * percentage;
        }
        const slideSize = Object.assign(Object.assign({}, perViewSize), {
          [axis]: axisSize
        });
        return slidesEls.map(() => slideSize);
      });
      const slideTranlatesRef = vue.computed(() => {
        const {
          value: slideSizes
        } = slideSizesRef;
        if (!slideSizes.length)
          return [];
        const {
          centeredSlides,
          spaceBetween
        } = props;
        const {
          value: axis
        } = sizeAxisRef;
        const {
          [axis]: perViewSize
        } = perViewSizeRef.value;
        let previousTranslate2 = 0;
        return slideSizes.map(({
          [axis]: slideSize
        }) => {
          let translate = previousTranslate2;
          if (centeredSlides) {
            translate += (slideSize - perViewSize) / 2;
          }
          previousTranslate2 += slideSize + spaceBetween;
          return translate;
        });
      });
      const isMountedRef = vue.ref(false);
      const transitionStyleRef = vue.computed(() => {
        const {
          transitionStyle
        } = props;
        return transitionStyle ? keep(transitionStyle, transitionProperties) : {};
      });
      const speedRef = vue.computed(() => userWantsControlRef.value ? 0 : resolveSpeed(transitionStyleRef.value.transitionDuration));
      const slideStylesRef = vue.computed(() => {
        const {
          value: slidesEls
        } = slideElsRef;
        if (!slidesEls.length)
          return [];
        const useComputedSize = !(autoSlideSizeRef.value || realSlidesPerViewRef.value === 1);
        const getSlideSize = (index) => {
          if (useComputedSize) {
            const {
              value: axis
            } = sizeAxisRef;
            return {
              [axis]: `${slideSizesRef.value[index][axis]}px`
            };
          }
        };
        if (userWantsControlRef.value) {
          return slidesEls.map((_, i) => getSlideSize(i));
        }
        const {
          effect,
          spaceBetween
        } = props;
        const {
          value: spaceAxis
        } = spaceAxisRef;
        return slidesEls.reduce((styles2, _, i) => {
          const style2 = Object.assign(Object.assign({}, getSlideSize(i)), {
            [`margin-${spaceAxis}`]: `${spaceBetween}px`
          });
          styles2.push(style2);
          if (isMountedRef.value && (effect === "fade" || effect === "card")) {
            Object.assign(style2, transitionStyleRef.value);
          }
          return styles2;
        }, []);
      });
      const totalViewRef = vue.computed(() => {
        const {
          value: slidesPerView
        } = displaySlidesPerViewRef;
        const {
          length: totalSlides
        } = slideElsRef.value;
        if (slidesPerView !== "auto") {
          return Math.max(totalSlides - slidesPerView, 0) + 1;
        } else {
          const {
            value: slideSizes
          } = slideSizesRef;
          const {
            length
          } = slideSizes;
          if (!length)
            return totalSlides;
          const {
            value: translates
          } = slideTranlatesRef;
          const {
            value: axis
          } = sizeAxisRef;
          const perViewSize = perViewSizeRef.value[axis];
          let lastViewSize = slideSizes[slideSizes.length - 1][axis];
          let i = length;
          while (i > 1 && lastViewSize < perViewSize) {
            i--;
            lastViewSize += translates[i] - translates[i - 1];
          }
          return clampValue(i + 1, 1, length);
        }
      });
      const displayTotalViewRef = vue.computed(() => getDisplayTotalView(totalViewRef.value, duplicatedableRef.value));
      const defaultRealIndex = getRealIndex(props.defaultIndex, duplicatedableRef.value);
      const uncontrolledDisplayIndexRef = vue.ref(getDisplayIndex(defaultRealIndex, totalViewRef.value, duplicatedableRef.value));
      const mergedDisplayIndexRef = useMergedState(vue.toRef(props, "currentIndex"), uncontrolledDisplayIndexRef);
      const realIndexRef = vue.computed(() => getRealIndex(mergedDisplayIndexRef.value, duplicatedableRef.value));
      function toRealIndex(index) {
        var _a, _b;
        index = clampValue(index, 0, totalViewRef.value - 1);
        const displayIndex = getDisplayIndex(index, totalViewRef.value, duplicatedableRef.value);
        const {
          value: lastDisplayIndex
        } = mergedDisplayIndexRef;
        if (displayIndex !== mergedDisplayIndexRef.value) {
          uncontrolledDisplayIndexRef.value = displayIndex;
          (_a = props["onUpdate:currentIndex"]) === null || _a === void 0 ? void 0 : _a.call(props, displayIndex, lastDisplayIndex);
          (_b = props.onUpdateCurrentIndex) === null || _b === void 0 ? void 0 : _b.call(props, displayIndex, lastDisplayIndex);
        }
      }
      function getRealPrevIndex(index = realIndexRef.value) {
        return getPrevIndex(index, totalViewRef.value, props.loop);
      }
      function getRealNextIndex(index = realIndexRef.value) {
        return getNextIndex(index, totalViewRef.value, props.loop);
      }
      function isRealPrev(slideOrIndex) {
        const index = getSlideIndex(slideOrIndex);
        return index !== null && getRealPrevIndex() === index;
      }
      function isRealNext(slideOrIndex) {
        const index = getSlideIndex(slideOrIndex);
        return index !== null && getRealNextIndex() === index;
      }
      function isRealActive(slideOrIndex) {
        return realIndexRef.value === getSlideIndex(slideOrIndex);
      }
      function isDisplayActive(index) {
        return mergedDisplayIndexRef.value === index;
      }
      function isPrevDisabled() {
        return getRealPrevIndex() === null;
      }
      function isNextDisabled() {
        return getRealNextIndex() === null;
      }
      let expectedTransitionDirection = 0;
      function to(index) {
        const realIndex = clampValue(getRealIndex(index, duplicatedableRef.value), 0, totalViewRef.value);
        if (index !== mergedDisplayIndexRef.value || realIndex !== realIndexRef.value) {
          toRealIndex(realIndex);
        }
      }
      function prev() {
        const prevIndex = getRealPrevIndex();
        if (prevIndex !== null) {
          expectedTransitionDirection = -1;
          toRealIndex(prevIndex);
        }
      }
      function next() {
        const nextIndex = getRealNextIndex();
        if (nextIndex !== null) {
          expectedTransitionDirection = 1;
          toRealIndex(nextIndex);
        }
      }
      let inTransition = false;
      function prevIfSlideTransitionEnd() {
        if (!inTransition || !duplicatedableRef.value)
          prev();
      }
      function nextIfSlideTransitionEnd() {
        if (!inTransition || !duplicatedableRef.value)
          next();
      }
      let previousTranslate = 0;
      const translateStyleRef = vue.ref({});
      function updateTranslate(translate, speed = 0) {
        translateStyleRef.value = Object.assign({}, transitionStyleRef.value, {
          transform: verticalRef.value ? `translateY(${-translate}px)` : `translateX(${-translate}px)`,
          transitionDuration: `${speed}ms`
        });
      }
      function fixTranslate(speed = 0) {
        if (sequenceLayoutRef.value) {
          translateTo(realIndexRef.value, speed);
        } else if (previousTranslate !== 0) {
          if (!inTransition && speed > 0) {
            inTransition = true;
          }
          updateTranslate(previousTranslate = 0, speed);
        }
      }
      function translateTo(index, speed) {
        const translate = getTranslate(index);
        if (translate !== previousTranslate && speed > 0) {
          inTransition = true;
        }
        previousTranslate = getTranslate(realIndexRef.value);
        updateTranslate(translate, speed);
      }
      function getTranslate(index) {
        let translate;
        if (index >= totalViewRef.value - 1) {
          translate = getLastViewTranslate();
        } else {
          translate = slideTranlatesRef.value[index] || 0;
        }
        return translate;
      }
      function getLastViewTranslate() {
        if (displaySlidesPerViewRef.value === "auto") {
          const {
            value: axis
          } = sizeAxisRef;
          const {
            [axis]: perViewSize
          } = perViewSizeRef.value;
          const {
            value: translates
          } = slideTranlatesRef;
          const lastTranslate = translates[translates.length - 1];
          let overallSize;
          if (lastTranslate === void 0) {
            overallSize = perViewSize;
          } else {
            const {
              value: slideSizes
            } = slideSizesRef;
            overallSize = lastTranslate + slideSizes[slideSizes.length - 1][axis];
          }
          return overallSize - perViewSize;
        } else {
          const {
            value: translates
          } = slideTranlatesRef;
          return translates[totalViewRef.value - 1] || 0;
        }
      }
      const carouselContext = {
        currentIndexRef: mergedDisplayIndexRef,
        to,
        prev: prevIfSlideTransitionEnd,
        next: nextIfSlideTransitionEnd,
        isVertical: () => verticalRef.value,
        isHorizontal: () => !verticalRef.value,
        isPrev: isRealPrev,
        isNext: isRealNext,
        isActive: isRealActive,
        isPrevDisabled,
        isNextDisabled,
        getSlideIndex,
        getSlideStyle,
        addSlide,
        removeSlide,
        onCarouselItemClick
      };
      provideCarouselContext(carouselContext);
      function addSlide(slide) {
        if (!slide)
          return;
        slideElsRef.value.push(slide);
      }
      function removeSlide(slide) {
        if (!slide)
          return;
        const index = getSlideIndex(slide);
        if (index !== -1) {
          slideElsRef.value.splice(index, 1);
        }
      }
      function getSlideIndex(slideOrIndex) {
        return typeof slideOrIndex === "number" ? slideOrIndex : slideOrIndex ? slideElsRef.value.indexOf(slideOrIndex) : -1;
      }
      function getSlideStyle(slide) {
        const index = getSlideIndex(slide);
        if (index !== -1) {
          const styles2 = [slideStylesRef.value[index]];
          const isPrev = carouselContext.isPrev(index);
          const isNext = carouselContext.isNext(index);
          if (isPrev) {
            styles2.push(props.prevSlideStyle || "");
          }
          if (isNext) {
            styles2.push(props.nextSlideStyle || "");
          }
          return vue.normalizeStyle(styles2);
        }
      }
      let dragStartX = 0;
      let dragStartY = 0;
      let dragOffset = 0;
      let dragStartTime = 0;
      let dragging = false;
      let isEffectiveDrag = false;
      function onCarouselItemClick(index, event) {
        let allowClick = !inTransition && !dragging && !isEffectiveDrag;
        if (props.effect === "card" && allowClick && !isRealActive(index)) {
          to(index);
          allowClick = false;
        }
        if (!allowClick) {
          event.preventDefault();
          event.stopPropagation();
        }
      }
      let autoplayTimer = null;
      function stopAutoplay() {
        if (autoplayTimer) {
          clearInterval(autoplayTimer);
          autoplayTimer = null;
        }
      }
      function resetAutoplay() {
        stopAutoplay();
        const disabled = !props.autoplay || displayTotalViewRef.value < 2;
        if (!disabled) {
          autoplayTimer = window.setInterval(next, props.interval);
        }
      }
      function handleTouchstart(event) {
        var _a;
        if (globalDragging)
          return;
        if (!((_a = slidesElRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(event)))) {
          return;
        }
        globalDragging = true;
        dragging = true;
        isEffectiveDrag = false;
        dragStartTime = Date.now();
        stopAutoplay();
        if (event.type !== "touchstart" && !event.target.isContentEditable) {
          event.preventDefault();
        }
        const touchEvent = isTouchEvent$1(event) ? event.touches[0] : event;
        if (verticalRef.value) {
          dragStartY = touchEvent.clientY;
        } else {
          dragStartX = touchEvent.clientX;
        }
        if (props.touchable) {
          on("touchmove", document, handleTouchmove);
          on("touchend", document, handleTouchend);
          on("touchcancel", document, handleTouchend);
        }
        if (props.draggable) {
          on("mousemove", document, handleTouchmove);
          on("mouseup", document, handleTouchend);
        }
      }
      function handleTouchmove(event) {
        const {
          value: vertical
        } = verticalRef;
        const {
          value: axis
        } = sizeAxisRef;
        const touchEvent = isTouchEvent$1(event) ? event.touches[0] : event;
        const offset = vertical ? touchEvent.clientY - dragStartY : touchEvent.clientX - dragStartX;
        const perViewSize = perViewSizeRef.value[axis];
        dragOffset = clampValue(offset, -perViewSize, perViewSize);
        if (event.cancelable) {
          event.preventDefault();
        }
        if (sequenceLayoutRef.value) {
          updateTranslate(previousTranslate - dragOffset, 0);
        }
      }
      function handleTouchend() {
        const {
          value: realIndex
        } = realIndexRef;
        let currentIndex = realIndex;
        if (!inTransition && dragOffset !== 0 && sequenceLayoutRef.value) {
          const currentTranslate = previousTranslate - dragOffset;
          const translates = [...slideTranlatesRef.value.slice(0, totalViewRef.value - 1), getLastViewTranslate()];
          let prevOffset = null;
          for (let i = 0; i < translates.length; i++) {
            const offset = Math.abs(translates[i] - currentTranslate);
            if (prevOffset !== null && prevOffset < offset) {
              break;
            }
            prevOffset = offset;
            currentIndex = i;
          }
        }
        if (currentIndex === realIndex) {
          const timeElapsed = Date.now() - dragStartTime;
          const {
            value: axis
          } = sizeAxisRef;
          const perViewSize = perViewSizeRef.value[axis];
          if (dragOffset > perViewSize / 2 || dragOffset / timeElapsed > 0.4) {
            prev();
          } else if (dragOffset < -perViewSize / 2 || dragOffset / timeElapsed < -0.4) {
            next();
          }
        }
        if (currentIndex !== null && currentIndex !== realIndex) {
          isEffectiveDrag = true;
          toRealIndex(currentIndex);
          void vue.nextTick(() => {
            if (!duplicatedableRef.value || uncontrolledDisplayIndexRef.value !== mergedDisplayIndexRef.value) {
              fixTranslate(speedRef.value);
            }
          });
        } else {
          fixTranslate(speedRef.value);
        }
        resetDragStatus();
        resetAutoplay();
      }
      function resetDragStatus() {
        if (dragging) {
          globalDragging = false;
        }
        dragging = false;
        dragStartX = 0;
        dragStartY = 0;
        dragOffset = 0;
        dragStartTime = 0;
        off("touchmove", document, handleTouchmove);
        off("touchend", document, handleTouchend);
        off("touchcancel", document, handleTouchend);
        off("mousemove", document, handleTouchmove);
        off("mouseup", document, handleTouchend);
      }
      function handleTransitionEnd() {
        if (sequenceLayoutRef.value && inTransition) {
          const {
            value: realIndex
          } = realIndexRef;
          translateTo(realIndex, 0);
        } else {
          resetAutoplay();
        }
        if (sequenceLayoutRef.value) {
          translateStyleRef.value.transitionDuration = "0ms";
        }
        inTransition = false;
      }
      function handleMousewheel(event) {
        event.preventDefault();
        if (inTransition)
          return;
        let {
          deltaX,
          deltaY
        } = event;
        if (event.shiftKey && !deltaX) {
          deltaX = deltaY;
        }
        const prevMultiplier = -1;
        const nextMultiplier = 1;
        const m = (deltaX || deltaY) > 0 ? nextMultiplier : prevMultiplier;
        let rx = 0;
        let ry = 0;
        if (verticalRef.value) {
          ry = m;
        } else {
          rx = m;
        }
        const responseStep = 10;
        if (ry * deltaY >= responseStep || rx * deltaX >= responseStep) {
          if (m === nextMultiplier && !isNextDisabled()) {
            next();
          } else if (m === prevMultiplier && !isPrevDisabled()) {
            prev();
          }
        }
      }
      function handleResize() {
        perViewSizeRef.value = calculateSize(selfElRef.value, true);
        resetAutoplay();
      }
      function handleSlideResize() {
        var _a, _b;
        if (autoSlideSizeRef.value) {
          (_b = (_a = slideSizesRef.effect).scheduler) === null || _b === void 0 ? void 0 : _b.call(_a);
          slideSizesRef.effect.run();
        }
      }
      function handleMouseenter() {
        if (props.autoplay) {
          stopAutoplay();
        }
      }
      function handleMouseleave() {
        if (props.autoplay) {
          resetAutoplay();
        }
      }
      vue.onMounted(() => {
        vue.watchEffect(resetAutoplay);
        requestAnimationFrame(() => isMountedRef.value = true);
      });
      vue.onBeforeUnmount(() => {
        resetDragStatus();
        stopAutoplay();
      });
      vue.onUpdated(() => {
        const {
          value: slidesEls
        } = slideElsRef;
        const {
          value: slideVNodes
        } = slideVNodesRef;
        const indexMap2 = /* @__PURE__ */ new Map();
        const getDisplayIndex2 = (el) => indexMap2.has(el) ? indexMap2.get(el) : -1;
        let isChanged = false;
        for (let i = 0; i < slidesEls.length; i++) {
          const index = slideVNodes.findIndex((v) => v.el === slidesEls[i]);
          if (index !== i) {
            isChanged = true;
          }
          indexMap2.set(slidesEls[i], index);
        }
        if (isChanged) {
          slidesEls.sort((a2, b) => getDisplayIndex2(a2) - getDisplayIndex2(b));
        }
      });
      vue.watch(realIndexRef, (nextRealIndex, lastRealIndex) => {
        if (nextRealIndex === lastRealIndex) {
          expectedTransitionDirection = 0;
          return;
        }
        resetAutoplay();
        if (sequenceLayoutRef.value) {
          if (duplicatedableRef.value) {
            const {
              value: length
            } = totalViewRef;
            if (expectedTransitionDirection === -1 && lastRealIndex === 1 && nextRealIndex === length - 2) {
              nextRealIndex = 0;
            } else if (expectedTransitionDirection === 1 && lastRealIndex === length - 2 && nextRealIndex === 1) {
              nextRealIndex = length - 1;
            }
          }
          translateTo(nextRealIndex, speedRef.value);
        } else {
          fixTranslate();
        }
        expectedTransitionDirection = 0;
      }, {
        immediate: true
      });
      vue.watch([duplicatedableRef, displaySlidesPerViewRef], () => void vue.nextTick(() => {
        toRealIndex(realIndexRef.value);
      }));
      vue.watch(slideTranlatesRef, () => {
        if (sequenceLayoutRef.value) {
          fixTranslate();
        }
      }, {
        deep: true
      });
      vue.watch(sequenceLayoutRef, (value) => {
        if (!value) {
          inTransition = false;
          updateTranslate(previousTranslate = 0);
        } else {
          fixTranslate();
        }
      });
      const slidesControlListenersRef = vue.computed(() => {
        return {
          onTouchstartPassive: props.touchable ? handleTouchstart : void 0,
          onMousedown: props.draggable ? handleTouchstart : void 0,
          onWheel: props.mousewheel ? handleMousewheel : void 0
        };
      });
      const arrowSlotPropsRef = vue.computed(() => Object.assign(Object.assign({}, keep(carouselContext, ["to", "prev", "next", "isPrevDisabled", "isNextDisabled"])), {
        total: displayTotalViewRef.value,
        currentIndex: mergedDisplayIndexRef.value
      }));
      const dotSlotPropsRef = vue.computed(() => ({
        total: displayTotalViewRef.value,
        currentIndex: mergedDisplayIndexRef.value,
        to: carouselContext.to
      }));
      const caroulseExposedMethod = {
        getCurrentIndex: () => mergedDisplayIndexRef.value,
        to,
        prev,
        next
      };
      const themeRef = useTheme("Carousel", "-carousel", style$19, carouselLight$1, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            dotSize,
            dotColor,
            dotColorActive,
            dotColorFocus,
            dotLineWidth,
            dotLineWidthActive,
            arrowColor
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-dot-color": dotColor,
          "--n-dot-color-focus": dotColorFocus,
          "--n-dot-color-active": dotColorActive,
          "--n-dot-size": dotSize,
          "--n-dot-line-width": dotLineWidth,
          "--n-dot-line-width-active": dotLineWidthActive,
          "--n-arrow-color": arrowColor
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("carousel", void 0, cssVarsRef, props) : void 0;
      return Object.assign(Object.assign({
        mergedClsPrefix: mergedClsPrefixRef,
        selfElRef,
        slidesElRef,
        slideVNodes: slideVNodesRef,
        duplicatedable: duplicatedableRef,
        userWantsControl: userWantsControlRef,
        autoSlideSize: autoSlideSizeRef,
        realIndex: realIndexRef,
        slideStyles: slideStylesRef,
        translateStyle: translateStyleRef,
        slidesControlListeners: slidesControlListenersRef,
        handleTransitionEnd,
        handleResize,
        handleSlideResize,
        handleMouseenter,
        handleMouseleave,
        isActive: isDisplayActive,
        arrowSlotProps: arrowSlotPropsRef,
        dotSlotProps: dotSlotPropsRef
      }, caroulseExposedMethod), {
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      });
    },
    render() {
      var _a;
      const {
        mergedClsPrefix,
        showArrow,
        userWantsControl,
        slideStyles,
        dotType,
        dotPlacement,
        slidesControlListeners,
        transitionProps = {},
        arrowSlotProps,
        dotSlotProps,
        $slots: {
          default: defaultSlot,
          dots: dotsSlot,
          arrow: arrowSlot
        }
      } = this;
      const children = defaultSlot && flatten$3(defaultSlot()) || [];
      let slides = filterCarouselItem(children);
      if (!slides.length) {
        slides = children.map((ch) => vue.h(NCarouselItem, null, {
          default: () => vue.cloneVNode(ch)
        }));
      }
      if (this.duplicatedable) {
        slides = addDuplicateSlides(slides);
      }
      this.slideVNodes.value = slides;
      if (this.autoSlideSize) {
        slides = slides.map((slide) => vue.h(VResizeObserver, {
          onResize: this.handleSlideResize
        }, {
          default: () => slide
        }));
      }
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      return vue.h("div", Object.assign({
        ref: "selfElRef",
        class: [this.themeClass, `${mergedClsPrefix}-carousel`, this.direction === "vertical" && `${mergedClsPrefix}-carousel--vertical`, this.showArrow && `${mergedClsPrefix}-carousel--show-arrow`, `${mergedClsPrefix}-carousel--${dotPlacement}`, `${mergedClsPrefix}-carousel--${this.direction}`, `${mergedClsPrefix}-carousel--${this.effect}`, userWantsControl && `${mergedClsPrefix}-carousel--usercontrol`],
        style: this.cssVars
      }, slidesControlListeners, {
        onMouseenter: this.handleMouseenter,
        onMouseleave: this.handleMouseleave
      }), vue.h(VResizeObserver, {
        onResize: this.handleResize
      }, {
        default: () => vue.h("div", {
          ref: "slidesElRef",
          class: `${mergedClsPrefix}-carousel__slides`,
          role: "listbox",
          style: this.translateStyle,
          onTransitionend: this.handleTransitionEnd
        }, userWantsControl ? slides.map((slide, i) => vue.h("div", {
          style: slideStyles[i],
          key: i
        }, vue.withDirectives(vue.h(vue.Transition, Object.assign({}, transitionProps), {
          default: () => slide
        }), [[vue.vShow, this.isActive(i)]]))) : slides)
      }), this.showDots && dotSlotProps.total > 1 && resolveSlotWithProps(dotsSlot, dotSlotProps, () => [vue.h(NCarouselDots, {
        key: dotType + dotPlacement,
        total: dotSlotProps.total,
        currentIndex: dotSlotProps.currentIndex,
        dotType,
        trigger: this.trigger,
        keyboard: this.keyboard
      })]), showArrow && resolveSlotWithProps(arrowSlot, arrowSlotProps, () => [vue.h(NCarouselArrow, null)]));
    }
  });
  function filterCarouselItem(vnodes) {
    return vnodes.reduce((carouselItems, vnode) => {
      if (isCarouselItem(vnode)) {
        carouselItems.push(vnode);
      }
      return carouselItems;
    }, []);
  }
  const commonVariables$c = {
    sizeSmall: "14px",
    sizeMedium: "16px",
    sizeLarge: "18px",
    labelPadding: "0 8px",
    labelFontWeight: "400"
  };
  function self$Z(vars) {
    const {
      baseColor,
      inputColorDisabled,
      cardColor,
      modalColor,
      popoverColor,
      textColorDisabled,
      borderColor,
      primaryColor,
      textColor2,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      borderRadiusSmall,
      lineHeight: lineHeight2
    } = vars;
    return Object.assign(Object.assign({}, commonVariables$c), {
      labelLineHeight: lineHeight2,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      borderRadius: borderRadiusSmall,
      color: baseColor,
      colorChecked: primaryColor,
      colorDisabled: inputColorDisabled,
      colorDisabledChecked: inputColorDisabled,
      colorTableHeader: cardColor,
      colorTableHeaderModal: modalColor,
      colorTableHeaderPopover: popoverColor,
      checkMarkColor: baseColor,
      checkMarkColorDisabled: textColorDisabled,
      checkMarkColorDisabledChecked: textColorDisabled,
      border: `1px solid ${borderColor}`,
      borderDisabled: `1px solid ${borderColor}`,
      borderDisabledChecked: `1px solid ${borderColor}`,
      borderChecked: `1px solid ${primaryColor}`,
      borderFocus: `1px solid ${primaryColor}`,
      boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, {
        alpha: 0.3
      })}`,
      textColor: textColor2,
      textColorDisabled
    });
  }
  const checkboxLight = {
    name: "Checkbox",
    common: commonLight,
    self: self$Z
  };
  const checkboxLight$1 = checkboxLight;
  function self$Y(vars) {
    const {
      borderRadius,
      boxShadow2,
      popoverColor,
      textColor2,
      textColor3,
      primaryColor,
      textColorDisabled,
      dividerColor,
      hoverColor,
      fontSizeMedium,
      heightMedium
    } = vars;
    return {
      menuBorderRadius: borderRadius,
      menuColor: popoverColor,
      menuBoxShadow: boxShadow2,
      menuDividerColor: dividerColor,
      menuHeight: "calc(var(--n-option-height) * 6.6)",
      optionArrowColor: textColor3,
      optionHeight: heightMedium,
      optionFontSize: fontSizeMedium,
      optionColorHover: hoverColor,
      optionTextColor: textColor2,
      optionTextColorActive: primaryColor,
      optionTextColorDisabled: textColorDisabled,
      optionCheckMarkColor: primaryColor,
      loadingColor: primaryColor,
      columnWidth: "180px"
    };
  }
  const cascaderLight = createTheme({
    name: "Cascader",
    common: commonLight,
    peers: {
      InternalSelectMenu: internalSelectMenuLight$1,
      InternalSelection: internalSelectionLight$1,
      Scrollbar: scrollbarLight$1,
      Checkbox: checkboxLight$1,
      Empty: emptyLight$1
    },
    self: self$Y
  });
  const cascaderLight$1 = cascaderLight;
  function getRawNodePath(tmNodes) {
    if (!tmNodes)
      return null;
    return tmNodes.map((tmNode) => tmNode.rawNode);
  }
  function createSelectOptions(tmNodes, checkStrategyIsChild, labelField, separator) {
    const selectOptions = [];
    const path = [];
    function traverse2(_tmNodes) {
      for (const tmNode of _tmNodes) {
        if (tmNode.disabled)
          continue;
        const {
          rawNode
        } = tmNode;
        path.push(rawNode);
        if (tmNode.isLeaf || !checkStrategyIsChild) {
          selectOptions.push({
            label: getPathLabel(tmNode, separator, labelField),
            value: tmNode.key,
            rawNode: tmNode.rawNode,
            path: Array.from(path)
          });
        }
        if (!tmNode.isLeaf && tmNode.children) {
          traverse2(tmNode.children);
        }
        path.pop();
      }
    }
    traverse2(tmNodes);
    return selectOptions;
  }
  function getPathLabel(node, separator, labelField) {
    const path = [];
    while (node) {
      path.push(node.rawNode[labelField]);
      node = node.parent;
    }
    return path.reverse().join(separator);
  }
  const CheckMark = vue.h("svg", {
    viewBox: "0 0 64 64",
    class: "check-icon"
  }, vue.h("path", {
    d: "M50.42,16.76L22.34,39.45l-8.1-11.46c-1.12-1.58-3.3-1.96-4.88-0.84c-1.58,1.12-1.95,3.3-0.84,4.88l10.26,14.51  c0.56,0.79,1.42,1.31,2.38,1.45c0.16,0.02,0.32,0.03,0.48,0.03c0.8,0,1.57-0.27,2.2-0.78l30.99-25.03c1.5-1.21,1.74-3.42,0.52-4.92  C54.13,15.78,51.93,15.55,50.42,16.76z"
  }));
  const LineMark = vue.h("svg", {
    viewBox: "0 0 100 100",
    class: "line-icon"
  }, vue.h("path", {
    d: "M80.2,55.5H21.4c-2.8,0-5.1-2.5-5.1-5.5l0,0c0-3,2.3-5.5,5.1-5.5h58.7c2.8,0,5.1,2.5,5.1,5.5l0,0C85.2,53.1,82.9,55.5,80.2,55.5z"
  }));
  const checkboxGroupInjectionKey = createInjectionKey("n-checkbox-group");
  const checkboxGroupProps = {
    min: Number,
    max: Number,
    size: String,
    value: Array,
    defaultValue: {
      type: Array,
      default: null
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    "onUpdate:value": [Function, Array],
    onUpdateValue: [Function, Array],
    // deprecated
    onChange: [Function, Array]
  };
  const NCheckboxGroup = vue.defineComponent({
    name: "CheckboxGroup",
    props: checkboxGroupProps,
    setup(props) {
      {
        vue.watchEffect(() => {
          if (props.onChange !== void 0) {
            warnOnce("checkbox-group", "`on-change` is deprecated, please use `on-update:value` instead.");
          }
        });
      }
      const {
        mergedClsPrefixRef
      } = useConfig(props);
      const formItem = useFormItem(props);
      const {
        mergedSizeRef,
        mergedDisabledRef
      } = formItem;
      const uncontrolledValueRef = vue.ref(props.defaultValue);
      const controlledValueRef = vue.computed(() => props.value);
      const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
      const checkedCount = vue.computed(() => {
        var _a;
        return ((_a = mergedValueRef.value) === null || _a === void 0 ? void 0 : _a.length) || 0;
      });
      const valueSetRef = vue.computed(() => {
        if (Array.isArray(mergedValueRef.value)) {
          return new Set(mergedValueRef.value);
        }
        return /* @__PURE__ */ new Set();
      });
      function toggleCheckbox(checked, checkboxValue) {
        const {
          nTriggerFormInput,
          nTriggerFormChange
        } = formItem;
        const {
          onChange,
          "onUpdate:value": _onUpdateValue,
          onUpdateValue
        } = props;
        if (Array.isArray(mergedValueRef.value)) {
          const groupValue = Array.from(mergedValueRef.value);
          const index = groupValue.findIndex((value) => value === checkboxValue);
          if (checked) {
            if (!~index) {
              groupValue.push(checkboxValue);
              if (onUpdateValue) {
                call(onUpdateValue, groupValue, {
                  actionType: "check",
                  value: checkboxValue
                });
              }
              if (_onUpdateValue) {
                call(_onUpdateValue, groupValue, {
                  actionType: "check",
                  value: checkboxValue
                });
              }
              nTriggerFormInput();
              nTriggerFormChange();
              uncontrolledValueRef.value = groupValue;
              if (onChange)
                call(onChange, groupValue);
            }
          } else {
            if (~index) {
              groupValue.splice(index, 1);
              if (onUpdateValue) {
                call(onUpdateValue, groupValue, {
                  actionType: "uncheck",
                  value: checkboxValue
                });
              }
              if (_onUpdateValue) {
                call(_onUpdateValue, groupValue, {
                  actionType: "uncheck",
                  value: checkboxValue
                });
              }
              if (onChange)
                call(onChange, groupValue);
              uncontrolledValueRef.value = groupValue;
              nTriggerFormInput();
              nTriggerFormChange();
            }
          }
        } else {
          if (checked) {
            if (onUpdateValue) {
              call(onUpdateValue, [checkboxValue], {
                actionType: "check",
                value: checkboxValue
              });
            }
            if (_onUpdateValue) {
              call(_onUpdateValue, [checkboxValue], {
                actionType: "check",
                value: checkboxValue
              });
            }
            if (onChange)
              call(onChange, [checkboxValue]);
            uncontrolledValueRef.value = [checkboxValue];
            nTriggerFormInput();
            nTriggerFormChange();
          } else {
            if (onUpdateValue) {
              call(onUpdateValue, [], {
                actionType: "uncheck",
                value: checkboxValue
              });
            }
            if (_onUpdateValue) {
              call(_onUpdateValue, [], {
                actionType: "uncheck",
                value: checkboxValue
              });
            }
            if (onChange)
              call(onChange, []);
            uncontrolledValueRef.value = [];
            nTriggerFormInput();
            nTriggerFormChange();
          }
        }
      }
      vue.provide(checkboxGroupInjectionKey, {
        checkedCountRef: checkedCount,
        maxRef: vue.toRef(props, "max"),
        minRef: vue.toRef(props, "min"),
        valueSetRef,
        disabledRef: mergedDisabledRef,
        mergedSizeRef,
        toggleCheckbox
      });
      return {
        mergedClsPrefix: mergedClsPrefixRef
      };
    },
    render() {
      return vue.h("div", {
        class: `${this.mergedClsPrefix}-checkbox-group`,
        role: "group"
      }, this.$slots);
    }
  });
  const style$18 = c$1([
    cB("checkbox", `
 font-size: var(--n-font-size);
 outline: none;
 cursor: pointer;
 display: inline-flex;
 flex-wrap: nowrap;
 align-items: flex-start;
 word-break: break-word;
 line-height: var(--n-size);
 --n-merged-color-table: var(--n-color-table);
 `, [cM("show-label", "line-height: var(--n-label-line-height);"), c$1("&:hover", [cB("checkbox-box", [cE("border", "border: var(--n-border-checked);")])]), c$1("&:focus:not(:active)", [cB("checkbox-box", [cE("border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), cM("inside-table", [cB("checkbox-box", `
 background-color: var(--n-merged-color-table);
 `)]), cM("checked", [cB("checkbox-box", `
 background-color: var(--n-color-checked);
 `, [cB("checkbox-icon", [
      // if not set width to 100%, safari & old chrome won't display the icon
      c$1(".check-icon", `
 opacity: 1;
 transform: scale(1);
 `)
    ])])]), cM("indeterminate", [cB("checkbox-box", [cB("checkbox-icon", [c$1(".check-icon", `
 opacity: 0;
 transform: scale(.5);
 `), c$1(".line-icon", `
 opacity: 1;
 transform: scale(1);
 `)])])]), cM("checked, indeterminate", [c$1("&:focus:not(:active)", [cB("checkbox-box", [cE("border", `
 border: var(--n-border-checked);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), cB("checkbox-box", `
 background-color: var(--n-color-checked);
 border-left: 0;
 border-top: 0;
 `, [cE("border", {
      border: "var(--n-border-checked)"
    })])]), cM("disabled", {
      cursor: "not-allowed"
    }, [cM("checked", [cB("checkbox-box", `
 background-color: var(--n-color-disabled-checked);
 `, [cE("border", {
      border: "var(--n-border-disabled-checked)"
    }), cB("checkbox-icon", [c$1(".check-icon, .line-icon", {
      fill: "var(--n-check-mark-color-disabled-checked)"
    })])])]), cB("checkbox-box", `
 background-color: var(--n-color-disabled);
 `, [cE("border", `
 border: var(--n-border-disabled);
 `), cB("checkbox-icon", [c$1(".check-icon, .line-icon", `
 fill: var(--n-check-mark-color-disabled);
 `)])]), cE("label", `
 color: var(--n-text-color-disabled);
 `)]), cB("checkbox-box-wrapper", `
 position: relative;
 width: var(--n-size);
 flex-shrink: 0;
 flex-grow: 0;
 user-select: none;
 -webkit-user-select: none;
 `), cB("checkbox-box", `
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 height: var(--n-size);
 width: var(--n-size);
 display: inline-block;
 box-sizing: border-box;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color 0.3s var(--n-bezier);
 `, [cE("border", `
 transition:
 border-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border: var(--n-border);
 `), cB("checkbox-icon", `
 display: flex;
 align-items: center;
 justify-content: center;
 position: absolute;
 left: 1px;
 right: 1px;
 top: 1px;
 bottom: 1px;
 `, [c$1(".check-icon, .line-icon", `
 width: 100%;
 fill: var(--n-check-mark-color);
 opacity: 0;
 transform: scale(0.5);
 transform-origin: center;
 transition:
 fill 0.3s var(--n-bezier),
 transform 0.3s var(--n-bezier),
 opacity 0.3s var(--n-bezier),
 border-color 0.3s var(--n-bezier);
 `), iconSwitchTransition({
      left: "1px",
      top: "1px"
    })])]), cE("label", `
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 user-select: none;
 -webkit-user-select: none;
 padding: var(--n-label-padding);
 font-weight: var(--n-label-font-weight);
 `, [c$1("&:empty", {
      display: "none"
    })])]),
    // modal table header checkbox
    insideModal(cB("checkbox", `
 --n-merged-color-table: var(--n-color-table-modal);
 `)),
    // popover table header checkbox
    insidePopover(cB("checkbox", `
 --n-merged-color-table: var(--n-color-table-popover);
 `))
  ]);
  const checkboxProps = Object.assign(Object.assign({}, useTheme.props), {
    size: String,
    checked: {
      type: [Boolean, String, Number],
      default: void 0
    },
    defaultChecked: {
      type: [Boolean, String, Number],
      default: false
    },
    value: [String, Number],
    disabled: {
      type: Boolean,
      default: void 0
    },
    indeterminate: Boolean,
    label: String,
    focusable: {
      type: Boolean,
      default: true
    },
    checkedValue: {
      type: [Boolean, String, Number],
      default: true
    },
    uncheckedValue: {
      type: [Boolean, String, Number],
      default: false
    },
    "onUpdate:checked": [Function, Array],
    onUpdateChecked: [Function, Array],
    // private
    privateInsideTable: Boolean,
    // deprecated
    onChange: [Function, Array]
  });
  const NCheckbox = vue.defineComponent({
    name: "Checkbox",
    props: checkboxProps,
    setup(props) {
      {
        vue.watchEffect(() => {
          if (props.onChange) {
            warnOnce("checkbox", "`on-change` is deprecated, please use `on-update:checked` instead.");
          }
        });
      }
      const NCheckboxGroup2 = vue.inject(checkboxGroupInjectionKey, null);
      const selfRef = vue.ref(null);
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled,
        mergedRtlRef
      } = useConfig(props);
      const uncontrolledCheckedRef = vue.ref(props.defaultChecked);
      const controlledCheckedRef = vue.toRef(props, "checked");
      const mergedCheckedRef = useMergedState(controlledCheckedRef, uncontrolledCheckedRef);
      const renderedCheckedRef = useMemo(() => {
        if (NCheckboxGroup2) {
          const groupValueSet = NCheckboxGroup2.valueSetRef.value;
          if (groupValueSet && props.value !== void 0) {
            return groupValueSet.has(props.value);
          }
          return false;
        } else {
          return mergedCheckedRef.value === props.checkedValue;
        }
      });
      const formItem = useFormItem(props, {
        mergedSize(NFormItem2) {
          const {
            size: size2
          } = props;
          if (size2 !== void 0)
            return size2;
          if (NCheckboxGroup2) {
            const {
              value: mergedSize
            } = NCheckboxGroup2.mergedSizeRef;
            if (mergedSize !== void 0) {
              return mergedSize;
            }
          }
          if (NFormItem2) {
            const {
              mergedSize
            } = NFormItem2;
            if (mergedSize !== void 0)
              return mergedSize.value;
          }
          return "medium";
        },
        mergedDisabled(NFormItem2) {
          const {
            disabled
          } = props;
          if (disabled !== void 0)
            return disabled;
          if (NCheckboxGroup2) {
            if (NCheckboxGroup2.disabledRef.value)
              return true;
            const {
              maxRef: {
                value: max
              },
              checkedCountRef
            } = NCheckboxGroup2;
            if (max !== void 0 && checkedCountRef.value >= max && !renderedCheckedRef.value) {
              return true;
            }
            const {
              minRef: {
                value: min
              }
            } = NCheckboxGroup2;
            if (min !== void 0 && checkedCountRef.value <= min && renderedCheckedRef.value) {
              return true;
            }
          }
          if (NFormItem2) {
            return NFormItem2.disabled.value;
          }
          return false;
        }
      });
      const {
        mergedDisabledRef,
        mergedSizeRef
      } = formItem;
      const themeRef = useTheme("Checkbox", "-checkbox", style$18, checkboxLight$1, props, mergedClsPrefixRef);
      function toggle(e) {
        if (NCheckboxGroup2 && props.value !== void 0) {
          NCheckboxGroup2.toggleCheckbox(!renderedCheckedRef.value, props.value);
        } else {
          const {
            onChange,
            "onUpdate:checked": _onUpdateCheck,
            onUpdateChecked
          } = props;
          const {
            nTriggerFormInput,
            nTriggerFormChange
          } = formItem;
          const nextChecked = renderedCheckedRef.value ? props.uncheckedValue : props.checkedValue;
          if (_onUpdateCheck) {
            call(_onUpdateCheck, nextChecked, e);
          }
          if (onUpdateChecked) {
            call(onUpdateChecked, nextChecked, e);
          }
          if (onChange)
            call(onChange, nextChecked, e);
          nTriggerFormInput();
          nTriggerFormChange();
          uncontrolledCheckedRef.value = nextChecked;
        }
      }
      function handleClick2(e) {
        if (!mergedDisabledRef.value) {
          toggle(e);
        }
      }
      function handleKeyUp(e) {
        if (mergedDisabledRef.value)
          return;
        switch (e.key) {
          case " ":
          case "Enter":
            toggle(e);
        }
      }
      function handleKeyDown(e) {
        switch (e.key) {
          case " ":
            e.preventDefault();
        }
      }
      const exposedMethods = {
        focus: () => {
          var _a;
          (_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.focus();
        },
        blur: () => {
          var _a;
          (_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.blur();
        }
      };
      const rtlEnabledRef = useRtl("Checkbox", mergedRtlRef, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          value: mergedSize
        } = mergedSizeRef;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            borderRadius,
            color,
            colorChecked,
            colorDisabled,
            colorTableHeader,
            colorTableHeaderModal,
            colorTableHeaderPopover,
            checkMarkColor,
            checkMarkColorDisabled,
            border,
            borderFocus,
            borderDisabled,
            borderChecked,
            boxShadowFocus,
            textColor,
            textColorDisabled,
            checkMarkColorDisabledChecked,
            colorDisabledChecked,
            borderDisabledChecked,
            labelPadding,
            labelLineHeight,
            labelFontWeight,
            [createKey("fontSize", mergedSize)]: fontSize2,
            [createKey("size", mergedSize)]: size2
          }
        } = themeRef.value;
        return {
          "--n-label-line-height": labelLineHeight,
          "--n-label-font-weight": labelFontWeight,
          "--n-size": size2,
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-border-radius": borderRadius,
          "--n-border": border,
          "--n-border-checked": borderChecked,
          "--n-border-focus": borderFocus,
          "--n-border-disabled": borderDisabled,
          "--n-border-disabled-checked": borderDisabledChecked,
          "--n-box-shadow-focus": boxShadowFocus,
          "--n-color": color,
          "--n-color-checked": colorChecked,
          "--n-color-table": colorTableHeader,
          "--n-color-table-modal": colorTableHeaderModal,
          "--n-color-table-popover": colorTableHeaderPopover,
          "--n-color-disabled": colorDisabled,
          "--n-color-disabled-checked": colorDisabledChecked,
          "--n-text-color": textColor,
          "--n-text-color-disabled": textColorDisabled,
          "--n-check-mark-color": checkMarkColor,
          "--n-check-mark-color-disabled": checkMarkColorDisabled,
          "--n-check-mark-color-disabled-checked": checkMarkColorDisabledChecked,
          "--n-font-size": fontSize2,
          "--n-label-padding": labelPadding
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("checkbox", vue.computed(() => mergedSizeRef.value[0]), cssVarsRef, props) : void 0;
      return Object.assign(formItem, exposedMethods, {
        rtlEnabled: rtlEnabledRef,
        selfRef,
        mergedClsPrefix: mergedClsPrefixRef,
        mergedDisabled: mergedDisabledRef,
        renderedChecked: renderedCheckedRef,
        mergedTheme: themeRef,
        labelId: createId(),
        handleClick: handleClick2,
        handleKeyUp,
        handleKeyDown,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      });
    },
    render() {
      var _a;
      const {
        $slots,
        renderedChecked,
        mergedDisabled,
        indeterminate,
        privateInsideTable,
        cssVars,
        labelId,
        label,
        mergedClsPrefix,
        focusable,
        handleKeyUp,
        handleKeyDown,
        handleClick: handleClick2
      } = this;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      const labelNode = resolveWrappedSlot($slots.default, (children) => {
        if (label || children) {
          return vue.h("span", {
            class: `${mergedClsPrefix}-checkbox__label`,
            id: labelId
          }, label || children);
        }
        return null;
      });
      return vue.h("div", {
        ref: "selfRef",
        class: [`${mergedClsPrefix}-checkbox`, this.themeClass, this.rtlEnabled && `${mergedClsPrefix}-checkbox--rtl`, renderedChecked && `${mergedClsPrefix}-checkbox--checked`, mergedDisabled && `${mergedClsPrefix}-checkbox--disabled`, indeterminate && `${mergedClsPrefix}-checkbox--indeterminate`, privateInsideTable && `${mergedClsPrefix}-checkbox--inside-table`, labelNode && `${mergedClsPrefix}-checkbox--show-label`],
        tabindex: mergedDisabled || !focusable ? void 0 : 0,
        role: "checkbox",
        "aria-checked": indeterminate ? "mixed" : renderedChecked,
        "aria-labelledby": labelId,
        style: cssVars,
        onKeyup: handleKeyUp,
        onKeydown: handleKeyDown,
        onClick: handleClick2,
        onMousedown: () => {
          on("selectstart", window, (e) => {
            e.preventDefault();
          }, {
            once: true
          });
        }
      }, vue.h("div", {
        class: `${mergedClsPrefix}-checkbox-box-wrapper`
      }, " ", vue.h("div", {
        class: `${mergedClsPrefix}-checkbox-box`
      }, vue.h(NIconSwitchTransition, null, {
        default: () => this.indeterminate ? vue.h("div", {
          key: "indeterminate",
          class: `${mergedClsPrefix}-checkbox-icon`
        }, LineMark) : vue.h("div", {
          key: "check",
          class: `${mergedClsPrefix}-checkbox-icon`
        }, CheckMark)
      }), vue.h("div", {
        class: `${mergedClsPrefix}-checkbox-box__border`
      }))), labelNode);
    }
  });
  const cascaderInjectionKey = createInjectionKey("n-cascader");
  const NCascaderOption = vue.defineComponent({
    name: "NCascaderOption",
    props: {
      tmNode: {
        type: Object,
        required: true
      }
    },
    setup(props) {
      const {
        expandTriggerRef,
        remoteRef,
        multipleRef,
        mergedValueRef,
        checkedKeysRef,
        indeterminateKeysRef,
        hoverKeyPathRef,
        keyboardKeyRef,
        loadingKeySetRef,
        cascadeRef,
        mergedCheckStrategyRef,
        onLoadRef,
        mergedClsPrefixRef,
        mergedThemeRef,
        labelFieldRef,
        showCheckboxRef,
        renderPrefixRef,
        renderSuffixRef,
        updateHoverKey,
        updateKeyboardKey,
        addLoadingKey,
        deleteLoadingKey,
        closeMenu,
        doCheck,
        doUncheck,
        renderLabelRef
      } = vue.inject(cascaderInjectionKey);
      const valueRef = vue.computed(() => props.tmNode.key);
      const useHoverTriggerRef = vue.computed(() => {
        const {
          value: expandTrigger
        } = expandTriggerRef;
        const {
          value: remote
        } = remoteRef;
        return !remote && expandTrigger === "hover";
      });
      const mergedHandleMouseEnterRef = vue.computed(() => {
        if (useHoverTriggerRef.value) {
          return handleMouseEnter;
        }
        return void 0;
      });
      const mergedHandleMouseMoveRef = vue.computed(() => {
        if (useHoverTriggerRef.value) {
          return handleMouseMove;
        }
        return void 0;
      });
      const checkedRef = useMemo(() => {
        const {
          value: multiple
        } = multipleRef;
        if (!multiple)
          return mergedValueRef.value === valueRef.value;
        return checkedKeysRef.value.includes(valueRef.value);
      });
      const indeterminateRef = useMemo(() => {
        if (!multipleRef.value)
          return false;
        return indeterminateKeysRef.value.includes(valueRef.value);
      });
      const hoverPendingRef = useMemo(() => {
        return hoverKeyPathRef.value.includes(valueRef.value);
      });
      const keyboardPendingRef = useMemo(() => {
        const {
          value: keyboardKey
        } = keyboardKeyRef;
        if (keyboardKey === null)
          return false;
        return keyboardKey === valueRef.value;
      });
      const isLoadingRef = useMemo(() => {
        if (remoteRef.value) {
          return loadingKeySetRef.value.has(valueRef.value);
        }
        return false;
      });
      const isLeafRef = vue.computed(() => props.tmNode.isLeaf);
      const disabledRef = vue.computed(() => props.tmNode.disabled);
      const labelRef = vue.computed(() => props.tmNode.rawNode[labelFieldRef.value]);
      const isShallowLoadedRef = vue.computed(() => {
        return props.tmNode.shallowLoaded;
      });
      function handleClick2(e) {
        if (disabledRef.value)
          return;
        const {
          value: remote
        } = remoteRef;
        const {
          value: loadingKeySet
        } = loadingKeySetRef;
        const {
          value: onLoad
        } = onLoadRef;
        const {
          value
        } = valueRef;
        const {
          value: isLeaf2
        } = isLeafRef;
        const {
          value: isShallowLoaded2
        } = isShallowLoadedRef;
        if (!happensIn(e, "checkbox")) {
          if (remote && !isShallowLoaded2 && !loadingKeySet.has(value) && onLoad) {
            addLoadingKey(value);
            onLoad(props.tmNode.rawNode).then(() => {
              deleteLoadingKey(value);
            }).catch(() => {
              deleteLoadingKey(value);
            });
          }
          updateHoverKey(value);
          updateKeyboardKey(value);
        }
        if (isLeaf2) {
          toggleCheckbox();
        }
      }
      function handleMouseEnter() {
        if (!useHoverTriggerRef.value || disabledRef.value)
          return;
        const {
          value
        } = valueRef;
        updateHoverKey(value);
        updateKeyboardKey(value);
      }
      function handleMouseMove() {
        if (!useHoverTriggerRef.value)
          return;
        handleMouseEnter();
      }
      function handleCheckboxUpdateValue() {
        const {
          value: isLeaf2
        } = isLeafRef;
        if (!isLeaf2)
          toggleCheckbox();
      }
      function toggleCheckbox() {
        const {
          value: multiple
        } = multipleRef;
        const {
          value
        } = valueRef;
        if (multiple) {
          if (indeterminateRef.value || checkedRef.value) {
            doUncheck(value);
          } else {
            doCheck(value);
          }
        } else {
          doCheck(value);
          closeMenu(true);
        }
      }
      return {
        checkStrategy: mergedCheckStrategyRef,
        multiple: multipleRef,
        cascade: cascadeRef,
        checked: checkedRef,
        indeterminate: indeterminateRef,
        hoverPending: hoverPendingRef,
        keyboardPending: keyboardPendingRef,
        isLoading: isLoadingRef,
        showCheckbox: showCheckboxRef,
        isLeaf: isLeafRef,
        disabled: disabledRef,
        label: labelRef,
        mergedClsPrefix: mergedClsPrefixRef,
        mergedTheme: mergedThemeRef,
        handleClick: handleClick2,
        handleCheckboxUpdateValue,
        mergedHandleMouseEnter: mergedHandleMouseEnterRef,
        mergedHandleMouseMove: mergedHandleMouseMoveRef,
        renderLabel: renderLabelRef,
        renderPrefix: renderPrefixRef,
        renderSuffix: renderSuffixRef
      };
    },
    render() {
      const {
        mergedClsPrefix,
        showCheckbox,
        renderLabel,
        renderPrefix,
        renderSuffix
      } = this;
      let prefixNode = null;
      if (showCheckbox || renderPrefix) {
        const originalNode = this.showCheckbox ? vue.h(NCheckbox, {
          focusable: false,
          "data-checkbox": true,
          disabled: this.disabled,
          checked: this.checked,
          indeterminate: this.indeterminate,
          theme: this.mergedTheme.peers.Checkbox,
          themeOverrides: this.mergedTheme.peerOverrides.Checkbox,
          onUpdateChecked: this.handleCheckboxUpdateValue
        }) : null;
        prefixNode = vue.h("div", {
          class: `${mergedClsPrefix}-cascader-option__prefix`
        }, renderPrefix ? renderPrefix({
          option: this.tmNode.rawNode,
          checked: this.checked,
          node: originalNode
        }) : originalNode);
      }
      let suffixNode = null;
      const originalSuffixChild = vue.h("div", {
        class: `${mergedClsPrefix}-cascader-option-icon-placeholder`
      }, !this.isLeaf ? vue.h(NBaseLoading, {
        clsPrefix: mergedClsPrefix,
        scale: 0.85,
        strokeWidth: 24,
        show: this.isLoading,
        class: `${mergedClsPrefix}-cascader-option-icon`
      }, {
        default: () => vue.h(NBaseIcon, {
          clsPrefix: mergedClsPrefix,
          key: "arrow",
          class: `${mergedClsPrefix}-cascader-option-icon ${mergedClsPrefix}-cascader-option-icon--arrow`
        }, {
          default: () => vue.h(ChevronRightIcon, null)
        })
      }) : this.checkStrategy === "child" && !(this.multiple && this.cascade) ? vue.h(vue.Transition, {
        name: "fade-in-scale-up-transition"
      }, {
        default: () => this.checked ? vue.h(NBaseIcon, {
          clsPrefix: mergedClsPrefix,
          class: `${mergedClsPrefix}-cascader-option-icon ${mergedClsPrefix}-cascader-option-icon--checkmark`
        }, {
          default: () => vue.h(FinishedIcon, null)
        }) : null
      }) : null);
      suffixNode = vue.h("div", {
        class: `${mergedClsPrefix}-cascader-option__suffix`
      }, renderSuffix ? renderSuffix({
        option: this.tmNode.rawNode,
        checked: this.checked,
        node: originalSuffixChild
      }) : originalSuffixChild);
      return vue.h("div", {
        class: [`${mergedClsPrefix}-cascader-option`, this.keyboardPending || this.hoverPending && `${mergedClsPrefix}-cascader-option--pending`, this.disabled && `${mergedClsPrefix}-cascader-option--disabled`, this.showCheckbox && `${mergedClsPrefix}-cascader-option--show-prefix`],
        onMouseenter: this.mergedHandleMouseEnter,
        onMousemove: this.mergedHandleMouseMove,
        onClick: this.handleClick
      }, prefixNode, vue.h("span", {
        class: `${mergedClsPrefix}-cascader-option__label`
      }, renderLabel ? renderLabel(this.tmNode.rawNode, this.checked) : this.label), suffixNode);
    }
  });
  const NCascaderSubmenu = vue.defineComponent({
    name: "CascaderSubmenu",
    props: {
      depth: {
        type: Number,
        required: true
      },
      tmNodes: {
        type: Array,
        required: true
      }
    },
    setup() {
      const {
        virtualScrollRef,
        mergedClsPrefixRef,
        mergedThemeRef,
        optionHeightRef
      } = vue.inject(cascaderInjectionKey);
      const scrollbarInstRef = vue.ref(null);
      const vlInstRef = vue.ref(null);
      const inst = {
        scroll(index, elSize) {
          var _a, _b;
          if (virtualScrollRef.value) {
            (_a = vlInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo({
              index
            });
          } else {
            (_b = scrollbarInstRef.value) === null || _b === void 0 ? void 0 : _b.scrollTo({
              index,
              elSize
            });
          }
        }
      };
      return Object.assign({
        mergedClsPrefix: mergedClsPrefixRef,
        mergedTheme: mergedThemeRef,
        scrollbarInstRef,
        vlInstRef,
        virtualScroll: virtualScrollRef,
        itemSize: vue.computed(() => depx(optionHeightRef.value)),
        handleVlScroll: () => {
          var _a;
          (_a = scrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.sync();
        },
        getVlContainer: () => {
          var _a;
          return (_a = vlInstRef.value) === null || _a === void 0 ? void 0 : _a.listElRef;
        },
        getVlContent: () => {
          var _a;
          return (_a = vlInstRef.value) === null || _a === void 0 ? void 0 : _a.itemsElRef;
        }
      }, inst);
    },
    render() {
      const {
        mergedClsPrefix,
        mergedTheme,
        virtualScroll
      } = this;
      return vue.h("div", {
        class: [virtualScroll && `${mergedClsPrefix}-cascader-submenu--virtual`, `${mergedClsPrefix}-cascader-submenu`]
      }, vue.h(NScrollbar, {
        ref: "scrollbarInstRef",
        theme: mergedTheme.peers.Scrollbar,
        themeOverrides: mergedTheme.peerOverrides.Scrollbar,
        container: virtualScroll ? this.getVlContainer : void 0,
        content: virtualScroll ? this.getVlContent : void 0
      }, {
        default: () => virtualScroll ? vue.h(VVirtualList, {
          items: this.tmNodes,
          itemSize: this.itemSize,
          onScroll: this.handleVlScroll,
          showScrollbar: false,
          ref: "vlInstRef"
        }, {
          default: ({
            item: tmNode
          }) => vue.h(NCascaderOption, {
            key: tmNode.key,
            tmNode
          })
        }) : this.tmNodes.map((tmNode) => vue.h(NCascaderOption, {
          key: tmNode.key,
          tmNode
        }))
      }));
    }
  });
  const CascaderMenu = vue.defineComponent({
    name: "NCascaderMenu",
    props: {
      value: [String, Number, Array],
      placement: {
        type: String,
        default: "bottom-start"
      },
      show: Boolean,
      menuModel: {
        type: Array,
        required: true
      },
      loading: Boolean,
      onFocus: {
        type: Function,
        required: true
      },
      onBlur: {
        type: Function,
        required: true
      },
      onKeydown: {
        type: Function,
        required: true
      },
      onMousedown: {
        type: Function,
        required: true
      },
      onTabout: {
        type: Function,
        required: true
      }
    },
    setup(props) {
      const {
        localeRef,
        isMountedRef,
        mergedClsPrefixRef,
        syncCascaderMenuPosition,
        handleCascaderMenuClickOutside,
        mergedThemeRef,
        getColumnStyleRef
      } = vue.inject(cascaderInjectionKey);
      const submenuInstRefs = [];
      const maskInstRef = vue.ref(null);
      const selfElRef = vue.ref(null);
      function handleResize() {
        syncCascaderMenuPosition();
      }
      useOnResize(selfElRef, handleResize);
      function showErrorMessage(label) {
        var _a;
        const {
          value: {
            loadingRequiredMessage
          }
        } = localeRef;
        (_a = maskInstRef.value) === null || _a === void 0 ? void 0 : _a.showOnce(loadingRequiredMessage(label));
      }
      function handleClickOutside(e) {
        handleCascaderMenuClickOutside(e);
      }
      function handleFocusin(e) {
        const {
          value: selfEl
        } = selfElRef;
        if (!selfEl)
          return;
        if (!selfEl.contains(e.relatedTarget)) {
          props.onFocus(e);
        }
      }
      function handleFocusout(e) {
        const {
          value: selfEl
        } = selfElRef;
        if (!selfEl)
          return;
        if (!selfEl.contains(e.relatedTarget)) {
          props.onBlur(e);
        }
      }
      const exposedRef = {
        scroll(depth, index, elSize) {
          const submenuInst = submenuInstRefs[depth];
          if (submenuInst) {
            submenuInst.scroll(index, elSize);
          }
        },
        showErrorMessage
      };
      return Object.assign({
        isMounted: isMountedRef,
        mergedClsPrefix: mergedClsPrefixRef,
        selfElRef,
        submenuInstRefs,
        maskInstRef,
        mergedTheme: mergedThemeRef,
        getColumnStyle: getColumnStyleRef,
        handleFocusin,
        handleFocusout,
        handleClickOutside
      }, exposedRef);
    },
    render() {
      const {
        submenuInstRefs,
        mergedClsPrefix,
        mergedTheme
      } = this;
      return vue.h(vue.Transition, {
        name: "fade-in-scale-up-transition",
        appear: this.isMounted
      }, {
        default: () => {
          if (!this.show)
            return null;
          return vue.withDirectives(vue.h("div", {
            tabindex: "0",
            ref: "selfElRef",
            class: `${mergedClsPrefix}-cascader-menu`,
            onMousedown: this.onMousedown,
            onFocusin: this.handleFocusin,
            onFocusout: this.handleFocusout,
            onKeydown: this.onKeydown
          }, this.menuModel[0].length ? vue.h("div", {
            class: `${mergedClsPrefix}-cascader-submenu-wrapper`
          }, this.menuModel.map((submenuOptions, index) => {
            var _a;
            return vue.h(NCascaderSubmenu, {
              style: (_a = this.getColumnStyle) === null || _a === void 0 ? void 0 : _a.call(this, {
                level: index
              }),
              ref: (instance) => {
                if (instance) {
                  submenuInstRefs[index] = instance;
                }
              },
              key: index,
              tmNodes: submenuOptions,
              depth: index + 1
            });
          }), vue.h(NBaseMenuMask, {
            clsPrefix: mergedClsPrefix,
            ref: "maskInstRef"
          })) : vue.h("div", {
            class: `${mergedClsPrefix}-cascader-menu__empty`
          }, resolveSlot(this.$slots.empty, () => [vue.h(NEmpty, {
            theme: mergedTheme.peers.Empty,
            themeOverrides: mergedTheme.peerOverrides.Empty
          })])), resolveWrappedSlot(this.$slots.action, (children) => children && vue.h("div", {
            class: `${mergedClsPrefix}-cascader-menu-action`,
            "data-action": true
          }, children)), vue.h(FocusDetector, {
            onFocus: this.onTabout
          })), [[clickoutside$1, this.handleClickOutside, void 0, {
            capture: true
          }]]);
        }
      });
    }
  });
  const CascaderSelectMenu = vue.defineComponent({
    name: "NCascaderSelectMenu",
    props: {
      value: {
        type: [String, Number, Array],
        default: null
      },
      show: Boolean,
      pattern: {
        type: String,
        default: ""
      },
      multiple: Boolean,
      tmNodes: {
        type: Array,
        default: () => []
      },
      filter: Function,
      labelField: {
        type: String,
        required: true
      },
      separator: {
        type: String,
        required: true
      }
    },
    setup(props) {
      const {
        isMountedRef,
        mergedValueRef,
        mergedClsPrefixRef,
        mergedThemeRef,
        mergedCheckStrategyRef,
        slots: cascaderSlots,
        syncSelectMenuPosition,
        closeMenu,
        handleSelectMenuClickOutside,
        doUncheck: cascaderDoUncheck,
        doCheck: cascaderDoCheck,
        clearPattern
      } = vue.inject(cascaderInjectionKey);
      const menuInstRef = vue.ref(null);
      const selectOptionsRef = vue.computed(() => {
        return createSelectOptions(props.tmNodes, mergedCheckStrategyRef.value === "child", props.labelField, props.separator);
      });
      const mergedFilterRef = vue.computed(() => {
        const {
          filter
        } = props;
        if (filter)
          return filter;
        const {
          labelField
        } = props;
        return (pattern, _, path) => path.some((option) => option[labelField] && ~option[labelField].toLowerCase().indexOf(pattern.toLowerCase()));
      });
      const filteredSelectOptionsRef = vue.computed(() => {
        const {
          pattern
        } = props;
        const {
          value: mergedFilter
        } = mergedFilterRef;
        return (pattern ? selectOptionsRef.value.filter((option) => {
          return mergedFilter(pattern, option.rawNode, option.path);
        }) : selectOptionsRef.value).map((option) => ({
          value: option.value,
          label: option.label
        }));
      });
      const selectTreeMateRef = vue.computed(() => {
        return createTreeMate(filteredSelectOptionsRef.value, createTmOptions("value", "children"));
      });
      function handleResize() {
        syncSelectMenuPosition();
      }
      function handleToggle(tmNode) {
        doCheck(tmNode);
      }
      function doCheck(tmNode) {
        if (props.multiple) {
          const {
            value: mergedValue
          } = mergedValueRef;
          if (Array.isArray(mergedValue)) {
            if (!mergedValue.includes(tmNode.key)) {
              cascaderDoCheck(tmNode.key);
            } else {
              cascaderDoUncheck(tmNode.key);
            }
          } else if (mergedValue === null) {
            cascaderDoCheck(tmNode.key);
          }
          clearPattern();
        } else {
          cascaderDoCheck(tmNode.key);
          closeMenu(true);
        }
      }
      function prev() {
        var _a;
        (_a = menuInstRef.value) === null || _a === void 0 ? void 0 : _a.prev();
      }
      function next() {
        var _a;
        (_a = menuInstRef.value) === null || _a === void 0 ? void 0 : _a.next();
      }
      function enter() {
        var _a;
        if (menuInstRef) {
          const pendingOptionTmNode = (_a = menuInstRef.value) === null || _a === void 0 ? void 0 : _a.getPendingTmNode();
          if (pendingOptionTmNode) {
            doCheck(pendingOptionTmNode);
          }
          return true;
        }
        return false;
      }
      function handleClickOutside(e) {
        handleSelectMenuClickOutside(e);
      }
      const exposedRef = {
        prev,
        next,
        enter
      };
      return Object.assign({
        isMounted: isMountedRef,
        mergedTheme: mergedThemeRef,
        mergedClsPrefix: mergedClsPrefixRef,
        menuInstRef,
        selectTreeMate: selectTreeMateRef,
        handleResize,
        handleToggle,
        handleClickOutside,
        cascaderSlots
      }, exposedRef);
    },
    render() {
      const {
        mergedClsPrefix,
        isMounted: isMounted2,
        mergedTheme,
        cascaderSlots
      } = this;
      return vue.h(vue.Transition, {
        name: "fade-in-scale-up-transition",
        appear: isMounted2
      }, {
        default: () => this.show ? vue.withDirectives(vue.h(NInternalSelectMenu, {
          ref: "menuInstRef",
          onResize: this.handleResize,
          clsPrefix: mergedClsPrefix,
          class: `${mergedClsPrefix}-cascader-menu`,
          autoPending: true,
          themeOverrides: mergedTheme.peerOverrides.InternalSelectMenu,
          theme: mergedTheme.peers.InternalSelectMenu,
          treeMate: this.selectTreeMate,
          multiple: this.multiple,
          value: this.value,
          onToggle: this.handleToggle
        }, {
          empty: () => resolveSlot(cascaderSlots["not-found"], () => [])
        }), [[clickoutside$1, this.handleClickOutside, void 0, {
          capture: true
        }]]) : null
      });
    }
  });
  const style$17 = c$1([cB("cascader-menu", `
 outline: none;
 position: relative;
 margin: 4px 0;
 display: flex;
 flex-flow: column nowrap;
 border-radius: var(--n-menu-border-radius);
 overflow: hidden;
 box-shadow: var(--n-menu-box-shadow);
 color: var(--n-option-text-color);
 background-color: var(--n-menu-color);
 `, [
    fadeInScaleUpTransition({
      transformOrigin: "inherit",
      duration: "0.2s"
    }),
    cE("empty", `
 display: flex;
 padding: 12px 32px;
 flex: 1;
 justify-content: center;
 `),
    // if width not set, cascader select menu's inner scroll area's width is
    // not correct, which won't change after select menu width is set
    cB("scrollbar", `
 width: 100%;
 `),
    cB("base-menu-mask", `
 background-color: var(--n-menu-mask-color);
 `),
    cB("base-loading", `
 color: var(--n-loading-color);
 `),
    cB("cascader-submenu-wrapper", `
 position: relative;
 display: flex;
 flex-wrap: nowrap;
 `),
    cB("cascader-submenu", `
 height: var(--n-menu-height);
 min-width: var(--n-column-width);
 position: relative;
 `, [cM("virtual", `
 width: var(--n-column-width);
 `), cB("scrollbar-content", `
 position: relative;
 `), c$1("&:first-child", `
 border-top-left-radius: var(--n-menu-border-radius);
 border-bottom-left-radius: var(--n-menu-border-radius);
 `), c$1("&:last-child", `
 border-top-right-radius: var(--n-menu-border-radius);
 border-bottom-right-radius: var(--n-menu-border-radius);
 `), c$1("&:not(:first-child)", `
 border-left: 1px solid var(--n-menu-divider-color);
 `)]),
    cB("cascader-menu-action", `
 box-sizing: border-box;
 padding: 8px;
 border-top: 1px solid var(--n-menu-divider-color);
 `),
    cB("cascader-option", `
 height: var(--n-option-height);
 line-height: var(--n-option-height);
 font-size: var(--n-option-font-size);
 padding: 0 0 0 18px;
 box-sizing: border-box;
 min-width: 182px;
 background-color: #0000;
 display: flex;
 align-items: center;
 white-space: nowrap;
 position: relative;
 cursor: pointer;
 transition:
 background-color .2s var(--n-bezier),
 color 0.2s var(--n-bezier);
 `, [cM("show-prefix", `
 padding-left: 0;
 `), cE("label", `
 flex: 1 0 0;
 overflow: hidden;
 text-overflow: ellipsis;
 `), cE("prefix", `
 min-width: 32px;
 display: flex;
 align-items: center;
 justify-content: center;
 `), cE("suffix", `
 min-width: 32px;
 display: flex;
 align-items: center;
 justify-content: center;
 `), cB("cascader-option-icon-placeholder", `
 line-height: 0;
 position: relative;
 width: 16px;
 height: 16px;
 font-size: 16px;
 `, [cB("cascader-option-icon", [cM("checkmark", `
 color: var(--n-option-check-mark-color);
 `, [fadeInScaleUpTransition({
      originalTransition: "background-color .3s var(--n-bezier), box-shadow .3s var(--n-bezier)"
    })]), cM("arrow", `
 color: var(--n-option-arrow-color);
 `)])]), cM("selected", `
 color: var(--n-option-text-color-active);
 `), cM("active", `
 color: var(--n-option-text-color-active);
 background-color: var(--n-option-color-hover);
 `), cM("pending", `
 background-color: var(--n-option-color-hover);
 `), c$1("&:hover", `
 background-color: var(--n-option-color-hover);
 `), cM("disabled", `
 color: var(--n-option-text-color-disabled);
 background-color: #0000;
 cursor: not-allowed;
 `, [cB("cascader-option-icon", [cM("arrow", `
 color: var(--n-option-text-color-disabled);
 `)])])])
  ]), cB("cascader", `
 z-index: auto;
 position: relative;
 width: 100%;
 `)]);
  const cascaderProps = Object.assign(Object.assign({}, useTheme.props), {
    allowCheckingNotLoaded: Boolean,
    to: useAdjustedTo.propTo,
    bordered: {
      type: Boolean,
      default: void 0
    },
    options: {
      type: Array,
      default: () => []
    },
    value: [String, Number, Array],
    defaultValue: {
      type: [String, Number, Array],
      default: null
    },
    placeholder: String,
    multiple: Boolean,
    size: String,
    filterable: Boolean,
    disabled: {
      type: Boolean,
      default: void 0
    },
    disabledField: {
      type: String,
      default: "disabled"
    },
    expandTrigger: {
      type: String,
      default: "click"
    },
    clearable: Boolean,
    clearFilterAfterSelect: {
      type: Boolean,
      default: true
    },
    remote: Boolean,
    onLoad: Function,
    separator: {
      type: String,
      default: " / "
    },
    filter: Function,
    placement: {
      type: String,
      default: "bottom-start"
    },
    cascade: {
      type: Boolean,
      default: true
    },
    leafOnly: Boolean,
    showPath: {
      type: Boolean,
      default: true
    },
    show: {
      type: Boolean,
      default: void 0
    },
    maxTagCount: [String, Number],
    ellipsisTagPopoverProps: Object,
    menuProps: Object,
    filterMenuProps: Object,
    virtualScroll: {
      type: Boolean,
      default: true
    },
    checkStrategy: {
      type: String,
      default: "all"
    },
    valueField: {
      type: String,
      default: "value"
    },
    labelField: {
      type: String,
      default: "label"
    },
    childrenField: {
      type: String,
      default: "children"
    },
    renderLabel: Function,
    status: String,
    "onUpdate:value": [Function, Array],
    onUpdateValue: [Function, Array],
    "onUpdate:show": [Function, Array],
    onUpdateShow: [Function, Array],
    onBlur: Function,
    onFocus: Function,
    getColumnStyle: Function,
    renderPrefix: Function,
    renderSuffix: Function,
    // deprecated
    onChange: [Function, Array]
  });
  const Cascader = vue.defineComponent({
    name: "Cascader",
    props: cascaderProps,
    setup(props, {
      slots
    }) {
      {
        vue.watchEffect(() => {
          if (props.leafOnly) {
            warnOnce("cascader", '`leaf-only` is deprecated, please use `check-strategy="child"` instead');
          }
          if (props.onChange !== void 0) {
            warnOnce("cascader", "`on-change` is deprecated, please use `on-update:value` instead.");
          }
        });
      }
      const {
        mergedBorderedRef,
        mergedClsPrefixRef,
        namespaceRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Cascader", "-cascader", style$17, cascaderLight$1, props, mergedClsPrefixRef);
      const {
        localeRef
      } = useLocale("Cascader");
      const uncontrolledValueRef = vue.ref(props.defaultValue);
      const controlledValueRef = vue.computed(() => props.value);
      const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
      const mergedCheckStrategyRef = vue.computed(() => {
        return props.leafOnly ? "child" : props.checkStrategy;
      });
      const patternRef = vue.ref("");
      const formItem = useFormItem(props);
      const {
        mergedSizeRef,
        mergedDisabledRef,
        mergedStatusRef
      } = formItem;
      const cascaderMenuInstRef = vue.ref(null);
      const selectMenuInstRef = vue.ref(null);
      const triggerInstRef = vue.ref(null);
      const keyboardKeyRef = vue.ref(null);
      const hoverKeyRef = vue.ref(null);
      const loadingKeySetRef = vue.ref(/* @__PURE__ */ new Set());
      const selectMenuFollowerRef = vue.ref(null);
      const cascaderMenuFollowerRef = vue.ref(null);
      const adjustedToRef = useAdjustedTo(props);
      const focusedRef = vue.ref(false);
      const addLoadingKey = (key) => {
        loadingKeySetRef.value.add(key);
      };
      const deleteLoadingKey = (key) => {
        loadingKeySetRef.value.delete(key);
      };
      const treeMateRef = vue.computed(() => {
        const {
          valueField,
          childrenField,
          disabledField
        } = props;
        return createTreeMate(props.options, {
          getDisabled(node) {
            return node[disabledField];
          },
          getKey(node) {
            return node[valueField];
          },
          getChildren(node) {
            return node[childrenField];
          }
        });
      });
      const mergedKeysRef = vue.computed(() => {
        const {
          cascade,
          multiple
        } = props;
        if (multiple && Array.isArray(mergedValueRef.value)) {
          return treeMateRef.value.getCheckedKeys(mergedValueRef.value, {
            cascade,
            allowNotLoaded: props.allowCheckingNotLoaded
          });
        } else {
          return {
            checkedKeys: [],
            indeterminateKeys: []
          };
        }
      });
      const checkedKeysRef = vue.computed(() => mergedKeysRef.value.checkedKeys);
      const indeterminateKeysRef = vue.computed(() => mergedKeysRef.value.indeterminateKeys);
      const menuModelRef = vue.computed(() => {
        const {
          treeNodePath,
          treeNode
        } = treeMateRef.value.getPath(hoverKeyRef.value);
        let ret;
        if (treeNode === null) {
          ret = [treeMateRef.value.treeNodes];
        } else {
          ret = treeNodePath.map((treeNode2) => treeNode2.siblings);
          if (!treeNode.isLeaf && !loadingKeySetRef.value.has(treeNode.key) && treeNode.children) {
            ret.push(treeNode.children);
          }
        }
        return ret;
      });
      const hoverKeyPathRef = vue.computed(() => {
        const {
          keyPath
        } = treeMateRef.value.getPath(hoverKeyRef.value);
        return keyPath;
      });
      const optionHeightRef = vue.computed(() => {
        return themeRef.value.self.optionHeight;
      });
      if (vue.isReactive(props.options)) {
        vue.watch(props.options, (value, oldValue) => {
          if (!(value === oldValue)) {
            hoverKeyRef.value = null;
            keyboardKeyRef.value = null;
          }
        });
      }
      const uncontrolledShowRef = vue.ref(false);
      function doUpdateShow(value) {
        const {
          onUpdateShow,
          "onUpdate:show": _onUpdateShow
        } = props;
        if (onUpdateShow) {
          call(onUpdateShow, value);
        }
        if (_onUpdateShow) {
          call(_onUpdateShow, value);
        }
        uncontrolledShowRef.value = value;
      }
      function doUpdateValue(value, option, optionPath) {
        const {
          onUpdateValue,
          "onUpdate:value": _onUpdateValue,
          onChange
        } = props;
        const {
          nTriggerFormInput,
          nTriggerFormChange
        } = formItem;
        if (onUpdateValue) {
          call(onUpdateValue, value, option, optionPath);
        }
        if (_onUpdateValue) {
          call(_onUpdateValue, value, option, optionPath);
        }
        if (onChange) {
          call(onChange, value, option, optionPath);
        }
        uncontrolledValueRef.value = value;
        nTriggerFormInput();
        nTriggerFormChange();
      }
      function updateKeyboardKey(key) {
        keyboardKeyRef.value = key;
      }
      function updateHoverKey(key) {
        hoverKeyRef.value = key;
      }
      function getOptionsByKeys(keys2) {
        const {
          value: {
            getNode
          }
        } = treeMateRef;
        return keys2.map((keys22) => {
          var _a;
          return ((_a = getNode(keys22)) === null || _a === void 0 ? void 0 : _a.rawNode) || null;
        });
      }
      function doCheck(key) {
        var _a;
        const {
          cascade,
          multiple,
          filterable
        } = props;
        const {
          value: {
            check,
            getNode,
            getPath: getPath2
          }
        } = treeMateRef;
        if (multiple) {
          try {
            const {
              checkedKeys
            } = check(key, mergedKeysRef.value.checkedKeys, {
              cascade,
              checkStrategy: mergedCheckStrategyRef.value,
              allowNotLoaded: props.allowCheckingNotLoaded
            });
            doUpdateValue(checkedKeys, getOptionsByKeys(checkedKeys), checkedKeys.map((checkedKey) => {
              var _a2;
              return getRawNodePath((_a2 = getPath2(checkedKey)) === null || _a2 === void 0 ? void 0 : _a2.treeNodePath);
            }));
            if (filterable)
              focusSelectionInput();
            keyboardKeyRef.value = key;
            hoverKeyRef.value = key;
          } catch (err) {
            if (err instanceof SubtreeNotLoadedError) {
              if (cascaderMenuInstRef.value) {
                const tmNode = getNode(key);
                if (tmNode !== null) {
                  cascaderMenuInstRef.value.showErrorMessage(tmNode.rawNode[props.labelField]);
                }
              }
            } else {
              throw err;
            }
          }
        } else {
          if (mergedCheckStrategyRef.value === "child") {
            const tmNode = getNode(key);
            if (tmNode === null || tmNode === void 0 ? void 0 : tmNode.isLeaf) {
              doUpdateValue(key, tmNode.rawNode, getRawNodePath(getPath2(key).treeNodePath));
            } else {
              return false;
            }
          } else {
            const tmNode = getNode(key);
            doUpdateValue(key, (tmNode === null || tmNode === void 0 ? void 0 : tmNode.rawNode) || null, getRawNodePath((_a = getPath2(key)) === null || _a === void 0 ? void 0 : _a.treeNodePath));
          }
        }
        return true;
      }
      function doUncheck(key) {
        const {
          cascade,
          multiple
        } = props;
        if (multiple) {
          const {
            value: {
              uncheck,
              getNode,
              getPath: getPath2
            }
          } = treeMateRef;
          const {
            checkedKeys
          } = uncheck(key, mergedKeysRef.value.checkedKeys, {
            cascade,
            checkStrategy: mergedCheckStrategyRef.value,
            allowNotLoaded: props.allowCheckingNotLoaded
          });
          doUpdateValue(checkedKeys, checkedKeys.map((checkedKey) => {
            var _a;
            return ((_a = getNode(checkedKey)) === null || _a === void 0 ? void 0 : _a.rawNode) || null;
          }), checkedKeys.map((checkedKey) => {
            var _a;
            return getRawNodePath((_a = getPath2(checkedKey)) === null || _a === void 0 ? void 0 : _a.treeNodePath);
          }));
          keyboardKeyRef.value = key;
          hoverKeyRef.value = key;
        }
      }
      const selectedOptionsRef = vue.computed(() => {
        if (props.multiple) {
          const {
            showPath,
            separator,
            labelField,
            cascade
          } = props;
          const {
            getCheckedKeys: getCheckedKeys2,
            getNode
          } = treeMateRef.value;
          const value = getCheckedKeys2(checkedKeysRef.value, {
            cascade,
            checkStrategy: mergedCheckStrategyRef.value,
            allowNotLoaded: props.allowCheckingNotLoaded
          }).checkedKeys;
          return value.map((key) => {
            const node = getNode(key);
            if (node === null) {
              return {
                label: String(key),
                value: key
              };
            } else {
              return {
                label: showPath ? getPathLabel(node, separator, labelField) : node.rawNode[labelField],
                value: node.key
              };
            }
          });
        } else {
          return [];
        }
      });
      const selectedOptionRef = vue.computed(() => {
        const {
          multiple,
          showPath,
          separator,
          labelField
        } = props;
        const {
          value
        } = mergedValueRef;
        if (!multiple && !Array.isArray(value)) {
          const {
            getNode
          } = treeMateRef.value;
          if (value === null) {
            return null;
          }
          const node = getNode(value);
          if (node === null) {
            return {
              label: String(value),
              value
            };
          } else {
            return {
              label: showPath ? getPathLabel(node, separator, labelField) : node.rawNode[labelField],
              value: node.key
            };
          }
        } else {
          return null;
        }
      });
      const controlledShowRef = vue.toRef(props, "show");
      const mergedShowRef = useMergedState(controlledShowRef, uncontrolledShowRef);
      const localizedPlaceholderRef = vue.computed(() => {
        const {
          placeholder
        } = props;
        if (placeholder !== void 0)
          return placeholder;
        return localeRef.value.placeholder;
      });
      const showSelectMenuRef = vue.computed(() => {
        return !!(props.filterable && patternRef.value);
      });
      vue.watch(mergedShowRef, (show) => {
        if (!show)
          return;
        if (props.multiple)
          return;
        const {
          value
        } = mergedValueRef;
        if (!Array.isArray(value) && value !== null) {
          keyboardKeyRef.value = value;
          hoverKeyRef.value = value;
          void vue.nextTick(() => {
            var _a;
            if (!mergedShowRef.value)
              return;
            const {
              value: hoverKey
            } = hoverKeyRef;
            if (mergedValueRef.value !== null) {
              const node = treeMateRef.value.getNode(hoverKey);
              if (node) {
                (_a = cascaderMenuInstRef.value) === null || _a === void 0 ? void 0 : _a.scroll(node.level, node.index, depx(optionHeightRef.value));
              }
            }
          });
        } else {
          keyboardKeyRef.value = null;
          hoverKeyRef.value = null;
        }
      }, {
        immediate: true
      });
      function doBlur(e) {
        const {
          onBlur
        } = props;
        const {
          nTriggerFormBlur
        } = formItem;
        if (onBlur)
          call(onBlur, e);
        nTriggerFormBlur();
      }
      function doFocus(e) {
        const {
          onFocus
        } = props;
        const {
          nTriggerFormFocus
        } = formItem;
        if (onFocus)
          call(onFocus, e);
        nTriggerFormFocus();
      }
      function focusSelectionInput() {
        var _a;
        (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.focusInput();
      }
      function focusSelection() {
        var _a;
        (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
      }
      function openMenu() {
        if (!mergedDisabledRef.value) {
          patternRef.value = "";
          doUpdateShow(true);
          if (props.filterable) {
            focusSelectionInput();
          }
        }
      }
      function closeMenu(returnFocus = false) {
        if (returnFocus) {
          focusSelection();
        }
        doUpdateShow(false);
        patternRef.value = "";
      }
      function handleCascaderMenuClickOutside(e) {
        var _a;
        if (showSelectMenuRef.value)
          return;
        if (mergedShowRef.value) {
          if (!((_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(getPreciseEventTarget(e)))) {
            closeMenu();
          }
        }
      }
      function handleSelectMenuClickOutside(e) {
        if (!showSelectMenuRef.value)
          return;
        handleCascaderMenuClickOutside(e);
      }
      function clearPattern() {
        if (props.clearFilterAfterSelect)
          patternRef.value = "";
      }
      function move2(direction) {
        var _a, _b, _c;
        const {
          value: keyboardKey
        } = keyboardKeyRef;
        const {
          value: treeMate
        } = treeMateRef;
        switch (direction) {
          case "prev":
            if (keyboardKey !== null) {
              const node = treeMate.getPrev(keyboardKey, {
                loop: true
              });
              if (node !== null) {
                updateKeyboardKey(node.key);
                (_a = cascaderMenuInstRef.value) === null || _a === void 0 ? void 0 : _a.scroll(node.level, node.index, depx(optionHeightRef.value));
              }
            }
            break;
          case "next":
            if (keyboardKey === null) {
              const node = treeMate.getFirstAvailableNode();
              if (node !== null) {
                updateKeyboardKey(node.key);
                (_b = cascaderMenuInstRef.value) === null || _b === void 0 ? void 0 : _b.scroll(node.level, node.index, depx(optionHeightRef.value));
              }
            } else {
              const node = treeMate.getNext(keyboardKey, {
                loop: true
              });
              if (node !== null) {
                updateKeyboardKey(node.key);
                (_c = cascaderMenuInstRef.value) === null || _c === void 0 ? void 0 : _c.scroll(node.level, node.index, depx(optionHeightRef.value));
              }
            }
            break;
          case "child":
            if (keyboardKey !== null) {
              const currentNode = treeMate.getNode(keyboardKey);
              if (currentNode !== null) {
                if (currentNode.shallowLoaded) {
                  const node = treeMate.getChild(keyboardKey);
                  if (node !== null) {
                    updateHoverKey(keyboardKey);
                    updateKeyboardKey(node.key);
                  }
                } else {
                  const {
                    value: loadingKeySet
                  } = loadingKeySetRef;
                  if (!loadingKeySet.has(keyboardKey)) {
                    addLoadingKey(keyboardKey);
                    updateHoverKey(keyboardKey);
                    const {
                      onLoad
                    } = props;
                    if (onLoad) {
                      onLoad(currentNode.rawNode).then(() => {
                        deleteLoadingKey(keyboardKey);
                      }).catch(() => {
                        deleteLoadingKey(keyboardKey);
                      });
                    }
                  }
                }
              }
            }
            break;
          case "parent":
            if (keyboardKey !== null) {
              const node = treeMate.getParent(keyboardKey);
              if (node !== null) {
                updateKeyboardKey(node.key);
                const parentNode = node.getParent();
                if (parentNode === null) {
                  updateHoverKey(null);
                } else {
                  updateHoverKey(parentNode.key);
                }
              }
            }
            break;
        }
      }
      function handleKeydown(e) {
        var _a, _b;
        switch (e.key) {
          case " ":
          case "ArrowDown":
          case "ArrowUp":
            if (props.filterable && mergedShowRef.value) {
              break;
            }
            e.preventDefault();
            break;
        }
        if (happensIn(e, "action"))
          return;
        switch (e.key) {
          case " ":
            if (props.filterable)
              return;
          case "Enter":
            if (!mergedShowRef.value) {
              openMenu();
            } else {
              const {
                value: showSelectMenu
              } = showSelectMenuRef;
              const {
                value: keyboardKey
              } = keyboardKeyRef;
              if (!showSelectMenu) {
                if (keyboardKey !== null) {
                  if (checkedKeysRef.value.includes(keyboardKey) || indeterminateKeysRef.value.includes(keyboardKey)) {
                    doUncheck(keyboardKey);
                  } else {
                    const checkIsValid = doCheck(keyboardKey);
                    if (!props.multiple && checkIsValid) {
                      closeMenu(true);
                    }
                  }
                }
              } else {
                if (selectMenuInstRef.value) {
                  const hasCorrespondingOption = selectMenuInstRef.value.enter();
                  if (hasCorrespondingOption)
                    clearPattern();
                }
              }
            }
            break;
          case "ArrowUp":
            e.preventDefault();
            if (mergedShowRef.value) {
              if (showSelectMenuRef.value) {
                (_a = selectMenuInstRef.value) === null || _a === void 0 ? void 0 : _a.prev();
              } else {
                move2("prev");
              }
            }
            break;
          case "ArrowDown":
            e.preventDefault();
            if (mergedShowRef.value) {
              if (showSelectMenuRef.value) {
                (_b = selectMenuInstRef.value) === null || _b === void 0 ? void 0 : _b.next();
              } else {
                move2("next");
              }
            } else {
              openMenu();
            }
            break;
          case "ArrowLeft":
            e.preventDefault();
            if (mergedShowRef.value && !showSelectMenuRef.value) {
              move2("parent");
            }
            break;
          case "ArrowRight":
            e.preventDefault();
            if (mergedShowRef.value && !showSelectMenuRef.value) {
              move2("child");
            }
            break;
          case "Escape":
            if (mergedShowRef.value) {
              markEventEffectPerformed(e);
              closeMenu(true);
            }
        }
      }
      function handleMenuKeydown(e) {
        handleKeydown(e);
      }
      function handleClear(e) {
        e.stopPropagation();
        if (props.multiple) {
          doUpdateValue([], [], []);
        } else {
          doUpdateValue(null, null, null);
        }
      }
      function handleTriggerFocus(e) {
        var _a;
        if (!((_a = cascaderMenuInstRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(e.relatedTarget))) {
          focusedRef.value = true;
          doFocus(e);
        }
      }
      function handleTriggerBlur(e) {
        var _a;
        if (!((_a = cascaderMenuInstRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(e.relatedTarget))) {
          focusedRef.value = false;
          doBlur(e);
          closeMenu();
        }
      }
      function handleMenuFocus(e) {
        var _a;
        if (!((_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(e.relatedTarget))) {
          focusedRef.value = true;
          doFocus(e);
        }
      }
      function handleMenuBlur(e) {
        var _a;
        if (!((_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(e.relatedTarget))) {
          focusedRef.value = false;
          doBlur(e);
        }
      }
      function handleMenuMousedown(e) {
        if (!happensIn(e, "action")) {
          if (props.multiple && props.filter) {
            e.preventDefault();
            focusSelectionInput();
          }
        }
      }
      function handleMenuTabout() {
        closeMenu(true);
      }
      function handleTriggerClick() {
        if (props.filterable) {
          openMenu();
        } else {
          if (mergedShowRef.value) {
            closeMenu(true);
          } else {
            openMenu();
          }
        }
      }
      function handlePatternInput(e) {
        patternRef.value = e.target.value;
      }
      function handleDeleteOption(option) {
        const {
          multiple
        } = props;
        const {
          value: mergedValue
        } = mergedValueRef;
        if (multiple && Array.isArray(mergedValue) && option.value !== void 0) {
          doUncheck(option.value);
        } else {
          doUpdateValue(null, null, null);
        }
      }
      function syncSelectMenuPosition() {
        var _a;
        (_a = selectMenuFollowerRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
      }
      function syncCascaderMenuPosition() {
        var _a;
        (_a = cascaderMenuFollowerRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
      }
      function handleTriggerResize() {
        if (mergedShowRef.value) {
          if (showSelectMenuRef.value) {
            syncSelectMenuPosition();
          } else {
            syncCascaderMenuPosition();
          }
        }
      }
      const showCheckboxRef = vue.computed(() => {
        if (props.multiple && props.cascade)
          return true;
        if (mergedCheckStrategyRef.value !== "child")
          return true;
        return false;
      });
      vue.provide(cascaderInjectionKey, {
        slots,
        mergedClsPrefixRef,
        mergedThemeRef: themeRef,
        mergedValueRef,
        checkedKeysRef,
        indeterminateKeysRef,
        hoverKeyPathRef,
        mergedCheckStrategyRef,
        showCheckboxRef,
        cascadeRef: vue.toRef(props, "cascade"),
        multipleRef: vue.toRef(props, "multiple"),
        keyboardKeyRef,
        hoverKeyRef,
        remoteRef: vue.toRef(props, "remote"),
        loadingKeySetRef,
        expandTriggerRef: vue.toRef(props, "expandTrigger"),
        isMountedRef: isMounted(),
        onLoadRef: vue.toRef(props, "onLoad"),
        virtualScrollRef: vue.toRef(props, "virtualScroll"),
        optionHeightRef,
        localeRef,
        labelFieldRef: vue.toRef(props, "labelField"),
        renderLabelRef: vue.toRef(props, "renderLabel"),
        getColumnStyleRef: vue.toRef(props, "getColumnStyle"),
        renderPrefixRef: vue.toRef(props, "renderPrefix"),
        renderSuffixRef: vue.toRef(props, "renderSuffix"),
        syncCascaderMenuPosition,
        syncSelectMenuPosition,
        updateKeyboardKey,
        updateHoverKey,
        addLoadingKey,
        deleteLoadingKey,
        doCheck,
        doUncheck,
        closeMenu,
        handleSelectMenuClickOutside,
        handleCascaderMenuClickOutside,
        clearPattern
      });
      const exposedMethods = {
        focus: () => {
          var _a;
          (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
        },
        blur: () => {
          var _a;
          (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.blur();
        },
        getCheckedData: () => {
          if (showCheckboxRef.value) {
            const checkedKeys = checkedKeysRef.value;
            return {
              keys: checkedKeys,
              options: getOptionsByKeys(checkedKeys)
            };
          }
          return {
            keys: [],
            options: []
          };
        },
        getIndeterminateData: () => {
          if (showCheckboxRef.value) {
            const indeterminateKeys = indeterminateKeysRef.value;
            return {
              keys: indeterminateKeys,
              options: getOptionsByKeys(indeterminateKeys)
            };
          }
          return {
            keys: [],
            options: []
          };
        }
      };
      const cssVarsRef = vue.computed(() => {
        const {
          self: {
            optionArrowColor,
            optionTextColor,
            optionTextColorActive,
            optionTextColorDisabled,
            optionCheckMarkColor,
            menuColor,
            menuBoxShadow,
            menuDividerColor,
            menuBorderRadius,
            menuHeight,
            optionColorHover,
            optionHeight,
            optionFontSize,
            loadingColor,
            columnWidth
          },
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-menu-border-radius": menuBorderRadius,
          "--n-menu-box-shadow": menuBoxShadow,
          "--n-menu-height": menuHeight,
          "--n-column-width": columnWidth,
          "--n-menu-color": menuColor,
          "--n-menu-divider-color": menuDividerColor,
          "--n-option-height": optionHeight,
          "--n-option-font-size": optionFontSize,
          "--n-option-text-color": optionTextColor,
          "--n-option-text-color-disabled": optionTextColorDisabled,
          "--n-option-text-color-active": optionTextColorActive,
          "--n-option-color-hover": optionColorHover,
          "--n-option-check-mark-color": optionCheckMarkColor,
          "--n-option-arrow-color": optionArrowColor,
          "--n-menu-mask-color": changeColor(menuColor, {
            alpha: 0.75
          }),
          "--n-loading-color": loadingColor
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("cascader", void 0, cssVarsRef, props) : void 0;
      return Object.assign(Object.assign({}, exposedMethods), {
        handleTriggerResize,
        mergedStatus: mergedStatusRef,
        selectMenuFollowerRef,
        cascaderMenuFollowerRef,
        triggerInstRef,
        selectMenuInstRef,
        cascaderMenuInstRef,
        mergedBordered: mergedBorderedRef,
        mergedClsPrefix: mergedClsPrefixRef,
        namespace: namespaceRef,
        mergedValue: mergedValueRef,
        mergedShow: mergedShowRef,
        showSelectMenu: showSelectMenuRef,
        pattern: patternRef,
        treeMate: treeMateRef,
        mergedSize: mergedSizeRef,
        mergedDisabled: mergedDisabledRef,
        localizedPlaceholder: localizedPlaceholderRef,
        selectedOption: selectedOptionRef,
        selectedOptions: selectedOptionsRef,
        adjustedTo: adjustedToRef,
        menuModel: menuModelRef,
        handleMenuTabout,
        handleMenuFocus,
        handleMenuBlur,
        handleMenuKeydown,
        handleMenuMousedown,
        handleTriggerFocus,
        handleTriggerBlur,
        handleTriggerClick,
        handleClear,
        handleDeleteOption,
        handlePatternInput,
        handleKeydown,
        focused: focusedRef,
        optionHeight: optionHeightRef,
        mergedTheme: themeRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      });
    },
    render() {
      const {
        mergedClsPrefix
      } = this;
      return vue.h("div", {
        class: `${mergedClsPrefix}-cascader`
      }, vue.h(VBinder, null, {
        default: () => [vue.h(VTarget, null, {
          default: () => vue.h(NInternalSelection, {
            onResize: this.handleTriggerResize,
            ref: "triggerInstRef",
            status: this.mergedStatus,
            clsPrefix: mergedClsPrefix,
            maxTagCount: this.maxTagCount,
            ellipsisTagPopoverProps: this.ellipsisTagPopoverProps,
            bordered: this.mergedBordered,
            size: this.mergedSize,
            theme: this.mergedTheme.peers.InternalSelection,
            themeOverrides: this.mergedTheme.peerOverrides.InternalSelection,
            active: this.mergedShow,
            pattern: this.pattern,
            placeholder: this.localizedPlaceholder,
            selectedOption: this.selectedOption,
            selectedOptions: this.selectedOptions,
            multiple: this.multiple,
            filterable: this.filterable,
            clearable: this.clearable,
            disabled: this.mergedDisabled,
            focused: this.focused,
            onFocus: this.handleTriggerFocus,
            onBlur: this.handleTriggerBlur,
            onClick: this.handleTriggerClick,
            onClear: this.handleClear,
            onDeleteOption: this.handleDeleteOption,
            onPatternInput: this.handlePatternInput,
            onKeydown: this.handleKeydown
          }, {
            arrow: () => {
              var _a, _b;
              return (_b = (_a = this.$slots).arrow) === null || _b === void 0 ? void 0 : _b.call(_a);
            }
          })
        }), vue.h(VFollower, {
          key: "cascaderMenu",
          ref: "cascaderMenuFollowerRef",
          show: this.mergedShow && !this.showSelectMenu,
          containerClass: this.namespace,
          placement: this.placement,
          width: !this.options.length ? "target" : void 0,
          teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey,
          to: this.adjustedTo
        }, {
          default: () => {
            var _a;
            (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
            const {
              menuProps: menuProps2
            } = this;
            return vue.h(CascaderMenu, Object.assign({}, menuProps2, {
              ref: "cascaderMenuInstRef",
              class: [this.themeClass, menuProps2 === null || menuProps2 === void 0 ? void 0 : menuProps2.class],
              value: this.mergedValue,
              show: this.mergedShow && !this.showSelectMenu,
              menuModel: this.menuModel,
              style: [this.cssVars, menuProps2 === null || menuProps2 === void 0 ? void 0 : menuProps2.style],
              onFocus: this.handleMenuFocus,
              onBlur: this.handleMenuBlur,
              onKeydown: this.handleMenuKeydown,
              onMousedown: this.handleMenuMousedown,
              onTabout: this.handleMenuTabout
            }), {
              action: () => {
                var _a2, _b;
                return (_b = (_a2 = this.$slots).action) === null || _b === void 0 ? void 0 : _b.call(_a2);
              },
              empty: () => {
                var _a2, _b;
                return (_b = (_a2 = this.$slots).empty) === null || _b === void 0 ? void 0 : _b.call(_a2);
              }
            });
          }
        }), vue.h(VFollower, {
          key: "selectMenu",
          ref: "selectMenuFollowerRef",
          show: this.mergedShow && this.showSelectMenu,
          containerClass: this.namespace,
          width: "target",
          placement: this.placement,
          to: this.adjustedTo,
          teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey
        }, {
          default: () => {
            var _a;
            (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
            const {
              filterMenuProps
            } = this;
            return vue.h(CascaderSelectMenu, Object.assign({}, filterMenuProps, {
              ref: "selectMenuInstRef",
              class: [this.themeClass, filterMenuProps === null || filterMenuProps === void 0 ? void 0 : filterMenuProps.class],
              value: this.mergedValue,
              show: this.mergedShow && this.showSelectMenu,
              pattern: this.pattern,
              multiple: this.multiple,
              tmNodes: this.treeMate.treeNodes,
              filter: this.filter,
              labelField: this.labelField,
              separator: this.separator,
              style: [this.cssVars, filterMenuProps === null || filterMenuProps === void 0 ? void 0 : filterMenuProps.style]
            }));
          }
        })]
      }));
    }
  });
  function self$X(vars) {
    const {
      textColor2,
      fontSize: fontSize2,
      fontWeightStrong,
      textColor3
    } = vars;
    return {
      textColor: textColor2,
      fontSize: fontSize2,
      fontWeightStrong,
      // extracted from hljs atom-one-light.scss
      "mono-3": "#a0a1a7",
      "hue-1": "#0184bb",
      "hue-2": "#4078f2",
      "hue-3": "#a626a4",
      "hue-4": "#50a14f",
      "hue-5": "#e45649",
      "hue-5-2": "#c91243",
      "hue-6": "#986801",
      "hue-6-2": "#c18401",
      // line-number styles
      lineNumberTextColor: textColor3
    };
  }
  const codeLight = {
    name: "Code",
    common: commonLight,
    self: self$X
  };
  const codeLight$1 = codeLight;
  const style$16 = c$1([cB("code", `
 font-size: var(--n-font-size);
 font-family: var(--n-font-family);
 `, [cM("show-line-numbers", `
 display: flex;
 `), cE("line-numbers", `
 user-select: none;
 padding-right: 12px;
 text-align: right;
 transition: color .3s var(--n-bezier);
 color: var(--n-line-number-text-color);
 `), cM("word-wrap", [c$1("pre", `
 white-space: pre-wrap;
 word-break: break-all;
 `)]), c$1("pre", `
 margin: 0;
 line-height: inherit;
 font-size: inherit;
 font-family: inherit;
 `), c$1("[class^=hljs]", `
 color: var(--n-text-color);
 transition: 
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `)]), ({
    props
  }) => {
    const codeClass = `${props.bPrefix}code`;
    return [`${codeClass} .hljs-comment,
 ${codeClass} .hljs-quote {
 color: var(--n-mono-3);
 font-style: italic;
 }`, `${codeClass} .hljs-doctag,
 ${codeClass} .hljs-keyword,
 ${codeClass} .hljs-formula {
 color: var(--n-hue-3);
 }`, `${codeClass} .hljs-section,
 ${codeClass} .hljs-name,
 ${codeClass} .hljs-selector-tag,
 ${codeClass} .hljs-deletion,
 ${codeClass} .hljs-subst {
 color: var(--n-hue-5);
 }`, `${codeClass} .hljs-literal {
 color: var(--n-hue-1);
 }`, `${codeClass} .hljs-string,
 ${codeClass} .hljs-regexp,
 ${codeClass} .hljs-addition,
 ${codeClass} .hljs-attribute,
 ${codeClass} .hljs-meta-string {
 color: var(--n-hue-4);
 }`, `${codeClass} .hljs-built_in,
 ${codeClass} .hljs-class .hljs-title {
 color: var(--n-hue-6-2);
 }`, `${codeClass} .hljs-attr,
 ${codeClass} .hljs-variable,
 ${codeClass} .hljs-template-variable,
 ${codeClass} .hljs-type,
 ${codeClass} .hljs-selector-class,
 ${codeClass} .hljs-selector-attr,
 ${codeClass} .hljs-selector-pseudo,
 ${codeClass} .hljs-number {
 color: var(--n-hue-6);
 }`, `${codeClass} .hljs-symbol,
 ${codeClass} .hljs-bullet,
 ${codeClass} .hljs-link,
 ${codeClass} .hljs-meta,
 ${codeClass} .hljs-selector-id,
 ${codeClass} .hljs-title {
 color: var(--n-hue-2);
 }`, `${codeClass} .hljs-emphasis {
 font-style: italic;
 }`, `${codeClass} .hljs-strong {
 font-weight: var(--n-font-weight-strong);
 }`, `${codeClass} .hljs-link {
 text-decoration: underline;
 }`];
  }]);
  const codeProps = Object.assign(Object.assign({}, useTheme.props), {
    language: String,
    code: {
      type: String,
      default: ""
    },
    trim: {
      type: Boolean,
      default: true
    },
    hljs: Object,
    uri: Boolean,
    inline: Boolean,
    wordWrap: Boolean,
    showLineNumbers: Boolean,
    // In n-log, we only need to mount code's style for highlight
    internalFontSize: Number,
    internalNoHighlight: Boolean
  });
  const NCode = vue.defineComponent({
    name: "Code",
    props: codeProps,
    setup(props, {
      slots
    }) {
      const {
        internalNoHighlight
      } = props;
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig();
      const codeRef = vue.ref(null);
      const hljsRef = internalNoHighlight ? {
        value: void 0
      } : useHljs(props);
      const createCodeHtml = (language, code, trim) => {
        const {
          value: hljs
        } = hljsRef;
        if (!hljs) {
          return null;
        }
        if (!(language && hljs.getLanguage(language))) {
          return null;
        }
        return hljs.highlight(trim ? code.trim() : code, {
          language
        }).value;
      };
      const mergedShowLineNumbersRef = vue.computed(() => {
        if (props.inline || props.wordWrap)
          return false;
        return props.showLineNumbers;
      });
      const setCode = () => {
        if (slots.default)
          return;
        const {
          value: codeEl
        } = codeRef;
        if (!codeEl)
          return;
        const {
          language
        } = props;
        const code = props.uri ? window.decodeURIComponent(props.code) : props.code;
        if (language) {
          const html = createCodeHtml(language, code, props.trim);
          if (html !== null) {
            if (props.inline) {
              codeEl.innerHTML = html;
            } else {
              const prevPreEl = codeEl.querySelector(".__code__");
              if (prevPreEl)
                codeEl.removeChild(prevPreEl);
              const preEl = document.createElement("pre");
              preEl.className = "__code__";
              preEl.innerHTML = html;
              codeEl.appendChild(preEl);
            }
            return;
          }
        }
        if (props.inline) {
          codeEl.textContent = code;
          return;
        }
        const maybePreEl = codeEl.querySelector(".__code__");
        if (maybePreEl) {
          maybePreEl.textContent = code;
        } else {
          const wrap = document.createElement("pre");
          wrap.className = "__code__";
          wrap.textContent = code;
          codeEl.innerHTML = "";
          codeEl.appendChild(wrap);
        }
      };
      vue.onMounted(setCode);
      vue.watch(vue.toRef(props, "language"), setCode);
      vue.watch(vue.toRef(props, "code"), setCode);
      if (!internalNoHighlight)
        vue.watch(hljsRef, setCode);
      const themeRef = useTheme("Code", "-code", style$16, codeLight$1, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2,
            fontFamilyMono
          },
          self: {
            textColor,
            fontSize: fontSize2,
            fontWeightStrong,
            lineNumberTextColor,
            // extracted from hljs atom-one-light.scss
            "mono-3": $1,
            "hue-1": $2,
            "hue-2": $3,
            "hue-3": $4,
            "hue-4": $5,
            "hue-5": $6,
            "hue-5-2": $7,
            "hue-6": $8,
            "hue-6-2": $9
          }
        } = themeRef.value;
        const {
          internalFontSize
        } = props;
        return {
          "--n-font-size": internalFontSize ? `${internalFontSize}px` : fontSize2,
          "--n-font-family": fontFamilyMono,
          "--n-font-weight-strong": fontWeightStrong,
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-text-color": textColor,
          "--n-mono-3": $1,
          "--n-hue-1": $2,
          "--n-hue-2": $3,
          "--n-hue-3": $4,
          "--n-hue-4": $5,
          "--n-hue-5": $6,
          "--n-hue-5-2": $7,
          "--n-hue-6": $8,
          "--n-hue-6-2": $9,
          "--n-line-number-text-color": lineNumberTextColor
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("code", vue.computed(() => {
        return `${props.internalFontSize || "a"}`;
      }), cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        codeRef,
        mergedShowLineNumbers: mergedShowLineNumbersRef,
        lineNumbers: vue.computed(() => {
          let number = 1;
          const numbers = [];
          let lastIsLineWrap = false;
          for (const char of props.code) {
            if (char === "\n") {
              lastIsLineWrap = true;
              numbers.push(number++);
            } else {
              lastIsLineWrap = false;
            }
          }
          if (!lastIsLineWrap) {
            numbers.push(number++);
          }
          return numbers.join("\n");
        }),
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a, _b;
      const {
        mergedClsPrefix,
        wordWrap,
        mergedShowLineNumbers,
        onRender
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h("code", {
        class: [`${mergedClsPrefix}-code`, this.themeClass, wordWrap && `${mergedClsPrefix}-code--word-wrap`, mergedShowLineNumbers && `${mergedClsPrefix}-code--show-line-numbers`],
        style: this.cssVars,
        ref: "codeRef"
      }, mergedShowLineNumbers ? vue.h("pre", {
        class: `${mergedClsPrefix}-code__line-numbers`
      }, this.lineNumbers) : null, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a));
    }
  });
  function self$W(vars) {
    const {
      fontWeight,
      textColor1,
      textColor2,
      textColorDisabled,
      dividerColor,
      fontSize: fontSize2
    } = vars;
    return {
      titleFontSize: fontSize2,
      titleFontWeight: fontWeight,
      dividerColor,
      titleTextColor: textColor1,
      titleTextColorDisabled: textColorDisabled,
      fontSize: fontSize2,
      textColor: textColor2,
      arrowColor: textColor2,
      arrowColorDisabled: textColorDisabled,
      itemMargin: "16px 0 0 0",
      titlePadding: "16px 0 0 0"
    };
  }
  const collapseLight = {
    name: "Collapse",
    common: commonLight,
    self: self$W
  };
  const collapseLight$1 = collapseLight;
  const style$15 = cB("collapse", "width: 100%;", [cB("collapse-item", `
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 margin: var(--n-item-margin);
 `, [cM("disabled", [cE("header", "cursor: not-allowed;", [cE("header-main", `
 color: var(--n-title-text-color-disabled);
 `), cB("collapse-item-arrow", `
 color: var(--n-arrow-color-disabled);
 `)])]), cB("collapse-item", "margin-left: 32px;"), c$1("&:first-child", "margin-top: 0;"), c$1("&:first-child >", [cE("header", "padding-top: 0;")]), cM("left-arrow-placement", [cE("header", [cB("collapse-item-arrow", "margin-right: 4px;")])]), cM("right-arrow-placement", [cE("header", [cB("collapse-item-arrow", "margin-left: 4px;")])]), cE("content-wrapper", [cE("content-inner", "padding-top: 16px;"), fadeInHeightExpandTransition({
    duration: "0.15s"
  })]), cM("active", [cE("header", [cM("active", [cB("collapse-item-arrow", "transform: rotate(90deg);")])])]), c$1("&:not(:first-child)", "border-top: 1px solid var(--n-divider-color);"), cNotM("disabled", [cM("trigger-area-main", [cE("header", [cE("header-main", "cursor: pointer;"), cB("collapse-item-arrow", "cursor: default;")])]), cM("trigger-area-arrow", [cE("header", [cB("collapse-item-arrow", "cursor: pointer;")])]), cM("trigger-area-extra", [cE("header", [cE("header-extra", "cursor: pointer;")])])]), cE("header", `
 font-size: var(--n-title-font-size);
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 transition: color .3s var(--n-bezier);
 position: relative;
 padding: var(--n-title-padding);
 color: var(--n-title-text-color);
 `, [cE("header-main", `
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 flex: 1;
 color: var(--n-title-text-color);
 `), cE("header-extra", `
 display: flex;
 align-items: center;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), cB("collapse-item-arrow", `
 display: flex;
 transition:
 transform .15s var(--n-bezier),
 color .3s var(--n-bezier);
 font-size: 18px;
 color: var(--n-arrow-color);
 `)])])]);
  const collapseProps = Object.assign(Object.assign({}, useTheme.props), {
    defaultExpandedNames: {
      type: [Array, String],
      default: null
    },
    expandedNames: [Array, String],
    arrowPlacement: {
      type: String,
      default: "left"
    },
    accordion: {
      type: Boolean,
      default: false
    },
    displayDirective: {
      type: String,
      default: "if"
    },
    triggerAreas: {
      type: Array,
      default: () => ["main", "extra", "arrow"]
    },
    onItemHeaderClick: [Function, Array],
    "onUpdate:expandedNames": [Function, Array],
    onUpdateExpandedNames: [Function, Array],
    // deprecated
    onExpandedNamesChange: {
      type: [Function, Array],
      validator: () => {
        {
          warn$2("collapse", "`on-expanded-names-change` is deprecated, please use `on-update:expanded-names` instead.");
        }
        return true;
      },
      default: void 0
    }
  });
  const collapseInjectionKey = createInjectionKey("n-collapse");
  const NCollapse = vue.defineComponent({
    name: "Collapse",
    props: collapseProps,
    setup(props, {
      slots
    }) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled,
        mergedRtlRef
      } = useConfig(props);
      const uncontrolledExpandedNamesRef = vue.ref(props.defaultExpandedNames);
      const controlledExpandedNamesRef = vue.computed(() => props.expandedNames);
      const mergedExpandedNamesRef = useMergedState(controlledExpandedNamesRef, uncontrolledExpandedNamesRef);
      const themeRef = useTheme("Collapse", "-collapse", style$15, collapseLight$1, props, mergedClsPrefixRef);
      function doUpdateExpandedNames(names) {
        const {
          "onUpdate:expandedNames": _onUpdateExpandedNames,
          onUpdateExpandedNames,
          onExpandedNamesChange
        } = props;
        if (onUpdateExpandedNames) {
          call(onUpdateExpandedNames, names);
        }
        if (_onUpdateExpandedNames) {
          call(_onUpdateExpandedNames, names);
        }
        if (onExpandedNamesChange) {
          call(onExpandedNamesChange, names);
        }
        uncontrolledExpandedNamesRef.value = names;
      }
      function doItemHeaderClick(info) {
        const {
          onItemHeaderClick
        } = props;
        if (onItemHeaderClick) {
          call(onItemHeaderClick, info);
        }
      }
      function toggleItem(collapse, name, event) {
        const {
          accordion
        } = props;
        const {
          value: expandedNames
        } = mergedExpandedNamesRef;
        if (accordion) {
          if (collapse) {
            doUpdateExpandedNames([name]);
            doItemHeaderClick({
              name,
              expanded: true,
              event
            });
          } else {
            doUpdateExpandedNames([]);
            doItemHeaderClick({
              name,
              expanded: false,
              event
            });
          }
        } else {
          if (!Array.isArray(expandedNames)) {
            doUpdateExpandedNames([name]);
            doItemHeaderClick({
              name,
              expanded: true,
              event
            });
          } else {
            const activeNames = expandedNames.slice();
            const index = activeNames.findIndex((activeName) => name === activeName);
            if (~index) {
              activeNames.splice(index, 1);
              doUpdateExpandedNames(activeNames);
              doItemHeaderClick({
                name,
                expanded: false,
                event
              });
            } else {
              activeNames.push(name);
              doUpdateExpandedNames(activeNames);
              doItemHeaderClick({
                name,
                expanded: true,
                event
              });
            }
          }
        }
      }
      vue.provide(collapseInjectionKey, {
        props,
        mergedClsPrefixRef,
        expandedNamesRef: mergedExpandedNamesRef,
        slots,
        toggleItem
      });
      const rtlEnabledRef = useRtl("Collapse", mergedRtlRef, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            titleFontWeight,
            dividerColor,
            titlePadding,
            titleTextColor,
            titleTextColorDisabled,
            textColor,
            arrowColor,
            fontSize: fontSize2,
            titleFontSize,
            arrowColorDisabled,
            itemMargin
          }
        } = themeRef.value;
        return {
          "--n-font-size": fontSize2,
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-text-color": textColor,
          "--n-divider-color": dividerColor,
          "--n-title-padding": titlePadding,
          "--n-title-font-size": titleFontSize,
          "--n-title-text-color": titleTextColor,
          "--n-title-text-color-disabled": titleTextColorDisabled,
          "--n-title-font-weight": titleFontWeight,
          "--n-arrow-color": arrowColor,
          "--n-arrow-color-disabled": arrowColorDisabled,
          "--n-item-margin": itemMargin
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("collapse", void 0, cssVarsRef, props) : void 0;
      return {
        rtlEnabled: rtlEnabledRef,
        mergedTheme: themeRef,
        mergedClsPrefix: mergedClsPrefixRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      return vue.h("div", {
        class: [`${this.mergedClsPrefix}-collapse`, this.rtlEnabled && `${this.mergedClsPrefix}-collapse--rtl`, this.themeClass],
        style: this.cssVars
      }, this.$slots);
    }
  });
  const NCollapseItemContent = vue.defineComponent({
    name: "CollapseItemContent",
    props: {
      displayDirective: {
        type: String,
        required: true
      },
      show: Boolean,
      clsPrefix: {
        type: String,
        required: true
      }
    },
    setup(props) {
      const onceTrueRef = useFalseUntilTruthy(vue.toRef(props, "show"));
      return {
        onceTrue: onceTrueRef
      };
    },
    render() {
      return vue.h(NFadeInExpandTransition, null, {
        default: () => {
          const {
            show,
            displayDirective,
            onceTrue,
            clsPrefix
          } = this;
          const useVShow = displayDirective === "show" && onceTrue;
          const contentNode = vue.h("div", {
            class: `${clsPrefix}-collapse-item__content-wrapper`
          }, vue.h("div", {
            class: `${clsPrefix}-collapse-item__content-inner`
          }, this.$slots));
          return useVShow ? vue.withDirectives(contentNode, [[vue.vShow, show]]) : show ? contentNode : null;
        }
      });
    }
  });
  const collapseItemProps = {
    title: String,
    name: [String, Number],
    disabled: Boolean,
    displayDirective: String
  };
  const NCollapseItem = vue.defineComponent({
    name: "CollapseItem",
    props: collapseItemProps,
    setup(props) {
      const {
        mergedRtlRef
      } = useConfig(props);
      const randomName = createId();
      const mergedNameRef = useMemo(() => {
        var _a;
        return (_a = props.name) !== null && _a !== void 0 ? _a : randomName;
      });
      const NCollapse2 = vue.inject(collapseInjectionKey);
      if (!NCollapse2) {
        throwError("collapse-item", "`n-collapse-item` must be placed inside `n-collapse`.");
      }
      const {
        expandedNamesRef,
        props: collapseProps2,
        mergedClsPrefixRef,
        slots: collapseSlots
      } = NCollapse2;
      const collapsedRef = vue.computed(() => {
        const {
          value: expandedNames
        } = expandedNamesRef;
        if (Array.isArray(expandedNames)) {
          const {
            value: name
          } = mergedNameRef;
          return !~expandedNames.findIndex((expandedName) => expandedName === name);
        } else if (expandedNames) {
          const {
            value: name
          } = mergedNameRef;
          return name !== expandedNames;
        }
        return true;
      });
      const rtlEnabledRef = useRtl("Collapse", mergedRtlRef, mergedClsPrefixRef);
      return {
        rtlEnabled: rtlEnabledRef,
        collapseSlots,
        randomName,
        mergedClsPrefix: mergedClsPrefixRef,
        collapsed: collapsedRef,
        triggerAreas: vue.toRef(collapseProps2, "triggerAreas"),
        mergedDisplayDirective: vue.computed(() => {
          const {
            displayDirective
          } = props;
          if (displayDirective) {
            return displayDirective;
          } else {
            return collapseProps2.displayDirective;
          }
        }),
        arrowPlacement: vue.computed(() => {
          return collapseProps2.arrowPlacement;
        }),
        handleClick(e) {
          let happensInArea = "main";
          if (happensIn(e, "arrow"))
            happensInArea = "arrow";
          if (happensIn(e, "extra"))
            happensInArea = "extra";
          if (!collapseProps2.triggerAreas.includes(happensInArea)) {
            return;
          }
          if (NCollapse2 && !props.disabled) {
            NCollapse2.toggleItem(collapsedRef.value, mergedNameRef.value, e);
          }
        }
      };
    },
    render() {
      const {
        collapseSlots,
        $slots,
        arrowPlacement,
        collapsed,
        mergedDisplayDirective,
        mergedClsPrefix,
        disabled,
        triggerAreas
      } = this;
      const headerNode = resolveSlotWithProps($slots.header, {
        collapsed
      }, () => [this.title]);
      const headerExtraSlot = $slots["header-extra"] || collapseSlots["header-extra"];
      const arrowSlot = $slots.arrow || collapseSlots.arrow;
      return vue.h("div", {
        class: [`${mergedClsPrefix}-collapse-item`, `${mergedClsPrefix}-collapse-item--${arrowPlacement}-arrow-placement`, disabled && `${mergedClsPrefix}-collapse-item--disabled`, !collapsed && `${mergedClsPrefix}-collapse-item--active`, triggerAreas.map((area) => {
          return `${mergedClsPrefix}-collapse-item--trigger-area-${area}`;
        })]
      }, vue.h("div", {
        class: [`${mergedClsPrefix}-collapse-item__header`, !collapsed && `${mergedClsPrefix}-collapse-item__header--active`]
      }, vue.h("div", {
        class: `${mergedClsPrefix}-collapse-item__header-main`,
        onClick: this.handleClick
      }, arrowPlacement === "right" && headerNode, vue.h("div", {
        class: `${mergedClsPrefix}-collapse-item-arrow`,
        key: this.rtlEnabled ? 0 : 1,
        "data-arrow": true
      }, resolveSlotWithProps(arrowSlot, {
        collapsed
      }, () => {
        var _a;
        return [vue.h(NBaseIcon, {
          clsPrefix: mergedClsPrefix
        }, {
          default: (_a = collapseSlots.expandIcon) !== null && _a !== void 0 ? _a : () => this.rtlEnabled ? vue.h(ChevronLeftIcon, null) : vue.h(ChevronRightIcon, null)
        })];
      })), arrowPlacement === "left" && headerNode), resolveWrappedSlotWithProps(headerExtraSlot, {
        collapsed
      }, (children) => vue.h("div", {
        class: `${mergedClsPrefix}-collapse-item__header-extra`,
        onClick: this.handleClick,
        "data-extra": true
      }, children))), vue.h(NCollapseItemContent, {
        clsPrefix: mergedClsPrefix,
        displayDirective: mergedDisplayDirective,
        show: !collapsed
      }, $slots));
    }
  });
  function self$V(vars) {
    const {
      cubicBezierEaseInOut: cubicBezierEaseInOut2
    } = vars;
    return {
      bezier: cubicBezierEaseInOut2
    };
  }
  const collapseTransitionLight = {
    name: "CollapseTransition",
    common: commonLight,
    self: self$V
  };
  const collapseTransitionLight$1 = collapseTransitionLight;
  const style$14 = cB("collapse-transition", {
    width: "100%"
  }, [fadeInHeightExpandTransition()]);
  const collapseTransitionProps = Object.assign(Object.assign({}, useTheme.props), {
    show: {
      type: Boolean,
      default: true
    },
    appear: Boolean,
    // The collapsed is implemented with mistake, collapsed=true would make it show
    // However there's no possibility to change so I just let it deprecated and use
    // `show` prop instead.
    /** @deprecated */
    collapsed: {
      type: Boolean,
      default: void 0
    }
  });
  const CollapseTransition = vue.defineComponent({
    name: "CollapseTransition",
    props: collapseTransitionProps,
    inheritAttrs: false,
    setup(props) {
      {
        vue.watchEffect(() => {
          if (props.collapsed !== void 0) {
            warnOnce("collapse-transition", "`collapsed` is deprecated, please use `show` instead");
          }
        });
      }
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled,
        mergedRtlRef
      } = useConfig(props);
      const mergedThemeRef = useTheme("CollapseTransition", "-collapse-transition", style$14, collapseTransitionLight$1, props, mergedClsPrefixRef);
      const rtlEnabledRef = useRtl("CollapseTransition", mergedRtlRef, mergedClsPrefixRef);
      const mergedShowRef = vue.computed(() => {
        if (props.collapsed !== void 0) {
          return props.collapsed;
        }
        return props.show;
      });
      const cssVarsRef = vue.computed(() => {
        const {
          self: {
            bezier
          }
        } = mergedThemeRef.value;
        return {
          "--n-bezier": bezier
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("collapse-transition", void 0, cssVarsRef, props) : void 0;
      return {
        rtlEnabled: rtlEnabledRef,
        mergedShow: mergedShowRef,
        mergedClsPrefix: mergedClsPrefixRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      return vue.h(NFadeInExpandTransition, {
        appear: this.appear
      }, {
        default: () => {
          var _a;
          if (!this.mergedShow)
            return;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h(
            "div",
            // Don't use jsx since it would cause useless spread in each rendering
            vue.mergeProps({
              class: [`${this.mergedClsPrefix}-collapse-transition`, this.rtlEnabled && `${this.mergedClsPrefix}-collapse-transition--rtl`, this.themeClass],
              style: this.cssVars
            }, this.$attrs),
            this.$slots
          );
        }
      });
    }
  });
  const configProviderProps = {
    abstract: Boolean,
    bordered: {
      type: Boolean,
      default: void 0
    },
    clsPrefix: String,
    locale: Object,
    dateLocale: Object,
    namespace: String,
    rtl: Array,
    tag: {
      type: String,
      default: "div"
    },
    hljs: Object,
    katex: Object,
    theme: Object,
    themeOverrides: Object,
    componentOptions: Object,
    icons: Object,
    breakpoints: Object,
    preflightStyleDisabled: Boolean,
    styleMountTarget: Object,
    inlineThemeDisabled: {
      type: Boolean,
      default: void 0
    },
    // deprecated
    as: {
      type: String,
      validator: () => {
        warn$2("config-provider", "`as` is deprecated, please use `tag` instead.");
        return true;
      },
      default: void 0
    }
  };
  const NConfigProvider = vue.defineComponent({
    name: "ConfigProvider",
    alias: ["App"],
    props: configProviderProps,
    setup(props) {
      const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
      const mergedThemeRef = vue.computed(() => {
        const {
          theme
        } = props;
        if (theme === null)
          return void 0;
        const inheritedTheme = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeRef.value;
        return theme === void 0 ? inheritedTheme : inheritedTheme === void 0 ? theme : Object.assign({}, inheritedTheme, theme);
      });
      const mergedThemeOverridesRef = vue.computed(() => {
        const {
          themeOverrides
        } = props;
        if (themeOverrides === null)
          return void 0;
        if (themeOverrides === void 0) {
          return NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeOverridesRef.value;
        } else {
          const inheritedThemeOverrides = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeOverridesRef.value;
          if (inheritedThemeOverrides === void 0) {
            return themeOverrides;
          } else {
            return merge$1({}, inheritedThemeOverrides, themeOverrides);
          }
        }
      });
      const mergedNamespaceRef = useMemo(() => {
        const {
          namespace: namespace2
        } = props;
        return namespace2 === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedNamespaceRef.value : namespace2;
      });
      const mergedBorderedRef = useMemo(() => {
        const {
          bordered
        } = props;
        return bordered === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBorderedRef.value : bordered;
      });
      const mergedIconsRef = vue.computed(() => {
        const {
          icons
        } = props;
        return icons === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedIconsRef.value : icons;
      });
      const mergedComponentPropsRef = vue.computed(() => {
        const {
          componentOptions
        } = props;
        if (componentOptions !== void 0)
          return componentOptions;
        return NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedComponentPropsRef.value;
      });
      const mergedClsPrefixRef = vue.computed(() => {
        const {
          clsPrefix
        } = props;
        if (clsPrefix !== void 0)
          return clsPrefix;
        if (NConfigProvider2)
          return NConfigProvider2.mergedClsPrefixRef.value;
        return defaultClsPrefix;
      });
      const mergedRtlRef = vue.computed(() => {
        var _a;
        const {
          rtl
        } = props;
        if (rtl === void 0) {
          return NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedRtlRef.value;
        }
        const rtlEnabledState = {};
        for (const rtlInfo of rtl) {
          rtlEnabledState[rtlInfo.name] = vue.markRaw(rtlInfo);
          (_a = rtlInfo.peers) === null || _a === void 0 ? void 0 : _a.forEach((peerRtlInfo) => {
            if (!(peerRtlInfo.name in rtlEnabledState)) {
              rtlEnabledState[peerRtlInfo.name] = vue.markRaw(peerRtlInfo);
            }
          });
        }
        return rtlEnabledState;
      });
      const mergedBreakpointsRef = vue.computed(() => {
        return props.breakpoints || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBreakpointsRef.value);
      });
      const inlineThemeDisabled = props.inlineThemeDisabled || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.inlineThemeDisabled);
      const preflightStyleDisabled = props.preflightStyleDisabled || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.preflightStyleDisabled);
      const styleMountTarget = props.styleMountTarget || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget);
      const mergedThemeHashRef = vue.computed(() => {
        const {
          value: theme
        } = mergedThemeRef;
        const {
          value: mergedThemeOverrides
        } = mergedThemeOverridesRef;
        const hasThemeOverrides = mergedThemeOverrides && Object.keys(mergedThemeOverrides).length !== 0;
        const themeName = theme === null || theme === void 0 ? void 0 : theme.name;
        if (themeName) {
          if (hasThemeOverrides) {
            return `${themeName}-${murmur2(JSON.stringify(mergedThemeOverridesRef.value))}`;
          }
          return themeName;
        } else {
          if (hasThemeOverrides) {
            return murmur2(JSON.stringify(mergedThemeOverridesRef.value));
          }
          return "";
        }
      });
      vue.provide(configProviderInjectionKey, {
        mergedThemeHashRef,
        mergedBreakpointsRef,
        mergedRtlRef,
        mergedIconsRef,
        mergedComponentPropsRef,
        mergedBorderedRef,
        mergedNamespaceRef,
        mergedClsPrefixRef,
        mergedLocaleRef: vue.computed(() => {
          const {
            locale
          } = props;
          if (locale === null)
            return void 0;
          return locale === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedLocaleRef.value : locale;
        }),
        mergedDateLocaleRef: vue.computed(() => {
          const {
            dateLocale
          } = props;
          if (dateLocale === null)
            return void 0;
          return dateLocale === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedDateLocaleRef.value : dateLocale;
        }),
        mergedHljsRef: vue.computed(() => {
          const {
            hljs
          } = props;
          return hljs === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedHljsRef.value : hljs;
        }),
        mergedKatexRef: vue.computed(() => {
          const {
            katex
          } = props;
          return katex === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedKatexRef.value : katex;
        }),
        mergedThemeRef,
        mergedThemeOverridesRef,
        inlineThemeDisabled: inlineThemeDisabled || false,
        preflightStyleDisabled: preflightStyleDisabled || false,
        styleMountTarget
      });
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        mergedBordered: mergedBorderedRef,
        mergedNamespace: mergedNamespaceRef,
        mergedTheme: mergedThemeRef,
        mergedThemeOverrides: mergedThemeOverridesRef
      };
    },
    render() {
      var _a, _b, _c, _d;
      return !this.abstract ? vue.h(this.as || this.tag, {
        class: `${this.mergedClsPrefix || defaultClsPrefix}-config-provider`
      }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a)) : (_d = (_c = this.$slots).default) === null || _d === void 0 ? void 0 : _d.call(_c);
    }
  });
  const countdownProps = {
    duration: {
      type: Number,
      default: 0
    },
    active: {
      type: Boolean,
      default: true
    },
    precision: {
      type: Number,
      default: 0
    },
    render: Function,
    onFinish: Function
  };
  const Countdown = vue.defineComponent({
    name: "Countdown",
    props: countdownProps,
    setup(props) {
      let timerId = null;
      let elapsed = 0;
      let finished = false;
      const distanceRef = vue.ref(0);
      vue.watchEffect(() => {
        distanceRef.value = props.duration;
      });
      let pnow = -1;
      function getDistance(time2) {
        return props.duration - elapsed + pnow - time2;
      }
      function getTimeInfo(distance) {
        const hours = Math.floor(distance / 36e5);
        const minutes = Math.floor(distance % 36e5 / 6e4);
        const seconds = Math.floor(distance % 6e4 / 1e3);
        const milliseconds = Math.floor(distance % 1e3);
        return {
          hours,
          minutes,
          seconds,
          milliseconds
        };
      }
      function getDisplayValue(info) {
        const {
          hours,
          minutes,
          seconds,
          milliseconds
        } = info;
        const {
          precision
        } = props;
        switch (precision) {
          case 0:
            return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
          default:
            return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}.${String(Math.floor(milliseconds / (precision === 1 ? 100 : precision === 2 ? 10 : 1))).padStart(precision, "0")}`;
        }
      }
      const frame = () => {
        var _a;
        const {
          precision
        } = props;
        const distance = getDistance(performance.now());
        if (distance <= 0) {
          distanceRef.value = 0;
          stopTimer();
          if (!finished) {
            finished = true;
            (_a = props.onFinish) === null || _a === void 0 ? void 0 : _a.call(props);
          }
          return;
        }
        let leftTime;
        switch (precision) {
          case 3:
          case 2:
            leftTime = distance % 34;
            break;
          case 1:
            leftTime = distance % 100;
            break;
          default:
            leftTime = distance % 1e3;
        }
        distanceRef.value = distance;
        timerId = window.setTimeout(() => {
          frame();
        }, leftTime);
      };
      function stopTimer() {
        if (timerId !== null) {
          window.clearTimeout(timerId);
          timerId = null;
        }
      }
      vue.onMounted(() => {
        vue.watchEffect(() => {
          if (props.active) {
            pnow = performance.now();
            frame();
          } else {
            const now2 = performance.now();
            if (pnow !== -1) {
              elapsed += now2 - pnow;
            }
            stopTimer();
          }
        });
      });
      vue.onBeforeUnmount(() => {
        stopTimer();
      });
      function reset() {
        distanceRef.value = props.duration;
        elapsed = 0;
        pnow = performance.now();
        if (props.active && finished) {
          frame();
        }
        finished = false;
      }
      const countdownExposedMethod = {
        reset
      };
      return Object.assign(countdownExposedMethod, {
        distance: distanceRef,
        getTimeInfo,
        getDisplayValue
      });
    },
    render() {
      const {
        render: render2,
        precision,
        distance,
        getTimeInfo,
        getDisplayValue
      } = this;
      let timeInfo;
      switch (precision) {
        case 0:
          timeInfo = getTimeInfo(distance + 999);
          timeInfo.milliseconds = 0;
          break;
        case 1:
          timeInfo = getTimeInfo(distance + 99);
          timeInfo.milliseconds = Math.floor(timeInfo.milliseconds / 100) * 100;
          break;
        case 2:
          timeInfo = getTimeInfo(distance + 9);
          timeInfo.milliseconds = Math.floor(timeInfo.milliseconds / 10) * 10;
          break;
        case 3:
          timeInfo = getTimeInfo(distance);
      }
      if (render2) {
        return render2(timeInfo);
      } else {
        return getDisplayValue(timeInfo);
      }
    }
  });
  const easeOut = (t) => 1 - Math.pow(1 - t, 5);
  function tween(props) {
    const {
      from,
      to,
      duration: duration2,
      onUpdate,
      onFinish
    } = props;
    const startTime = performance.now();
    const tick = () => {
      const current = performance.now();
      const elapsedTime = Math.min(current - startTime, duration2);
      const currentValue = from + (to - from) * easeOut(elapsedTime / duration2);
      if (elapsedTime === duration2) {
        onFinish();
        return;
      }
      onUpdate(currentValue);
      requestAnimationFrame(tick);
    };
    tick();
  }
  const numberAnimationProps = {
    to: {
      type: Number,
      default: 0
    },
    precision: {
      type: Number,
      default: 0
    },
    showSeparator: Boolean,
    locale: String,
    from: {
      type: Number,
      default: 0
    },
    active: {
      type: Boolean,
      default: true
    },
    duration: {
      type: Number,
      default: 2e3
    },
    onFinish: Function
  };
  const NumberAnimation = vue.defineComponent({
    name: "NumberAnimation",
    props: numberAnimationProps,
    setup(props) {
      const {
        localeRef
      } = useLocale("name");
      const {
        duration: duration2
      } = props;
      const displayedValueRef = vue.ref(props.from);
      const mergedLocaleRef = vue.computed(() => {
        const {
          locale
        } = props;
        if (locale !== void 0)
          return locale;
        return localeRef.value;
      });
      let animating = false;
      const onUpdate = (currentValue) => {
        displayedValueRef.value = currentValue;
      };
      const onFinish = () => {
        var _a;
        displayedValueRef.value = props.to;
        animating = false;
        (_a = props.onFinish) === null || _a === void 0 ? void 0 : _a.call(props);
      };
      const animate = (from = props.from, to = props.to) => {
        animating = true;
        displayedValueRef.value = props.from;
        if (from !== to) {
          tween({
            from,
            to,
            duration: duration2,
            onUpdate,
            onFinish
          });
        }
      };
      const formattedValueRef = vue.computed(() => {
        var _a;
        const formatted = round(displayedValueRef.value, props.precision).toFixed(props.precision);
        const splitValue = formatted.split(".");
        const numberFormatter = new Intl.NumberFormat(mergedLocaleRef.value);
        const decimalSeparator = (_a = numberFormatter.formatToParts(0.5).find((part) => part.type === "decimal")) === null || _a === void 0 ? void 0 : _a.value;
        const integer = props.showSeparator ? numberFormatter.format(Number(splitValue[0])) : splitValue[0];
        const decimal = splitValue[1];
        return {
          integer,
          decimal,
          decimalSeparator
        };
      });
      function play() {
        if (animating)
          return;
        animate();
      }
      vue.onMounted(() => {
        vue.watchEffect(() => {
          if (props.active)
            animate();
        });
      });
      const exposedMethods = {
        play
      };
      return Object.assign({
        formattedValue: formattedValueRef
      }, exposedMethods);
    },
    render() {
      const {
        formattedValue: {
          integer,
          decimal,
          decimalSeparator
        }
      } = this;
      return [integer, decimal ? decimalSeparator : null, decimal];
    }
  });
  function self$U(vars) {
    const {
      boxShadow2
    } = vars;
    return {
      menuBoxShadow: boxShadow2
    };
  }
  const popselectLight = createTheme({
    name: "Popselect",
    common: commonLight,
    peers: {
      Popover: popoverLight$1,
      InternalSelectMenu: internalSelectMenuLight$1
    },
    self: self$U
  });
  const popselectLight$1 = popselectLight;
  const popselectInjectionKey = createInjectionKey("n-popselect");
  const style$13 = cB("popselect-menu", `
 box-shadow: var(--n-menu-box-shadow);
`);
  const panelProps$1 = {
    multiple: Boolean,
    value: {
      type: [String, Number, Array],
      default: null
    },
    cancelable: Boolean,
    options: {
      type: Array,
      default: () => []
    },
    size: {
      type: String,
      default: "medium"
    },
    scrollable: Boolean,
    "onUpdate:value": [Function, Array],
    onUpdateValue: [Function, Array],
    onMouseenter: Function,
    onMouseleave: Function,
    renderLabel: Function,
    showCheckmark: {
      type: Boolean,
      default: void 0
    },
    nodeProps: Function,
    virtualScroll: Boolean,
    // deprecated
    onChange: [Function, Array]
  };
  const panelPropKeys$1 = keysOf(panelProps$1);
  const NPopselectPanel = vue.defineComponent({
    name: "PopselectPanel",
    props: panelProps$1,
    setup(props) {
      {
        vue.watchEffect(() => {
          if (props.onChange !== void 0) {
            warn$2("popselect", "`on-change` is deprecated, please use `on-update:value` instead.");
          }
        });
      }
      const NPopselect2 = vue.inject(popselectInjectionKey);
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Popselect", "-pop-select", style$13, popselectLight$1, NPopselect2.props, mergedClsPrefixRef);
      const treeMateRef = vue.computed(() => {
        return createTreeMate(props.options, createTmOptions("value", "children"));
      });
      function doUpdateValue(value, option) {
        const {
          onUpdateValue,
          "onUpdate:value": _onUpdateValue,
          onChange
        } = props;
        if (onUpdateValue)
          call(onUpdateValue, value, option);
        if (_onUpdateValue) {
          call(_onUpdateValue, value, option);
        }
        if (onChange)
          call(onChange, value, option);
      }
      function handleToggle(tmNode) {
        toggle(tmNode.key);
      }
      function handleMenuMousedown(e) {
        if (!happensIn(e, "action") && !happensIn(e, "empty") && !happensIn(e, "header")) {
          e.preventDefault();
        }
      }
      function toggle(value) {
        const {
          value: {
            getNode
          }
        } = treeMateRef;
        if (props.multiple) {
          if (Array.isArray(props.value)) {
            const newValue = [];
            const newOptions = [];
            let shouldAddValue = true;
            props.value.forEach((v) => {
              if (v === value) {
                shouldAddValue = false;
                return;
              }
              const tmNode = getNode(v);
              if (tmNode) {
                newValue.push(tmNode.key);
                newOptions.push(tmNode.rawNode);
              }
            });
            if (shouldAddValue) {
              newValue.push(value);
              newOptions.push(getNode(value).rawNode);
            }
            doUpdateValue(newValue, newOptions);
          } else {
            const tmNode = getNode(value);
            if (tmNode) {
              doUpdateValue([value], [tmNode.rawNode]);
            }
          }
        } else {
          if (props.value === value && props.cancelable) {
            doUpdateValue(null, null);
          } else {
            const tmNode = getNode(value);
            if (tmNode) {
              doUpdateValue(value, tmNode.rawNode);
            }
            const {
              "onUpdate:show": _onUpdateShow,
              onUpdateShow
            } = NPopselect2.props;
            if (_onUpdateShow)
              call(_onUpdateShow, false);
            if (onUpdateShow)
              call(onUpdateShow, false);
            NPopselect2.setShow(false);
          }
        }
        void vue.nextTick(() => {
          NPopselect2.syncPosition();
        });
      }
      vue.watch(vue.toRef(props, "options"), () => {
        void vue.nextTick(() => {
          NPopselect2.syncPosition();
        });
      });
      const cssVarsRef = vue.computed(() => {
        const {
          self: {
            menuBoxShadow
          }
        } = themeRef.value;
        return {
          "--n-menu-box-shadow": menuBoxShadow
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("select", void 0, cssVarsRef, NPopselect2.props) : void 0;
      return {
        mergedTheme: NPopselect2.mergedThemeRef,
        mergedClsPrefix: mergedClsPrefixRef,
        treeMate: treeMateRef,
        handleToggle,
        handleMenuMousedown,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      return vue.h(NInternalSelectMenu, {
        clsPrefix: this.mergedClsPrefix,
        focusable: true,
        nodeProps: this.nodeProps,
        class: [`${this.mergedClsPrefix}-popselect-menu`, this.themeClass],
        style: this.cssVars,
        theme: this.mergedTheme.peers.InternalSelectMenu,
        themeOverrides: this.mergedTheme.peerOverrides.InternalSelectMenu,
        multiple: this.multiple,
        treeMate: this.treeMate,
        size: this.size,
        value: this.value,
        virtualScroll: this.virtualScroll,
        scrollable: this.scrollable,
        renderLabel: this.renderLabel,
        onToggle: this.handleToggle,
        onMouseenter: this.onMouseenter,
        onMouseleave: this.onMouseenter,
        onMousedown: this.handleMenuMousedown,
        showCheckmark: this.showCheckmark
      }, {
        header: () => {
          var _a2, _b;
          return ((_b = (_a2 = this.$slots).header) === null || _b === void 0 ? void 0 : _b.call(_a2)) || [];
        },
        action: () => {
          var _a2, _b;
          return ((_b = (_a2 = this.$slots).action) === null || _b === void 0 ? void 0 : _b.call(_a2)) || [];
        },
        empty: () => {
          var _a2, _b;
          return ((_b = (_a2 = this.$slots).empty) === null || _b === void 0 ? void 0 : _b.call(_a2)) || [];
        }
      });
    }
  });
  const popselectProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), omit(popoverBaseProps, ["showArrow", "arrow"])), {
    placement: Object.assign(Object.assign({}, popoverBaseProps.placement), {
      default: "bottom"
    }),
    trigger: {
      type: String,
      default: "hover"
    }
  }), panelProps$1);
  const NPopselect = vue.defineComponent({
    name: "Popselect",
    props: popselectProps,
    inheritAttrs: false,
    __popover__: true,
    setup(props) {
      const {
        mergedClsPrefixRef
      } = useConfig(props);
      const themeRef = useTheme("Popselect", "-popselect", void 0, popselectLight$1, props, mergedClsPrefixRef);
      const popoverInstRef = vue.ref(null);
      function syncPosition() {
        var _a;
        (_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
      }
      function setShow(value) {
        var _a;
        (_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.setShow(value);
      }
      vue.provide(popselectInjectionKey, {
        props,
        mergedThemeRef: themeRef,
        syncPosition,
        setShow
      });
      const exposedMethods = {
        syncPosition,
        setShow
      };
      return Object.assign(Object.assign({}, exposedMethods), {
        popoverInstRef,
        mergedTheme: themeRef
      });
    },
    render() {
      const {
        mergedTheme
      } = this;
      const popoverProps2 = {
        theme: mergedTheme.peers.Popover,
        themeOverrides: mergedTheme.peerOverrides.Popover,
        builtinThemeOverrides: {
          padding: "0"
        },
        ref: "popoverInstRef",
        internalRenderBody: (className, ref, style2, onMouseenter, onMouseleave) => {
          const {
            $attrs
          } = this;
          return vue.h(NPopselectPanel, Object.assign({}, $attrs, {
            class: [$attrs.class, className],
            style: [$attrs.style, ...style2]
          }, keep(this.$props, panelPropKeys$1), {
            ref: createRefSetter(ref),
            onMouseenter: mergeEventHandlers([onMouseenter, $attrs.onMouseenter]),
            onMouseleave: mergeEventHandlers([onMouseleave, $attrs.onMouseleave])
          }), {
            header: () => {
              var _a, _b;
              return (_b = (_a = this.$slots).header) === null || _b === void 0 ? void 0 : _b.call(_a);
            },
            action: () => {
              var _a, _b;
              return (_b = (_a = this.$slots).action) === null || _b === void 0 ? void 0 : _b.call(_a);
            },
            empty: () => {
              var _a, _b;
              return (_b = (_a = this.$slots).empty) === null || _b === void 0 ? void 0 : _b.call(_a);
            }
          });
        }
      };
      return vue.h(NPopover, Object.assign({}, omit(this.$props, panelPropKeys$1), popoverProps2, {
        internalDeactivateImmediately: true
      }), {
        trigger: () => {
          var _a, _b;
          return (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
      });
    }
  });
  function self$T(vars) {
    const {
      boxShadow2
    } = vars;
    return {
      menuBoxShadow: boxShadow2
    };
  }
  const selectLight = createTheme({
    name: "Select",
    common: commonLight,
    peers: {
      InternalSelection: internalSelectionLight$1,
      InternalSelectMenu: internalSelectMenuLight$1
    },
    self: self$T
  });
  const selectLight$1 = selectLight;
  const style$12 = c$1([cB("select", `
 z-index: auto;
 outline: none;
 width: 100%;
 position: relative;
 `), cB("select-menu", `
 margin: 4px 0;
 box-shadow: var(--n-menu-box-shadow);
 `, [fadeInScaleUpTransition({
    originalTransition: "background-color .3s var(--n-bezier), box-shadow .3s var(--n-bezier)"
  })])]);
  const selectProps = Object.assign(Object.assign({}, useTheme.props), {
    to: useAdjustedTo.propTo,
    bordered: {
      type: Boolean,
      default: void 0
    },
    clearable: Boolean,
    clearFilterAfterSelect: {
      type: Boolean,
      default: true
    },
    options: {
      type: Array,
      default: () => []
    },
    defaultValue: {
      type: [String, Number, Array],
      default: null
    },
    keyboard: {
      type: Boolean,
      default: true
    },
    value: [String, Number, Array],
    placeholder: String,
    menuProps: Object,
    multiple: Boolean,
    size: String,
    menuSize: {
      type: String
    },
    filterable: Boolean,
    disabled: {
      type: Boolean,
      default: void 0
    },
    remote: Boolean,
    loading: Boolean,
    filter: Function,
    placement: {
      type: String,
      default: "bottom-start"
    },
    widthMode: {
      type: String,
      default: "trigger"
    },
    tag: Boolean,
    onCreate: Function,
    fallbackOption: {
      type: [Function, Boolean],
      default: void 0
    },
    show: {
      type: Boolean,
      default: void 0
    },
    showArrow: {
      type: Boolean,
      default: true
    },
    maxTagCount: [Number, String],
    ellipsisTagPopoverProps: Object,
    consistentMenuWidth: {
      type: Boolean,
      default: true
    },
    virtualScroll: {
      type: Boolean,
      default: true
    },
    labelField: {
      type: String,
      default: "label"
    },
    valueField: {
      type: String,
      default: "value"
    },
    childrenField: {
      type: String,
      default: "children"
    },
    renderLabel: Function,
    renderOption: Function,
    renderTag: Function,
    "onUpdate:value": [Function, Array],
    inputProps: Object,
    nodeProps: Function,
    ignoreComposition: {
      type: Boolean,
      default: true
    },
    showOnFocus: Boolean,
    // for jsx
    onUpdateValue: [Function, Array],
    onBlur: [Function, Array],
    onClear: [Function, Array],
    onFocus: [Function, Array],
    onScroll: [Function, Array],
    onSearch: [Function, Array],
    onUpdateShow: [Function, Array],
    "onUpdate:show": [Function, Array],
    displayDirective: {
      type: String,
      default: "show"
    },
    resetMenuOnOptionsChange: {
      type: Boolean,
      default: true
    },
    status: String,
    showCheckmark: {
      type: Boolean,
      default: true
    },
    /** deprecated */
    onChange: [Function, Array],
    items: Array
  });
  const NSelect = vue.defineComponent({
    name: "Select",
    props: selectProps,
    setup(props) {
      {
        vue.watchEffect(() => {
          if (props.items !== void 0) {
            warnOnce("select", "`items` is deprecated, please use `options` instead.");
          }
          if (props.onChange !== void 0) {
            warnOnce("select", "`on-change` is deprecated, please use `on-update:value` instead.");
          }
        });
      }
      const {
        mergedClsPrefixRef,
        mergedBorderedRef,
        namespaceRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Select", "-select", style$12, selectLight$1, props, mergedClsPrefixRef);
      const uncontrolledValueRef = vue.ref(props.defaultValue);
      const controlledValueRef = vue.toRef(props, "value");
      const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
      const focusedRef = vue.ref(false);
      const patternRef = vue.ref("");
      const compitableOptionsRef = useCompitable(props, ["items", "options"]);
      const createdOptionsRef = vue.ref([]);
      const beingCreatedOptionsRef = vue.ref([]);
      const localOptionsRef = vue.computed(() => {
        return beingCreatedOptionsRef.value.concat(createdOptionsRef.value).concat(compitableOptionsRef.value);
      });
      const resolvedFilterRef = vue.computed(() => {
        const {
          filter
        } = props;
        if (filter)
          return filter;
        const {
          labelField,
          valueField
        } = props;
        return (pattern, option) => {
          if (!option)
            return false;
          const label = option[labelField];
          if (typeof label === "string") {
            return patternMatched(pattern, label);
          }
          const value = option[valueField];
          if (typeof value === "string") {
            return patternMatched(pattern, value);
          }
          if (typeof value === "number") {
            return patternMatched(pattern, String(value));
          }
          return false;
        };
      });
      const filteredOptionsRef = vue.computed(() => {
        if (props.remote) {
          return compitableOptionsRef.value;
        } else {
          const {
            value: localOptions
          } = localOptionsRef;
          const {
            value: pattern
          } = patternRef;
          if (!pattern.length || !props.filterable) {
            return localOptions;
          } else {
            return filterOptions(localOptions, resolvedFilterRef.value, pattern, props.childrenField);
          }
        }
      });
      const treeMateRef = vue.computed(() => {
        const {
          valueField,
          childrenField
        } = props;
        const options = createTmOptions(valueField, childrenField);
        return createTreeMate(filteredOptionsRef.value, options);
      });
      const valOptMapRef = vue.computed(() => createValOptMap(localOptionsRef.value, props.valueField, props.childrenField));
      const uncontrolledShowRef = vue.ref(false);
      const mergedShowRef = useMergedState(vue.toRef(props, "show"), uncontrolledShowRef);
      const triggerRef = vue.ref(null);
      const followerRef = vue.ref(null);
      const menuRef = vue.ref(null);
      const {
        localeRef
      } = useLocale("Select");
      const localizedPlaceholderRef = vue.computed(() => {
        var _a;
        return (_a = props.placeholder) !== null && _a !== void 0 ? _a : localeRef.value.placeholder;
      });
      const emptyArray = [];
      const memoValOptMapRef = vue.ref(/* @__PURE__ */ new Map());
      const wrappedFallbackOptionRef = vue.computed(() => {
        const {
          fallbackOption
        } = props;
        if (fallbackOption === void 0) {
          const {
            labelField,
            valueField
          } = props;
          return (value) => ({
            [labelField]: String(value),
            [valueField]: value
          });
        }
        if (fallbackOption === false)
          return false;
        return (value) => {
          return Object.assign(fallbackOption(value), {
            value
          });
        };
      });
      function getMergedOptions(values) {
        const remote = props.remote;
        const {
          value: memoValOptMap
        } = memoValOptMapRef;
        const {
          value: valOptMap
        } = valOptMapRef;
        const {
          value: wrappedFallbackOption
        } = wrappedFallbackOptionRef;
        const options = [];
        values.forEach((value) => {
          if (valOptMap.has(value)) {
            options.push(valOptMap.get(value));
          } else if (remote && memoValOptMap.has(value)) {
            options.push(memoValOptMap.get(value));
          } else if (wrappedFallbackOption) {
            const option = wrappedFallbackOption(value);
            if (option) {
              options.push(option);
            }
          }
        });
        return options;
      }
      const selectedOptionsRef = vue.computed(() => {
        if (props.multiple) {
          const {
            value: values
          } = mergedValueRef;
          if (!Array.isArray(values))
            return [];
          return getMergedOptions(values);
        }
        return null;
      });
      const selectedOptionRef = vue.computed(() => {
        const {
          value: mergedValue
        } = mergedValueRef;
        if (!props.multiple && !Array.isArray(mergedValue)) {
          if (mergedValue === null)
            return null;
          return getMergedOptions([mergedValue])[0] || null;
        }
        return null;
      });
      const formItem = useFormItem(props);
      const {
        mergedSizeRef,
        mergedDisabledRef,
        mergedStatusRef
      } = formItem;
      function doUpdateValue(value, option) {
        const {
          onChange,
          "onUpdate:value": _onUpdateValue,
          onUpdateValue
        } = props;
        const {
          nTriggerFormChange,
          nTriggerFormInput
        } = formItem;
        if (onChange)
          call(onChange, value, option);
        if (onUpdateValue)
          call(onUpdateValue, value, option);
        if (_onUpdateValue) {
          call(_onUpdateValue, value, option);
        }
        uncontrolledValueRef.value = value;
        nTriggerFormChange();
        nTriggerFormInput();
      }
      function doBlur(e) {
        const {
          onBlur
        } = props;
        const {
          nTriggerFormBlur
        } = formItem;
        if (onBlur)
          call(onBlur, e);
        nTriggerFormBlur();
      }
      function doClear() {
        const {
          onClear
        } = props;
        if (onClear)
          call(onClear);
      }
      function doFocus(e) {
        const {
          onFocus,
          showOnFocus
        } = props;
        const {
          nTriggerFormFocus
        } = formItem;
        if (onFocus)
          call(onFocus, e);
        nTriggerFormFocus();
        if (showOnFocus) {
          openMenu();
        }
      }
      function doSearch(value) {
        const {
          onSearch
        } = props;
        if (onSearch)
          call(onSearch, value);
      }
      function doScroll(e) {
        const {
          onScroll
        } = props;
        if (onScroll)
          call(onScroll, e);
      }
      function updateMemorizedOptions() {
        var _a;
        const {
          remote,
          multiple
        } = props;
        if (remote) {
          const {
            value: memoValOptMap
          } = memoValOptMapRef;
          if (multiple) {
            const {
              valueField
            } = props;
            (_a = selectedOptionsRef.value) === null || _a === void 0 ? void 0 : _a.forEach((option) => {
              memoValOptMap.set(option[valueField], option);
            });
          } else {
            const option = selectedOptionRef.value;
            if (option) {
              memoValOptMap.set(option[props.valueField], option);
            }
          }
        }
      }
      function doUpdateShow(value) {
        const {
          onUpdateShow,
          "onUpdate:show": _onUpdateShow
        } = props;
        if (onUpdateShow)
          call(onUpdateShow, value);
        if (_onUpdateShow)
          call(_onUpdateShow, value);
        uncontrolledShowRef.value = value;
      }
      function openMenu() {
        if (!mergedDisabledRef.value) {
          doUpdateShow(true);
          uncontrolledShowRef.value = true;
          if (props.filterable) {
            focusSelectionInput();
          }
        }
      }
      function closeMenu() {
        doUpdateShow(false);
      }
      function handleMenuAfterLeave() {
        patternRef.value = "";
        beingCreatedOptionsRef.value = emptyArray;
      }
      const activeWithoutMenuOpenRef = vue.ref(false);
      function onTriggerInputFocus() {
        if (props.filterable) {
          activeWithoutMenuOpenRef.value = true;
        }
      }
      function onTriggerInputBlur() {
        if (props.filterable) {
          activeWithoutMenuOpenRef.value = false;
          if (!mergedShowRef.value) {
            handleMenuAfterLeave();
          }
        }
      }
      function handleTriggerClick() {
        if (mergedDisabledRef.value)
          return;
        if (!mergedShowRef.value) {
          openMenu();
        } else {
          if (!props.filterable) {
            closeMenu();
          } else {
            focusSelectionInput();
          }
        }
      }
      function handleTriggerBlur(e) {
        var _a, _b;
        if ((_b = (_a = menuRef.value) === null || _a === void 0 ? void 0 : _a.selfRef) === null || _b === void 0 ? void 0 : _b.contains(e.relatedTarget)) {
          return;
        }
        focusedRef.value = false;
        doBlur(e);
        closeMenu();
      }
      function handleTriggerFocus(e) {
        doFocus(e);
        focusedRef.value = true;
      }
      function handleMenuFocus() {
        focusedRef.value = true;
      }
      function handleMenuBlur(e) {
        var _a;
        if ((_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(e.relatedTarget))
          return;
        focusedRef.value = false;
        doBlur(e);
        closeMenu();
      }
      function handleMenuTabOut() {
        var _a;
        (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.focus();
        closeMenu();
      }
      function handleMenuClickOutside(e) {
        var _a;
        if (mergedShowRef.value) {
          if (!((_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(getPreciseEventTarget(e)))) {
            closeMenu();
          }
        }
      }
      function createClearedMultipleSelectValue(value) {
        if (!Array.isArray(value))
          return [];
        if (wrappedFallbackOptionRef.value) {
          return Array.from(value);
        } else {
          const {
            remote
          } = props;
          const {
            value: valOptMap
          } = valOptMapRef;
          if (remote) {
            const {
              value: memoValOptMap
            } = memoValOptMapRef;
            return value.filter((v) => valOptMap.has(v) || memoValOptMap.has(v));
          } else {
            return value.filter((v) => valOptMap.has(v));
          }
        }
      }
      function handleToggleByTmNode(tmNode) {
        handleToggleByOption(tmNode.rawNode);
      }
      function handleToggleByOption(option) {
        if (mergedDisabledRef.value)
          return;
        const {
          tag,
          remote,
          clearFilterAfterSelect,
          valueField
        } = props;
        if (tag && !remote) {
          const {
            value: beingCreatedOptions
          } = beingCreatedOptionsRef;
          const beingCreatedOption = beingCreatedOptions[0] || null;
          if (beingCreatedOption) {
            const createdOptions = createdOptionsRef.value;
            if (!createdOptions.length) {
              createdOptionsRef.value = [beingCreatedOption];
            } else {
              createdOptions.push(beingCreatedOption);
            }
            beingCreatedOptionsRef.value = emptyArray;
          }
        }
        if (remote) {
          memoValOptMapRef.value.set(option[valueField], option);
        }
        if (props.multiple) {
          const changedValue = createClearedMultipleSelectValue(mergedValueRef.value);
          const index = changedValue.findIndex((value) => value === option[valueField]);
          if (~index) {
            changedValue.splice(index, 1);
            if (tag && !remote) {
              const createdOptionIndex = getCreatedOptionIndex(option[valueField]);
              if (~createdOptionIndex) {
                createdOptionsRef.value.splice(createdOptionIndex, 1);
                if (clearFilterAfterSelect)
                  patternRef.value = "";
              }
            }
          } else {
            changedValue.push(option[valueField]);
            if (clearFilterAfterSelect)
              patternRef.value = "";
          }
          doUpdateValue(changedValue, getMergedOptions(changedValue));
        } else {
          if (tag && !remote) {
            const createdOptionIndex = getCreatedOptionIndex(option[valueField]);
            if (~createdOptionIndex) {
              createdOptionsRef.value = [createdOptionsRef.value[createdOptionIndex]];
            } else {
              createdOptionsRef.value = emptyArray;
            }
          }
          focusSelection();
          closeMenu();
          doUpdateValue(option[valueField], option);
        }
      }
      function getCreatedOptionIndex(optionValue) {
        const createdOptions = createdOptionsRef.value;
        return createdOptions.findIndex((createdOption) => createdOption[props.valueField] === optionValue);
      }
      function handlePatternInput(e) {
        if (!mergedShowRef.value) {
          openMenu();
        }
        const {
          value
        } = e.target;
        patternRef.value = value;
        const {
          tag,
          remote
        } = props;
        doSearch(value);
        if (tag && !remote) {
          if (!value) {
            beingCreatedOptionsRef.value = emptyArray;
            return;
          }
          const {
            onCreate
          } = props;
          const optionBeingCreated = onCreate ? onCreate(value) : {
            [props.labelField]: value,
            [props.valueField]: value
          };
          const {
            valueField,
            labelField
          } = props;
          if (compitableOptionsRef.value.some((option) => {
            return option[valueField] === optionBeingCreated[valueField] || option[labelField] === optionBeingCreated[labelField];
          }) || createdOptionsRef.value.some((option) => {
            return option[valueField] === optionBeingCreated[valueField] || option[labelField] === optionBeingCreated[labelField];
          })) {
            beingCreatedOptionsRef.value = emptyArray;
          } else {
            beingCreatedOptionsRef.value = [optionBeingCreated];
          }
        }
      }
      function handleClear(e) {
        e.stopPropagation();
        const {
          multiple
        } = props;
        if (!multiple && props.filterable) {
          closeMenu();
        }
        doClear();
        if (multiple) {
          doUpdateValue([], []);
        } else {
          doUpdateValue(null, null);
        }
      }
      function handleMenuMousedown(e) {
        if (!happensIn(e, "action") && !happensIn(e, "empty") && !happensIn(e, "header")) {
          e.preventDefault();
        }
      }
      function handleMenuScroll(e) {
        doScroll(e);
      }
      function handleKeydown(e) {
        var _a, _b, _c, _d, _e;
        if (!props.keyboard) {
          e.preventDefault();
          return;
        }
        switch (e.key) {
          case " ":
            if (props.filterable) {
              break;
            } else {
              e.preventDefault();
            }
          case "Enter":
            if (!((_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.isComposing)) {
              if (mergedShowRef.value) {
                const pendingTmNode = (_b = menuRef.value) === null || _b === void 0 ? void 0 : _b.getPendingTmNode();
                if (pendingTmNode) {
                  handleToggleByTmNode(pendingTmNode);
                } else if (!props.filterable) {
                  closeMenu();
                  focusSelection();
                }
              } else {
                openMenu();
                if (props.tag && activeWithoutMenuOpenRef.value) {
                  const beingCreatedOption = beingCreatedOptionsRef.value[0];
                  if (beingCreatedOption) {
                    const optionValue = beingCreatedOption[props.valueField];
                    const {
                      value: mergedValue
                    } = mergedValueRef;
                    if (props.multiple) {
                      if (Array.isArray(mergedValue) && mergedValue.includes(optionValue))
                        ;
                      else {
                        handleToggleByOption(beingCreatedOption);
                      }
                    } else {
                      handleToggleByOption(beingCreatedOption);
                    }
                  }
                }
              }
            }
            e.preventDefault();
            break;
          case "ArrowUp":
            e.preventDefault();
            if (props.loading)
              return;
            if (mergedShowRef.value) {
              (_c = menuRef.value) === null || _c === void 0 ? void 0 : _c.prev();
            }
            break;
          case "ArrowDown":
            e.preventDefault();
            if (props.loading)
              return;
            if (mergedShowRef.value) {
              (_d = menuRef.value) === null || _d === void 0 ? void 0 : _d.next();
            } else {
              openMenu();
            }
            break;
          case "Escape":
            if (mergedShowRef.value) {
              markEventEffectPerformed(e);
              closeMenu();
            }
            (_e = triggerRef.value) === null || _e === void 0 ? void 0 : _e.focus();
            break;
        }
      }
      function focusSelection() {
        var _a;
        (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.focus();
      }
      function focusSelectionInput() {
        var _a;
        (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.focusInput();
      }
      function handleTriggerOrMenuResize() {
        var _a;
        if (!mergedShowRef.value)
          return;
        (_a = followerRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
      }
      updateMemorizedOptions();
      vue.watch(vue.toRef(props, "options"), updateMemorizedOptions);
      const exposedMethods = {
        focus: () => {
          var _a;
          (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.focus();
        },
        focusInput: () => {
          var _a;
          (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.focusInput();
        },
        blur: () => {
          var _a;
          (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.blur();
        },
        blurInput: () => {
          var _a;
          (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.blurInput();
        }
      };
      const cssVarsRef = vue.computed(() => {
        const {
          self: {
            menuBoxShadow
          }
        } = themeRef.value;
        return {
          "--n-menu-box-shadow": menuBoxShadow
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("select", void 0, cssVarsRef, props) : void 0;
      return Object.assign(Object.assign({}, exposedMethods), {
        mergedStatus: mergedStatusRef,
        mergedClsPrefix: mergedClsPrefixRef,
        mergedBordered: mergedBorderedRef,
        namespace: namespaceRef,
        treeMate: treeMateRef,
        isMounted: isMounted(),
        triggerRef,
        menuRef,
        pattern: patternRef,
        uncontrolledShow: uncontrolledShowRef,
        mergedShow: mergedShowRef,
        adjustedTo: useAdjustedTo(props),
        uncontrolledValue: uncontrolledValueRef,
        mergedValue: mergedValueRef,
        followerRef,
        localizedPlaceholder: localizedPlaceholderRef,
        selectedOption: selectedOptionRef,
        selectedOptions: selectedOptionsRef,
        mergedSize: mergedSizeRef,
        mergedDisabled: mergedDisabledRef,
        focused: focusedRef,
        activeWithoutMenuOpen: activeWithoutMenuOpenRef,
        inlineThemeDisabled,
        onTriggerInputFocus,
        onTriggerInputBlur,
        handleTriggerOrMenuResize,
        handleMenuFocus,
        handleMenuBlur,
        handleMenuTabOut,
        handleTriggerClick,
        handleToggle: handleToggleByTmNode,
        handleDeleteOption: handleToggleByOption,
        handlePatternInput,
        handleClear,
        handleTriggerBlur,
        handleTriggerFocus,
        handleKeydown,
        handleMenuAfterLeave,
        handleMenuClickOutside,
        handleMenuScroll,
        handleMenuKeydown: handleKeydown,
        handleMenuMousedown,
        mergedTheme: themeRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      });
    },
    render() {
      return vue.h("div", {
        class: `${this.mergedClsPrefix}-select`
      }, vue.h(VBinder, null, {
        default: () => [vue.h(VTarget, null, {
          default: () => vue.h(NInternalSelection, {
            ref: "triggerRef",
            inlineThemeDisabled: this.inlineThemeDisabled,
            status: this.mergedStatus,
            inputProps: this.inputProps,
            clsPrefix: this.mergedClsPrefix,
            showArrow: this.showArrow,
            maxTagCount: this.maxTagCount,
            ellipsisTagPopoverProps: this.ellipsisTagPopoverProps,
            bordered: this.mergedBordered,
            active: this.activeWithoutMenuOpen || this.mergedShow,
            pattern: this.pattern,
            placeholder: this.localizedPlaceholder,
            selectedOption: this.selectedOption,
            selectedOptions: this.selectedOptions,
            multiple: this.multiple,
            renderTag: this.renderTag,
            renderLabel: this.renderLabel,
            filterable: this.filterable,
            clearable: this.clearable,
            disabled: this.mergedDisabled,
            size: this.mergedSize,
            theme: this.mergedTheme.peers.InternalSelection,
            labelField: this.labelField,
            valueField: this.valueField,
            themeOverrides: this.mergedTheme.peerOverrides.InternalSelection,
            loading: this.loading,
            focused: this.focused,
            onClick: this.handleTriggerClick,
            onDeleteOption: this.handleDeleteOption,
            onPatternInput: this.handlePatternInput,
            onClear: this.handleClear,
            onBlur: this.handleTriggerBlur,
            onFocus: this.handleTriggerFocus,
            onKeydown: this.handleKeydown,
            onPatternBlur: this.onTriggerInputBlur,
            onPatternFocus: this.onTriggerInputFocus,
            onResize: this.handleTriggerOrMenuResize,
            ignoreComposition: this.ignoreComposition
          }, {
            arrow: () => {
              var _a, _b;
              return [(_b = (_a = this.$slots).arrow) === null || _b === void 0 ? void 0 : _b.call(_a)];
            }
          })
        }), vue.h(VFollower, {
          ref: "followerRef",
          show: this.mergedShow,
          to: this.adjustedTo,
          teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey,
          containerClass: this.namespace,
          width: this.consistentMenuWidth ? "target" : void 0,
          minWidth: "target",
          placement: this.placement
        }, {
          default: () => vue.h(vue.Transition, {
            name: "fade-in-scale-up-transition",
            appear: this.isMounted,
            onAfterLeave: this.handleMenuAfterLeave
          }, {
            default: () => {
              var _a, _b, _c;
              if (!(this.mergedShow || this.displayDirective === "show")) {
                return null;
              }
              (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
              return vue.withDirectives(vue.h(NInternalSelectMenu, Object.assign({}, this.menuProps, {
                ref: "menuRef",
                onResize: this.handleTriggerOrMenuResize,
                inlineThemeDisabled: this.inlineThemeDisabled,
                virtualScroll: this.consistentMenuWidth && this.virtualScroll,
                class: [`${this.mergedClsPrefix}-select-menu`, this.themeClass, (_b = this.menuProps) === null || _b === void 0 ? void 0 : _b.class],
                clsPrefix: this.mergedClsPrefix,
                focusable: true,
                labelField: this.labelField,
                valueField: this.valueField,
                autoPending: true,
                nodeProps: this.nodeProps,
                theme: this.mergedTheme.peers.InternalSelectMenu,
                themeOverrides: this.mergedTheme.peerOverrides.InternalSelectMenu,
                treeMate: this.treeMate,
                multiple: this.multiple,
                size: this.menuSize,
                renderOption: this.renderOption,
                renderLabel: this.renderLabel,
                value: this.mergedValue,
                style: [(_c = this.menuProps) === null || _c === void 0 ? void 0 : _c.style, this.cssVars],
                onToggle: this.handleToggle,
                onScroll: this.handleMenuScroll,
                onFocus: this.handleMenuFocus,
                onBlur: this.handleMenuBlur,
                onKeydown: this.handleMenuKeydown,
                onTabOut: this.handleMenuTabOut,
                onMousedown: this.handleMenuMousedown,
                show: this.mergedShow,
                showCheckmark: this.showCheckmark,
                resetMenuOnOptionsChange: this.resetMenuOnOptionsChange
              }), {
                empty: () => {
                  var _a2, _b2;
                  return [(_b2 = (_a2 = this.$slots).empty) === null || _b2 === void 0 ? void 0 : _b2.call(_a2)];
                },
                header: () => {
                  var _a2, _b2;
                  return [(_b2 = (_a2 = this.$slots).header) === null || _b2 === void 0 ? void 0 : _b2.call(_a2)];
                },
                action: () => {
                  var _a2, _b2;
                  return [(_b2 = (_a2 = this.$slots).action) === null || _b2 === void 0 ? void 0 : _b2.call(_a2)];
                }
              }), this.displayDirective === "show" ? [[vue.vShow, this.mergedShow], [clickoutside$1, this.handleMenuClickOutside, void 0, {
                capture: true
              }]] : [[clickoutside$1, this.handleMenuClickOutside, void 0, {
                capture: true
              }]]);
            }
          })
        })]
      }));
    }
  });
  const commonVariables$b = {
    itemPaddingSmall: "0 4px",
    itemMarginSmall: "0 0 0 8px",
    itemMarginSmallRtl: "0 8px 0 0",
    itemPaddingMedium: "0 4px",
    itemMarginMedium: "0 0 0 8px",
    itemMarginMediumRtl: "0 8px 0 0",
    itemPaddingLarge: "0 4px",
    itemMarginLarge: "0 0 0 8px",
    itemMarginLargeRtl: "0 8px 0 0",
    buttonIconSizeSmall: "14px",
    buttonIconSizeMedium: "16px",
    buttonIconSizeLarge: "18px",
    inputWidthSmall: "60px",
    selectWidthSmall: "unset",
    inputMarginSmall: "0 0 0 8px",
    inputMarginSmallRtl: "0 8px 0 0",
    selectMarginSmall: "0 0 0 8px",
    prefixMarginSmall: "0 8px 0 0",
    suffixMarginSmall: "0 0 0 8px",
    inputWidthMedium: "60px",
    selectWidthMedium: "unset",
    inputMarginMedium: "0 0 0 8px",
    inputMarginMediumRtl: "0 8px 0 0",
    selectMarginMedium: "0 0 0 8px",
    prefixMarginMedium: "0 8px 0 0",
    suffixMarginMedium: "0 0 0 8px",
    inputWidthLarge: "60px",
    selectWidthLarge: "unset",
    inputMarginLarge: "0 0 0 8px",
    inputMarginLargeRtl: "0 8px 0 0",
    selectMarginLarge: "0 0 0 8px",
    prefixMarginLarge: "0 8px 0 0",
    suffixMarginLarge: "0 0 0 8px"
  };
  function self$S(vars) {
    const {
      textColor2,
      primaryColor,
      primaryColorHover,
      primaryColorPressed,
      inputColorDisabled,
      textColorDisabled,
      borderColor,
      borderRadius,
      // item font size
      fontSizeTiny,
      fontSizeSmall,
      fontSizeMedium,
      // item size
      heightTiny,
      heightSmall,
      heightMedium
    } = vars;
    return Object.assign(Object.assign({}, commonVariables$b), {
      buttonColor: "#0000",
      buttonColorHover: "#0000",
      buttonColorPressed: "#0000",
      buttonBorder: `1px solid ${borderColor}`,
      buttonBorderHover: `1px solid ${borderColor}`,
      buttonBorderPressed: `1px solid ${borderColor}`,
      buttonIconColor: textColor2,
      buttonIconColorHover: textColor2,
      buttonIconColorPressed: textColor2,
      itemTextColor: textColor2,
      itemTextColorHover: primaryColorHover,
      itemTextColorPressed: primaryColorPressed,
      itemTextColorActive: primaryColor,
      itemTextColorDisabled: textColorDisabled,
      itemColor: "#0000",
      itemColorHover: "#0000",
      itemColorPressed: "#0000",
      itemColorActive: "#0000",
      itemColorActiveHover: "#0000",
      itemColorDisabled: inputColorDisabled,
      itemBorder: "1px solid #0000",
      itemBorderHover: "1px solid #0000",
      itemBorderPressed: "1px solid #0000",
      itemBorderActive: `1px solid ${primaryColor}`,
      itemBorderDisabled: `1px solid ${borderColor}`,
      itemBorderRadius: borderRadius,
      itemSizeSmall: heightTiny,
      itemSizeMedium: heightSmall,
      itemSizeLarge: heightMedium,
      itemFontSizeSmall: fontSizeTiny,
      itemFontSizeMedium: fontSizeSmall,
      itemFontSizeLarge: fontSizeMedium,
      jumperFontSizeSmall: fontSizeTiny,
      jumperFontSizeMedium: fontSizeSmall,
      jumperFontSizeLarge: fontSizeMedium,
      jumperTextColor: textColor2,
      jumperTextColorDisabled: textColorDisabled
    });
  }
  const paginationLight = createTheme({
    name: "Pagination",
    common: commonLight,
    peers: {
      Select: selectLight$1,
      Input: inputLight$1,
      Popselect: popselectLight$1
    },
    self: self$S
  });
  const paginationLight$1 = paginationLight;
  const hoverStyleProps = `
 background: var(--n-item-color-hover);
 color: var(--n-item-text-color-hover);
 border: var(--n-item-border-hover);
`;
  const hoverStyleChildren$1 = [cM("button", `
 background: var(--n-button-color-hover);
 border: var(--n-button-border-hover);
 color: var(--n-button-icon-color-hover);
 `)];
  const style$11 = cB("pagination", `
 display: flex;
 vertical-align: middle;
 font-size: var(--n-item-font-size);
 flex-wrap: nowrap;
`, [cB("pagination-prefix", `
 display: flex;
 align-items: center;
 margin: var(--n-prefix-margin);
 `), cB("pagination-suffix", `
 display: flex;
 align-items: center;
 margin: var(--n-suffix-margin);
 `), c$1("> *:not(:first-child)", `
 margin: var(--n-item-margin);
 `), cB("select", `
 width: var(--n-select-width);
 `), c$1("&.transition-disabled", [cB("pagination-item", "transition: none!important;")]), cB("pagination-quick-jumper", `
 white-space: nowrap;
 display: flex;
 color: var(--n-jumper-text-color);
 transition: color .3s var(--n-bezier);
 align-items: center;
 font-size: var(--n-jumper-font-size);
 `, [cB("input", `
 margin: var(--n-input-margin);
 width: var(--n-input-width);
 `)]), cB("pagination-item", `
 position: relative;
 cursor: pointer;
 user-select: none;
 -webkit-user-select: none;
 display: flex;
 align-items: center;
 justify-content: center;
 box-sizing: border-box;
 min-width: var(--n-item-size);
 height: var(--n-item-size);
 padding: var(--n-item-padding);
 background-color: var(--n-item-color);
 color: var(--n-item-text-color);
 border-radius: var(--n-item-border-radius);
 border: var(--n-item-border);
 fill: var(--n-button-icon-color);
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 fill .3s var(--n-bezier);
 `, [cM("button", `
 background: var(--n-button-color);
 color: var(--n-button-icon-color);
 border: var(--n-button-border);
 padding: 0;
 `, [cB("base-icon", `
 font-size: var(--n-button-icon-size);
 `)]), cNotM("disabled", [cM("hover", hoverStyleProps, hoverStyleChildren$1), c$1("&:hover", hoverStyleProps, hoverStyleChildren$1), c$1("&:active", `
 background: var(--n-item-color-pressed);
 color: var(--n-item-text-color-pressed);
 border: var(--n-item-border-pressed);
 `, [cM("button", `
 background: var(--n-button-color-pressed);
 border: var(--n-button-border-pressed);
 color: var(--n-button-icon-color-pressed);
 `)]), cM("active", `
 background: var(--n-item-color-active);
 color: var(--n-item-text-color-active);
 border: var(--n-item-border-active);
 `, [c$1("&:hover", `
 background: var(--n-item-color-active-hover);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 color: var(--n-item-text-color-disabled);
 `, [cM("active, button", `
 background-color: var(--n-item-color-disabled);
 border: var(--n-item-border-disabled);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 `, [cB("pagination-quick-jumper", `
 color: var(--n-jumper-text-color-disabled);
 `)]), cM("simple", `
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 `, [cB("pagination-quick-jumper", [cB("input", `
 margin: 0;
 `)])])]);
  function getDefaultPageSize(paginationProps2) {
    var _a;
    if (!paginationProps2)
      return 10;
    const {
      defaultPageSize
    } = paginationProps2;
    if (defaultPageSize !== void 0)
      return defaultPageSize;
    const pageSizeOption = (_a = paginationProps2.pageSizes) === null || _a === void 0 ? void 0 : _a[0];
    if (typeof pageSizeOption === "number")
      return pageSizeOption;
    return (pageSizeOption === null || pageSizeOption === void 0 ? void 0 : pageSizeOption.value) || 10;
  }
  function createPageItemsInfo(currentPage, pageCount, pageSlot, showQuickJumpDropdown) {
    let hasFastBackward = false;
    let hasFastForward = false;
    let fastBackwardTo = 1;
    let fastForwardTo = pageCount;
    if (pageCount === 1) {
      return {
        hasFastBackward: false,
        hasFastForward: false,
        fastForwardTo,
        fastBackwardTo,
        items: [{
          type: "page",
          label: 1,
          active: currentPage === 1,
          mayBeFastBackward: false,
          mayBeFastForward: false
        }]
      };
    }
    if (pageCount === 2) {
      return {
        hasFastBackward: false,
        hasFastForward: false,
        fastForwardTo,
        fastBackwardTo,
        items: [{
          type: "page",
          label: 1,
          active: currentPage === 1,
          mayBeFastBackward: false,
          mayBeFastForward: false
        }, {
          type: "page",
          label: 2,
          active: currentPage === 2,
          mayBeFastBackward: true,
          mayBeFastForward: false
        }]
      };
    }
    const firstPage = 1;
    const lastPage = pageCount;
    let middleStart = currentPage;
    let middleEnd = currentPage;
    const middleDelta = (pageSlot - 5) / 2;
    middleEnd += Math.ceil(middleDelta);
    middleEnd = Math.min(Math.max(middleEnd, firstPage + pageSlot - 3), lastPage - 2);
    middleStart -= Math.floor(middleDelta);
    middleStart = Math.max(Math.min(middleStart, lastPage - pageSlot + 3), firstPage + 2);
    let leftSplit = false;
    let rightSplit = false;
    if (middleStart > firstPage + 2)
      leftSplit = true;
    if (middleEnd < lastPage - 2)
      rightSplit = true;
    const items = [];
    items.push({
      type: "page",
      label: 1,
      active: currentPage === 1,
      mayBeFastBackward: false,
      mayBeFastForward: false
    });
    if (leftSplit) {
      hasFastBackward = true;
      fastBackwardTo = middleStart - 1;
      items.push({
        type: "fast-backward",
        active: false,
        label: void 0,
        options: showQuickJumpDropdown ? createRange(firstPage + 1, middleStart - 1) : null
      });
    } else if (lastPage >= firstPage + 1) {
      items.push({
        type: "page",
        label: firstPage + 1,
        mayBeFastBackward: true,
        mayBeFastForward: false,
        active: currentPage === firstPage + 1
      });
    }
    for (let i = middleStart; i <= middleEnd; ++i) {
      items.push({
        type: "page",
        label: i,
        mayBeFastBackward: false,
        mayBeFastForward: false,
        active: currentPage === i
      });
    }
    if (rightSplit) {
      hasFastForward = true;
      fastForwardTo = middleEnd + 1;
      items.push({
        type: "fast-forward",
        active: false,
        label: void 0,
        options: showQuickJumpDropdown ? createRange(middleEnd + 1, lastPage - 1) : null
      });
    } else if (middleEnd === lastPage - 2 && items[items.length - 1].label !== lastPage - 1) {
      items.push({
        type: "page",
        mayBeFastForward: true,
        mayBeFastBackward: false,
        label: lastPage - 1,
        active: currentPage === lastPage - 1
      });
    }
    if (items[items.length - 1].label !== lastPage) {
      items.push({
        type: "page",
        mayBeFastForward: false,
        mayBeFastBackward: false,
        label: lastPage,
        active: currentPage === lastPage
      });
    }
    return {
      hasFastBackward,
      hasFastForward,
      fastBackwardTo,
      fastForwardTo,
      items
    };
  }
  function createRange(from, to) {
    const range2 = [];
    for (let i = from; i <= to; ++i) {
      range2.push({
        label: `${i}`,
        value: i
      });
    }
    return range2;
  }
  const paginationProps = Object.assign(Object.assign({}, useTheme.props), {
    simple: Boolean,
    page: Number,
    defaultPage: {
      type: Number,
      default: 1
    },
    itemCount: Number,
    pageCount: Number,
    defaultPageCount: {
      type: Number,
      default: 1
    },
    showSizePicker: Boolean,
    pageSize: Number,
    defaultPageSize: Number,
    pageSizes: {
      type: Array,
      default() {
        return [10];
      }
    },
    showQuickJumper: Boolean,
    size: {
      type: String,
      default: "medium"
    },
    disabled: Boolean,
    pageSlot: {
      type: Number,
      default: 9
    },
    selectProps: Object,
    prev: Function,
    next: Function,
    goto: Function,
    prefix: Function,
    suffix: Function,
    label: Function,
    displayOrder: {
      type: Array,
      default: ["pages", "size-picker", "quick-jumper"]
    },
    to: useAdjustedTo.propTo,
    showQuickJumpDropdown: {
      type: Boolean,
      default: true
    },
    "onUpdate:page": [Function, Array],
    onUpdatePage: [Function, Array],
    "onUpdate:pageSize": [Function, Array],
    onUpdatePageSize: [Function, Array],
    /** @deprecated */
    onPageSizeChange: [Function, Array],
    /** @deprecated */
    onChange: [Function, Array]
  });
  const NPagination = vue.defineComponent({
    name: "Pagination",
    props: paginationProps,
    setup(props) {
      {
        vue.watchEffect(() => {
          if (props.pageCount !== void 0 && props.itemCount !== void 0) {
            warn$2("pagination", "`page-count` and `item-count` should't be specified together. Only `item-count` will take effect.");
          }
          if (props.onPageSizeChange) {
            warnOnce("pagination", "`on-page-size-change` is deprecated, please use `on-update:page-size` instead.");
          }
          if (props.onChange) {
            warnOnce("pagination", "`on-change` is deprecated, please use `on-update:page` instead.");
          }
        });
      }
      const {
        mergedComponentPropsRef,
        mergedClsPrefixRef,
        inlineThemeDisabled,
        mergedRtlRef
      } = useConfig(props);
      const themeRef = useTheme("Pagination", "-pagination", style$11, paginationLight$1, props, mergedClsPrefixRef);
      const {
        localeRef
      } = useLocale("Pagination");
      const selfRef = vue.ref(null);
      const uncontrolledPageRef = vue.ref(props.defaultPage);
      const uncontrolledPageSizeRef = vue.ref(getDefaultPageSize(props));
      const mergedPageRef = useMergedState(vue.toRef(props, "page"), uncontrolledPageRef);
      const mergedPageSizeRef = useMergedState(vue.toRef(props, "pageSize"), uncontrolledPageSizeRef);
      const mergedPageCountRef = vue.computed(() => {
        const {
          itemCount
        } = props;
        if (itemCount !== void 0) {
          return Math.max(1, Math.ceil(itemCount / mergedPageSizeRef.value));
        }
        const {
          pageCount
        } = props;
        if (pageCount !== void 0)
          return Math.max(pageCount, 1);
        return 1;
      });
      const jumperValueRef = vue.ref("");
      vue.watchEffect(() => {
        void props.simple;
        jumperValueRef.value = String(mergedPageRef.value);
      });
      const fastForwardActiveRef = vue.ref(false);
      const fastBackwardActiveRef = vue.ref(false);
      const showFastForwardMenuRef = vue.ref(false);
      const showFastBackwardMenuRef = vue.ref(false);
      const handleFastForwardMouseenter = () => {
        if (props.disabled)
          return;
        fastForwardActiveRef.value = true;
        disableTransitionOneTick();
      };
      const handleFastForwardMouseleave = () => {
        if (props.disabled)
          return;
        fastForwardActiveRef.value = false;
        disableTransitionOneTick();
      };
      const handleFastBackwardMouseenter = () => {
        fastBackwardActiveRef.value = true;
        disableTransitionOneTick();
      };
      const handleFastBackwardMouseleave = () => {
        fastBackwardActiveRef.value = false;
        disableTransitionOneTick();
      };
      const handleMenuSelect = (value) => {
        doUpdatePage(value);
      };
      const pageItemsInfo = vue.computed(() => createPageItemsInfo(mergedPageRef.value, mergedPageCountRef.value, props.pageSlot, props.showQuickJumpDropdown));
      vue.watchEffect(() => {
        if (!pageItemsInfo.value.hasFastBackward) {
          fastBackwardActiveRef.value = false;
          showFastBackwardMenuRef.value = false;
        } else if (!pageItemsInfo.value.hasFastForward) {
          fastForwardActiveRef.value = false;
          showFastForwardMenuRef.value = false;
        }
      });
      const pageSizeOptionsRef = vue.computed(() => {
        const suffix2 = localeRef.value.selectionSuffix;
        return props.pageSizes.map((size2) => {
          if (typeof size2 === "number") {
            return {
              label: `${size2} / ${suffix2}`,
              value: size2
            };
          } else {
            return size2;
          }
        });
      });
      const inputSizeRef = vue.computed(() => {
        var _a, _b;
        return ((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.Pagination) === null || _b === void 0 ? void 0 : _b.inputSize) || smallerSize(props.size);
      });
      const selectSizeRef = vue.computed(() => {
        var _a, _b;
        return ((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.Pagination) === null || _b === void 0 ? void 0 : _b.selectSize) || smallerSize(props.size);
      });
      const startIndexRef = vue.computed(() => {
        return (mergedPageRef.value - 1) * mergedPageSizeRef.value;
      });
      const endIndexRef = vue.computed(() => {
        const endIndex = mergedPageRef.value * mergedPageSizeRef.value - 1;
        const {
          itemCount
        } = props;
        if (itemCount !== void 0) {
          return endIndex > itemCount - 1 ? itemCount - 1 : endIndex;
        }
        return endIndex;
      });
      const mergedItemCountRef = vue.computed(() => {
        const {
          itemCount
        } = props;
        if (itemCount !== void 0)
          return itemCount;
        return (props.pageCount || 1) * mergedPageSizeRef.value;
      });
      const rtlEnabledRef = useRtl("Pagination", mergedRtlRef, mergedClsPrefixRef);
      function disableTransitionOneTick() {
        void vue.nextTick(() => {
          var _a;
          const {
            value: selfEl
          } = selfRef;
          if (!selfEl)
            return;
          selfEl.classList.add("transition-disabled");
          void ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.offsetWidth);
          selfEl.classList.remove("transition-disabled");
        });
      }
      function doUpdatePage(page) {
        if (page === mergedPageRef.value)
          return;
        const {
          "onUpdate:page": _onUpdatePage,
          onUpdatePage,
          onChange,
          simple
        } = props;
        if (_onUpdatePage)
          call(_onUpdatePage, page);
        if (onUpdatePage)
          call(onUpdatePage, page);
        if (onChange)
          call(onChange, page);
        uncontrolledPageRef.value = page;
        if (simple) {
          jumperValueRef.value = String(page);
        }
      }
      function doUpdatePageSize(pageSize) {
        if (pageSize === mergedPageSizeRef.value)
          return;
        const {
          "onUpdate:pageSize": _onUpdatePageSize,
          onUpdatePageSize,
          onPageSizeChange
        } = props;
        if (_onUpdatePageSize)
          call(_onUpdatePageSize, pageSize);
        if (onUpdatePageSize)
          call(onUpdatePageSize, pageSize);
        if (onPageSizeChange)
          call(onPageSizeChange, pageSize);
        uncontrolledPageSizeRef.value = pageSize;
        if (mergedPageCountRef.value < mergedPageRef.value) {
          doUpdatePage(mergedPageCountRef.value);
        }
      }
      function forward() {
        if (props.disabled)
          return;
        const page = Math.min(mergedPageRef.value + 1, mergedPageCountRef.value);
        doUpdatePage(page);
      }
      function backward() {
        if (props.disabled)
          return;
        const page = Math.max(mergedPageRef.value - 1, 1);
        doUpdatePage(page);
      }
      function fastForward() {
        if (props.disabled)
          return;
        const page = Math.min(pageItemsInfo.value.fastForwardTo, mergedPageCountRef.value);
        doUpdatePage(page);
      }
      function fastBackward() {
        if (props.disabled)
          return;
        const page = Math.max(pageItemsInfo.value.fastBackwardTo, 1);
        doUpdatePage(page);
      }
      function handleSizePickerChange(value) {
        doUpdatePageSize(value);
      }
      function doQuickJump() {
        const page = Number.parseInt(jumperValueRef.value);
        if (Number.isNaN(page))
          return;
        doUpdatePage(Math.max(1, Math.min(page, mergedPageCountRef.value)));
        if (!props.simple) {
          jumperValueRef.value = "";
        }
      }
      function handleQuickJumperChange() {
        doQuickJump();
      }
      function handlePageItemClick(pageItem) {
        if (props.disabled)
          return;
        switch (pageItem.type) {
          case "page":
            doUpdatePage(pageItem.label);
            break;
          case "fast-backward":
            fastBackward();
            break;
          case "fast-forward":
            fastForward();
            break;
        }
      }
      function handleJumperInput(value) {
        jumperValueRef.value = value.replace(/\D+/g, "");
      }
      vue.watchEffect(() => {
        void mergedPageRef.value;
        void mergedPageSizeRef.value;
        disableTransitionOneTick();
      });
      const cssVarsRef = vue.computed(() => {
        const {
          size: size2
        } = props;
        const {
          self: {
            buttonBorder,
            buttonBorderHover,
            buttonBorderPressed,
            buttonIconColor,
            buttonIconColorHover,
            buttonIconColorPressed,
            itemTextColor,
            itemTextColorHover,
            itemTextColorPressed,
            itemTextColorActive,
            itemTextColorDisabled,
            itemColor,
            itemColorHover,
            itemColorPressed,
            itemColorActive,
            itemColorActiveHover,
            itemColorDisabled,
            itemBorder,
            itemBorderHover,
            itemBorderPressed,
            itemBorderActive,
            itemBorderDisabled,
            itemBorderRadius,
            jumperTextColor,
            jumperTextColorDisabled,
            buttonColor,
            buttonColorHover,
            buttonColorPressed,
            [createKey("itemPadding", size2)]: itemPadding,
            [createKey("itemMargin", size2)]: itemMargin,
            [createKey("inputWidth", size2)]: inputWidth,
            [createKey("selectWidth", size2)]: selectWidth,
            [createKey("inputMargin", size2)]: inputMargin,
            [createKey("selectMargin", size2)]: selectMargin,
            [createKey("jumperFontSize", size2)]: jumperFontSize,
            [createKey("prefixMargin", size2)]: prefixMargin,
            [createKey("suffixMargin", size2)]: suffixMargin,
            [createKey("itemSize", size2)]: itemSize,
            [createKey("buttonIconSize", size2)]: buttonIconSize,
            [createKey("itemFontSize", size2)]: itemFontSize,
            [`${createKey("itemMargin", size2)}Rtl`]: itemMarginRtl,
            [`${createKey("inputMargin", size2)}Rtl`]: inputMarginRtl
          },
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          }
        } = themeRef.value;
        return {
          "--n-prefix-margin": prefixMargin,
          "--n-suffix-margin": suffixMargin,
          "--n-item-font-size": itemFontSize,
          "--n-select-width": selectWidth,
          "--n-select-margin": selectMargin,
          "--n-input-width": inputWidth,
          "--n-input-margin": inputMargin,
          "--n-input-margin-rtl": inputMarginRtl,
          "--n-item-size": itemSize,
          "--n-item-text-color": itemTextColor,
          "--n-item-text-color-disabled": itemTextColorDisabled,
          "--n-item-text-color-hover": itemTextColorHover,
          "--n-item-text-color-active": itemTextColorActive,
          "--n-item-text-color-pressed": itemTextColorPressed,
          "--n-item-color": itemColor,
          "--n-item-color-hover": itemColorHover,
          "--n-item-color-disabled": itemColorDisabled,
          "--n-item-color-active": itemColorActive,
          "--n-item-color-active-hover": itemColorActiveHover,
          "--n-item-color-pressed": itemColorPressed,
          "--n-item-border": itemBorder,
          "--n-item-border-hover": itemBorderHover,
          "--n-item-border-disabled": itemBorderDisabled,
          "--n-item-border-active": itemBorderActive,
          "--n-item-border-pressed": itemBorderPressed,
          "--n-item-padding": itemPadding,
          "--n-item-border-radius": itemBorderRadius,
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-jumper-font-size": jumperFontSize,
          "--n-jumper-text-color": jumperTextColor,
          "--n-jumper-text-color-disabled": jumperTextColorDisabled,
          "--n-item-margin": itemMargin,
          "--n-item-margin-rtl": itemMarginRtl,
          "--n-button-icon-size": buttonIconSize,
          "--n-button-icon-color": buttonIconColor,
          "--n-button-icon-color-hover": buttonIconColorHover,
          "--n-button-icon-color-pressed": buttonIconColorPressed,
          "--n-button-color-hover": buttonColorHover,
          "--n-button-color": buttonColor,
          "--n-button-color-pressed": buttonColorPressed,
          "--n-button-border": buttonBorder,
          "--n-button-border-hover": buttonBorderHover,
          "--n-button-border-pressed": buttonBorderPressed
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("pagination", vue.computed(() => {
        let hash = "";
        const {
          size: size2
        } = props;
        hash += size2[0];
        return hash;
      }), cssVarsRef, props) : void 0;
      return {
        rtlEnabled: rtlEnabledRef,
        mergedClsPrefix: mergedClsPrefixRef,
        locale: localeRef,
        selfRef,
        mergedPage: mergedPageRef,
        pageItems: vue.computed(() => {
          return pageItemsInfo.value.items;
        }),
        mergedItemCount: mergedItemCountRef,
        jumperValue: jumperValueRef,
        pageSizeOptions: pageSizeOptionsRef,
        mergedPageSize: mergedPageSizeRef,
        inputSize: inputSizeRef,
        selectSize: selectSizeRef,
        mergedTheme: themeRef,
        mergedPageCount: mergedPageCountRef,
        startIndex: startIndexRef,
        endIndex: endIndexRef,
        showFastForwardMenu: showFastForwardMenuRef,
        showFastBackwardMenu: showFastBackwardMenuRef,
        fastForwardActive: fastForwardActiveRef,
        fastBackwardActive: fastBackwardActiveRef,
        handleMenuSelect,
        handleFastForwardMouseenter,
        handleFastForwardMouseleave,
        handleFastBackwardMouseenter,
        handleFastBackwardMouseleave,
        handleJumperInput,
        handleBackwardClick: backward,
        handleForwardClick: forward,
        handlePageItemClick,
        handleSizePickerChange,
        handleQuickJumperChange,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      const {
        $slots,
        mergedClsPrefix,
        disabled,
        cssVars,
        mergedPage,
        mergedPageCount,
        pageItems,
        showSizePicker,
        showQuickJumper,
        mergedTheme,
        locale,
        inputSize,
        selectSize,
        mergedPageSize,
        pageSizeOptions,
        jumperValue,
        simple,
        prev,
        next,
        prefix: prefix2,
        suffix: suffix2,
        label,
        goto,
        handleJumperInput,
        handleSizePickerChange,
        handleBackwardClick,
        handlePageItemClick,
        handleForwardClick,
        handleQuickJumperChange,
        onRender
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      const renderPrefix = $slots.prefix || prefix2;
      const renderSuffix = $slots.suffix || suffix2;
      const renderPrev = prev || $slots.prev;
      const renderNext = next || $slots.next;
      const renderLabel = label || $slots.label;
      return vue.h("div", {
        ref: "selfRef",
        class: [`${mergedClsPrefix}-pagination`, this.themeClass, this.rtlEnabled && `${mergedClsPrefix}-pagination--rtl`, disabled && `${mergedClsPrefix}-pagination--disabled`, simple && `${mergedClsPrefix}-pagination--simple`],
        style: cssVars
      }, renderPrefix ? vue.h("div", {
        class: `${mergedClsPrefix}-pagination-prefix`
      }, renderPrefix({
        page: mergedPage,
        pageSize: mergedPageSize,
        pageCount: mergedPageCount,
        startIndex: this.startIndex,
        endIndex: this.endIndex,
        itemCount: this.mergedItemCount
      })) : null, this.displayOrder.map((part) => {
        switch (part) {
          case "pages":
            return vue.h(vue.Fragment, null, vue.h("div", {
              class: [`${mergedClsPrefix}-pagination-item`, !renderPrev && `${mergedClsPrefix}-pagination-item--button`, (mergedPage <= 1 || mergedPage > mergedPageCount || disabled) && `${mergedClsPrefix}-pagination-item--disabled`],
              onClick: handleBackwardClick
            }, renderPrev ? renderPrev({
              page: mergedPage,
              pageSize: mergedPageSize,
              pageCount: mergedPageCount,
              startIndex: this.startIndex,
              endIndex: this.endIndex,
              itemCount: this.mergedItemCount
            }) : vue.h(NBaseIcon, {
              clsPrefix: mergedClsPrefix
            }, {
              default: () => this.rtlEnabled ? vue.h(ForwardIcon, null) : vue.h(BackwardIcon, null)
            })), simple ? vue.h(vue.Fragment, null, vue.h("div", {
              class: `${mergedClsPrefix}-pagination-quick-jumper`
            }, vue.h(NInput, {
              value: jumperValue,
              onUpdateValue: handleJumperInput,
              size: inputSize,
              placeholder: "",
              disabled,
              theme: mergedTheme.peers.Input,
              themeOverrides: mergedTheme.peerOverrides.Input,
              onChange: handleQuickJumperChange
            })), " /", " ", mergedPageCount) : pageItems.map((pageItem, index) => {
              let contentNode;
              let onMouseenter;
              let onMouseleave;
              const {
                type
              } = pageItem;
              switch (type) {
                case "page":
                  const pageNode = pageItem.label;
                  if (renderLabel) {
                    contentNode = renderLabel({
                      type: "page",
                      node: pageNode,
                      active: pageItem.active
                    });
                  } else {
                    contentNode = pageNode;
                  }
                  break;
                case "fast-forward":
                  const fastForwardNode = this.fastForwardActive ? vue.h(NBaseIcon, {
                    clsPrefix: mergedClsPrefix
                  }, {
                    default: () => this.rtlEnabled ? vue.h(FastBackwardIcon, null) : vue.h(FastForwardIcon, null)
                  }) : vue.h(NBaseIcon, {
                    clsPrefix: mergedClsPrefix
                  }, {
                    default: () => vue.h(MoreIcon, null)
                  });
                  if (renderLabel) {
                    contentNode = renderLabel({
                      type: "fast-forward",
                      node: fastForwardNode,
                      active: this.fastForwardActive || this.showFastForwardMenu
                    });
                  } else {
                    contentNode = fastForwardNode;
                  }
                  onMouseenter = this.handleFastForwardMouseenter;
                  onMouseleave = this.handleFastForwardMouseleave;
                  break;
                case "fast-backward":
                  const fastBackwardNode = this.fastBackwardActive ? vue.h(NBaseIcon, {
                    clsPrefix: mergedClsPrefix
                  }, {
                    default: () => this.rtlEnabled ? vue.h(FastForwardIcon, null) : vue.h(FastBackwardIcon, null)
                  }) : vue.h(NBaseIcon, {
                    clsPrefix: mergedClsPrefix
                  }, {
                    default: () => vue.h(MoreIcon, null)
                  });
                  if (renderLabel) {
                    contentNode = renderLabel({
                      type: "fast-backward",
                      node: fastBackwardNode,
                      active: this.fastBackwardActive || this.showFastBackwardMenu
                    });
                  } else {
                    contentNode = fastBackwardNode;
                  }
                  onMouseenter = this.handleFastBackwardMouseenter;
                  onMouseleave = this.handleFastBackwardMouseleave;
                  break;
              }
              const itemNode = vue.h("div", {
                key: index,
                class: [`${mergedClsPrefix}-pagination-item`, pageItem.active && `${mergedClsPrefix}-pagination-item--active`, type !== "page" && (type === "fast-backward" && this.showFastBackwardMenu || type === "fast-forward" && this.showFastForwardMenu) && `${mergedClsPrefix}-pagination-item--hover`, disabled && `${mergedClsPrefix}-pagination-item--disabled`, type === "page" && `${mergedClsPrefix}-pagination-item--clickable`],
                onClick: () => {
                  handlePageItemClick(pageItem);
                },
                onMouseenter,
                onMouseleave
              }, contentNode);
              if (type === "page" && !pageItem.mayBeFastBackward && !pageItem.mayBeFastForward) {
                return itemNode;
              } else {
                const key = pageItem.type === "page" ? pageItem.mayBeFastBackward ? "fast-backward" : "fast-forward" : pageItem.type;
                if (pageItem.type !== "page" && !pageItem.options) {
                  return itemNode;
                }
                return vue.h(NPopselect, {
                  to: this.to,
                  key,
                  disabled,
                  trigger: "hover",
                  virtualScroll: true,
                  style: {
                    width: "60px"
                  },
                  theme: mergedTheme.peers.Popselect,
                  themeOverrides: mergedTheme.peerOverrides.Popselect,
                  builtinThemeOverrides: {
                    peers: {
                      InternalSelectMenu: {
                        height: "calc(var(--n-option-height) * 4.6)"
                      }
                    }
                  },
                  nodeProps: () => ({
                    style: {
                      justifyContent: "center"
                    }
                  }),
                  show: type === "page" ? false : type === "fast-backward" ? this.showFastBackwardMenu : this.showFastForwardMenu,
                  onUpdateShow: (value) => {
                    if (type === "page")
                      return;
                    if (value) {
                      if (type === "fast-backward") {
                        this.showFastBackwardMenu = value;
                      } else {
                        this.showFastForwardMenu = value;
                      }
                    } else {
                      this.showFastBackwardMenu = false;
                      this.showFastForwardMenu = false;
                    }
                  },
                  options: pageItem.type !== "page" && pageItem.options ? pageItem.options : [],
                  onUpdateValue: this.handleMenuSelect,
                  scrollable: true,
                  showCheckmark: false
                }, {
                  default: () => itemNode
                });
              }
            }), vue.h("div", {
              class: [`${mergedClsPrefix}-pagination-item`, !renderNext && `${mergedClsPrefix}-pagination-item--button`, {
                [`${mergedClsPrefix}-pagination-item--disabled`]: mergedPage < 1 || mergedPage >= mergedPageCount || disabled
              }],
              onClick: handleForwardClick
            }, renderNext ? renderNext({
              page: mergedPage,
              pageSize: mergedPageSize,
              pageCount: mergedPageCount,
              itemCount: this.mergedItemCount,
              startIndex: this.startIndex,
              endIndex: this.endIndex
            }) : vue.h(NBaseIcon, {
              clsPrefix: mergedClsPrefix
            }, {
              default: () => this.rtlEnabled ? vue.h(BackwardIcon, null) : vue.h(ForwardIcon, null)
            })));
          case "size-picker": {
            return !simple && showSizePicker ? vue.h(NSelect, Object.assign({
              consistentMenuWidth: false,
              placeholder: "",
              showCheckmark: false,
              to: this.to
            }, this.selectProps, {
              size: selectSize,
              options: pageSizeOptions,
              value: mergedPageSize,
              disabled,
              theme: mergedTheme.peers.Select,
              themeOverrides: mergedTheme.peerOverrides.Select,
              onUpdateValue: handleSizePickerChange
            })) : null;
          }
          case "quick-jumper":
            return !simple && showQuickJumper ? vue.h("div", {
              class: `${mergedClsPrefix}-pagination-quick-jumper`
            }, goto ? goto() : resolveSlot(this.$slots.goto, () => [locale.goto]), vue.h(NInput, {
              value: jumperValue,
              onUpdateValue: handleJumperInput,
              size: inputSize,
              placeholder: "",
              disabled,
              theme: mergedTheme.peers.Input,
              themeOverrides: mergedTheme.peerOverrides.Input,
              onChange: handleQuickJumperChange
            })) : null;
          default:
            return null;
        }
      }), renderSuffix ? vue.h("div", {
        class: `${mergedClsPrefix}-pagination-suffix`
      }, renderSuffix({
        page: mergedPage,
        pageSize: mergedPageSize,
        pageCount: mergedPageCount,
        startIndex: this.startIndex,
        endIndex: this.endIndex,
        itemCount: this.mergedItemCount
      })) : null);
    }
  });
  const commonVars$9 = {
    padding: "8px 14px"
  };
  function self$R(vars) {
    const {
      borderRadius,
      boxShadow2,
      baseColor
    } = vars;
    return Object.assign(Object.assign({}, commonVars$9), {
      borderRadius,
      boxShadow: boxShadow2,
      color: composite(baseColor, "rgba(0, 0, 0, .85)"),
      textColor: baseColor
    });
  }
  const tooltipLight = createTheme({
    name: "Tooltip",
    common: commonLight,
    peers: {
      Popover: popoverLight$1
    },
    self: self$R
  });
  const tooltipLight$1 = tooltipLight;
  const ellipsisLight = createTheme({
    name: "Ellipsis",
    common: commonLight,
    peers: {
      Tooltip: tooltipLight$1
    }
  });
  const ellipsisLight$1 = ellipsisLight;
  const commonVariables$a = {
    radioSizeSmall: "14px",
    radioSizeMedium: "16px",
    radioSizeLarge: "18px",
    labelPadding: "0 8px",
    labelFontWeight: "400"
  };
  function self$Q(vars) {
    const {
      borderColor,
      primaryColor,
      baseColor,
      textColorDisabled,
      inputColorDisabled,
      textColor2,
      opacityDisabled,
      borderRadius,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      heightSmall,
      heightMedium,
      heightLarge,
      lineHeight: lineHeight2
    } = vars;
    return Object.assign(Object.assign({}, commonVariables$a), {
      labelLineHeight: lineHeight2,
      buttonHeightSmall: heightSmall,
      buttonHeightMedium: heightMedium,
      buttonHeightLarge: heightLarge,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      boxShadow: `inset 0 0 0 1px ${borderColor}`,
      boxShadowActive: `inset 0 0 0 1px ${primaryColor}`,
      boxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, {
        alpha: 0.2
      })}`,
      boxShadowHover: `inset 0 0 0 1px ${primaryColor}`,
      boxShadowDisabled: `inset 0 0 0 1px ${borderColor}`,
      color: baseColor,
      colorDisabled: inputColorDisabled,
      colorActive: "#0000",
      textColor: textColor2,
      textColorDisabled,
      dotColorActive: primaryColor,
      dotColorDisabled: borderColor,
      buttonBorderColor: borderColor,
      buttonBorderColorActive: primaryColor,
      buttonBorderColorHover: borderColor,
      buttonColor: baseColor,
      buttonColorActive: baseColor,
      buttonTextColor: textColor2,
      buttonTextColorActive: primaryColor,
      buttonTextColorHover: primaryColor,
      opacityDisabled,
      buttonBoxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, {
        alpha: 0.3
      })}`,
      buttonBoxShadowHover: "inset 0 0 0 1px #0000",
      buttonBoxShadow: "inset 0 0 0 1px #0000",
      buttonBorderRadius: borderRadius
    });
  }
  const radioLight = {
    name: "Radio",
    common: commonLight,
    self: self$Q
  };
  const radioLight$1 = radioLight;
  const commonVariables$9 = {
    padding: "4px 0",
    optionIconSizeSmall: "14px",
    optionIconSizeMedium: "16px",
    optionIconSizeLarge: "16px",
    optionIconSizeHuge: "18px",
    optionSuffixWidthSmall: "14px",
    optionSuffixWidthMedium: "14px",
    optionSuffixWidthLarge: "16px",
    optionSuffixWidthHuge: "16px",
    optionIconSuffixWidthSmall: "32px",
    optionIconSuffixWidthMedium: "32px",
    optionIconSuffixWidthLarge: "36px",
    optionIconSuffixWidthHuge: "36px",
    optionPrefixWidthSmall: "14px",
    optionPrefixWidthMedium: "14px",
    optionPrefixWidthLarge: "16px",
    optionPrefixWidthHuge: "16px",
    optionIconPrefixWidthSmall: "36px",
    optionIconPrefixWidthMedium: "36px",
    optionIconPrefixWidthLarge: "40px",
    optionIconPrefixWidthHuge: "40px"
  };
  function self$P(vars) {
    const {
      primaryColor,
      textColor2,
      dividerColor,
      hoverColor,
      popoverColor,
      invertedColor,
      borderRadius,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      fontSizeHuge,
      heightSmall,
      heightMedium,
      heightLarge,
      heightHuge,
      textColor3,
      opacityDisabled
    } = vars;
    return Object.assign(Object.assign({}, commonVariables$9), {
      optionHeightSmall: heightSmall,
      optionHeightMedium: heightMedium,
      optionHeightLarge: heightLarge,
      optionHeightHuge: heightHuge,
      borderRadius,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      fontSizeHuge,
      // non-inverted
      optionTextColor: textColor2,
      optionTextColorHover: textColor2,
      optionTextColorActive: primaryColor,
      optionTextColorChildActive: primaryColor,
      color: popoverColor,
      dividerColor,
      suffixColor: textColor2,
      prefixColor: textColor2,
      optionColorHover: hoverColor,
      optionColorActive: changeColor(primaryColor, {
        alpha: 0.1
      }),
      groupHeaderTextColor: textColor3,
      // inverted
      optionTextColorInverted: "#BBB",
      optionTextColorHoverInverted: "#FFF",
      optionTextColorActiveInverted: "#FFF",
      optionTextColorChildActiveInverted: "#FFF",
      colorInverted: invertedColor,
      dividerColorInverted: "#BBB",
      suffixColorInverted: "#BBB",
      prefixColorInverted: "#BBB",
      optionColorHoverInverted: primaryColor,
      optionColorActiveInverted: primaryColor,
      groupHeaderTextColorInverted: "#AAA",
      optionOpacityDisabled: opacityDisabled
    });
  }
  const dropdownLight = createTheme({
    name: "Dropdown",
    common: commonLight,
    peers: {
      Popover: popoverLight$1
    },
    self: self$P
  });
  const dropdownLight$1 = dropdownLight;
  const commonVariables$8 = {
    thPaddingSmall: "8px",
    thPaddingMedium: "12px",
    thPaddingLarge: "12px",
    tdPaddingSmall: "8px",
    tdPaddingMedium: "12px",
    tdPaddingLarge: "12px",
    sorterSize: "15px",
    resizableContainerSize: "8px",
    resizableSize: "2px",
    filterSize: "15px",
    paginationMargin: "12px 0 0 0",
    emptyPadding: "48px 0",
    actionPadding: "8px 12px",
    actionButtonMargin: "0 8px 0 0"
  };
  function self$O(vars) {
    const {
      cardColor,
      modalColor,
      popoverColor,
      textColor2,
      textColor1,
      tableHeaderColor,
      tableColorHover,
      iconColor,
      primaryColor,
      fontWeightStrong,
      borderRadius,
      lineHeight: lineHeight2,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      dividerColor,
      heightSmall,
      opacityDisabled,
      tableColorStriped
    } = vars;
    return Object.assign(Object.assign({}, commonVariables$8), {
      actionDividerColor: dividerColor,
      lineHeight: lineHeight2,
      borderRadius,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      borderColor: composite(cardColor, dividerColor),
      tdColorHover: composite(cardColor, tableColorHover),
      tdColorSorting: composite(cardColor, tableColorHover),
      tdColorStriped: composite(cardColor, tableColorStriped),
      thColor: composite(cardColor, tableHeaderColor),
      thColorHover: composite(composite(cardColor, tableHeaderColor), tableColorHover),
      thColorSorting: composite(composite(cardColor, tableHeaderColor), tableColorHover),
      tdColor: cardColor,
      tdTextColor: textColor2,
      thTextColor: textColor1,
      thFontWeight: fontWeightStrong,
      thButtonColorHover: tableColorHover,
      thIconColor: iconColor,
      thIconColorActive: primaryColor,
      // modal
      borderColorModal: composite(modalColor, dividerColor),
      tdColorHoverModal: composite(modalColor, tableColorHover),
      tdColorSortingModal: composite(modalColor, tableColorHover),
      tdColorStripedModal: composite(modalColor, tableColorStriped),
      thColorModal: composite(modalColor, tableHeaderColor),
      thColorHoverModal: composite(composite(modalColor, tableHeaderColor), tableColorHover),
      thColorSortingModal: composite(composite(modalColor, tableHeaderColor), tableColorHover),
      tdColorModal: modalColor,
      // popover
      borderColorPopover: composite(popoverColor, dividerColor),
      tdColorHoverPopover: composite(popoverColor, tableColorHover),
      tdColorSortingPopover: composite(popoverColor, tableColorHover),
      tdColorStripedPopover: composite(popoverColor, tableColorStriped),
      thColorPopover: composite(popoverColor, tableHeaderColor),
      thColorHoverPopover: composite(composite(popoverColor, tableHeaderColor), tableColorHover),
      thColorSortingPopover: composite(composite(popoverColor, tableHeaderColor), tableColorHover),
      tdColorPopover: popoverColor,
      boxShadowBefore: "inset -12px 0 8px -12px rgba(0, 0, 0, .18)",
      boxShadowAfter: "inset 12px 0 8px -12px rgba(0, 0, 0, .18)",
      // loading
      loadingColor: primaryColor,
      loadingSize: heightSmall,
      opacityLoading: opacityDisabled
    });
  }
  const dataTableLight = createTheme({
    name: "DataTable",
    common: commonLight,
    peers: {
      Button: buttonLight$1,
      Checkbox: checkboxLight$1,
      Radio: radioLight$1,
      Pagination: paginationLight$1,
      Scrollbar: scrollbarLight$1,
      Empty: emptyLight$1,
      Popover: popoverLight$1,
      Ellipsis: ellipsisLight$1,
      Dropdown: dropdownLight$1
    },
    self: self$O
  });
  const dataTableLight$1 = dataTableLight;
  const tooltipProps = Object.assign(Object.assign({}, popoverBaseProps), useTheme.props);
  const NTooltip = vue.defineComponent({
    name: "Tooltip",
    props: tooltipProps,
    __popover__: true,
    setup(props) {
      const {
        mergedClsPrefixRef
      } = useConfig(props);
      const themeRef = useTheme("Tooltip", "-tooltip", void 0, tooltipLight$1, props, mergedClsPrefixRef);
      const popoverRef = vue.ref(null);
      const tooltipExposedMethod = {
        syncPosition() {
          popoverRef.value.syncPosition();
        },
        setShow(show) {
          popoverRef.value.setShow(show);
        }
      };
      return Object.assign(Object.assign({}, tooltipExposedMethod), {
        popoverRef,
        mergedTheme: themeRef,
        popoverThemeOverrides: vue.computed(() => {
          return themeRef.value.self;
        })
      });
    },
    render() {
      const {
        mergedTheme,
        internalExtraClass
      } = this;
      return vue.h(NPopover, Object.assign(Object.assign({}, this.$props), {
        theme: mergedTheme.peers.Popover,
        themeOverrides: mergedTheme.peerOverrides.Popover,
        builtinThemeOverrides: this.popoverThemeOverrides,
        internalExtraClass: internalExtraClass.concat("tooltip"),
        ref: "popoverRef"
      }), this.$slots);
    }
  });
  const style$10 = cB("ellipsis", {
    overflow: "hidden"
  }, [cNotM("line-clamp", `
 white-space: nowrap;
 display: inline-block;
 vertical-align: bottom;
 max-width: 100%;
 `), cM("line-clamp", `
 display: -webkit-inline-box;
 -webkit-box-orient: vertical;
 `), cM("cursor-pointer", `
 cursor: pointer;
 `)]);
  function createLineClampClass(clsPrefix) {
    return `${clsPrefix}-ellipsis--line-clamp`;
  }
  function createCursorClass(clsPrefix, cursor) {
    return `${clsPrefix}-ellipsis--cursor-${cursor}`;
  }
  const ellipsisProps = Object.assign(Object.assign({}, useTheme.props), {
    expandTrigger: String,
    lineClamp: [Number, String],
    tooltip: {
      type: [Boolean, Object],
      default: true
    }
  });
  const NEllipsis = vue.defineComponent({
    name: "Ellipsis",
    inheritAttrs: false,
    props: ellipsisProps,
    setup(props, {
      slots,
      attrs
    }) {
      const mergedClsPrefixRef = useMergedClsPrefix();
      const mergedTheme = useTheme("Ellipsis", "-ellipsis", style$10, ellipsisLight$1, props, mergedClsPrefixRef);
      const triggerRef = vue.ref(null);
      const triggerInnerRef = vue.ref(null);
      const tooltipRef = vue.ref(null);
      const expandedRef = vue.ref(false);
      const ellipsisStyleRef = vue.computed(() => {
        const {
          lineClamp
        } = props;
        const {
          value: expanded
        } = expandedRef;
        if (lineClamp !== void 0) {
          return {
            textOverflow: "",
            "-webkit-line-clamp": expanded ? "" : lineClamp
          };
        } else {
          return {
            textOverflow: expanded ? "" : "ellipsis",
            "-webkit-line-clamp": ""
          };
        }
      });
      function getTooltipDisabled() {
        let tooltipDisabled = false;
        const {
          value: expanded
        } = expandedRef;
        if (expanded)
          return true;
        const {
          value: trigger2
        } = triggerRef;
        if (trigger2) {
          const {
            lineClamp
          } = props;
          syncEllipsisStyle(trigger2);
          if (lineClamp !== void 0) {
            tooltipDisabled = trigger2.scrollHeight <= trigger2.offsetHeight;
          } else {
            const {
              value: triggerInner
            } = triggerInnerRef;
            if (triggerInner) {
              tooltipDisabled = triggerInner.getBoundingClientRect().width <= trigger2.getBoundingClientRect().width;
            }
          }
          syncCursorStyle(trigger2, tooltipDisabled);
        }
        return tooltipDisabled;
      }
      const handleClickRef = vue.computed(() => {
        return props.expandTrigger === "click" ? () => {
          var _a;
          const {
            value: expanded
          } = expandedRef;
          if (expanded) {
            (_a = tooltipRef.value) === null || _a === void 0 ? void 0 : _a.setShow(false);
          }
          expandedRef.value = !expanded;
        } : void 0;
      });
      vue.onDeactivated(() => {
        var _a;
        if (props.tooltip) {
          (_a = tooltipRef.value) === null || _a === void 0 ? void 0 : _a.setShow(false);
        }
      });
      const renderTrigger = () => vue.h("span", Object.assign({}, vue.mergeProps(attrs, {
        class: [`${mergedClsPrefixRef.value}-ellipsis`, props.lineClamp !== void 0 ? createLineClampClass(mergedClsPrefixRef.value) : void 0, props.expandTrigger === "click" ? createCursorClass(mergedClsPrefixRef.value, "pointer") : void 0],
        style: ellipsisStyleRef.value
      }), {
        ref: "triggerRef",
        onClick: handleClickRef.value,
        onMouseenter: (
          // get tooltip disabled will derive cursor style
          props.expandTrigger === "click" ? getTooltipDisabled : void 0
        )
      }), props.lineClamp ? slots : vue.h("span", {
        ref: "triggerInnerRef"
      }, slots));
      function syncEllipsisStyle(trigger2) {
        if (!trigger2)
          return;
        const latestStyle = ellipsisStyleRef.value;
        const lineClampClass = createLineClampClass(mergedClsPrefixRef.value);
        if (props.lineClamp !== void 0) {
          syncTriggerClass(trigger2, lineClampClass, "add");
        } else {
          syncTriggerClass(trigger2, lineClampClass, "remove");
        }
        for (const key in latestStyle) {
          if (trigger2.style[key] !== latestStyle[key]) {
            trigger2.style[key] = latestStyle[key];
          }
        }
      }
      function syncCursorStyle(trigger2, tooltipDisabled) {
        const cursorClass = createCursorClass(mergedClsPrefixRef.value, "pointer");
        if (props.expandTrigger === "click" && !tooltipDisabled) {
          syncTriggerClass(trigger2, cursorClass, "add");
        } else {
          syncTriggerClass(trigger2, cursorClass, "remove");
        }
      }
      function syncTriggerClass(trigger2, styleClass, action) {
        if (action === "add") {
          if (!trigger2.classList.contains(styleClass)) {
            trigger2.classList.add(styleClass);
          }
        } else {
          if (trigger2.classList.contains(styleClass)) {
            trigger2.classList.remove(styleClass);
          }
        }
      }
      return {
        mergedTheme,
        triggerRef,
        triggerInnerRef,
        tooltipRef,
        handleClick: handleClickRef,
        renderTrigger,
        getTooltipDisabled
      };
    },
    render() {
      var _a;
      const {
        tooltip,
        renderTrigger,
        $slots
      } = this;
      if (tooltip) {
        const {
          mergedTheme
        } = this;
        return vue.h(NTooltip, Object.assign({
          ref: "tooltipRef",
          placement: "top"
        }, tooltip, {
          getDisabled: this.getTooltipDisabled,
          theme: mergedTheme.peers.Tooltip,
          themeOverrides: mergedTheme.peerOverrides.Tooltip
        }), {
          trigger: renderTrigger,
          default: (_a = $slots.tooltip) !== null && _a !== void 0 ? _a : $slots.default
        });
      } else {
        return renderTrigger();
      }
    }
  });
  const NPerformantEllipsis = vue.defineComponent({
    name: "PerformantEllipsis",
    props: ellipsisProps,
    inheritAttrs: false,
    setup(props, {
      attrs,
      slots
    }) {
      const mouseEnteredRef = vue.ref(false);
      const mergedClsPrefixRef = useMergedClsPrefix();
      useStyle("-ellipsis", style$10, mergedClsPrefixRef);
      const renderTrigger = () => {
        const {
          lineClamp
        } = props;
        const mergedClsPrefix = mergedClsPrefixRef.value;
        return vue.h("span", Object.assign({}, vue.mergeProps(attrs, {
          class: [`${mergedClsPrefix}-ellipsis`, lineClamp !== void 0 ? createLineClampClass(mergedClsPrefix) : void 0, props.expandTrigger === "click" ? createCursorClass(mergedClsPrefix, "pointer") : void 0],
          style: lineClamp === void 0 ? {
            textOverflow: "ellipsis"
          } : {
            "-webkit-line-clamp": lineClamp
          }
        }), {
          onMouseenter: () => {
            mouseEnteredRef.value = true;
          }
        }), lineClamp ? slots : vue.h("span", null, slots));
      };
      return {
        mouseEntered: mouseEnteredRef,
        renderTrigger
      };
    },
    render() {
      if (this.mouseEntered) {
        return vue.h(NEllipsis, vue.mergeProps({}, this.$attrs, this.$props), this.$slots);
      } else {
        return this.renderTrigger();
      }
    }
  });
  const dataTableProps = Object.assign(Object.assign({}, useTheme.props), {
    onUnstableColumnResize: Function,
    pagination: {
      type: [Object, Boolean],
      default: false
    },
    paginateSinglePage: {
      type: Boolean,
      default: true
    },
    minHeight: [Number, String],
    maxHeight: [Number, String],
    // Use any type as row data to make prop data acceptable
    columns: {
      type: Array,
      default: () => []
    },
    rowClassName: [String, Function],
    rowProps: Function,
    rowKey: Function,
    summary: [Function],
    data: {
      type: Array,
      default: () => []
    },
    loading: Boolean,
    bordered: {
      type: Boolean,
      default: void 0
    },
    bottomBordered: {
      type: Boolean,
      default: void 0
    },
    striped: Boolean,
    scrollX: [Number, String],
    defaultCheckedRowKeys: {
      type: Array,
      default: () => []
    },
    checkedRowKeys: Array,
    singleLine: {
      type: Boolean,
      default: true
    },
    singleColumn: Boolean,
    size: {
      type: String,
      default: "medium"
    },
    remote: Boolean,
    defaultExpandedRowKeys: {
      type: Array,
      default: []
    },
    defaultExpandAll: Boolean,
    expandedRowKeys: Array,
    stickyExpandedRows: Boolean,
    virtualScroll: Boolean,
    virtualScrollX: Boolean,
    virtualScrollHeader: Boolean,
    headerHeight: {
      type: Number,
      default: 28
    },
    heightForRow: Function,
    minRowHeight: {
      type: Number,
      default: 28
    },
    tableLayout: {
      type: String,
      default: "auto"
    },
    allowCheckingNotLoaded: Boolean,
    cascade: {
      type: Boolean,
      default: true
    },
    childrenKey: {
      type: String,
      default: "children"
    },
    indent: {
      type: Number,
      default: 16
    },
    flexHeight: Boolean,
    summaryPlacement: {
      type: String,
      default: "bottom"
    },
    paginationBehaviorOnFilter: {
      type: String,
      default: "current"
    },
    filterIconPopoverProps: Object,
    scrollbarProps: Object,
    renderCell: Function,
    renderExpandIcon: Function,
    spinProps: {
      type: Object,
      default: {}
    },
    onLoad: Function,
    "onUpdate:page": [Function, Array],
    onUpdatePage: [Function, Array],
    "onUpdate:pageSize": [Function, Array],
    onUpdatePageSize: [Function, Array],
    "onUpdate:sorter": [Function, Array],
    onUpdateSorter: [Function, Array],
    "onUpdate:filters": [Function, Array],
    onUpdateFilters: [Function, Array],
    "onUpdate:checkedRowKeys": [Function, Array],
    onUpdateCheckedRowKeys: [Function, Array],
    "onUpdate:expandedRowKeys": [Function, Array],
    onUpdateExpandedRowKeys: [Function, Array],
    onScroll: Function,
    // deprecated
    onPageChange: [Function, Array],
    onPageSizeChange: [Function, Array],
    onSorterChange: [Function, Array],
    onFiltersChange: [Function, Array],
    onCheckedRowKeysChange: [Function, Array]
  });
  const dataTableInjectionKey = createInjectionKey("n-data-table");
  const RenderSorter = vue.defineComponent({
    name: "DataTableRenderSorter",
    props: {
      render: {
        type: Function,
        required: true
      },
      order: {
        // asc, desc
        type: [String, Boolean],
        default: false
      }
    },
    render() {
      const {
        render: render2,
        order
      } = this;
      return render2({
        order
      });
    }
  });
  const SortButton = vue.defineComponent({
    name: "SortIcon",
    props: {
      column: {
        type: Object,
        required: true
      }
    },
    setup(props) {
      const {
        mergedComponentPropsRef
      } = useConfig();
      const {
        mergedSortStateRef,
        mergedClsPrefixRef
      } = vue.inject(dataTableInjectionKey);
      const sortStateRef = vue.computed(() => mergedSortStateRef.value.find((state) => state.columnKey === props.column.key));
      const activeRef = vue.computed(() => {
        return sortStateRef.value !== void 0;
      });
      const mergedSortOrderRef = vue.computed(() => {
        const {
          value: sortState
        } = sortStateRef;
        if (sortState && activeRef.value) {
          return sortState.order;
        }
        return false;
      });
      const mergedRenderSorterRef = vue.computed(() => {
        var _a, _b;
        return ((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.DataTable) === null || _b === void 0 ? void 0 : _b.renderSorter) || props.column.renderSorter;
      });
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        active: activeRef,
        mergedSortOrder: mergedSortOrderRef,
        mergedRenderSorter: mergedRenderSorterRef
      };
    },
    render() {
      const {
        mergedRenderSorter,
        mergedSortOrder,
        mergedClsPrefix
      } = this;
      const {
        renderSorterIcon
      } = this.column;
      return mergedRenderSorter ? vue.h(RenderSorter, {
        render: mergedRenderSorter,
        order: mergedSortOrder
      }) : vue.h("span", {
        class: [`${mergedClsPrefix}-data-table-sorter`, mergedSortOrder === "ascend" && `${mergedClsPrefix}-data-table-sorter--asc`, mergedSortOrder === "descend" && `${mergedClsPrefix}-data-table-sorter--desc`]
      }, renderSorterIcon ? renderSorterIcon({
        order: mergedSortOrder
      }) : vue.h(NBaseIcon, {
        clsPrefix: mergedClsPrefix
      }, {
        default: () => vue.h(ArrowDownIcon, null)
      }));
    }
  });
  const radioBaseProps = {
    name: String,
    value: {
      type: [String, Number, Boolean],
      default: "on"
    },
    checked: {
      type: Boolean,
      default: void 0
    },
    defaultChecked: Boolean,
    disabled: {
      type: Boolean,
      default: void 0
    },
    label: String,
    size: String,
    onUpdateChecked: [Function, Array],
    "onUpdate:checked": [Function, Array],
    // deprecated
    checkedValue: {
      type: Boolean,
      default: void 0
    }
  };
  const radioGroupInjectionKey = createInjectionKey("n-radio-group");
  function setup(props) {
    {
      vue.watchEffect(() => {
        if (props.checkedValue !== void 0) {
          warnOnce("radio", "`checked-value` is deprecated, please use `checked` instead.");
        }
      });
    }
    const NRadioGroup2 = vue.inject(radioGroupInjectionKey, null);
    const formItem = useFormItem(props, {
      mergedSize(NFormItem2) {
        const {
          size: size2
        } = props;
        if (size2 !== void 0)
          return size2;
        if (NRadioGroup2) {
          const {
            mergedSizeRef: {
              value: mergedSize
            }
          } = NRadioGroup2;
          if (mergedSize !== void 0) {
            return mergedSize;
          }
        }
        if (NFormItem2) {
          return NFormItem2.mergedSize.value;
        }
        return "medium";
      },
      mergedDisabled(NFormItem2) {
        if (props.disabled)
          return true;
        if (NRadioGroup2 === null || NRadioGroup2 === void 0 ? void 0 : NRadioGroup2.disabledRef.value)
          return true;
        if (NFormItem2 === null || NFormItem2 === void 0 ? void 0 : NFormItem2.disabled.value)
          return true;
        return false;
      }
    });
    const {
      mergedSizeRef,
      mergedDisabledRef
    } = formItem;
    const inputRef = vue.ref(null);
    const labelRef = vue.ref(null);
    const uncontrolledCheckedRef = vue.ref(props.defaultChecked);
    const controlledCheckedRef = vue.toRef(props, "checked");
    const mergedCheckedRef = useMergedState(controlledCheckedRef, uncontrolledCheckedRef);
    const renderSafeCheckedRef = useMemo(() => {
      if (NRadioGroup2)
        return NRadioGroup2.valueRef.value === props.value;
      return mergedCheckedRef.value;
    });
    const mergedNameRef = useMemo(() => {
      const {
        name
      } = props;
      if (name !== void 0)
        return name;
      if (NRadioGroup2)
        return NRadioGroup2.nameRef.value;
    });
    const focusRef = vue.ref(false);
    function doUpdateChecked() {
      if (NRadioGroup2) {
        const {
          doUpdateValue
        } = NRadioGroup2;
        const {
          value
        } = props;
        call(doUpdateValue, value);
      } else {
        const {
          onUpdateChecked,
          "onUpdate:checked": _onUpdateChecked
        } = props;
        const {
          nTriggerFormInput,
          nTriggerFormChange
        } = formItem;
        if (onUpdateChecked)
          call(onUpdateChecked, true);
        if (_onUpdateChecked)
          call(_onUpdateChecked, true);
        nTriggerFormInput();
        nTriggerFormChange();
        uncontrolledCheckedRef.value = true;
      }
    }
    function toggle() {
      if (mergedDisabledRef.value)
        return;
      if (!renderSafeCheckedRef.value) {
        doUpdateChecked();
      }
    }
    function handleRadioInputChange() {
      toggle();
      if (inputRef.value) {
        inputRef.value.checked = renderSafeCheckedRef.value;
      }
    }
    function handleRadioInputBlur() {
      focusRef.value = false;
    }
    function handleRadioInputFocus() {
      focusRef.value = true;
    }
    return {
      mergedClsPrefix: NRadioGroup2 ? NRadioGroup2.mergedClsPrefixRef : useConfig(props).mergedClsPrefixRef,
      inputRef,
      labelRef,
      mergedName: mergedNameRef,
      mergedDisabled: mergedDisabledRef,
      renderSafeChecked: renderSafeCheckedRef,
      focus: focusRef,
      mergedSize: mergedSizeRef,
      handleRadioInputChange,
      handleRadioInputBlur,
      handleRadioInputFocus
    };
  }
  const style$$ = cB("radio", `
 line-height: var(--n-label-line-height);
 outline: none;
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 display: inline-flex;
 align-items: flex-start;
 flex-wrap: nowrap;
 font-size: var(--n-font-size);
 word-break: break-word;
`, [cM("checked", [cE("dot", `
 background-color: var(--n-color-active);
 `)]), cE("dot-wrapper", `
 position: relative;
 flex-shrink: 0;
 flex-grow: 0;
 width: var(--n-radio-size);
 `), cB("radio-input", `
 position: absolute;
 border: 0;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 opacity: 0;
 z-index: 1;
 cursor: pointer;
 `), cE("dot", `
 position: absolute;
 top: 50%;
 left: 0;
 transform: translateY(-50%);
 height: var(--n-radio-size);
 width: var(--n-radio-size);
 background: var(--n-color);
 box-shadow: var(--n-box-shadow);
 border-radius: 50%;
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `, [c$1("&::before", `
 content: "";
 opacity: 0;
 position: absolute;
 left: 4px;
 top: 4px;
 height: calc(100% - 8px);
 width: calc(100% - 8px);
 border-radius: 50%;
 transform: scale(.8);
 background: var(--n-dot-color-active);
 transition: 
 opacity .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 transform .3s var(--n-bezier);
 `), cM("checked", {
    boxShadow: "var(--n-box-shadow-active)"
  }, [c$1("&::before", `
 opacity: 1;
 transform: scale(1);
 `)])]), cE("label", `
 color: var(--n-text-color);
 padding: var(--n-label-padding);
 font-weight: var(--n-label-font-weight);
 display: inline-block;
 transition: color .3s var(--n-bezier);
 `), cNotM("disabled", `
 cursor: pointer;
 `, [c$1("&:hover", [cE("dot", {
    boxShadow: "var(--n-box-shadow-hover)"
  })]), cM("focus", [c$1("&:not(:active)", [cE("dot", {
    boxShadow: "var(--n-box-shadow-focus)"
  })])])]), cM("disabled", `
 cursor: not-allowed;
 `, [cE("dot", {
    boxShadow: "var(--n-box-shadow-disabled)",
    backgroundColor: "var(--n-color-disabled)"
  }, [c$1("&::before", {
    backgroundColor: "var(--n-dot-color-disabled)"
  }), cM("checked", `
 opacity: 1;
 `)]), cE("label", {
    color: "var(--n-text-color-disabled)"
  }), cB("radio-input", `
 cursor: not-allowed;
 `)])]);
  const radioProps = Object.assign(Object.assign({}, useTheme.props), radioBaseProps);
  const NRadio = vue.defineComponent({
    name: "Radio",
    props: radioProps,
    setup(props) {
      const radio = setup(props);
      const themeRef = useTheme("Radio", "-radio", style$$, radioLight$1, props, radio.mergedClsPrefix);
      const cssVarsRef = vue.computed(() => {
        const {
          mergedSize: {
            value: size2
          }
        } = radio;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            boxShadow,
            boxShadowActive,
            boxShadowDisabled,
            boxShadowFocus,
            boxShadowHover,
            color,
            colorDisabled,
            colorActive,
            textColor,
            textColorDisabled,
            dotColorActive,
            dotColorDisabled,
            labelPadding,
            labelLineHeight,
            labelFontWeight,
            [createKey("fontSize", size2)]: fontSize2,
            [createKey("radioSize", size2)]: radioSize
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-label-line-height": labelLineHeight,
          "--n-label-font-weight": labelFontWeight,
          "--n-box-shadow": boxShadow,
          "--n-box-shadow-active": boxShadowActive,
          "--n-box-shadow-disabled": boxShadowDisabled,
          "--n-box-shadow-focus": boxShadowFocus,
          "--n-box-shadow-hover": boxShadowHover,
          "--n-color": color,
          "--n-color-active": colorActive,
          "--n-color-disabled": colorDisabled,
          "--n-dot-color-active": dotColorActive,
          "--n-dot-color-disabled": dotColorDisabled,
          "--n-font-size": fontSize2,
          "--n-radio-size": radioSize,
          "--n-text-color": textColor,
          "--n-text-color-disabled": textColorDisabled,
          "--n-label-padding": labelPadding
        };
      });
      const {
        inlineThemeDisabled,
        mergedClsPrefixRef,
        mergedRtlRef
      } = useConfig(props);
      const rtlEnabledRef = useRtl("Radio", mergedRtlRef, mergedClsPrefixRef);
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("radio", vue.computed(() => radio.mergedSize.value[0]), cssVarsRef, props) : void 0;
      return Object.assign(radio, {
        rtlEnabled: rtlEnabledRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      });
    },
    render() {
      const {
        $slots,
        mergedClsPrefix,
        onRender,
        label
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h("label", {
        class: [`${mergedClsPrefix}-radio`, this.themeClass, this.rtlEnabled && `${mergedClsPrefix}-radio--rtl`, this.mergedDisabled && `${mergedClsPrefix}-radio--disabled`, this.renderSafeChecked && `${mergedClsPrefix}-radio--checked`, this.focus && `${mergedClsPrefix}-radio--focus`],
        style: this.cssVars
      }, vue.h("input", {
        ref: "inputRef",
        type: "radio",
        class: `${mergedClsPrefix}-radio-input`,
        value: this.value,
        name: this.mergedName,
        checked: this.renderSafeChecked,
        disabled: this.mergedDisabled,
        onChange: this.handleRadioInputChange,
        onFocus: this.handleRadioInputFocus,
        onBlur: this.handleRadioInputBlur
      }), vue.h("div", {
        class: `${mergedClsPrefix}-radio__dot-wrapper`
      }, " ", vue.h("div", {
        class: [`${mergedClsPrefix}-radio__dot`, this.renderSafeChecked && `${mergedClsPrefix}-radio__dot--checked`]
      })), resolveWrappedSlot($slots.default, (children) => {
        if (!children && !label)
          return null;
        return vue.h("div", {
          ref: "labelRef",
          class: `${mergedClsPrefix}-radio__label`
        }, children || label);
      }));
    }
  });
  const style$_ = cB("radio-group", `
 display: inline-block;
 font-size: var(--n-font-size);
`, [cE("splitor", `
 display: inline-block;
 vertical-align: bottom;
 width: 1px;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 background: var(--n-button-border-color);
 `, [cM("checked", {
    backgroundColor: "var(--n-button-border-color-active)"
  }), cM("disabled", {
    opacity: "var(--n-opacity-disabled)"
  })]), cM("button-group", `
 white-space: nowrap;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [cB("radio-button", {
    height: "var(--n-height)",
    lineHeight: "var(--n-height)"
  }), cE("splitor", {
    height: "var(--n-height)"
  })]), cB("radio-button", `
 vertical-align: bottom;
 outline: none;
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 display: inline-block;
 box-sizing: border-box;
 padding-left: 14px;
 padding-right: 14px;
 white-space: nowrap;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 background: var(--n-button-color);
 color: var(--n-button-text-color);
 border-top: 1px solid var(--n-button-border-color);
 border-bottom: 1px solid var(--n-button-border-color);
 `, [cB("radio-input", `
 pointer-events: none;
 position: absolute;
 border: 0;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 opacity: 0;
 z-index: 1;
 `), cE("state-border", `
 z-index: 1;
 pointer-events: none;
 position: absolute;
 box-shadow: var(--n-button-box-shadow);
 transition: box-shadow .3s var(--n-bezier);
 left: -1px;
 bottom: -1px;
 right: -1px;
 top: -1px;
 `), c$1("&:first-child", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 border-left: 1px solid var(--n-button-border-color);
 `, [cE("state-border", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 `)]), c$1("&:last-child", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 border-right: 1px solid var(--n-button-border-color);
 `, [cE("state-border", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 `)]), cNotM("disabled", `
 cursor: pointer;
 `, [c$1("&:hover", [cE("state-border", `
 transition: box-shadow .3s var(--n-bezier);
 box-shadow: var(--n-button-box-shadow-hover);
 `), cNotM("checked", {
    color: "var(--n-button-text-color-hover)"
  })]), cM("focus", [c$1("&:not(:active)", [cE("state-border", {
    boxShadow: "var(--n-button-box-shadow-focus)"
  })])])]), cM("checked", `
 background: var(--n-button-color-active);
 color: var(--n-button-text-color-active);
 border-color: var(--n-button-border-color-active);
 `), cM("disabled", `
 cursor: not-allowed;
 opacity: var(--n-opacity-disabled);
 `)])]);
  function mapSlot(defaultSlot, value, clsPrefix) {
    var _a;
    const children = [];
    let isButtonGroup = false;
    for (let i = 0; i < defaultSlot.length; ++i) {
      const wrappedInstance = defaultSlot[i];
      const name = (_a = wrappedInstance.type) === null || _a === void 0 ? void 0 : _a.name;
      if (name === "RadioButton") {
        isButtonGroup = true;
      }
      if (isButtonGroup && name !== "RadioButton") {
        warn$2("radio-group", "`n-radio-group` in button mode only takes `n-radio-button` as children.");
        continue;
      }
      const instanceProps = wrappedInstance.props;
      if (name !== "RadioButton") {
        children.push(wrappedInstance);
        continue;
      }
      if (i === 0) {
        children.push(wrappedInstance);
      } else {
        const lastInstanceProps = children[children.length - 1].props;
        const lastInstanceChecked = value === lastInstanceProps.value;
        const lastInstanceDisabled = lastInstanceProps.disabled;
        const currentInstanceChecked = value === instanceProps.value;
        const currentInstanceDisabled = instanceProps.disabled;
        const lastInstancePriority = (lastInstanceChecked ? 2 : 0) + (!lastInstanceDisabled ? 1 : 0);
        const currentInstancePriority = (currentInstanceChecked ? 2 : 0) + (!currentInstanceDisabled ? 1 : 0);
        const lastInstanceClass = {
          [`${clsPrefix}-radio-group__splitor--disabled`]: lastInstanceDisabled,
          [`${clsPrefix}-radio-group__splitor--checked`]: lastInstanceChecked
        };
        const currentInstanceClass = {
          [`${clsPrefix}-radio-group__splitor--disabled`]: currentInstanceDisabled,
          [`${clsPrefix}-radio-group__splitor--checked`]: currentInstanceChecked
        };
        const splitorClass = lastInstancePriority < currentInstancePriority ? currentInstanceClass : lastInstanceClass;
        children.push(vue.h("div", {
          class: [`${clsPrefix}-radio-group__splitor`, splitorClass]
        }), wrappedInstance);
      }
    }
    return {
      children,
      isButtonGroup
    };
  }
  const radioGroupProps = Object.assign(Object.assign({}, useTheme.props), {
    name: String,
    value: [String, Number, Boolean],
    defaultValue: {
      type: [String, Number, Boolean],
      default: null
    },
    size: String,
    disabled: {
      type: Boolean,
      default: void 0
    },
    "onUpdate:value": [Function, Array],
    onUpdateValue: [Function, Array]
  });
  const NRadioGroup = vue.defineComponent({
    name: "RadioGroup",
    props: radioGroupProps,
    setup(props) {
      const selfElRef = vue.ref(null);
      const {
        mergedSizeRef,
        mergedDisabledRef,
        nTriggerFormChange,
        nTriggerFormInput,
        nTriggerFormBlur,
        nTriggerFormFocus
      } = useFormItem(props);
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled,
        mergedRtlRef
      } = useConfig(props);
      const themeRef = useTheme("Radio", "-radio-group", style$_, radioLight$1, props, mergedClsPrefixRef);
      const uncontrolledValueRef = vue.ref(props.defaultValue);
      const controlledValueRef = vue.toRef(props, "value");
      const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
      function doUpdateValue(value) {
        const {
          onUpdateValue,
          "onUpdate:value": _onUpdateValue
        } = props;
        if (onUpdateValue) {
          call(onUpdateValue, value);
        }
        if (_onUpdateValue) {
          call(_onUpdateValue, value);
        }
        uncontrolledValueRef.value = value;
        nTriggerFormChange();
        nTriggerFormInput();
      }
      function handleFocusin(e) {
        const {
          value: selfEl
        } = selfElRef;
        if (!selfEl)
          return;
        if (selfEl.contains(e.relatedTarget))
          return;
        nTriggerFormFocus();
      }
      function handleFocusout(e) {
        const {
          value: selfEl
        } = selfElRef;
        if (!selfEl)
          return;
        if (selfEl.contains(e.relatedTarget))
          return;
        nTriggerFormBlur();
      }
      vue.provide(radioGroupInjectionKey, {
        mergedClsPrefixRef,
        nameRef: vue.toRef(props, "name"),
        valueRef: mergedValueRef,
        disabledRef: mergedDisabledRef,
        mergedSizeRef,
        doUpdateValue
      });
      const rtlEnabledRef = useRtl("Radio", mergedRtlRef, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          value: size2
        } = mergedSizeRef;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            buttonBorderColor,
            buttonBorderColorActive,
            buttonBorderRadius,
            buttonBoxShadow,
            buttonBoxShadowFocus,
            buttonBoxShadowHover,
            buttonColor,
            buttonColorActive,
            buttonTextColor,
            buttonTextColorActive,
            buttonTextColorHover,
            opacityDisabled,
            [createKey("buttonHeight", size2)]: height,
            [createKey("fontSize", size2)]: fontSize2
          }
        } = themeRef.value;
        return {
          "--n-font-size": fontSize2,
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-button-border-color": buttonBorderColor,
          "--n-button-border-color-active": buttonBorderColorActive,
          "--n-button-border-radius": buttonBorderRadius,
          "--n-button-box-shadow": buttonBoxShadow,
          "--n-button-box-shadow-focus": buttonBoxShadowFocus,
          "--n-button-box-shadow-hover": buttonBoxShadowHover,
          "--n-button-color": buttonColor,
          "--n-button-color-active": buttonColorActive,
          "--n-button-text-color": buttonTextColor,
          "--n-button-text-color-hover": buttonTextColorHover,
          "--n-button-text-color-active": buttonTextColorActive,
          "--n-height": height,
          "--n-opacity-disabled": opacityDisabled
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("radio-group", vue.computed(() => mergedSizeRef.value[0]), cssVarsRef, props) : void 0;
      return {
        selfElRef,
        rtlEnabled: rtlEnabledRef,
        mergedClsPrefix: mergedClsPrefixRef,
        mergedValue: mergedValueRef,
        handleFocusout,
        handleFocusin,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a;
      const {
        mergedValue,
        mergedClsPrefix,
        handleFocusin,
        handleFocusout
      } = this;
      const {
        children,
        isButtonGroup
      } = mapSlot(flatten$3(getSlot$1(this)), mergedValue, mergedClsPrefix);
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      return vue.h("div", {
        onFocusin: handleFocusin,
        onFocusout: handleFocusout,
        ref: "selfElRef",
        class: [`${mergedClsPrefix}-radio-group`, this.rtlEnabled && `${mergedClsPrefix}-radio-group--rtl`, this.themeClass, isButtonGroup && `${mergedClsPrefix}-radio-group--button-group`],
        style: this.cssVars
      }, children);
    }
  });
  const radioButtonProps = radioBaseProps;
  const RadioButton = vue.defineComponent({
    name: "RadioButton",
    props: radioBaseProps,
    setup,
    render() {
      const {
        mergedClsPrefix
      } = this;
      return vue.h("label", {
        class: [`${mergedClsPrefix}-radio-button`, this.mergedDisabled && `${mergedClsPrefix}-radio-button--disabled`, this.renderSafeChecked && `${mergedClsPrefix}-radio-button--checked`, this.focus && [`${mergedClsPrefix}-radio-button--focus`]]
      }, vue.h("input", {
        ref: "inputRef",
        type: "radio",
        class: `${mergedClsPrefix}-radio-input`,
        value: this.value,
        name: this.mergedName,
        checked: this.renderSafeChecked,
        disabled: this.mergedDisabled,
        onChange: this.handleRadioInputChange,
        onFocus: this.handleRadioInputFocus,
        onBlur: this.handleRadioInputBlur
      }), vue.h("div", {
        class: `${mergedClsPrefix}-radio-button__state-border`
      }), resolveWrappedSlot(this.$slots.default, (children) => {
        if (!children && !this.label)
          return null;
        return vue.h("div", {
          ref: "labelRef",
          class: `${mergedClsPrefix}-radio__label`
        }, children || this.label);
      }));
    }
  });
  const SELECTION_COL_WIDTH = 40;
  const EXPAND_COL_WIDTH = 40;
  function getNumberColWidth(col) {
    if (col.type === "selection") {
      return col.width === void 0 ? SELECTION_COL_WIDTH : depx(col.width);
    }
    if (col.type === "expand") {
      return col.width === void 0 ? EXPAND_COL_WIDTH : depx(col.width);
    }
    if ("children" in col)
      return void 0;
    if (typeof col.width === "string") {
      return depx(col.width);
    }
    return col.width;
  }
  function getStringColWidth(col) {
    var _a, _b;
    if (col.type === "selection") {
      return formatLength((_a = col.width) !== null && _a !== void 0 ? _a : SELECTION_COL_WIDTH);
    }
    if (col.type === "expand") {
      return formatLength((_b = col.width) !== null && _b !== void 0 ? _b : EXPAND_COL_WIDTH);
    }
    if ("children" in col) {
      return void 0;
    }
    return formatLength(col.width);
  }
  function getColKey(col) {
    if (col.type === "selection")
      return "__n_selection__";
    if (col.type === "expand")
      return "__n_expand__";
    return col.key;
  }
  function createShallowClonedObject(object) {
    if (!object)
      return object;
    if (typeof object === "object") {
      return Object.assign({}, object);
    }
    return object;
  }
  function getFlagOfOrder(order) {
    if (order === "ascend")
      return 1;
    else if (order === "descend")
      return -1;
    return 0;
  }
  function clampValueFollowCSSRules(value, min, max) {
    if (max !== void 0) {
      value = Math.min(value, typeof max === "number" ? max : Number.parseFloat(max));
    }
    if (min !== void 0) {
      value = Math.max(value, typeof min === "number" ? min : Number.parseFloat(min));
    }
    return value;
  }
  function createCustomWidthStyle(column, resizedWidth) {
    if (resizedWidth !== void 0) {
      return {
        width: resizedWidth,
        minWidth: resizedWidth,
        maxWidth: resizedWidth
      };
    }
    const width = getStringColWidth(column);
    const {
      minWidth,
      maxWidth
    } = column;
    return {
      width,
      minWidth: formatLength(minWidth) || width,
      maxWidth: formatLength(maxWidth)
    };
  }
  function createRowClassName(row, index, rowClassName) {
    if (typeof rowClassName === "function")
      return rowClassName(row, index);
    return rowClassName || "";
  }
  function shouldUseArrayInSingleMode(column) {
    return column.filterOptionValues !== void 0 || column.filterOptionValue === void 0 && column.defaultFilterOptionValues !== void 0;
  }
  function isColumnSortable(column) {
    if ("children" in column)
      return false;
    return !!column.sorter;
  }
  function isColumnResizable(column) {
    if ("children" in column && !!column.children.length)
      return false;
    return !!column.resizable;
  }
  function isColumnFilterable(column) {
    if ("children" in column)
      return false;
    return !!column.filter && (!!column.filterOptions || !!column.renderFilterMenu);
  }
  function getNextOrderOf(order) {
    if (!order)
      return "descend";
    else if (order === "descend")
      return "ascend";
    return false;
  }
  function createNextSorter(column, currentSortState) {
    if (column.sorter === void 0)
      return null;
    if (currentSortState === null || currentSortState.columnKey !== column.key) {
      return {
        columnKey: column.key,
        sorter: column.sorter,
        order: getNextOrderOf(false)
      };
    } else {
      return Object.assign(Object.assign({}, currentSortState), {
        order: getNextOrderOf(currentSortState.order)
      });
    }
  }
  function isColumnSorting(column, mergedSortState) {
    return mergedSortState.find((state) => state.columnKey === column.key && state.order) !== void 0;
  }
  function formatCsvCell(value) {
    if (typeof value === "string") {
      return value.replace(/,/g, "\\,");
    } else if (value === null || value === void 0) {
      return "";
    } else {
      return `${value}`.replace(/,/g, "\\,");
    }
  }
  function generateCsv(columns, data) {
    const exportableColumns = columns.filter((column) => column.type !== "expand" && column.type !== "selection" && column.allowExport !== false);
    const header = exportableColumns.map((col) => col.title).join(",");
    const rows = data.map((row) => {
      return exportableColumns.map((col) => formatCsvCell(row[col.key])).join(",");
    });
    return [header, ...rows].join("\n");
  }
  const NDataTableFilterMenu = vue.defineComponent({
    name: "DataTableFilterMenu",
    props: {
      column: {
        type: Object,
        required: true
      },
      radioGroupName: {
        type: String,
        required: true
      },
      multiple: {
        type: Boolean,
        required: true
      },
      value: {
        type: [Array, String, Number],
        default: null
      },
      options: {
        type: Array,
        required: true
      },
      onConfirm: {
        type: Function,
        required: true
      },
      onClear: {
        type: Function,
        required: true
      },
      onChange: {
        type: Function,
        required: true
      }
    },
    setup(props) {
      const {
        mergedClsPrefixRef: mergedClsPrefixRefRtl,
        mergedRtlRef
      } = useConfig(props);
      const rtlEnabledRef = useRtl("DataTable", mergedRtlRef, mergedClsPrefixRefRtl);
      const {
        mergedClsPrefixRef,
        mergedThemeRef,
        localeRef
      } = vue.inject(dataTableInjectionKey);
      const temporalValueRef = vue.ref(props.value);
      const checkboxGroupValueRef = vue.computed(() => {
        const {
          value: temporalValue
        } = temporalValueRef;
        if (!Array.isArray(temporalValue))
          return null;
        return temporalValue;
      });
      const radioGroupValueRef = vue.computed(() => {
        const {
          value: temporalValue
        } = temporalValueRef;
        if (shouldUseArrayInSingleMode(props.column)) {
          return Array.isArray(temporalValue) && temporalValue.length && temporalValue[0] || null;
        }
        if (!Array.isArray(temporalValue))
          return temporalValue;
        return null;
      });
      function doChange(value) {
        props.onChange(value);
      }
      function handleChange(value) {
        if (props.multiple && Array.isArray(value)) {
          temporalValueRef.value = value;
        } else if (shouldUseArrayInSingleMode(props.column) && !Array.isArray(value)) {
          temporalValueRef.value = [value];
        } else {
          temporalValueRef.value = value;
        }
      }
      function handleConfirmClick() {
        doChange(temporalValueRef.value);
        props.onConfirm();
      }
      function handleClearClick() {
        if (props.multiple || shouldUseArrayInSingleMode(props.column)) {
          doChange([]);
        } else {
          doChange(null);
        }
        props.onClear();
      }
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        rtlEnabled: rtlEnabledRef,
        mergedTheme: mergedThemeRef,
        locale: localeRef,
        checkboxGroupValue: checkboxGroupValueRef,
        radioGroupValue: radioGroupValueRef,
        handleChange,
        handleConfirmClick,
        handleClearClick
      };
    },
    render() {
      const {
        mergedTheme,
        locale,
        mergedClsPrefix
      } = this;
      return vue.h("div", {
        class: [`${mergedClsPrefix}-data-table-filter-menu`, this.rtlEnabled && `${mergedClsPrefix}-data-table-filter-menu--rtl`]
      }, vue.h(NScrollbar, null, {
        default: () => {
          const {
            checkboxGroupValue,
            handleChange
          } = this;
          return this.multiple ? vue.h(NCheckboxGroup, {
            value: checkboxGroupValue,
            class: `${mergedClsPrefix}-data-table-filter-menu__group`,
            onUpdateValue: handleChange
          }, {
            default: () => this.options.map((option) => {
              return vue.h(NCheckbox, {
                key: option.value,
                theme: mergedTheme.peers.Checkbox,
                themeOverrides: mergedTheme.peerOverrides.Checkbox,
                value: option.value
              }, {
                default: () => option.label
              });
            })
          }) : vue.h(NRadioGroup, {
            name: this.radioGroupName,
            class: `${mergedClsPrefix}-data-table-filter-menu__group`,
            value: this.radioGroupValue,
            onUpdateValue: this.handleChange
          }, {
            default: () => this.options.map((option) => vue.h(NRadio, {
              key: option.value,
              value: option.value,
              theme: mergedTheme.peers.Radio,
              themeOverrides: mergedTheme.peerOverrides.Radio
            }, {
              default: () => option.label
            }))
          });
        }
      }), vue.h("div", {
        class: `${mergedClsPrefix}-data-table-filter-menu__action`
      }, vue.h(NButton, {
        size: "tiny",
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        onClick: this.handleClearClick
      }, {
        default: () => locale.clear
      }), vue.h(NButton, {
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        type: "primary",
        size: "tiny",
        onClick: this.handleConfirmClick
      }, {
        default: () => locale.confirm
      })));
    }
  });
  const RenderFilter = vue.defineComponent({
    name: "DataTableRenderFilter",
    props: {
      render: {
        type: Function,
        required: true
      },
      active: {
        type: Boolean,
        default: false
      },
      show: {
        type: Boolean,
        default: false
      }
    },
    render() {
      const {
        render: render2,
        active,
        show
      } = this;
      return render2({
        active,
        show
      });
    }
  });
  function createFilterState(currentFilterState, columnKey, mergedFilterValue) {
    const nextFilterState = Object.assign({}, currentFilterState);
    nextFilterState[columnKey] = mergedFilterValue;
    return nextFilterState;
  }
  const FilterButton = vue.defineComponent({
    name: "DataTableFilterButton",
    props: {
      column: {
        type: Object,
        required: true
      },
      options: {
        type: Array,
        default: () => []
      }
    },
    setup(props) {
      const {
        mergedComponentPropsRef
      } = useConfig();
      const {
        mergedThemeRef,
        mergedClsPrefixRef,
        mergedFilterStateRef,
        filterMenuCssVarsRef,
        paginationBehaviorOnFilterRef,
        doUpdatePage,
        doUpdateFilters,
        filterIconPopoverPropsRef
      } = vue.inject(dataTableInjectionKey);
      const showPopoverRef = vue.ref(false);
      const filterStateRef = mergedFilterStateRef;
      const filterMultipleRef = vue.computed(() => {
        return props.column.filterMultiple !== false;
      });
      const mergedFilterValueRef = vue.computed(() => {
        const filterValue = filterStateRef.value[props.column.key];
        if (filterValue === void 0) {
          const {
            value: multiple
          } = filterMultipleRef;
          if (multiple)
            return [];
          else
            return null;
        }
        return filterValue;
      });
      const activeRef = vue.computed(() => {
        const {
          value: filterValue
        } = mergedFilterValueRef;
        if (Array.isArray(filterValue)) {
          return filterValue.length > 0;
        }
        return filterValue !== null;
      });
      const mergedRenderFilterRef = vue.computed(() => {
        var _a, _b;
        return ((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.DataTable) === null || _b === void 0 ? void 0 : _b.renderFilter) || props.column.renderFilter;
      });
      function handleFilterChange(mergedFilterValue) {
        const nextFilterState = createFilterState(filterStateRef.value, props.column.key, mergedFilterValue);
        doUpdateFilters(nextFilterState, props.column);
        if (paginationBehaviorOnFilterRef.value === "first") {
          doUpdatePage(1);
        }
      }
      function handleFilterMenuCancel() {
        showPopoverRef.value = false;
      }
      function handleFilterMenuConfirm() {
        showPopoverRef.value = false;
      }
      return {
        mergedTheme: mergedThemeRef,
        mergedClsPrefix: mergedClsPrefixRef,
        active: activeRef,
        showPopover: showPopoverRef,
        mergedRenderFilter: mergedRenderFilterRef,
        filterIconPopoverProps: filterIconPopoverPropsRef,
        filterMultiple: filterMultipleRef,
        mergedFilterValue: mergedFilterValueRef,
        filterMenuCssVars: filterMenuCssVarsRef,
        handleFilterChange,
        handleFilterMenuConfirm,
        handleFilterMenuCancel
      };
    },
    render() {
      const {
        mergedTheme,
        mergedClsPrefix,
        handleFilterMenuCancel,
        filterIconPopoverProps
      } = this;
      return vue.h(NPopover, Object.assign({
        show: this.showPopover,
        onUpdateShow: (v) => this.showPopover = v,
        trigger: "click",
        theme: mergedTheme.peers.Popover,
        themeOverrides: mergedTheme.peerOverrides.Popover,
        placement: "bottom"
      }, filterIconPopoverProps, {
        style: {
          padding: 0
        }
      }), {
        trigger: () => {
          const {
            mergedRenderFilter
          } = this;
          if (mergedRenderFilter) {
            return vue.h(RenderFilter, {
              "data-data-table-filter": true,
              render: mergedRenderFilter,
              active: this.active,
              show: this.showPopover
            });
          }
          const {
            renderFilterIcon
          } = this.column;
          return vue.h("div", {
            "data-data-table-filter": true,
            class: [`${mergedClsPrefix}-data-table-filter`, {
              [`${mergedClsPrefix}-data-table-filter--active`]: this.active,
              [`${mergedClsPrefix}-data-table-filter--show`]: this.showPopover
            }]
          }, renderFilterIcon ? renderFilterIcon({
            active: this.active,
            show: this.showPopover
          }) : vue.h(NBaseIcon, {
            clsPrefix: mergedClsPrefix
          }, {
            default: () => vue.h(FilterIcon, null)
          }));
        },
        default: () => {
          const {
            renderFilterMenu
          } = this.column;
          return renderFilterMenu ? renderFilterMenu({
            hide: handleFilterMenuCancel
          }) : vue.h(NDataTableFilterMenu, {
            style: this.filterMenuCssVars,
            radioGroupName: String(this.column.key),
            multiple: this.filterMultiple,
            value: this.mergedFilterValue,
            options: this.options,
            column: this.column,
            onChange: this.handleFilterChange,
            onClear: this.handleFilterMenuCancel,
            onConfirm: this.handleFilterMenuConfirm
          });
        }
      });
    }
  });
  const ResizeButton = vue.defineComponent({
    name: "ColumnResizeButton",
    props: {
      onResizeStart: Function,
      onResize: Function,
      onResizeEnd: Function
    },
    setup(props) {
      const {
        mergedClsPrefixRef
      } = vue.inject(dataTableInjectionKey);
      const activeRef = vue.ref(false);
      let startX = 0;
      function getMouseX(e) {
        return e.clientX;
      }
      function handleMousedown(e) {
        var _a;
        e.preventDefault();
        const alreadyStarted = activeRef.value;
        startX = getMouseX(e);
        activeRef.value = true;
        if (!alreadyStarted) {
          on("mousemove", window, handleMousemove);
          on("mouseup", window, handleMouseup);
          (_a = props.onResizeStart) === null || _a === void 0 ? void 0 : _a.call(props);
        }
      }
      function handleMousemove(e) {
        var _a;
        (_a = props.onResize) === null || _a === void 0 ? void 0 : _a.call(props, getMouseX(e) - startX);
      }
      function handleMouseup() {
        var _a;
        activeRef.value = false;
        (_a = props.onResizeEnd) === null || _a === void 0 ? void 0 : _a.call(props);
        off("mousemove", window, handleMousemove);
        off("mouseup", window, handleMouseup);
      }
      vue.onBeforeUnmount(() => {
        off("mousemove", window, handleMousemove);
        off("mouseup", window, handleMouseup);
      });
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        active: activeRef,
        handleMousedown
      };
    },
    render() {
      const {
        mergedClsPrefix
      } = this;
      return vue.h("span", {
        "data-data-table-resizable": true,
        class: [`${mergedClsPrefix}-data-table-resize-button`, this.active && `${mergedClsPrefix}-data-table-resize-button--active`],
        onMousedown: this.handleMousedown
      });
    }
  });
  const NDropdownDivider = vue.defineComponent({
    name: "DropdownDivider",
    props: {
      clsPrefix: {
        type: String,
        required: true
      }
    },
    render() {
      return vue.h("div", {
        class: `${this.clsPrefix}-dropdown-divider`
      });
    }
  });
  function self$N(vars) {
    const {
      textColorBase,
      opacity1,
      opacity2,
      opacity3,
      opacity4,
      opacity5
    } = vars;
    return {
      color: textColorBase,
      opacity1Depth: opacity1,
      opacity2Depth: opacity2,
      opacity3Depth: opacity3,
      opacity4Depth: opacity4,
      opacity5Depth: opacity5
    };
  }
  const iconLight = {
    name: "Icon",
    common: commonLight,
    self: self$N
  };
  const iconLight$1 = iconLight;
  const style$Z = cB("icon", `
 height: 1em;
 width: 1em;
 line-height: 1em;
 text-align: center;
 display: inline-block;
 position: relative;
 fill: currentColor;
 transform: translateZ(0);
`, [cM("color-transition", {
    transition: "color .3s var(--n-bezier)"
  }), cM("depth", {
    color: "var(--n-color)"
  }, [c$1("svg", {
    opacity: "var(--n-opacity)",
    transition: "opacity .3s var(--n-bezier)"
  })]), c$1("svg", {
    height: "1em",
    width: "1em"
  })]);
  const iconProps = Object.assign(Object.assign({}, useTheme.props), {
    depth: [String, Number],
    size: [Number, String],
    color: String,
    component: [Object, Function]
  });
  const NIcon = vue.defineComponent({
    _n_icon__: true,
    name: "Icon",
    inheritAttrs: false,
    props: iconProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Icon", "-icon", style$Z, iconLight$1, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          depth
        } = props;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: self2
        } = themeRef.value;
        if (depth !== void 0) {
          const {
            color,
            [`opacity${depth}Depth`]: opacity
          } = self2;
          return {
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-color": color,
            "--n-opacity": opacity
          };
        }
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-color": "",
          "--n-opacity": ""
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("icon", vue.computed(() => `${props.depth || "d"}`), cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        mergedStyle: vue.computed(() => {
          const {
            size: size2,
            color
          } = props;
          return {
            fontSize: formatLength(size2),
            color
          };
        }),
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a;
      const {
        $parent,
        depth,
        mergedClsPrefix,
        component,
        onRender,
        themeClass
      } = this;
      if ((_a = $parent === null || $parent === void 0 ? void 0 : $parent.$options) === null || _a === void 0 ? void 0 : _a._n_icon__) {
        warn$2("icon", "don't wrap `n-icon` inside `n-icon`");
      }
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h("i", vue.mergeProps(this.$attrs, {
        role: "img",
        class: [`${mergedClsPrefix}-icon`, themeClass, {
          [`${mergedClsPrefix}-icon--depth`]: depth,
          [`${mergedClsPrefix}-icon--color-transition`]: depth !== void 0
        }],
        style: [this.cssVars, this.mergedStyle]
      }), component ? vue.h(component) : this.$slots);
    }
  });
  const dropdownMenuInjectionKey = createInjectionKey("n-dropdown-menu");
  const dropdownInjectionKey = createInjectionKey("n-dropdown");
  const dropdownOptionInjectionKey = createInjectionKey("n-dropdown-option");
  function isSubmenuNode(rawNode, childrenField) {
    return rawNode.type === "submenu" || rawNode.type === void 0 && rawNode[childrenField] !== void 0;
  }
  function isGroupNode(rawNode) {
    return rawNode.type === "group";
  }
  function isDividerNode$1(rawNode) {
    return rawNode.type === "divider";
  }
  function isRenderNode(rawNode) {
    return rawNode.type === "render";
  }
  const NDropdownOption = vue.defineComponent({
    name: "DropdownOption",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      tmNode: {
        type: Object,
        required: true
      },
      parentKey: {
        type: [String, Number],
        default: null
      },
      placement: {
        type: String,
        default: "right-start"
      },
      props: Object,
      scrollable: Boolean
    },
    setup(props) {
      const NDropdown2 = vue.inject(dropdownInjectionKey);
      const {
        hoverKeyRef,
        keyboardKeyRef,
        lastToggledSubmenuKeyRef,
        pendingKeyPathRef,
        activeKeyPathRef,
        animatedRef,
        mergedShowRef,
        renderLabelRef,
        renderIconRef,
        labelFieldRef,
        childrenFieldRef,
        renderOptionRef,
        nodePropsRef,
        menuPropsRef
      } = NDropdown2;
      const NDropdownOption2 = vue.inject(dropdownOptionInjectionKey, null);
      const NDropdownMenu2 = vue.inject(dropdownMenuInjectionKey);
      const NPopoverBody2 = vue.inject(popoverBodyInjectionKey);
      const rawNodeRef = vue.computed(() => props.tmNode.rawNode);
      const hasSubmenuRef = vue.computed(() => {
        const {
          value: childrenField
        } = childrenFieldRef;
        return isSubmenuNode(props.tmNode.rawNode, childrenField);
      });
      const mergedDisabledRef = vue.computed(() => {
        const {
          disabled
        } = props.tmNode;
        return disabled;
      });
      const showSubmenuRef = vue.computed(() => {
        if (!hasSubmenuRef.value)
          return false;
        const {
          key,
          disabled
        } = props.tmNode;
        if (disabled)
          return false;
        const {
          value: hoverKey
        } = hoverKeyRef;
        const {
          value: keyboardKey
        } = keyboardKeyRef;
        const {
          value: lastToggledSubmenuKey
        } = lastToggledSubmenuKeyRef;
        const {
          value: pendingKeyPath
        } = pendingKeyPathRef;
        if (hoverKey !== null)
          return pendingKeyPath.includes(key);
        if (keyboardKey !== null) {
          return pendingKeyPath.includes(key) && pendingKeyPath[pendingKeyPath.length - 1] !== key;
        }
        if (lastToggledSubmenuKey !== null)
          return pendingKeyPath.includes(key);
        return false;
      });
      const shouldDelayRef = vue.computed(() => {
        return keyboardKeyRef.value === null && !animatedRef.value;
      });
      const deferredShowSubmenuRef = useDeferredTrue(showSubmenuRef, 300, shouldDelayRef);
      const parentEnteringSubmenuRef = vue.computed(() => {
        return !!(NDropdownOption2 === null || NDropdownOption2 === void 0 ? void 0 : NDropdownOption2.enteringSubmenuRef.value);
      });
      const enteringSubmenuRef = vue.ref(false);
      vue.provide(dropdownOptionInjectionKey, {
        enteringSubmenuRef
      });
      function handleSubmenuBeforeEnter() {
        enteringSubmenuRef.value = true;
      }
      function handleSubmenuAfterEnter() {
        enteringSubmenuRef.value = false;
      }
      function handleMouseEnter() {
        const {
          parentKey,
          tmNode
        } = props;
        if (tmNode.disabled)
          return;
        if (!mergedShowRef.value)
          return;
        lastToggledSubmenuKeyRef.value = parentKey;
        keyboardKeyRef.value = null;
        hoverKeyRef.value = tmNode.key;
      }
      function handleMouseMove() {
        const {
          tmNode
        } = props;
        if (tmNode.disabled)
          return;
        if (!mergedShowRef.value)
          return;
        if (hoverKeyRef.value === tmNode.key)
          return;
        handleMouseEnter();
      }
      function handleMouseLeave(e) {
        if (props.tmNode.disabled)
          return;
        if (!mergedShowRef.value)
          return;
        const {
          relatedTarget
        } = e;
        if (relatedTarget && !happensIn({
          target: relatedTarget
        }, "dropdownOption") && !happensIn({
          target: relatedTarget
        }, "scrollbarRail")) {
          hoverKeyRef.value = null;
        }
      }
      function handleClick2() {
        const {
          value: hasSubmenu
        } = hasSubmenuRef;
        const {
          tmNode
        } = props;
        if (!mergedShowRef.value)
          return;
        if (!hasSubmenu && !tmNode.disabled) {
          NDropdown2.doSelect(tmNode.key, tmNode.rawNode);
          NDropdown2.doUpdateShow(false);
        }
      }
      return {
        labelField: labelFieldRef,
        renderLabel: renderLabelRef,
        renderIcon: renderIconRef,
        siblingHasIcon: NDropdownMenu2.showIconRef,
        siblingHasSubmenu: NDropdownMenu2.hasSubmenuRef,
        menuProps: menuPropsRef,
        popoverBody: NPopoverBody2,
        animated: animatedRef,
        mergedShowSubmenu: vue.computed(() => {
          return deferredShowSubmenuRef.value && !parentEnteringSubmenuRef.value;
        }),
        rawNode: rawNodeRef,
        hasSubmenu: hasSubmenuRef,
        pending: useMemo(() => {
          const {
            value: pendingKeyPath
          } = pendingKeyPathRef;
          const {
            key
          } = props.tmNode;
          return pendingKeyPath.includes(key);
        }),
        childActive: useMemo(() => {
          const {
            value: activeKeyPath
          } = activeKeyPathRef;
          const {
            key
          } = props.tmNode;
          const index = activeKeyPath.findIndex((k) => key === k);
          if (index === -1)
            return false;
          return index < activeKeyPath.length - 1;
        }),
        active: useMemo(() => {
          const {
            value: activeKeyPath
          } = activeKeyPathRef;
          const {
            key
          } = props.tmNode;
          const index = activeKeyPath.findIndex((k) => key === k);
          if (index === -1)
            return false;
          return index === activeKeyPath.length - 1;
        }),
        mergedDisabled: mergedDisabledRef,
        renderOption: renderOptionRef,
        nodeProps: nodePropsRef,
        handleClick: handleClick2,
        handleMouseMove,
        handleMouseEnter,
        handleMouseLeave,
        handleSubmenuBeforeEnter,
        handleSubmenuAfterEnter
      };
    },
    render() {
      var _a, _b;
      const {
        animated,
        rawNode,
        mergedShowSubmenu,
        clsPrefix,
        siblingHasIcon,
        siblingHasSubmenu,
        renderLabel,
        renderIcon,
        renderOption,
        nodeProps,
        props,
        scrollable
      } = this;
      let submenuVNode = null;
      if (mergedShowSubmenu) {
        const submenuNodeProps = (_a = this.menuProps) === null || _a === void 0 ? void 0 : _a.call(this, rawNode, rawNode.children);
        submenuVNode = vue.h(NDropdownMenu, Object.assign({}, submenuNodeProps, {
          clsPrefix,
          scrollable: this.scrollable,
          tmNodes: this.tmNode.children,
          parentKey: this.tmNode.key
        }));
      }
      const builtinProps = {
        class: [`${clsPrefix}-dropdown-option-body`, this.pending && `${clsPrefix}-dropdown-option-body--pending`, this.active && `${clsPrefix}-dropdown-option-body--active`, this.childActive && `${clsPrefix}-dropdown-option-body--child-active`, this.mergedDisabled && `${clsPrefix}-dropdown-option-body--disabled`],
        onMousemove: this.handleMouseMove,
        onMouseenter: this.handleMouseEnter,
        onMouseleave: this.handleMouseLeave,
        onClick: this.handleClick
      };
      const optionNodeProps = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode);
      const node = vue.h("div", Object.assign({
        class: [`${clsPrefix}-dropdown-option`, optionNodeProps === null || optionNodeProps === void 0 ? void 0 : optionNodeProps.class],
        "data-dropdown-option": true
      }, optionNodeProps), vue.h("div", vue.mergeProps(builtinProps, props), [vue.h("div", {
        class: [`${clsPrefix}-dropdown-option-body__prefix`, siblingHasIcon && `${clsPrefix}-dropdown-option-body__prefix--show-icon`]
      }, [renderIcon ? renderIcon(rawNode) : render$1(rawNode.icon)]), vue.h("div", {
        "data-dropdown-option": true,
        class: `${clsPrefix}-dropdown-option-body__label`
      }, renderLabel ? renderLabel(rawNode) : render$1((_b = rawNode[this.labelField]) !== null && _b !== void 0 ? _b : rawNode.title)), vue.h("div", {
        "data-dropdown-option": true,
        class: [`${clsPrefix}-dropdown-option-body__suffix`, siblingHasSubmenu && `${clsPrefix}-dropdown-option-body__suffix--has-submenu`]
      }, this.hasSubmenu ? vue.h(NIcon, null, {
        default: () => vue.h(ChevronRightIcon, null)
      }) : null)]), this.hasSubmenu ? vue.h(VBinder, null, {
        default: () => [vue.h(VTarget, null, {
          default: () => vue.h("div", {
            class: `${clsPrefix}-dropdown-offset-container`
          }, vue.h(VFollower, {
            show: this.mergedShowSubmenu,
            placement: this.placement,
            to: scrollable ? this.popoverBody || void 0 : void 0,
            teleportDisabled: !scrollable
          }, {
            default: () => {
              return vue.h("div", {
                class: `${clsPrefix}-dropdown-menu-wrapper`
              }, animated ? vue.h(vue.Transition, {
                onBeforeEnter: this.handleSubmenuBeforeEnter,
                onAfterEnter: this.handleSubmenuAfterEnter,
                name: "fade-in-scale-up-transition",
                appear: true
              }, {
                default: () => submenuVNode
              }) : submenuVNode);
            }
          }))
        })]
      }) : null);
      if (renderOption) {
        return renderOption({
          node,
          option: rawNode
        });
      }
      return node;
    }
  });
  const NDropdownGroupHeader = vue.defineComponent({
    name: "DropdownGroupHeader",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      tmNode: {
        type: Object,
        required: true
      }
    },
    setup() {
      const {
        showIconRef,
        hasSubmenuRef
      } = vue.inject(dropdownMenuInjectionKey);
      const {
        renderLabelRef,
        labelFieldRef,
        nodePropsRef,
        renderOptionRef
      } = vue.inject(dropdownInjectionKey);
      return {
        labelField: labelFieldRef,
        showIcon: showIconRef,
        hasSubmenu: hasSubmenuRef,
        renderLabel: renderLabelRef,
        nodeProps: nodePropsRef,
        renderOption: renderOptionRef
      };
    },
    render() {
      var _a;
      const {
        clsPrefix,
        hasSubmenu,
        showIcon,
        nodeProps,
        renderLabel,
        renderOption
      } = this;
      const {
        rawNode
      } = this.tmNode;
      const node = vue.h("div", Object.assign({
        class: `${clsPrefix}-dropdown-option`
      }, nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode)), vue.h("div", {
        class: `${clsPrefix}-dropdown-option-body ${clsPrefix}-dropdown-option-body--group`
      }, vue.h("div", {
        "data-dropdown-option": true,
        class: [`${clsPrefix}-dropdown-option-body__prefix`, showIcon && `${clsPrefix}-dropdown-option-body__prefix--show-icon`]
      }, render$1(rawNode.icon)), vue.h("div", {
        class: `${clsPrefix}-dropdown-option-body__label`,
        "data-dropdown-option": true
      }, renderLabel ? renderLabel(rawNode) : render$1((_a = rawNode.title) !== null && _a !== void 0 ? _a : rawNode[this.labelField])), vue.h("div", {
        class: [`${clsPrefix}-dropdown-option-body__suffix`, hasSubmenu && `${clsPrefix}-dropdown-option-body__suffix--has-submenu`],
        "data-dropdown-option": true
      })));
      if (renderOption) {
        return renderOption({
          node,
          option: rawNode
        });
      }
      return node;
    }
  });
  const NDropdownGroup = vue.defineComponent({
    name: "NDropdownGroup",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      tmNode: {
        type: Object,
        required: true
      },
      parentKey: {
        type: [String, Number],
        default: null
      }
    },
    render() {
      const {
        tmNode,
        parentKey,
        clsPrefix
      } = this;
      const {
        children
      } = tmNode;
      return vue.h(vue.Fragment, null, vue.h(NDropdownGroupHeader, {
        clsPrefix,
        tmNode,
        key: tmNode.key
      }), children === null || children === void 0 ? void 0 : children.map((child) => {
        const {
          rawNode
        } = child;
        if (rawNode.show === false)
          return null;
        if (isDividerNode$1(rawNode)) {
          return vue.h(NDropdownDivider, {
            clsPrefix,
            key: child.key
          });
        }
        if (child.isGroup) {
          warn$2("dropdown", "`group` node is not allowed to be put in `group` node.");
          return null;
        }
        return vue.h(NDropdownOption, {
          clsPrefix,
          tmNode: child,
          parentKey,
          key: child.key
        });
      }));
    }
  });
  const NDropdownRenderOption = vue.defineComponent({
    name: "DropdownRenderOption",
    props: {
      tmNode: {
        type: Object,
        required: true
      }
    },
    render() {
      const {
        rawNode: {
          render: render2,
          props
        }
      } = this.tmNode;
      return vue.h("div", props, [render2 === null || render2 === void 0 ? void 0 : render2()]);
    }
  });
  const NDropdownMenu = vue.defineComponent({
    name: "DropdownMenu",
    props: {
      scrollable: Boolean,
      showArrow: Boolean,
      arrowStyle: [String, Object],
      clsPrefix: {
        type: String,
        required: true
      },
      tmNodes: {
        type: Array,
        default: () => []
      },
      parentKey: {
        type: [String, Number],
        default: null
      }
    },
    setup(props) {
      const {
        renderIconRef,
        childrenFieldRef
      } = vue.inject(dropdownInjectionKey);
      vue.provide(dropdownMenuInjectionKey, {
        showIconRef: vue.computed(() => {
          const renderIcon = renderIconRef.value;
          return props.tmNodes.some((tmNode) => {
            var _a;
            if (tmNode.isGroup) {
              return (_a = tmNode.children) === null || _a === void 0 ? void 0 : _a.some(({
                rawNode: rawChild
              }) => renderIcon ? renderIcon(rawChild) : rawChild.icon);
            }
            const {
              rawNode
            } = tmNode;
            return renderIcon ? renderIcon(rawNode) : rawNode.icon;
          });
        }),
        hasSubmenuRef: vue.computed(() => {
          const {
            value: childrenField
          } = childrenFieldRef;
          return props.tmNodes.some((tmNode) => {
            var _a;
            if (tmNode.isGroup) {
              return (_a = tmNode.children) === null || _a === void 0 ? void 0 : _a.some(({
                rawNode: rawChild
              }) => isSubmenuNode(rawChild, childrenField));
            }
            const {
              rawNode
            } = tmNode;
            return isSubmenuNode(rawNode, childrenField);
          });
        })
      });
      const bodyRef = vue.ref(null);
      vue.provide(modalBodyInjectionKey, null);
      vue.provide(drawerBodyInjectionKey, null);
      vue.provide(popoverBodyInjectionKey, bodyRef);
      return {
        bodyRef
      };
    },
    render() {
      const {
        parentKey,
        clsPrefix,
        scrollable
      } = this;
      const menuOptionsNode = this.tmNodes.map((tmNode) => {
        const {
          rawNode
        } = tmNode;
        if (rawNode.show === false)
          return null;
        if (isRenderNode(rawNode)) {
          return vue.h(NDropdownRenderOption, {
            tmNode,
            key: tmNode.key
          });
        }
        if (isDividerNode$1(rawNode)) {
          return vue.h(NDropdownDivider, {
            clsPrefix,
            key: tmNode.key
          });
        }
        if (isGroupNode(rawNode)) {
          return vue.h(NDropdownGroup, {
            clsPrefix,
            tmNode,
            parentKey,
            key: tmNode.key
          });
        }
        return vue.h(NDropdownOption, {
          clsPrefix,
          tmNode,
          parentKey,
          key: tmNode.key,
          props: rawNode.props,
          scrollable
        });
      });
      return vue.h("div", {
        class: [`${clsPrefix}-dropdown-menu`, scrollable && `${clsPrefix}-dropdown-menu--scrollable`],
        ref: "bodyRef"
      }, scrollable ? vue.h(XScrollbar, {
        contentClass: `${clsPrefix}-dropdown-menu__content`
      }, {
        default: () => menuOptionsNode
      }) : menuOptionsNode, this.showArrow ? renderArrow({
        clsPrefix,
        arrowStyle: this.arrowStyle,
        arrowClass: void 0,
        arrowWrapperClass: void 0,
        arrowWrapperStyle: void 0
      }) : null);
    }
  });
  const style$Y = cB("dropdown-menu", `
 transform-origin: var(--v-transform-origin);
 background-color: var(--n-color);
 border-radius: var(--n-border-radius);
 box-shadow: var(--n-box-shadow);
 position: relative;
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
`, [fadeInScaleUpTransition(), cB("dropdown-option", `
 position: relative;
 `, [c$1("a", `
 text-decoration: none;
 color: inherit;
 outline: none;
 `, [c$1("&::before", `
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]), cB("dropdown-option-body", `
 display: flex;
 cursor: pointer;
 position: relative;
 height: var(--n-option-height);
 line-height: var(--n-option-height);
 font-size: var(--n-font-size);
 color: var(--n-option-text-color);
 transition: color .3s var(--n-bezier);
 `, [c$1("&::before", `
 content: "";
 position: absolute;
 top: 0;
 bottom: 0;
 left: 4px;
 right: 4px;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 `), cNotM("disabled", [cM("pending", `
 color: var(--n-option-text-color-hover);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-hover);
 `), c$1("&::before", "background-color: var(--n-option-color-hover);")]), cM("active", `
 color: var(--n-option-text-color-active);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-active);
 `), c$1("&::before", "background-color: var(--n-option-color-active);")]), cM("child-active", `
 color: var(--n-option-text-color-child-active);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-child-active);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 opacity: var(--n-option-opacity-disabled);
 `), cM("group", `
 font-size: calc(var(--n-font-size) - 1px);
 color: var(--n-group-header-text-color);
 `, [cE("prefix", `
 width: calc(var(--n-option-prefix-width) / 2);
 `, [cM("show-icon", `
 width: calc(var(--n-option-icon-prefix-width) / 2);
 `)])]), cE("prefix", `
 width: var(--n-option-prefix-width);
 display: flex;
 justify-content: center;
 align-items: center;
 color: var(--n-prefix-color);
 transition: color .3s var(--n-bezier);
 z-index: 1;
 `, [cM("show-icon", `
 width: var(--n-option-icon-prefix-width);
 `), cB("icon", `
 font-size: var(--n-option-icon-size);
 `)]), cE("label", `
 white-space: nowrap;
 flex: 1;
 z-index: 1;
 `), cE("suffix", `
 box-sizing: border-box;
 flex-grow: 0;
 flex-shrink: 0;
 display: flex;
 justify-content: flex-end;
 align-items: center;
 min-width: var(--n-option-suffix-width);
 padding: 0 8px;
 transition: color .3s var(--n-bezier);
 color: var(--n-suffix-color);
 z-index: 1;
 `, [cM("has-submenu", `
 width: var(--n-option-icon-suffix-width);
 `), cB("icon", `
 font-size: var(--n-option-icon-size);
 `)]), cB("dropdown-menu", "pointer-events: all;")]), cB("dropdown-offset-container", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: -4px;
 bottom: -4px;
 `)]), cB("dropdown-divider", `
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-divider-color);
 height: 1px;
 margin: 4px 0;
 `), cB("dropdown-menu-wrapper", `
 transform-origin: var(--v-transform-origin);
 width: fit-content;
 `), c$1(">", [cB("scrollbar", `
 height: inherit;
 max-height: inherit;
 `)]), cNotM("scrollable", `
 padding: var(--n-padding);
 `), cM("scrollable", [cE("content", `
 padding: var(--n-padding);
 `)])]);
  const dropdownBaseProps = {
    animated: {
      type: Boolean,
      default: true
    },
    keyboard: {
      type: Boolean,
      default: true
    },
    size: {
      type: String,
      default: "medium"
    },
    inverted: Boolean,
    placement: {
      type: String,
      default: "bottom"
    },
    onSelect: [Function, Array],
    options: {
      type: Array,
      default: () => []
    },
    menuProps: Function,
    showArrow: Boolean,
    renderLabel: Function,
    renderIcon: Function,
    renderOption: Function,
    nodeProps: Function,
    labelField: {
      type: String,
      default: "label"
    },
    keyField: {
      type: String,
      default: "key"
    },
    childrenField: {
      type: String,
      default: "children"
    },
    // for menu, not documented
    value: [String, Number]
  };
  const popoverPropKeys = Object.keys(popoverBaseProps);
  const dropdownProps = Object.assign(Object.assign(Object.assign({}, popoverBaseProps), dropdownBaseProps), useTheme.props);
  const NDropdown = vue.defineComponent({
    name: "Dropdown",
    inheritAttrs: false,
    props: dropdownProps,
    setup(props) {
      const uncontrolledShowRef = vue.ref(false);
      const mergedShowRef = useMergedState(vue.toRef(props, "show"), uncontrolledShowRef);
      const treemateRef = vue.computed(() => {
        const {
          keyField,
          childrenField
        } = props;
        return createTreeMate(props.options, {
          getKey(node) {
            return node[keyField];
          },
          getDisabled(node) {
            return node.disabled === true;
          },
          getIgnored(node) {
            return node.type === "divider" || node.type === "render";
          },
          getChildren(node) {
            return node[childrenField];
          }
        });
      });
      const tmNodesRef = vue.computed(() => {
        return treemateRef.value.treeNodes;
      });
      const hoverKeyRef = vue.ref(null);
      const keyboardKeyRef = vue.ref(null);
      const lastToggledSubmenuKeyRef = vue.ref(null);
      const pendingKeyRef = vue.computed(() => {
        var _a, _b, _c;
        return (_c = (_b = (_a = hoverKeyRef.value) !== null && _a !== void 0 ? _a : keyboardKeyRef.value) !== null && _b !== void 0 ? _b : lastToggledSubmenuKeyRef.value) !== null && _c !== void 0 ? _c : null;
      });
      const pendingKeyPathRef = vue.computed(() => treemateRef.value.getPath(pendingKeyRef.value).keyPath);
      const activeKeyPathRef = vue.computed(() => treemateRef.value.getPath(props.value).keyPath);
      const keyboardEnabledRef = useMemo(() => {
        return props.keyboard && mergedShowRef.value;
      });
      useKeyboard$1({
        keydown: {
          ArrowUp: {
            prevent: true,
            handler: handleKeydownUp
          },
          ArrowRight: {
            prevent: true,
            handler: handleKeydownRight
          },
          ArrowDown: {
            prevent: true,
            handler: handleKeydownDown
          },
          ArrowLeft: {
            prevent: true,
            handler: handleKeydownLeft
          },
          Enter: {
            prevent: true,
            handler: handleKeydownEnter
          },
          Escape: handleKeydownEsc
        }
      }, keyboardEnabledRef);
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Dropdown", "-dropdown", style$Y, dropdownLight$1, props, mergedClsPrefixRef);
      vue.provide(dropdownInjectionKey, {
        labelFieldRef: vue.toRef(props, "labelField"),
        childrenFieldRef: vue.toRef(props, "childrenField"),
        renderLabelRef: vue.toRef(props, "renderLabel"),
        renderIconRef: vue.toRef(props, "renderIcon"),
        hoverKeyRef,
        keyboardKeyRef,
        lastToggledSubmenuKeyRef,
        pendingKeyPathRef,
        activeKeyPathRef,
        animatedRef: vue.toRef(props, "animated"),
        mergedShowRef,
        nodePropsRef: vue.toRef(props, "nodeProps"),
        renderOptionRef: vue.toRef(props, "renderOption"),
        menuPropsRef: vue.toRef(props, "menuProps"),
        doSelect,
        doUpdateShow
      });
      vue.watch(mergedShowRef, (value) => {
        if (!props.animated && !value) {
          clearPendingState();
        }
      });
      function doSelect(key, node) {
        const {
          onSelect
        } = props;
        if (onSelect)
          call(onSelect, key, node);
      }
      function doUpdateShow(value) {
        const {
          "onUpdate:show": _onUpdateShow,
          onUpdateShow
        } = props;
        if (_onUpdateShow)
          call(_onUpdateShow, value);
        if (onUpdateShow)
          call(onUpdateShow, value);
        uncontrolledShowRef.value = value;
      }
      function clearPendingState() {
        hoverKeyRef.value = null;
        keyboardKeyRef.value = null;
        lastToggledSubmenuKeyRef.value = null;
      }
      function handleKeydownEsc() {
        doUpdateShow(false);
      }
      function handleKeydownLeft() {
        handleKeydown("left");
      }
      function handleKeydownRight() {
        handleKeydown("right");
      }
      function handleKeydownUp() {
        handleKeydown("up");
      }
      function handleKeydownDown() {
        handleKeydown("down");
      }
      function handleKeydownEnter() {
        const pendingNode = getPendingNode();
        if ((pendingNode === null || pendingNode === void 0 ? void 0 : pendingNode.isLeaf) && mergedShowRef.value) {
          doSelect(pendingNode.key, pendingNode.rawNode);
          doUpdateShow(false);
        }
      }
      function getPendingNode() {
        var _a;
        const {
          value: treeMate
        } = treemateRef;
        const {
          value: pendingKey
        } = pendingKeyRef;
        if (!treeMate || pendingKey === null)
          return null;
        return (_a = treeMate.getNode(pendingKey)) !== null && _a !== void 0 ? _a : null;
      }
      function handleKeydown(direction) {
        const {
          value: pendingKey
        } = pendingKeyRef;
        const {
          value: {
            getFirstAvailableNode: getFirstAvailableNode2
          }
        } = treemateRef;
        let nextKeyboardKey = null;
        if (pendingKey === null) {
          const firstNode = getFirstAvailableNode2();
          if (firstNode !== null) {
            nextKeyboardKey = firstNode.key;
          }
        } else {
          const currentNode = getPendingNode();
          if (currentNode) {
            let nextNode;
            switch (direction) {
              case "down":
                nextNode = currentNode.getNext();
                break;
              case "up":
                nextNode = currentNode.getPrev();
                break;
              case "right":
                nextNode = currentNode.getChild();
                break;
              case "left":
                nextNode = currentNode.getParent();
                break;
            }
            if (nextNode)
              nextKeyboardKey = nextNode.key;
          }
        }
        if (nextKeyboardKey !== null) {
          hoverKeyRef.value = null;
          keyboardKeyRef.value = nextKeyboardKey;
        }
      }
      const cssVarsRef = vue.computed(() => {
        const {
          size: size2,
          inverted
        } = props;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: self2
        } = themeRef.value;
        const {
          padding,
          dividerColor,
          borderRadius,
          optionOpacityDisabled,
          [createKey("optionIconSuffixWidth", size2)]: optionIconSuffixWidth,
          [createKey("optionSuffixWidth", size2)]: optionSuffixWidth,
          [createKey("optionIconPrefixWidth", size2)]: optionIconPrefixWidth,
          [createKey("optionPrefixWidth", size2)]: optionPrefixWidth,
          [createKey("fontSize", size2)]: fontSize2,
          [createKey("optionHeight", size2)]: optionHeight,
          [createKey("optionIconSize", size2)]: optionIconSize
        } = self2;
        const vars = {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-font-size": fontSize2,
          "--n-padding": padding,
          "--n-border-radius": borderRadius,
          "--n-option-height": optionHeight,
          "--n-option-prefix-width": optionPrefixWidth,
          "--n-option-icon-prefix-width": optionIconPrefixWidth,
          "--n-option-suffix-width": optionSuffixWidth,
          "--n-option-icon-suffix-width": optionIconSuffixWidth,
          "--n-option-icon-size": optionIconSize,
          "--n-divider-color": dividerColor,
          "--n-option-opacity-disabled": optionOpacityDisabled
        };
        if (inverted) {
          vars["--n-color"] = self2.colorInverted;
          vars["--n-option-color-hover"] = self2.optionColorHoverInverted;
          vars["--n-option-color-active"] = self2.optionColorActiveInverted;
          vars["--n-option-text-color"] = self2.optionTextColorInverted;
          vars["--n-option-text-color-hover"] = self2.optionTextColorHoverInverted;
          vars["--n-option-text-color-active"] = self2.optionTextColorActiveInverted;
          vars["--n-option-text-color-child-active"] = self2.optionTextColorChildActiveInverted;
          vars["--n-prefix-color"] = self2.prefixColorInverted;
          vars["--n-suffix-color"] = self2.suffixColorInverted;
          vars["--n-group-header-text-color"] = self2.groupHeaderTextColorInverted;
        } else {
          vars["--n-color"] = self2.color;
          vars["--n-option-color-hover"] = self2.optionColorHover;
          vars["--n-option-color-active"] = self2.optionColorActive;
          vars["--n-option-text-color"] = self2.optionTextColor;
          vars["--n-option-text-color-hover"] = self2.optionTextColorHover;
          vars["--n-option-text-color-active"] = self2.optionTextColorActive;
          vars["--n-option-text-color-child-active"] = self2.optionTextColorChildActive;
          vars["--n-prefix-color"] = self2.prefixColor;
          vars["--n-suffix-color"] = self2.suffixColor;
          vars["--n-group-header-text-color"] = self2.groupHeaderTextColor;
        }
        return vars;
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("dropdown", vue.computed(() => `${props.size[0]}${props.inverted ? "i" : ""}`), cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        mergedTheme: themeRef,
        // data
        tmNodes: tmNodesRef,
        // show
        mergedShow: mergedShowRef,
        // methods
        handleAfterLeave: () => {
          if (!props.animated)
            return;
          clearPendingState();
        },
        doUpdateShow,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      const renderPopoverBody = (className, ref, style2, onMouseenter, onMouseleave) => {
        var _a;
        const {
          mergedClsPrefix,
          menuProps: menuProps2
        } = this;
        (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
        const menuNodeProps = (menuProps2 === null || menuProps2 === void 0 ? void 0 : menuProps2(void 0, this.tmNodes.map((v) => v.rawNode))) || {};
        const dropdownProps2 = {
          ref: createRefSetter(ref),
          class: [className, `${mergedClsPrefix}-dropdown`, this.themeClass],
          clsPrefix: mergedClsPrefix,
          tmNodes: this.tmNodes,
          style: [...style2, this.cssVars],
          showArrow: this.showArrow,
          arrowStyle: this.arrowStyle,
          scrollable: this.scrollable,
          onMouseenter,
          onMouseleave
        };
        return vue.h(NDropdownMenu, vue.mergeProps(this.$attrs, dropdownProps2, menuNodeProps));
      };
      const {
        mergedTheme
      } = this;
      const popoverProps2 = {
        show: this.mergedShow,
        theme: mergedTheme.peers.Popover,
        themeOverrides: mergedTheme.peerOverrides.Popover,
        internalOnAfterLeave: this.handleAfterLeave,
        internalRenderBody: renderPopoverBody,
        onUpdateShow: this.doUpdateShow,
        "onUpdate:show": void 0
      };
      return vue.h(NPopover, Object.assign({}, keep(this.$props, popoverPropKeys), popoverProps2), {
        trigger: () => {
          var _a, _b;
          return (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
      });
    }
  });
  const allKey = "_n_all__";
  const noneKey = "_n_none__";
  function createSelectHandler(options, rawPaginatedDataRef, doCheckAll, doUncheckAll) {
    if (!options)
      return () => {
      };
    return (key) => {
      for (const option of options) {
        switch (key) {
          case allKey:
            doCheckAll(true);
            return;
          case noneKey:
            doUncheckAll(true);
            return;
          default:
            if (typeof option === "object" && option.key === key) {
              option.onSelect(rawPaginatedDataRef.value);
              return;
            }
        }
      }
    };
  }
  function createDropdownOptions(options, localeRef) {
    if (!options)
      return [];
    return options.map((option) => {
      switch (option) {
        case "all":
          return {
            label: localeRef.checkTableAll,
            key: allKey
          };
        case "none":
          return {
            label: localeRef.uncheckTableAll,
            key: noneKey
          };
        default:
          return option;
      }
    });
  }
  const SelectionMenu = vue.defineComponent({
    name: "DataTableSelectionMenu",
    props: {
      clsPrefix: {
        type: String,
        required: true
      }
    },
    setup(props) {
      const {
        props: dataTableProps2,
        localeRef,
        checkOptionsRef,
        rawPaginatedDataRef,
        doCheckAll,
        doUncheckAll
      } = vue.inject(dataTableInjectionKey);
      const handleSelectRef = vue.computed(() => createSelectHandler(checkOptionsRef.value, rawPaginatedDataRef, doCheckAll, doUncheckAll));
      const optionsRef = vue.computed(() => createDropdownOptions(checkOptionsRef.value, localeRef.value));
      return () => {
        var _a, _b, _c, _d;
        const {
          clsPrefix
        } = props;
        return vue.h(NDropdown, {
          theme: (_b = (_a = dataTableProps2.theme) === null || _a === void 0 ? void 0 : _a.peers) === null || _b === void 0 ? void 0 : _b.Dropdown,
          themeOverrides: (_d = (_c = dataTableProps2.themeOverrides) === null || _c === void 0 ? void 0 : _c.peers) === null || _d === void 0 ? void 0 : _d.Dropdown,
          options: optionsRef.value,
          onSelect: handleSelectRef.value
        }, {
          default: () => vue.h(NBaseIcon, {
            clsPrefix,
            class: `${clsPrefix}-data-table-check-extra`
          }, {
            default: () => vue.h(ChevronDownIcon, null)
          })
        });
      };
    }
  });
  function renderTitle(column) {
    return typeof column.title === "function" ? column.title(column) : column.title;
  }
  const VirtualListItemWrapper$1 = vue.defineComponent({
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      id: {
        type: String,
        required: true
      },
      cols: {
        type: Array,
        required: true
      },
      width: String
    },
    render() {
      const {
        clsPrefix,
        id,
        cols,
        width
      } = this;
      return vue.h("table", {
        style: {
          tableLayout: "fixed",
          width
        },
        class: `${clsPrefix}-data-table-table`
      }, vue.h("colgroup", null, cols.map((col) => vue.h("col", {
        key: col.key,
        style: col.style
      }))), vue.h("thead", {
        "data-n-id": id,
        class: `${clsPrefix}-data-table-thead`
      }, this.$slots));
    }
  });
  const TableHeader = vue.defineComponent({
    name: "DataTableHeader",
    props: {
      discrete: {
        type: Boolean,
        default: true
      }
    },
    setup() {
      const {
        mergedClsPrefixRef,
        scrollXRef,
        fixedColumnLeftMapRef,
        fixedColumnRightMapRef,
        mergedCurrentPageRef,
        allRowsCheckedRef,
        someRowsCheckedRef,
        rowsRef,
        colsRef,
        mergedThemeRef,
        checkOptionsRef,
        mergedSortStateRef,
        componentId,
        mergedTableLayoutRef,
        headerCheckboxDisabledRef,
        virtualScrollHeaderRef,
        headerHeightRef,
        onUnstableColumnResize,
        doUpdateResizableWidth,
        handleTableHeaderScroll,
        deriveNextSorter,
        doUncheckAll,
        doCheckAll
      } = vue.inject(dataTableInjectionKey);
      const virtualListRef = vue.ref();
      const cellElsRef = vue.ref({});
      function getCellActualWidth(key) {
        const element = cellElsRef.value[key];
        return element === null || element === void 0 ? void 0 : element.getBoundingClientRect().width;
      }
      function handleCheckboxUpdateChecked() {
        if (allRowsCheckedRef.value) {
          doUncheckAll();
        } else {
          doCheckAll();
        }
      }
      function handleColHeaderClick(e, column) {
        if (happensIn(e, "dataTableFilter") || happensIn(e, "dataTableResizable")) {
          return;
        }
        if (!isColumnSortable(column))
          return;
        const activeSorter = mergedSortStateRef.value.find((state) => state.columnKey === column.key) || null;
        const nextSorter = createNextSorter(column, activeSorter);
        deriveNextSorter(nextSorter);
      }
      const resizeStartWidthMap = /* @__PURE__ */ new Map();
      function handleColumnResizeStart(column) {
        resizeStartWidthMap.set(column.key, getCellActualWidth(column.key));
      }
      function handleColumnResize(column, displacementX) {
        const startWidth = resizeStartWidthMap.get(column.key);
        if (startWidth === void 0) {
          return;
        }
        const widthAfterResize = startWidth + displacementX;
        const limitWidth = clampValueFollowCSSRules(widthAfterResize, column.minWidth, column.maxWidth);
        onUnstableColumnResize(widthAfterResize, limitWidth, column, getCellActualWidth);
        doUpdateResizableWidth(column, limitWidth);
      }
      return {
        cellElsRef,
        componentId,
        mergedSortState: mergedSortStateRef,
        mergedClsPrefix: mergedClsPrefixRef,
        scrollX: scrollXRef,
        fixedColumnLeftMap: fixedColumnLeftMapRef,
        fixedColumnRightMap: fixedColumnRightMapRef,
        currentPage: mergedCurrentPageRef,
        allRowsChecked: allRowsCheckedRef,
        someRowsChecked: someRowsCheckedRef,
        rows: rowsRef,
        cols: colsRef,
        mergedTheme: mergedThemeRef,
        checkOptions: checkOptionsRef,
        mergedTableLayout: mergedTableLayoutRef,
        headerCheckboxDisabled: headerCheckboxDisabledRef,
        headerHeight: headerHeightRef,
        virtualScrollHeader: virtualScrollHeaderRef,
        virtualListRef,
        handleCheckboxUpdateChecked,
        handleColHeaderClick,
        handleTableHeaderScroll,
        handleColumnResizeStart,
        handleColumnResize
      };
    },
    render() {
      const {
        cellElsRef,
        mergedClsPrefix,
        fixedColumnLeftMap,
        fixedColumnRightMap,
        currentPage,
        allRowsChecked,
        someRowsChecked,
        rows,
        cols,
        mergedTheme,
        checkOptions,
        componentId,
        discrete,
        mergedTableLayout,
        headerCheckboxDisabled,
        mergedSortState,
        virtualScrollHeader,
        handleColHeaderClick,
        handleCheckboxUpdateChecked,
        handleColumnResizeStart,
        handleColumnResize
      } = this;
      const renderRow = (row, getLeft, headerHeightPx) => row.map(({
        column,
        colIndex,
        colSpan,
        rowSpan,
        isLast
      }) => {
        var _a, _b;
        const key = getColKey(column);
        const {
          ellipsis
        } = column;
        const createColumnVNode = () => {
          if (column.type === "selection") {
            return column.multiple !== false ? vue.h(vue.Fragment, null, vue.h(NCheckbox, {
              key: currentPage,
              privateInsideTable: true,
              checked: allRowsChecked,
              indeterminate: someRowsChecked,
              disabled: headerCheckboxDisabled,
              onUpdateChecked: handleCheckboxUpdateChecked
            }), checkOptions ? vue.h(SelectionMenu, {
              clsPrefix: mergedClsPrefix
            }) : null) : null;
          }
          return vue.h(vue.Fragment, null, vue.h("div", {
            class: `${mergedClsPrefix}-data-table-th__title-wrapper`
          }, vue.h("div", {
            class: `${mergedClsPrefix}-data-table-th__title`
          }, ellipsis === true || ellipsis && !ellipsis.tooltip ? vue.h("div", {
            class: `${mergedClsPrefix}-data-table-th__ellipsis`
          }, renderTitle(column)) : ellipsis && typeof ellipsis === "object" ? vue.h(NEllipsis, Object.assign({}, ellipsis, {
            theme: mergedTheme.peers.Ellipsis,
            themeOverrides: mergedTheme.peerOverrides.Ellipsis
          }), {
            default: () => renderTitle(column)
          }) : renderTitle(column)), isColumnSortable(column) ? vue.h(SortButton, {
            column
          }) : null), isColumnFilterable(column) ? vue.h(FilterButton, {
            column,
            options: column.filterOptions
          }) : null, isColumnResizable(column) ? vue.h(ResizeButton, {
            onResizeStart: () => {
              handleColumnResizeStart(column);
            },
            onResize: (displacementX) => {
              handleColumnResize(column, displacementX);
            }
          }) : null);
        };
        const leftFixed = key in fixedColumnLeftMap;
        const rightFixed = key in fixedColumnRightMap;
        const CellComponent = getLeft && !column.fixed ? "div" : "th";
        return vue.h(CellComponent, {
          ref: (el) => cellElsRef[key] = el,
          key,
          style: [getLeft && !column.fixed ? {
            position: "absolute",
            left: pxfy(getLeft(colIndex)),
            top: 0,
            bottom: 0
          } : {
            left: pxfy((_a = fixedColumnLeftMap[key]) === null || _a === void 0 ? void 0 : _a.start),
            right: pxfy((_b = fixedColumnRightMap[key]) === null || _b === void 0 ? void 0 : _b.start)
          }, {
            width: pxfy(column.width),
            textAlign: column.titleAlign || column.align,
            height: headerHeightPx
          }],
          colspan: colSpan,
          rowspan: rowSpan,
          "data-col-key": key,
          class: [`${mergedClsPrefix}-data-table-th`, (leftFixed || rightFixed) && `${mergedClsPrefix}-data-table-th--fixed-${leftFixed ? "left" : "right"}`, {
            [`${mergedClsPrefix}-data-table-th--sorting`]: isColumnSorting(column, mergedSortState),
            [`${mergedClsPrefix}-data-table-th--filterable`]: isColumnFilterable(column),
            [`${mergedClsPrefix}-data-table-th--sortable`]: isColumnSortable(column),
            [`${mergedClsPrefix}-data-table-th--selection`]: column.type === "selection",
            [`${mergedClsPrefix}-data-table-th--last`]: isLast
          }, column.className],
          onClick: column.type !== "selection" && column.type !== "expand" && !("children" in column) ? (e) => {
            handleColHeaderClick(e, column);
          } : void 0
        }, createColumnVNode());
      });
      if (virtualScrollHeader) {
        const {
          headerHeight
        } = this;
        let leftFixedColsCount = 0;
        let rightFixedColsCount = 0;
        cols.forEach((col) => {
          if (col.column.fixed === "left") {
            leftFixedColsCount++;
          } else if (col.column.fixed === "right") {
            rightFixedColsCount++;
          }
        });
        return vue.h(VVirtualList, {
          ref: "virtualListRef",
          class: `${mergedClsPrefix}-data-table-base-table-header`,
          style: {
            height: pxfy(headerHeight)
          },
          onScroll: this.handleTableHeaderScroll,
          columns: cols,
          itemSize: headerHeight,
          showScrollbar: false,
          items: [{}],
          itemResizable: false,
          visibleItemsTag: VirtualListItemWrapper$1,
          visibleItemsProps: {
            clsPrefix: mergedClsPrefix,
            id: componentId,
            cols,
            width: formatLength(this.scrollX)
          },
          renderItemWithCols: ({
            startColIndex,
            endColIndex,
            getLeft
          }) => {
            const row = cols.map((col, index) => {
              return {
                column: col.column,
                isLast: index === cols.length - 1,
                colIndex: col.index,
                colSpan: 1,
                rowSpan: 1
              };
            }).filter(({
              column
            }, index) => {
              if (startColIndex <= index && index <= endColIndex) {
                return true;
              }
              if (column.fixed) {
                return true;
              }
              return false;
            });
            const cells = renderRow(row, getLeft, pxfy(headerHeight));
            cells.splice(leftFixedColsCount, 0, vue.h("th", {
              colspan: cols.length - leftFixedColsCount - rightFixedColsCount,
              style: {
                pointerEvents: "none",
                visibility: "hidden",
                height: 0
              }
            }));
            return vue.h("tr", {
              style: {
                position: "relative"
              }
            }, cells);
          }
        }, {
          default: ({
            renderedItemWithCols
          }) => renderedItemWithCols
        });
      }
      const theadVNode = vue.h("thead", {
        class: `${mergedClsPrefix}-data-table-thead`,
        "data-n-id": componentId
      }, rows.map((row) => {
        return vue.h("tr", {
          class: `${mergedClsPrefix}-data-table-tr`
        }, renderRow(row, null, void 0));
      }));
      if (!discrete) {
        return theadVNode;
      }
      const {
        handleTableHeaderScroll,
        scrollX
      } = this;
      return vue.h("div", {
        class: `${mergedClsPrefix}-data-table-base-table-header`,
        onScroll: handleTableHeaderScroll
      }, vue.h("table", {
        class: `${mergedClsPrefix}-data-table-table`,
        style: {
          minWidth: formatLength(scrollX),
          tableLayout: mergedTableLayout
        }
      }, vue.h("colgroup", null, cols.map((col) => vue.h("col", {
        key: col.key,
        style: col.style
      }))), theadVNode));
    }
  });
  const Cell = vue.defineComponent({
    name: "DataTableCell",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      row: {
        type: Object,
        required: true
      },
      index: {
        type: Number,
        required: true
      },
      column: {
        type: Object,
        required: true
      },
      isSummary: Boolean,
      mergedTheme: {
        type: Object,
        required: true
      },
      renderCell: Function
    },
    render() {
      var _a;
      const {
        isSummary,
        column,
        row,
        renderCell
      } = this;
      let cell;
      const {
        render: render2,
        key,
        ellipsis
      } = column;
      if (render2 && !isSummary) {
        cell = render2(row, this.index);
      } else {
        if (isSummary) {
          cell = (_a = row[key]) === null || _a === void 0 ? void 0 : _a.value;
        } else {
          cell = renderCell ? renderCell(get(row, key), row, column) : get(row, key);
        }
      }
      if (ellipsis) {
        if (typeof ellipsis === "object") {
          const {
            mergedTheme
          } = this;
          if (column.ellipsisComponent === "performant-ellipsis") {
            return vue.h(NPerformantEllipsis, Object.assign({}, ellipsis, {
              theme: mergedTheme.peers.Ellipsis,
              themeOverrides: mergedTheme.peerOverrides.Ellipsis
            }), {
              default: () => cell
            });
          }
          return vue.h(NEllipsis, Object.assign({}, ellipsis, {
            theme: mergedTheme.peers.Ellipsis,
            themeOverrides: mergedTheme.peerOverrides.Ellipsis
          }), {
            default: () => cell
          });
        } else {
          return vue.h("span", {
            class: `${this.clsPrefix}-data-table-td__ellipsis`
          }, cell);
        }
      }
      return cell;
    }
  });
  const ExpandTrigger = vue.defineComponent({
    name: "DataTableExpandTrigger",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      expanded: Boolean,
      loading: Boolean,
      onClick: {
        type: Function,
        required: true
      },
      renderExpandIcon: {
        type: Function
      },
      rowData: {
        type: Object,
        required: true
      }
    },
    render() {
      const {
        clsPrefix
      } = this;
      return vue.h("div", {
        class: [`${clsPrefix}-data-table-expand-trigger`, this.expanded && `${clsPrefix}-data-table-expand-trigger--expanded`],
        onClick: this.onClick,
        onMousedown: (e) => {
          e.preventDefault();
        }
      }, vue.h(NIconSwitchTransition, null, {
        default: () => {
          return this.loading ? vue.h(NBaseLoading, {
            key: "loading",
            clsPrefix: this.clsPrefix,
            radius: 85,
            strokeWidth: 15,
            scale: 0.88
          }) : this.renderExpandIcon ? this.renderExpandIcon({
            expanded: this.expanded,
            rowData: this.rowData
          }) : vue.h(NBaseIcon, {
            clsPrefix,
            key: "base-icon"
          }, {
            default: () => vue.h(ChevronRightIcon, null)
          });
        }
      }));
    }
  });
  const RenderSafeCheckbox = vue.defineComponent({
    name: "DataTableBodyCheckbox",
    props: {
      rowKey: {
        type: [String, Number],
        required: true
      },
      disabled: {
        type: Boolean,
        required: true
      },
      onUpdateChecked: {
        type: Function,
        required: true
      }
    },
    setup(props) {
      const {
        mergedCheckedRowKeySetRef,
        mergedInderminateRowKeySetRef
      } = vue.inject(dataTableInjectionKey);
      return () => {
        const {
          rowKey
        } = props;
        return vue.h(NCheckbox, {
          privateInsideTable: true,
          disabled: props.disabled,
          indeterminate: mergedInderminateRowKeySetRef.value.has(rowKey),
          checked: mergedCheckedRowKeySetRef.value.has(rowKey),
          onUpdateChecked: props.onUpdateChecked
        });
      };
    }
  });
  const RenderSafeRadio = vue.defineComponent({
    name: "DataTableBodyRadio",
    props: {
      rowKey: {
        type: [String, Number],
        required: true
      },
      disabled: {
        type: Boolean,
        required: true
      },
      onUpdateChecked: {
        type: Function,
        required: true
      }
    },
    setup(props) {
      const {
        mergedCheckedRowKeySetRef,
        componentId
      } = vue.inject(dataTableInjectionKey);
      return () => {
        const {
          rowKey
        } = props;
        return vue.h(NRadio, {
          name: componentId,
          disabled: props.disabled,
          checked: mergedCheckedRowKeySetRef.value.has(rowKey),
          onUpdateChecked: props.onUpdateChecked
        });
      };
    }
  });
  function flatten(rowInfos, expandedRowKeys) {
    const fRows = [];
    function traverse2(rs, rootIndex) {
      rs.forEach((r) => {
        if (r.children && expandedRowKeys.has(r.key)) {
          fRows.push({
            tmNode: r,
            striped: false,
            key: r.key,
            index: rootIndex
          });
          traverse2(r.children, rootIndex);
        } else {
          fRows.push({
            key: r.key,
            tmNode: r,
            striped: false,
            index: rootIndex
          });
        }
      });
    }
    rowInfos.forEach((rowInfo) => {
      fRows.push(rowInfo);
      const {
        children
      } = rowInfo.tmNode;
      if (children && expandedRowKeys.has(rowInfo.key)) {
        traverse2(children, rowInfo.index);
      }
    });
    return fRows;
  }
  const VirtualListItemWrapper = vue.defineComponent({
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      id: {
        type: String,
        required: true
      },
      cols: {
        type: Array,
        required: true
      },
      onMouseenter: Function,
      onMouseleave: Function
    },
    render() {
      const {
        clsPrefix,
        id,
        cols,
        onMouseenter,
        onMouseleave
      } = this;
      return vue.h("table", {
        style: {
          tableLayout: "fixed"
        },
        class: `${clsPrefix}-data-table-table`,
        onMouseenter,
        onMouseleave
      }, vue.h("colgroup", null, cols.map((col) => vue.h("col", {
        key: col.key,
        style: col.style
      }))), vue.h("tbody", {
        "data-n-id": id,
        class: `${clsPrefix}-data-table-tbody`
      }, this.$slots));
    }
  });
  const TableBody = vue.defineComponent({
    name: "DataTableBody",
    props: {
      onResize: Function,
      showHeader: Boolean,
      flexHeight: Boolean,
      bodyStyle: Object
    },
    setup(props) {
      const {
        slots: dataTableSlots,
        bodyWidthRef,
        mergedExpandedRowKeysRef,
        mergedClsPrefixRef,
        mergedThemeRef,
        scrollXRef,
        colsRef,
        paginatedDataRef,
        rawPaginatedDataRef,
        fixedColumnLeftMapRef,
        fixedColumnRightMapRef,
        mergedCurrentPageRef,
        rowClassNameRef,
        leftActiveFixedColKeyRef,
        leftActiveFixedChildrenColKeysRef,
        rightActiveFixedColKeyRef,
        rightActiveFixedChildrenColKeysRef,
        renderExpandRef,
        hoverKeyRef,
        summaryRef,
        mergedSortStateRef,
        virtualScrollRef,
        virtualScrollXRef,
        heightForRowRef,
        minRowHeightRef,
        componentId,
        mergedTableLayoutRef,
        childTriggerColIndexRef,
        indentRef,
        rowPropsRef,
        maxHeightRef,
        stripedRef,
        loadingRef,
        onLoadRef,
        loadingKeySetRef,
        expandableRef,
        stickyExpandedRowsRef,
        renderExpandIconRef,
        summaryPlacementRef,
        treeMateRef,
        scrollbarPropsRef,
        setHeaderScrollLeft,
        doUpdateExpandedRowKeys,
        handleTableBodyScroll,
        doCheck,
        doUncheck,
        renderCell
      } = vue.inject(dataTableInjectionKey);
      const NConfigProvider2 = vue.inject(configProviderInjectionKey);
      const scrollbarInstRef = vue.ref(null);
      const virtualListRef = vue.ref(null);
      const emptyElRef = vue.ref(null);
      const emptyRef = useMemo(() => paginatedDataRef.value.length === 0);
      const shouldDisplaySomeTablePartRef = useMemo(() => props.showHeader || !emptyRef.value);
      const bodyShowHeaderOnlyRef = useMemo(() => {
        return props.showHeader || emptyRef.value;
      });
      let lastSelectedKey = "";
      const mergedExpandedRowKeySetRef = vue.computed(() => {
        return new Set(mergedExpandedRowKeysRef.value);
      });
      function getRowInfo(key) {
        var _a;
        return (_a = treeMateRef.value.getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode;
      }
      function handleCheckboxUpdateChecked(tmNode, checked, shiftKey) {
        const rowInfo = getRowInfo(tmNode.key);
        if (!rowInfo) {
          warn$2("data-table", `fail to get row data with key ${tmNode.key}`);
          return;
        }
        if (shiftKey) {
          const lastIndex = paginatedDataRef.value.findIndex((item) => item.key === lastSelectedKey);
          if (lastIndex !== -1) {
            const currentIndex = paginatedDataRef.value.findIndex((item) => item.key === tmNode.key);
            const start = Math.min(lastIndex, currentIndex);
            const end = Math.max(lastIndex, currentIndex);
            const rowKeysToCheck = [];
            paginatedDataRef.value.slice(start, end + 1).forEach((r) => {
              if (!r.disabled) {
                rowKeysToCheck.push(r.key);
              }
            });
            if (checked) {
              doCheck(rowKeysToCheck, false, rowInfo);
            } else {
              doUncheck(rowKeysToCheck, rowInfo);
            }
            lastSelectedKey = tmNode.key;
            return;
          }
        }
        if (checked) {
          doCheck(tmNode.key, false, rowInfo);
        } else {
          doUncheck(tmNode.key, rowInfo);
        }
        lastSelectedKey = tmNode.key;
      }
      function handleRadioUpdateChecked(tmNode) {
        const rowInfo = getRowInfo(tmNode.key);
        if (!rowInfo) {
          warn$2("data-table", `fail to get row data with key ${tmNode.key}`);
          return;
        }
        doCheck(tmNode.key, true, rowInfo);
      }
      function getScrollContainer() {
        if (!shouldDisplaySomeTablePartRef.value) {
          const {
            value: emptyEl
          } = emptyElRef;
          if (emptyEl) {
            return emptyEl;
          } else {
            return null;
          }
        }
        if (virtualScrollRef.value) {
          return virtualListContainer();
        }
        const {
          value
        } = scrollbarInstRef;
        if (value)
          return value.containerRef;
        return null;
      }
      function handleUpdateExpanded(key, tmNode) {
        var _a;
        if (loadingKeySetRef.value.has(key))
          return;
        const {
          value: mergedExpandedRowKeys
        } = mergedExpandedRowKeysRef;
        const index = mergedExpandedRowKeys.indexOf(key);
        const nextExpandedKeys = Array.from(mergedExpandedRowKeys);
        if (~index) {
          nextExpandedKeys.splice(index, 1);
          doUpdateExpandedRowKeys(nextExpandedKeys);
        } else {
          if (tmNode && !tmNode.isLeaf && !tmNode.shallowLoaded) {
            loadingKeySetRef.value.add(key);
            void ((_a = onLoadRef.value) === null || _a === void 0 ? void 0 : _a.call(onLoadRef, tmNode.rawNode).then(() => {
              const {
                value: futureMergedExpandedRowKeys
              } = mergedExpandedRowKeysRef;
              const futureNextExpandedKeys = Array.from(futureMergedExpandedRowKeys);
              const index2 = futureNextExpandedKeys.indexOf(key);
              if (!~index2) {
                futureNextExpandedKeys.push(key);
              }
              doUpdateExpandedRowKeys(futureNextExpandedKeys);
            }).finally(() => {
              loadingKeySetRef.value.delete(key);
            }));
          } else {
            nextExpandedKeys.push(key);
            doUpdateExpandedRowKeys(nextExpandedKeys);
          }
        }
      }
      function handleMouseleaveTable() {
        hoverKeyRef.value = null;
      }
      function virtualListContainer() {
        const {
          value
        } = virtualListRef;
        return (value === null || value === void 0 ? void 0 : value.listElRef) || null;
      }
      function virtualListContent() {
        const {
          value
        } = virtualListRef;
        return (value === null || value === void 0 ? void 0 : value.itemsElRef) || null;
      }
      function handleVirtualListScroll(e) {
        var _a;
        handleTableBodyScroll(e);
        (_a = scrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.sync();
      }
      function handleVirtualListResize(e) {
        var _a;
        const {
          onResize
        } = props;
        if (onResize)
          onResize(e);
        (_a = scrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.sync();
      }
      const exposedMethods = {
        getScrollContainer,
        scrollTo(arg0, arg1) {
          var _a, _b;
          if (virtualScrollRef.value) {
            (_a = virtualListRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(arg0, arg1);
          } else {
            (_b = scrollbarInstRef.value) === null || _b === void 0 ? void 0 : _b.scrollTo(arg0, arg1);
          }
        }
      };
      const style2 = c$1([({
        props: cProps
      }) => {
        const createActiveLeftFixedStyle = (leftActiveFixedColKey) => {
          if (leftActiveFixedColKey === null)
            return null;
          return c$1(`[data-n-id="${cProps.componentId}"] [data-col-key="${leftActiveFixedColKey}"]::after`, {
            boxShadow: "var(--n-box-shadow-after)"
          });
        };
        const createActiveRightFixedStyle = (rightActiveFixedColKey) => {
          if (rightActiveFixedColKey === null)
            return null;
          return c$1(`[data-n-id="${cProps.componentId}"] [data-col-key="${rightActiveFixedColKey}"]::before`, {
            boxShadow: "var(--n-box-shadow-before)"
          });
        };
        return c$1([createActiveLeftFixedStyle(cProps.leftActiveFixedColKey), createActiveRightFixedStyle(cProps.rightActiveFixedColKey), cProps.leftActiveFixedChildrenColKeys.map((leftActiveFixedColKey) => createActiveLeftFixedStyle(leftActiveFixedColKey)), cProps.rightActiveFixedChildrenColKeys.map((rightActiveFixedColKey) => createActiveRightFixedStyle(rightActiveFixedColKey))]);
      }]);
      let fixedStyleMounted = false;
      vue.watchEffect(() => {
        const {
          value: leftActiveFixedColKey
        } = leftActiveFixedColKeyRef;
        const {
          value: leftActiveFixedChildrenColKeys
        } = leftActiveFixedChildrenColKeysRef;
        const {
          value: rightActiveFixedColKey
        } = rightActiveFixedColKeyRef;
        const {
          value: rightActiveFixedChildrenColKeys
        } = rightActiveFixedChildrenColKeysRef;
        if (!fixedStyleMounted && leftActiveFixedColKey === null && rightActiveFixedColKey === null) {
          return;
        }
        const cProps = {
          leftActiveFixedColKey,
          leftActiveFixedChildrenColKeys,
          rightActiveFixedColKey,
          rightActiveFixedChildrenColKeys,
          componentId
        };
        style2.mount({
          id: `n-${componentId}`,
          force: true,
          props: cProps,
          anchorMetaName: cssrAnchorMetaName,
          parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
        });
        fixedStyleMounted = true;
      });
      vue.onUnmounted(() => {
        style2.unmount({
          id: `n-${componentId}`,
          parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
        });
      });
      return Object.assign({
        bodyWidth: bodyWidthRef,
        summaryPlacement: summaryPlacementRef,
        dataTableSlots,
        componentId,
        scrollbarInstRef,
        virtualListRef,
        emptyElRef,
        summary: summaryRef,
        mergedClsPrefix: mergedClsPrefixRef,
        mergedTheme: mergedThemeRef,
        scrollX: scrollXRef,
        cols: colsRef,
        loading: loadingRef,
        bodyShowHeaderOnly: bodyShowHeaderOnlyRef,
        shouldDisplaySomeTablePart: shouldDisplaySomeTablePartRef,
        empty: emptyRef,
        paginatedDataAndInfo: vue.computed(() => {
          const {
            value: striped
          } = stripedRef;
          let hasChildren = false;
          const data = paginatedDataRef.value.map(striped ? (tmNode, index) => {
            if (!tmNode.isLeaf)
              hasChildren = true;
            return {
              tmNode,
              key: tmNode.key,
              striped: index % 2 === 1,
              index
            };
          } : (tmNode, index) => {
            if (!tmNode.isLeaf)
              hasChildren = true;
            return {
              tmNode,
              key: tmNode.key,
              striped: false,
              index
            };
          });
          return {
            data,
            hasChildren
          };
        }),
        rawPaginatedData: rawPaginatedDataRef,
        fixedColumnLeftMap: fixedColumnLeftMapRef,
        fixedColumnRightMap: fixedColumnRightMapRef,
        currentPage: mergedCurrentPageRef,
        rowClassName: rowClassNameRef,
        renderExpand: renderExpandRef,
        mergedExpandedRowKeySet: mergedExpandedRowKeySetRef,
        hoverKey: hoverKeyRef,
        mergedSortState: mergedSortStateRef,
        virtualScroll: virtualScrollRef,
        virtualScrollX: virtualScrollXRef,
        heightForRow: heightForRowRef,
        minRowHeight: minRowHeightRef,
        mergedTableLayout: mergedTableLayoutRef,
        childTriggerColIndex: childTriggerColIndexRef,
        indent: indentRef,
        rowProps: rowPropsRef,
        maxHeight: maxHeightRef,
        loadingKeySet: loadingKeySetRef,
        expandable: expandableRef,
        stickyExpandedRows: stickyExpandedRowsRef,
        renderExpandIcon: renderExpandIconRef,
        scrollbarProps: scrollbarPropsRef,
        setHeaderScrollLeft,
        handleVirtualListScroll,
        handleVirtualListResize,
        handleMouseleaveTable,
        virtualListContainer,
        virtualListContent,
        handleTableBodyScroll,
        handleCheckboxUpdateChecked,
        handleRadioUpdateChecked,
        handleUpdateExpanded,
        renderCell
      }, exposedMethods);
    },
    render() {
      const {
        mergedTheme,
        scrollX,
        mergedClsPrefix,
        virtualScroll,
        maxHeight,
        mergedTableLayout,
        flexHeight,
        loadingKeySet,
        onResize,
        setHeaderScrollLeft
      } = this;
      const scrollable = scrollX !== void 0 || maxHeight !== void 0 || flexHeight;
      const isBasicAutoLayout = !scrollable && mergedTableLayout === "auto";
      const xScrollable = scrollX !== void 0 || isBasicAutoLayout;
      const contentStyle = {
        minWidth: formatLength(scrollX) || "100%"
      };
      if (scrollX)
        contentStyle.width = "100%";
      const tableNode = vue.h(NScrollbar, Object.assign({}, this.scrollbarProps, {
        ref: "scrollbarInstRef",
        scrollable: scrollable || isBasicAutoLayout,
        class: `${mergedClsPrefix}-data-table-base-table-body`,
        style: !this.empty ? this.bodyStyle : void 0,
        theme: mergedTheme.peers.Scrollbar,
        themeOverrides: mergedTheme.peerOverrides.Scrollbar,
        contentStyle,
        container: virtualScroll ? this.virtualListContainer : void 0,
        content: virtualScroll ? this.virtualListContent : void 0,
        horizontalRailStyle: {
          zIndex: 3
        },
        verticalRailStyle: {
          zIndex: 3
        },
        xScrollable,
        onScroll: virtualScroll ? void 0 : this.handleTableBodyScroll,
        internalOnUpdateScrollLeft: setHeaderScrollLeft,
        onResize
      }), {
        default: () => {
          const cordToPass = {};
          const cordKey = {};
          const {
            cols,
            paginatedDataAndInfo,
            mergedTheme: mergedTheme2,
            fixedColumnLeftMap,
            fixedColumnRightMap,
            currentPage,
            rowClassName,
            mergedSortState,
            mergedExpandedRowKeySet,
            stickyExpandedRows,
            componentId,
            childTriggerColIndex,
            expandable,
            rowProps: rowProps2,
            handleMouseleaveTable,
            renderExpand,
            summary,
            handleCheckboxUpdateChecked,
            handleRadioUpdateChecked,
            handleUpdateExpanded,
            heightForRow,
            minRowHeight,
            virtualScrollX
          } = this;
          const {
            length: colCount
          } = cols;
          let mergedData;
          const {
            data: paginatedData,
            hasChildren
          } = paginatedDataAndInfo;
          const mergedPaginationData = hasChildren ? flatten(paginatedData, mergedExpandedRowKeySet) : paginatedData;
          if (summary) {
            const summaryRows = summary(this.rawPaginatedData);
            if (Array.isArray(summaryRows)) {
              const summaryRowData = summaryRows.map((row, i) => ({
                isSummaryRow: true,
                key: `__n_summary__${i}`,
                tmNode: {
                  rawNode: row,
                  disabled: true
                },
                index: -1
              }));
              mergedData = this.summaryPlacement === "top" ? [...summaryRowData, ...mergedPaginationData] : [...mergedPaginationData, ...summaryRowData];
            } else {
              const summaryRowData = {
                isSummaryRow: true,
                key: "__n_summary__",
                tmNode: {
                  rawNode: summaryRows,
                  disabled: true
                },
                index: -1
              };
              mergedData = this.summaryPlacement === "top" ? [summaryRowData, ...mergedPaginationData] : [...mergedPaginationData, summaryRowData];
            }
          } else {
            mergedData = mergedPaginationData;
          }
          const indentStyle = hasChildren ? {
            width: pxfy(this.indent)
          } : void 0;
          const displayedData = [];
          mergedData.forEach((rowInfo) => {
            if (renderExpand && mergedExpandedRowKeySet.has(rowInfo.key) && (!expandable || expandable(rowInfo.tmNode.rawNode))) {
              displayedData.push(rowInfo, {
                isExpandedRow: true,
                key: `${rowInfo.key}-expand`,
                // solve key repeat of the expanded row
                tmNode: rowInfo.tmNode,
                index: rowInfo.index
              });
            } else {
              displayedData.push(rowInfo);
            }
          });
          const {
            length: rowCount
          } = displayedData;
          const rowIndexToKey = {};
          paginatedData.forEach(({
            tmNode
          }, rowIndex) => {
            rowIndexToKey[rowIndex] = tmNode.key;
          });
          const bodyWidth = stickyExpandedRows ? this.bodyWidth : null;
          const bodyWidthPx = bodyWidth === null ? void 0 : `${bodyWidth}px`;
          const CellComponent = this.virtualScrollX ? "div" : "td";
          let leftFixedColsCount = 0;
          let rightFixedColsCount = 0;
          if (virtualScrollX) {
            cols.forEach((col) => {
              if (col.column.fixed === "left") {
                leftFixedColsCount++;
              } else if (col.column.fixed === "right") {
                rightFixedColsCount++;
              }
            });
          }
          const renderRow = ({
            // Normal
            rowInfo,
            displayedRowIndex,
            isVirtual,
            // Virtual X
            isVirtualX,
            startColIndex,
            endColIndex,
            getLeft
          }) => {
            const {
              index: actualRowIndex
            } = rowInfo;
            if ("isExpandedRow" in rowInfo) {
              const {
                tmNode: {
                  key,
                  rawNode
                }
              } = rowInfo;
              return vue.h("tr", {
                class: `${mergedClsPrefix}-data-table-tr ${mergedClsPrefix}-data-table-tr--expanded`,
                key: `${key}__expand`
              }, vue.h("td", {
                class: [`${mergedClsPrefix}-data-table-td`, `${mergedClsPrefix}-data-table-td--last-col`, displayedRowIndex + 1 === rowCount && `${mergedClsPrefix}-data-table-td--last-row`],
                colspan: colCount
              }, stickyExpandedRows ? vue.h("div", {
                class: `${mergedClsPrefix}-data-table-expand`,
                style: {
                  width: bodyWidthPx
                }
              }, renderExpand(rawNode, actualRowIndex)) : renderExpand(rawNode, actualRowIndex)));
            }
            const isSummary = "isSummaryRow" in rowInfo;
            const striped = !isSummary && rowInfo.striped;
            const {
              tmNode,
              key: rowKey
            } = rowInfo;
            const {
              rawNode: rowData
            } = tmNode;
            const expanded = mergedExpandedRowKeySet.has(rowKey);
            const props = rowProps2 ? rowProps2(rowData, actualRowIndex) : void 0;
            const mergedRowClassName = typeof rowClassName === "string" ? rowClassName : createRowClassName(rowData, actualRowIndex, rowClassName);
            const iteratedCols = isVirtualX ? cols.filter((col, index) => {
              if (startColIndex <= index && index <= endColIndex)
                return true;
              if (col.column.fixed) {
                return true;
              }
              return false;
            }) : cols;
            const virtualXRowHeight = isVirtualX ? pxfy((heightForRow === null || heightForRow === void 0 ? void 0 : heightForRow(rowData, actualRowIndex)) || minRowHeight) : void 0;
            const cells = iteratedCols.map((col) => {
              var _a, _b, _c, _d, _e;
              const colIndex = col.index;
              if (displayedRowIndex in cordToPass) {
                const cordOfRowToPass = cordToPass[displayedRowIndex];
                const indexInCordOfRowToPass = cordOfRowToPass.indexOf(colIndex);
                if (~indexInCordOfRowToPass) {
                  cordOfRowToPass.splice(indexInCordOfRowToPass, 1);
                  return null;
                }
              }
              const {
                column
              } = col;
              const colKey = getColKey(col);
              const {
                rowSpan,
                colSpan
              } = column;
              const mergedColSpan = isSummary ? ((_a = rowInfo.tmNode.rawNode[colKey]) === null || _a === void 0 ? void 0 : _a.colSpan) || 1 : colSpan ? colSpan(rowData, actualRowIndex) : 1;
              const mergedRowSpan = isSummary ? ((_b = rowInfo.tmNode.rawNode[colKey]) === null || _b === void 0 ? void 0 : _b.rowSpan) || 1 : rowSpan ? rowSpan(rowData, actualRowIndex) : 1;
              const isLastCol = colIndex + mergedColSpan === colCount;
              const isLastRow = displayedRowIndex + mergedRowSpan === rowCount;
              const isCrossRowTd = mergedRowSpan > 1;
              if (isCrossRowTd) {
                cordKey[displayedRowIndex] = {
                  [colIndex]: []
                };
              }
              if (mergedColSpan > 1 || isCrossRowTd) {
                for (let i = displayedRowIndex; i < displayedRowIndex + mergedRowSpan; ++i) {
                  if (isCrossRowTd) {
                    cordKey[displayedRowIndex][colIndex].push(rowIndexToKey[i]);
                  }
                  for (let j = colIndex; j < colIndex + mergedColSpan; ++j) {
                    if (i === displayedRowIndex && j === colIndex) {
                      continue;
                    }
                    if (!(i in cordToPass)) {
                      cordToPass[i] = [j];
                    } else {
                      cordToPass[i].push(j);
                    }
                  }
                }
              }
              const hoverKey = isCrossRowTd ? this.hoverKey : null;
              const {
                cellProps
              } = column;
              const resolvedCellProps = cellProps === null || cellProps === void 0 ? void 0 : cellProps(rowData, actualRowIndex);
              const indentOffsetStyle = {
                "--indent-offset": ""
              };
              const FinalCellComponent = column.fixed ? "td" : CellComponent;
              return vue.h(FinalCellComponent, Object.assign({}, resolvedCellProps, {
                key: colKey,
                style: [{
                  textAlign: column.align || void 0,
                  width: pxfy(column.width)
                }, isVirtualX && {
                  height: virtualXRowHeight
                }, isVirtualX && !column.fixed ? {
                  position: "absolute",
                  left: pxfy(getLeft(colIndex)),
                  top: 0,
                  bottom: 0
                } : {
                  left: pxfy((_c = fixedColumnLeftMap[colKey]) === null || _c === void 0 ? void 0 : _c.start),
                  right: pxfy((_d = fixedColumnRightMap[colKey]) === null || _d === void 0 ? void 0 : _d.start)
                }, indentOffsetStyle, (resolvedCellProps === null || resolvedCellProps === void 0 ? void 0 : resolvedCellProps.style) || ""],
                colspan: mergedColSpan,
                rowspan: isVirtual ? void 0 : mergedRowSpan,
                "data-col-key": colKey,
                class: [`${mergedClsPrefix}-data-table-td`, column.className, resolvedCellProps === null || resolvedCellProps === void 0 ? void 0 : resolvedCellProps.class, isSummary && `${mergedClsPrefix}-data-table-td--summary`, hoverKey !== null && cordKey[displayedRowIndex][colIndex].includes(hoverKey) && `${mergedClsPrefix}-data-table-td--hover`, isColumnSorting(column, mergedSortState) && `${mergedClsPrefix}-data-table-td--sorting`, column.fixed && `${mergedClsPrefix}-data-table-td--fixed-${column.fixed}`, column.align && `${mergedClsPrefix}-data-table-td--${column.align}-align`, column.type === "selection" && `${mergedClsPrefix}-data-table-td--selection`, column.type === "expand" && `${mergedClsPrefix}-data-table-td--expand`, isLastCol && `${mergedClsPrefix}-data-table-td--last-col`, isLastRow && `${mergedClsPrefix}-data-table-td--last-row`]
              }), hasChildren && colIndex === childTriggerColIndex ? [repeat(indentOffsetStyle["--indent-offset"] = isSummary ? 0 : rowInfo.tmNode.level, vue.h("div", {
                class: `${mergedClsPrefix}-data-table-indent`,
                style: indentStyle
              })), isSummary || rowInfo.tmNode.isLeaf ? vue.h("div", {
                class: `${mergedClsPrefix}-data-table-expand-placeholder`
              }) : vue.h(ExpandTrigger, {
                class: `${mergedClsPrefix}-data-table-expand-trigger`,
                clsPrefix: mergedClsPrefix,
                expanded,
                rowData,
                renderExpandIcon: this.renderExpandIcon,
                loading: loadingKeySet.has(rowInfo.key),
                onClick: () => {
                  handleUpdateExpanded(rowKey, rowInfo.tmNode);
                }
              })] : null, column.type === "selection" ? !isSummary ? column.multiple === false ? vue.h(RenderSafeRadio, {
                key: currentPage,
                rowKey,
                disabled: rowInfo.tmNode.disabled,
                onUpdateChecked: () => {
                  handleRadioUpdateChecked(rowInfo.tmNode);
                }
              }) : vue.h(RenderSafeCheckbox, {
                key: currentPage,
                rowKey,
                disabled: rowInfo.tmNode.disabled,
                onUpdateChecked: (checked, e) => {
                  handleCheckboxUpdateChecked(rowInfo.tmNode, checked, e.shiftKey);
                }
              }) : null : column.type === "expand" ? !isSummary ? !column.expandable || ((_e = column.expandable) === null || _e === void 0 ? void 0 : _e.call(column, rowData)) ? vue.h(ExpandTrigger, {
                clsPrefix: mergedClsPrefix,
                rowData,
                expanded,
                renderExpandIcon: this.renderExpandIcon,
                onClick: () => {
                  handleUpdateExpanded(rowKey, null);
                }
              }) : null : null : vue.h(Cell, {
                clsPrefix: mergedClsPrefix,
                index: actualRowIndex,
                row: rowData,
                column,
                isSummary,
                mergedTheme: mergedTheme2,
                renderCell: this.renderCell
              }));
            });
            if (isVirtualX) {
              if (leftFixedColsCount && rightFixedColsCount) {
                cells.splice(leftFixedColsCount, 0, vue.h("td", {
                  colspan: cols.length - leftFixedColsCount - rightFixedColsCount,
                  style: {
                    pointerEvents: "none",
                    visibility: "hidden",
                    height: 0
                  }
                }));
              }
            }
            const row = vue.h("tr", Object.assign({}, props, {
              onMouseenter: (e) => {
                var _a;
                this.hoverKey = rowKey;
                (_a = props === null || props === void 0 ? void 0 : props.onMouseenter) === null || _a === void 0 ? void 0 : _a.call(props, e);
              },
              key: rowKey,
              class: [`${mergedClsPrefix}-data-table-tr`, isSummary && `${mergedClsPrefix}-data-table-tr--summary`, striped && `${mergedClsPrefix}-data-table-tr--striped`, expanded && `${mergedClsPrefix}-data-table-tr--expanded`, mergedRowClassName, props === null || props === void 0 ? void 0 : props.class],
              style: [props === null || props === void 0 ? void 0 : props.style, isVirtualX && {
                height: virtualXRowHeight
              }]
            }), cells);
            return row;
          };
          if (!virtualScroll) {
            return vue.h("table", {
              class: `${mergedClsPrefix}-data-table-table`,
              onMouseleave: handleMouseleaveTable,
              style: {
                tableLayout: this.mergedTableLayout
              }
            }, vue.h("colgroup", null, cols.map((col) => vue.h("col", {
              key: col.key,
              style: col.style
            }))), this.showHeader ? vue.h(TableHeader, {
              discrete: false
            }) : null, !this.empty ? vue.h("tbody", {
              "data-n-id": componentId,
              class: `${mergedClsPrefix}-data-table-tbody`
            }, displayedData.map((rowInfo, displayedRowIndex) => {
              return renderRow({
                rowInfo,
                displayedRowIndex,
                isVirtual: false,
                isVirtualX: false,
                startColIndex: -1,
                endColIndex: -1,
                getLeft(_index) {
                  return -1;
                }
              });
            })) : null);
          } else {
            return vue.h(VVirtualList, {
              ref: "virtualListRef",
              items: displayedData,
              itemSize: this.minRowHeight,
              visibleItemsTag: VirtualListItemWrapper,
              visibleItemsProps: {
                clsPrefix: mergedClsPrefix,
                id: componentId,
                cols,
                onMouseleave: handleMouseleaveTable
              },
              showScrollbar: false,
              onResize: this.handleVirtualListResize,
              onScroll: this.handleVirtualListScroll,
              itemsStyle: contentStyle,
              itemResizable: !virtualScrollX,
              columns: cols,
              renderItemWithCols: virtualScrollX ? ({
                itemIndex,
                item,
                startColIndex,
                endColIndex,
                getLeft
              }) => {
                return renderRow({
                  displayedRowIndex: itemIndex,
                  isVirtual: true,
                  isVirtualX: true,
                  rowInfo: item,
                  startColIndex,
                  endColIndex,
                  getLeft
                });
              } : void 0
            }, {
              default: ({
                item,
                index,
                renderedItemWithCols
              }) => {
                if (renderedItemWithCols)
                  return renderedItemWithCols;
                return renderRow({
                  rowInfo: item,
                  displayedRowIndex: index,
                  isVirtual: true,
                  isVirtualX: false,
                  startColIndex: 0,
                  endColIndex: 0,
                  getLeft(_index) {
                    return 0;
                  }
                });
              }
            });
          }
        }
      });
      if (this.empty) {
        const createEmptyNode = () => vue.h("div", {
          class: [`${mergedClsPrefix}-data-table-empty`, this.loading && `${mergedClsPrefix}-data-table-empty--hide`],
          style: this.bodyStyle,
          ref: "emptyElRef"
        }, resolveSlot(this.dataTableSlots.empty, () => [vue.h(NEmpty, {
          theme: this.mergedTheme.peers.Empty,
          themeOverrides: this.mergedTheme.peerOverrides.Empty
        })]));
        if (this.shouldDisplaySomeTablePart) {
          return vue.h(vue.Fragment, null, tableNode, createEmptyNode());
        } else {
          return vue.h(VResizeObserver, {
            onResize: this.onResize
          }, {
            default: createEmptyNode
          });
        }
      }
      return tableNode;
    }
  });
  const MainTable = vue.defineComponent({
    name: "MainTable",
    setup() {
      const {
        mergedClsPrefixRef,
        rightFixedColumnsRef,
        leftFixedColumnsRef,
        bodyWidthRef,
        maxHeightRef,
        minHeightRef,
        flexHeightRef,
        virtualScrollHeaderRef,
        syncScrollState
      } = vue.inject(dataTableInjectionKey);
      const headerInstRef = vue.ref(null);
      const bodyInstRef = vue.ref(null);
      const selfElRef = vue.ref(null);
      const fixedStateInitializedRef = vue.ref(!(leftFixedColumnsRef.value.length || rightFixedColumnsRef.value.length));
      const bodyStyleRef = vue.computed(() => {
        return {
          maxHeight: formatLength(maxHeightRef.value),
          minHeight: formatLength(minHeightRef.value)
        };
      });
      function handleBodyResize(entry) {
        bodyWidthRef.value = entry.contentRect.width;
        syncScrollState();
        if (!fixedStateInitializedRef.value) {
          fixedStateInitializedRef.value = true;
        }
      }
      function getHeaderElement() {
        var _a;
        const {
          value
        } = headerInstRef;
        if (value) {
          if (virtualScrollHeaderRef.value) {
            return ((_a = value.virtualListRef) === null || _a === void 0 ? void 0 : _a.listElRef) || null;
          } else {
            return value.$el;
          }
        }
        return null;
      }
      function getBodyElement() {
        const {
          value
        } = bodyInstRef;
        if (value) {
          return value.getScrollContainer();
        }
        return null;
      }
      const exposedMethods = {
        getBodyElement,
        getHeaderElement,
        scrollTo(arg0, arg1) {
          var _a;
          (_a = bodyInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(arg0, arg1);
        }
      };
      vue.watchEffect(() => {
        const {
          value: selfEl
        } = selfElRef;
        if (!selfEl)
          return;
        const transitionDisabledClass = `${mergedClsPrefixRef.value}-data-table-base-table--transition-disabled`;
        if (fixedStateInitializedRef.value) {
          setTimeout(() => {
            selfEl.classList.remove(transitionDisabledClass);
          }, 0);
        } else {
          selfEl.classList.add(transitionDisabledClass);
        }
      });
      return Object.assign({
        maxHeight: maxHeightRef,
        mergedClsPrefix: mergedClsPrefixRef,
        selfElRef,
        headerInstRef,
        bodyInstRef,
        bodyStyle: bodyStyleRef,
        flexHeight: flexHeightRef,
        handleBodyResize
      }, exposedMethods);
    },
    render() {
      const {
        mergedClsPrefix,
        maxHeight,
        flexHeight
      } = this;
      const headerInBody = maxHeight === void 0 && !flexHeight;
      return vue.h("div", {
        class: `${mergedClsPrefix}-data-table-base-table`,
        ref: "selfElRef"
      }, headerInBody ? null : vue.h(TableHeader, {
        ref: "headerInstRef"
      }), vue.h(TableBody, {
        ref: "bodyInstRef",
        bodyStyle: this.bodyStyle,
        showHeader: headerInBody,
        flexHeight,
        onResize: this.handleBodyResize
      }));
    }
  });
  function useCheck(props, data) {
    const {
      paginatedDataRef,
      treeMateRef,
      selectionColumnRef
    } = data;
    const uncontrolledCheckedRowKeysRef = vue.ref(props.defaultCheckedRowKeys);
    const mergedCheckState = vue.computed(() => {
      var _a;
      const {
        checkedRowKeys
      } = props;
      const sourceKeys = checkedRowKeys === void 0 ? uncontrolledCheckedRowKeysRef.value : checkedRowKeys;
      if (((_a = selectionColumnRef.value) === null || _a === void 0 ? void 0 : _a.multiple) === false) {
        return {
          checkedKeys: sourceKeys.slice(0, 1),
          indeterminateKeys: []
        };
      }
      return treeMateRef.value.getCheckedKeys(sourceKeys, {
        cascade: props.cascade,
        allowNotLoaded: props.allowCheckingNotLoaded
      });
    });
    const mergedCheckedRowKeysRef = vue.computed(() => mergedCheckState.value.checkedKeys);
    const mergedInderminateRowKeysRef = vue.computed(() => mergedCheckState.value.indeterminateKeys);
    const mergedCheckedRowKeySetRef = vue.computed(() => {
      return new Set(mergedCheckedRowKeysRef.value);
    });
    const mergedInderminateRowKeySetRef = vue.computed(() => {
      return new Set(mergedInderminateRowKeysRef.value);
    });
    const countOfCurrentPageCheckedRowsRef = vue.computed(() => {
      const {
        value: mergedCheckedRowKeySet
      } = mergedCheckedRowKeySetRef;
      return paginatedDataRef.value.reduce((total, tmNode) => {
        const {
          key,
          disabled
        } = tmNode;
        return total + (!disabled && mergedCheckedRowKeySet.has(key) ? 1 : 0);
      }, 0);
    });
    const countOfCurrentPageDisabledRowsRef = vue.computed(() => {
      return paginatedDataRef.value.filter((item) => item.disabled).length;
    });
    const someRowsCheckedRef = vue.computed(() => {
      const {
        length
      } = paginatedDataRef.value;
      const {
        value: mergedInderminateRowKeySet
      } = mergedInderminateRowKeySetRef;
      return countOfCurrentPageCheckedRowsRef.value > 0 && countOfCurrentPageCheckedRowsRef.value < length - countOfCurrentPageDisabledRowsRef.value || paginatedDataRef.value.some((rowData) => mergedInderminateRowKeySet.has(rowData.key));
    });
    const allRowsCheckedRef = vue.computed(() => {
      const {
        length
      } = paginatedDataRef.value;
      return countOfCurrentPageCheckedRowsRef.value !== 0 && countOfCurrentPageCheckedRowsRef.value === length - countOfCurrentPageDisabledRowsRef.value;
    });
    const headerCheckboxDisabledRef = vue.computed(() => {
      return paginatedDataRef.value.length === 0;
    });
    function doUpdateCheckedRowKeys(keys2, row, action) {
      const {
        "onUpdate:checkedRowKeys": _onUpdateCheckedRowKeys,
        onUpdateCheckedRowKeys,
        onCheckedRowKeysChange
      } = props;
      const rows = [];
      const {
        value: {
          getNode
        }
      } = treeMateRef;
      keys2.forEach((key) => {
        var _a;
        const row2 = (_a = getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode;
        rows.push(row2);
      });
      if (_onUpdateCheckedRowKeys) {
        call(_onUpdateCheckedRowKeys, keys2, rows, {
          row,
          action
        });
      }
      if (onUpdateCheckedRowKeys) {
        call(onUpdateCheckedRowKeys, keys2, rows, {
          row,
          action
        });
      }
      if (onCheckedRowKeysChange) {
        call(onCheckedRowKeysChange, keys2, rows, {
          row,
          action
        });
      }
      uncontrolledCheckedRowKeysRef.value = keys2;
    }
    function doCheck(rowKey, single = false, rowInfo) {
      if (props.loading)
        return;
      if (single) {
        doUpdateCheckedRowKeys(Array.isArray(rowKey) ? rowKey.slice(0, 1) : [rowKey], rowInfo, "check");
        return;
      }
      doUpdateCheckedRowKeys(treeMateRef.value.check(rowKey, mergedCheckedRowKeysRef.value, {
        cascade: props.cascade,
        allowNotLoaded: props.allowCheckingNotLoaded
      }).checkedKeys, rowInfo, "check");
    }
    function doUncheck(rowKey, rowInfo) {
      if (props.loading)
        return;
      doUpdateCheckedRowKeys(treeMateRef.value.uncheck(rowKey, mergedCheckedRowKeysRef.value, {
        cascade: props.cascade,
        allowNotLoaded: props.allowCheckingNotLoaded
      }).checkedKeys, rowInfo, "uncheck");
    }
    function doCheckAll(checkWholeTable = false) {
      const {
        value: column
      } = selectionColumnRef;
      if (!column || props.loading)
        return;
      const rowKeysToCheck = [];
      (checkWholeTable ? treeMateRef.value.treeNodes : paginatedDataRef.value).forEach((tmNode) => {
        if (!tmNode.disabled) {
          rowKeysToCheck.push(tmNode.key);
        }
      });
      doUpdateCheckedRowKeys(treeMateRef.value.check(rowKeysToCheck, mergedCheckedRowKeysRef.value, {
        cascade: true,
        allowNotLoaded: props.allowCheckingNotLoaded
      }).checkedKeys, void 0, "checkAll");
    }
    function doUncheckAll(checkWholeTable = false) {
      const {
        value: column
      } = selectionColumnRef;
      if (!column || props.loading)
        return;
      const rowKeysToUncheck = [];
      (checkWholeTable ? treeMateRef.value.treeNodes : paginatedDataRef.value).forEach((tmNode) => {
        if (!tmNode.disabled) {
          rowKeysToUncheck.push(tmNode.key);
        }
      });
      doUpdateCheckedRowKeys(treeMateRef.value.uncheck(rowKeysToUncheck, mergedCheckedRowKeysRef.value, {
        cascade: true,
        allowNotLoaded: props.allowCheckingNotLoaded
      }).checkedKeys, void 0, "uncheckAll");
    }
    return {
      mergedCheckedRowKeySetRef,
      mergedCheckedRowKeysRef,
      mergedInderminateRowKeySetRef,
      someRowsCheckedRef,
      allRowsCheckedRef,
      headerCheckboxDisabledRef,
      doUpdateCheckedRowKeys,
      doCheckAll,
      doUncheckAll,
      doCheck,
      doUncheck
    };
  }
  function getMultiplePriority(sorter) {
    if (typeof sorter === "object" && typeof sorter.multiple === "number") {
      return sorter.multiple;
    }
    return false;
  }
  function getSortFunction(sorter, columnKey) {
    if (columnKey && (sorter === void 0 || sorter === "default" || typeof sorter === "object" && sorter.compare === "default")) {
      return getDefaultSorterFn(columnKey);
    }
    if (typeof sorter === "function") {
      return sorter;
    }
    if (sorter && typeof sorter === "object" && sorter.compare && sorter.compare !== "default") {
      return sorter.compare;
    }
    return false;
  }
  function getDefaultSorterFn(columnKey) {
    return (row1, row2) => {
      const value1 = row1[columnKey];
      const value2 = row2[columnKey];
      if (value1 === null || value1 === void 0) {
        if (value2 === null || value2 === void 0)
          return 0;
        return -1;
      } else if (value2 === null || value2 === void 0) {
        return 1;
      } else if (typeof value1 === "number" && typeof value2 === "number") {
        return value1 - value2;
      } else if (typeof value1 === "string" && typeof value2 === "string") {
        return value1.localeCompare(value2);
      }
      return 0;
    };
  }
  function useSorter(props, {
    dataRelatedColsRef,
    filteredDataRef
  }) {
    const defaultSortState = [];
    dataRelatedColsRef.value.forEach((column) => {
      var _a;
      if (column.sorter !== void 0) {
        updateSortStatesByNewSortState(defaultSortState, {
          columnKey: column.key,
          sorter: column.sorter,
          order: (_a = column.defaultSortOrder) !== null && _a !== void 0 ? _a : false
        });
      }
    });
    const uncontrolledSortStateRef = vue.ref(defaultSortState);
    const mergedSortStateRef = vue.computed(() => {
      const columnsWithControlledSortOrder = dataRelatedColsRef.value.filter((column) => column.type !== "selection" && column.sorter !== void 0 && (column.sortOrder === "ascend" || column.sortOrder === "descend" || column.sortOrder === false));
      const columnToSort = columnsWithControlledSortOrder.filter((col) => col.sortOrder !== false);
      if (columnToSort.length) {
        return columnToSort.map((column) => {
          return {
            columnKey: column.key,
            // column to sort has controlled sorter
            // sorter && sort order won't be undefined
            order: column.sortOrder,
            sorter: column.sorter
          };
        });
      }
      if (columnsWithControlledSortOrder.length)
        return [];
      const {
        value: uncontrolledSortState
      } = uncontrolledSortStateRef;
      if (Array.isArray(uncontrolledSortState)) {
        return uncontrolledSortState;
      } else if (uncontrolledSortState) {
        return [uncontrolledSortState];
      } else {
        return [];
      }
    });
    const sortedDataRef = vue.computed(() => {
      const activeSorters = mergedSortStateRef.value.slice().sort((a2, b) => {
        const item1Priority = getMultiplePriority(a2.sorter) || 0;
        const item2Priority = getMultiplePriority(b.sorter) || 0;
        return item2Priority - item1Priority;
      });
      if (activeSorters.length) {
        const filteredData = filteredDataRef.value.slice();
        return filteredData.sort((tmNode1, tmNode2) => {
          let compareResult = 0;
          activeSorters.some((sorterState) => {
            const {
              columnKey,
              sorter,
              order
            } = sorterState;
            const compareFn = getSortFunction(sorter, columnKey);
            if (compareFn && order) {
              compareResult = compareFn(tmNode1.rawNode, tmNode2.rawNode);
              if (compareResult !== 0) {
                compareResult = compareResult * getFlagOfOrder(order);
                return true;
              }
            }
            return false;
          });
          return compareResult;
        });
      }
      return filteredDataRef.value;
    });
    function getUpdatedSorterState(sortState) {
      let currentSortState = mergedSortStateRef.value.slice();
      if (sortState && getMultiplePriority(sortState.sorter) !== false) {
        currentSortState = currentSortState.filter((sortState2) => getMultiplePriority(sortState2.sorter) !== false);
        updateSortStatesByNewSortState(currentSortState, sortState);
        return currentSortState;
      } else if (sortState) {
        return sortState;
      }
      return null;
    }
    function deriveNextSorter(sortState) {
      const nextSorterState = getUpdatedSorterState(sortState);
      doUpdateSorter(nextSorterState);
    }
    function doUpdateSorter(sortState) {
      const {
        "onUpdate:sorter": _onUpdateSorter,
        onUpdateSorter,
        onSorterChange
      } = props;
      if (_onUpdateSorter) {
        call(_onUpdateSorter, sortState);
      }
      if (onUpdateSorter) {
        call(onUpdateSorter, sortState);
      }
      if (onSorterChange) {
        call(onSorterChange, sortState);
      }
      uncontrolledSortStateRef.value = sortState;
    }
    function sort(columnKey, order = "ascend") {
      if (!columnKey) {
        clearSorter();
      } else {
        const columnToSort = dataRelatedColsRef.value.find((column) => column.type !== "selection" && column.type !== "expand" && column.key === columnKey);
        if (!(columnToSort === null || columnToSort === void 0 ? void 0 : columnToSort.sorter))
          return;
        const sorter = columnToSort.sorter;
        deriveNextSorter({
          columnKey,
          sorter,
          order
        });
      }
    }
    function clearSorter() {
      doUpdateSorter(null);
    }
    function updateSortStatesByNewSortState(sortStates, sortState) {
      const index = sortStates.findIndex((state) => (sortState === null || sortState === void 0 ? void 0 : sortState.columnKey) && state.columnKey === sortState.columnKey);
      if (index !== void 0 && index >= 0) {
        sortStates[index] = sortState;
      } else {
        sortStates.push(sortState);
      }
    }
    return {
      clearSorter,
      sort,
      sortedDataRef,
      mergedSortStateRef,
      deriveNextSorter
    };
  }
  function useTableData(props, {
    dataRelatedColsRef
  }) {
    const selectionColumnRef = vue.computed(() => {
      const getSelectionColumn = (cols) => {
        for (let i = 0; i < cols.length; ++i) {
          const col = cols[i];
          if ("children" in col) {
            return getSelectionColumn(col.children);
          } else if (col.type === "selection") {
            return col;
          }
        }
        return null;
      };
      return getSelectionColumn(props.columns);
    });
    const treeMateRef = vue.computed(() => {
      const {
        childrenKey
      } = props;
      return createTreeMate(props.data, {
        ignoreEmptyChildren: true,
        getKey: props.rowKey,
        getChildren: (rowData) => rowData[childrenKey],
        getDisabled: (rowData) => {
          var _a, _b;
          if ((_b = (_a = selectionColumnRef.value) === null || _a === void 0 ? void 0 : _a.disabled) === null || _b === void 0 ? void 0 : _b.call(_a, rowData)) {
            return true;
          }
          return false;
        }
      });
    });
    const childTriggerColIndexRef = useMemo(() => {
      const {
        columns
      } = props;
      const {
        length
      } = columns;
      let firstContentfulColIndex = null;
      for (let i = 0; i < length; ++i) {
        const col = columns[i];
        if (!col.type && firstContentfulColIndex === null) {
          firstContentfulColIndex = i;
        }
        if ("tree" in col && col.tree) {
          return i;
        }
      }
      return firstContentfulColIndex || 0;
    });
    const uncontrolledFilterStateRef = vue.ref({});
    const {
      pagination
    } = props;
    const uncontrolledCurrentPageRef = vue.ref(pagination ? pagination.defaultPage || 1 : 1);
    const uncontrolledPageSizeRef = vue.ref(getDefaultPageSize(pagination));
    const mergedFilterStateRef = vue.computed(() => {
      const columnsWithControlledFilter = dataRelatedColsRef.value.filter((column) => {
        return column.filterOptionValues !== void 0 || column.filterOptionValue !== void 0;
      });
      const controlledFilterState = {};
      columnsWithControlledFilter.forEach((column) => {
        var _a;
        if (column.type === "selection" || column.type === "expand")
          return;
        if (column.filterOptionValues === void 0) {
          controlledFilterState[column.key] = (_a = column.filterOptionValue) !== null && _a !== void 0 ? _a : null;
        } else {
          controlledFilterState[column.key] = column.filterOptionValues;
        }
      });
      const activeFilters = Object.assign(createShallowClonedObject(uncontrolledFilterStateRef.value), controlledFilterState);
      return activeFilters;
    });
    const filteredDataRef = vue.computed(() => {
      const mergedFilterState = mergedFilterStateRef.value;
      const {
        columns
      } = props;
      function createDefaultFilter(columnKey) {
        return (filterOptionValue, row) => !!~String(row[columnKey]).indexOf(String(filterOptionValue));
      }
      const {
        value: {
          treeNodes: data
        }
      } = treeMateRef;
      const columnEntries = [];
      columns.forEach((column) => {
        if (column.type === "selection" || column.type === "expand" || "children" in column) {
          return;
        }
        columnEntries.push([column.key, column]);
      });
      return data ? data.filter((tmNode) => {
        const {
          rawNode: row
        } = tmNode;
        for (const [columnKey, column] of columnEntries) {
          let activeFilterOptionValues = mergedFilterState[columnKey];
          if (activeFilterOptionValues == null)
            continue;
          if (!Array.isArray(activeFilterOptionValues)) {
            activeFilterOptionValues = [activeFilterOptionValues];
          }
          if (!activeFilterOptionValues.length)
            continue;
          const filter2 = column.filter === "default" ? createDefaultFilter(columnKey) : column.filter;
          if (column && typeof filter2 === "function") {
            if (column.filterMode === "and") {
              if (activeFilterOptionValues.some((filterOptionValue) => !filter2(filterOptionValue, row))) {
                return false;
              }
            } else {
              if (activeFilterOptionValues.some((filterOptionValue) => filter2(filterOptionValue, row))) {
                continue;
              } else {
                return false;
              }
            }
          }
        }
        return true;
      }) : [];
    });
    const {
      sortedDataRef,
      deriveNextSorter,
      mergedSortStateRef,
      sort,
      clearSorter
    } = useSorter(props, {
      dataRelatedColsRef,
      filteredDataRef
    });
    dataRelatedColsRef.value.forEach((column) => {
      var _a;
      if (column.filter) {
        const defaultFilterOptionValues = column.defaultFilterOptionValues;
        if (column.filterMultiple) {
          uncontrolledFilterStateRef.value[column.key] = defaultFilterOptionValues || [];
        } else if (defaultFilterOptionValues !== void 0) {
          uncontrolledFilterStateRef.value[column.key] = defaultFilterOptionValues === null ? [] : defaultFilterOptionValues;
        } else {
          uncontrolledFilterStateRef.value[column.key] = (_a = column.defaultFilterOptionValue) !== null && _a !== void 0 ? _a : null;
        }
      }
    });
    const controlledCurrentPageRef = vue.computed(() => {
      const {
        pagination: pagination2
      } = props;
      if (pagination2 === false)
        return void 0;
      return pagination2.page;
    });
    const controlledPageSizeRef = vue.computed(() => {
      const {
        pagination: pagination2
      } = props;
      if (pagination2 === false)
        return void 0;
      return pagination2.pageSize;
    });
    const _mergedCurrentPageRef = useMergedState(controlledCurrentPageRef, uncontrolledCurrentPageRef);
    const mergedPageSizeRef = useMergedState(controlledPageSizeRef, uncontrolledPageSizeRef);
    const boundedMergedCurrentPageRef = useMemo(() => {
      const page2 = _mergedCurrentPageRef.value;
      return props.remote ? page2 : Math.max(1, Math.min(Math.ceil(filteredDataRef.value.length / mergedPageSizeRef.value), page2));
    });
    const mergedPageCountRef = vue.computed(() => {
      const {
        pagination: pagination2
      } = props;
      if (pagination2) {
        const {
          pageCount
        } = pagination2;
        if (pageCount !== void 0)
          return pageCount;
      }
      return void 0;
    });
    const paginatedDataRef = vue.computed(() => {
      if (props.remote)
        return treeMateRef.value.treeNodes;
      if (!props.pagination)
        return sortedDataRef.value;
      const pageSize = mergedPageSizeRef.value;
      const startIndex = (boundedMergedCurrentPageRef.value - 1) * pageSize;
      return sortedDataRef.value.slice(startIndex, startIndex + pageSize);
    });
    const rawPaginatedDataRef = vue.computed(() => {
      return paginatedDataRef.value.map((tmNode) => tmNode.rawNode);
    });
    function mergedOnUpdatePage(page2) {
      const {
        pagination: pagination2
      } = props;
      if (pagination2) {
        const {
          onChange,
          "onUpdate:page": _onUpdatePage,
          onUpdatePage
        } = pagination2;
        if (onChange)
          call(onChange, page2);
        if (onUpdatePage)
          call(onUpdatePage, page2);
        if (_onUpdatePage)
          call(_onUpdatePage, page2);
        doUpdatePage(page2);
      }
    }
    function mergedOnUpdatePageSize(pageSize) {
      const {
        pagination: pagination2
      } = props;
      if (pagination2) {
        const {
          onPageSizeChange,
          "onUpdate:pageSize": _onUpdatePageSize,
          onUpdatePageSize
        } = pagination2;
        if (onPageSizeChange)
          call(onPageSizeChange, pageSize);
        if (onUpdatePageSize)
          call(onUpdatePageSize, pageSize);
        if (_onUpdatePageSize)
          call(_onUpdatePageSize, pageSize);
        doUpdatePageSize(pageSize);
      }
    }
    const mergedItemCountRef = vue.computed(() => {
      if (props.remote) {
        const {
          pagination: pagination2
        } = props;
        if (pagination2) {
          const {
            itemCount
          } = pagination2;
          if (itemCount !== void 0)
            return itemCount;
        }
        return void 0;
      }
      return filteredDataRef.value.length;
    });
    const mergedPaginationRef = vue.computed(() => {
      return Object.assign(Object.assign({}, props.pagination), {
        // reset deprecated methods
        onChange: void 0,
        onUpdatePage: void 0,
        onUpdatePageSize: void 0,
        onPageSizeChange: void 0,
        "onUpdate:page": mergedOnUpdatePage,
        "onUpdate:pageSize": mergedOnUpdatePageSize,
        // writing merged props after pagination to avoid
        // pagination[key] === undefined
        // key still exists but value is undefined
        page: boundedMergedCurrentPageRef.value,
        pageSize: mergedPageSizeRef.value,
        pageCount: mergedItemCountRef.value === void 0 ? mergedPageCountRef.value : void 0,
        itemCount: mergedItemCountRef.value
      });
    });
    function doUpdatePage(page2) {
      const {
        "onUpdate:page": _onUpdatePage,
        onPageChange,
        onUpdatePage
      } = props;
      if (onUpdatePage)
        call(onUpdatePage, page2);
      if (_onUpdatePage)
        call(_onUpdatePage, page2);
      if (onPageChange)
        call(onPageChange, page2);
      uncontrolledCurrentPageRef.value = page2;
    }
    function doUpdatePageSize(pageSize) {
      const {
        "onUpdate:pageSize": _onUpdatePageSize,
        onPageSizeChange,
        onUpdatePageSize
      } = props;
      if (onPageSizeChange)
        call(onPageSizeChange, pageSize);
      if (onUpdatePageSize)
        call(onUpdatePageSize, pageSize);
      if (_onUpdatePageSize)
        call(_onUpdatePageSize, pageSize);
      uncontrolledPageSizeRef.value = pageSize;
    }
    function doUpdateFilters(filters2, sourceColumn) {
      const {
        onUpdateFilters,
        "onUpdate:filters": _onUpdateFilters,
        onFiltersChange
      } = props;
      if (onUpdateFilters)
        call(onUpdateFilters, filters2, sourceColumn);
      if (_onUpdateFilters)
        call(_onUpdateFilters, filters2, sourceColumn);
      if (onFiltersChange)
        call(onFiltersChange, filters2, sourceColumn);
      uncontrolledFilterStateRef.value = filters2;
    }
    function onUnstableColumnResize(resizedWidth, limitedWidth, column, getColumnWidth) {
      var _a;
      (_a = props.onUnstableColumnResize) === null || _a === void 0 ? void 0 : _a.call(props, resizedWidth, limitedWidth, column, getColumnWidth);
    }
    function page(page2) {
      doUpdatePage(page2);
    }
    function clearFilter() {
      clearFilters();
    }
    function clearFilters() {
      filters({});
    }
    function filters(filters2) {
      filter(filters2);
    }
    function filter(filters2) {
      if (!filters2) {
        uncontrolledFilterStateRef.value = {};
      } else if (filters2) {
        uncontrolledFilterStateRef.value = createShallowClonedObject(filters2);
      } else {
        warn$2("data-table", "`filters` is not an object");
      }
    }
    return {
      treeMateRef,
      mergedCurrentPageRef: boundedMergedCurrentPageRef,
      mergedPaginationRef,
      paginatedDataRef,
      rawPaginatedDataRef,
      mergedFilterStateRef,
      mergedSortStateRef,
      hoverKeyRef: vue.ref(null),
      selectionColumnRef,
      childTriggerColIndexRef,
      doUpdateFilters,
      deriveNextSorter,
      doUpdatePageSize,
      doUpdatePage,
      onUnstableColumnResize,
      // exported methods
      filter,
      filters,
      clearFilter,
      clearFilters,
      clearSorter,
      page,
      sort
    };
  }
  function useScroll(props, {
    mainTableInstRef,
    mergedCurrentPageRef,
    bodyWidthRef
  }) {
    let lastScrollLeft = 0;
    const scrollPartRef = vue.ref();
    const leftActiveFixedColKeyRef = vue.ref(null);
    const leftActiveFixedChildrenColKeysRef = vue.ref([]);
    const rightActiveFixedColKeyRef = vue.ref(null);
    const rightActiveFixedChildrenColKeysRef = vue.ref([]);
    const styleScrollXRef = vue.computed(() => {
      return formatLength(props.scrollX);
    });
    const leftFixedColumnsRef = vue.computed(() => {
      return props.columns.filter((column) => column.fixed === "left");
    });
    const rightFixedColumnsRef = vue.computed(() => {
      return props.columns.filter((column) => column.fixed === "right");
    });
    const fixedColumnLeftMapRef = vue.computed(() => {
      const columns = {};
      let left = 0;
      function traverse2(cols) {
        cols.forEach((col) => {
          const positionInfo = {
            start: left,
            end: 0
          };
          columns[getColKey(col)] = positionInfo;
          if ("children" in col) {
            traverse2(col.children);
            positionInfo.end = left;
          } else {
            left += getNumberColWidth(col) || 0;
            positionInfo.end = left;
          }
        });
      }
      traverse2(leftFixedColumnsRef.value);
      return columns;
    });
    const fixedColumnRightMapRef = vue.computed(() => {
      const columns = {};
      let right = 0;
      function traverse2(cols) {
        for (let i = cols.length - 1; i >= 0; --i) {
          const col = cols[i];
          const positionInfo = {
            start: right,
            end: 0
          };
          columns[getColKey(col)] = positionInfo;
          if ("children" in col) {
            traverse2(col.children);
            positionInfo.end = right;
          } else {
            right += getNumberColWidth(col) || 0;
            positionInfo.end = right;
          }
        }
      }
      traverse2(rightFixedColumnsRef.value);
      return columns;
    });
    function deriveActiveLeftFixedColumn() {
      var _a, _b;
      const {
        value: leftFixedColumns
      } = leftFixedColumnsRef;
      let leftWidth = 0;
      const {
        value: fixedColumnLeftMap
      } = fixedColumnLeftMapRef;
      let leftActiveFixedColKey = null;
      for (let i = 0; i < leftFixedColumns.length; ++i) {
        const key = getColKey(leftFixedColumns[i]);
        if (lastScrollLeft > (((_a = fixedColumnLeftMap[key]) === null || _a === void 0 ? void 0 : _a.start) || 0) - leftWidth) {
          leftActiveFixedColKey = key;
          leftWidth = ((_b = fixedColumnLeftMap[key]) === null || _b === void 0 ? void 0 : _b.end) || 0;
        } else {
          break;
        }
      }
      leftActiveFixedColKeyRef.value = leftActiveFixedColKey;
    }
    function deriveActiveLeftFixedChildrenColumns() {
      leftActiveFixedChildrenColKeysRef.value = [];
      let activeLeftFixedColumn = props.columns.find((col) => getColKey(col) === leftActiveFixedColKeyRef.value);
      while (activeLeftFixedColumn && "children" in activeLeftFixedColumn) {
        const length = activeLeftFixedColumn.children.length;
        if (length === 0)
          break;
        const nextActiveLeftFixedColumn = activeLeftFixedColumn.children[length - 1];
        leftActiveFixedChildrenColKeysRef.value.push(getColKey(nextActiveLeftFixedColumn));
        activeLeftFixedColumn = nextActiveLeftFixedColumn;
      }
    }
    function deriveActiveRightFixedColumn() {
      var _a, _b;
      const {
        value: rightFixedColumns
      } = rightFixedColumnsRef;
      const scrollWidth = Number(props.scrollX);
      const {
        value: tableWidth
      } = bodyWidthRef;
      if (tableWidth === null)
        return;
      let rightWidth = 0;
      let rightActiveFixedColKey = null;
      const {
        value: fixedColumnRightMap
      } = fixedColumnRightMapRef;
      for (let i = rightFixedColumns.length - 1; i >= 0; --i) {
        const key = getColKey(rightFixedColumns[i]);
        if (Math.round(lastScrollLeft + (((_a = fixedColumnRightMap[key]) === null || _a === void 0 ? void 0 : _a.start) || 0) + tableWidth - rightWidth) < scrollWidth) {
          rightActiveFixedColKey = key;
          rightWidth = ((_b = fixedColumnRightMap[key]) === null || _b === void 0 ? void 0 : _b.end) || 0;
        } else {
          break;
        }
      }
      rightActiveFixedColKeyRef.value = rightActiveFixedColKey;
    }
    function deriveActiveRightFixedChildrenColumns() {
      rightActiveFixedChildrenColKeysRef.value = [];
      let activeRightFixedColumn = props.columns.find((col) => getColKey(col) === rightActiveFixedColKeyRef.value);
      while (activeRightFixedColumn && "children" in activeRightFixedColumn && activeRightFixedColumn.children.length) {
        const nextActiveRightFixedColumn = activeRightFixedColumn.children[0];
        rightActiveFixedChildrenColKeysRef.value.push(getColKey(nextActiveRightFixedColumn));
        activeRightFixedColumn = nextActiveRightFixedColumn;
      }
    }
    function getScrollElements() {
      const header = mainTableInstRef.value ? mainTableInstRef.value.getHeaderElement() : null;
      const body = mainTableInstRef.value ? mainTableInstRef.value.getBodyElement() : null;
      return {
        header,
        body
      };
    }
    function scrollMainTableBodyToTop() {
      const {
        body
      } = getScrollElements();
      if (body) {
        body.scrollTop = 0;
      }
    }
    function handleTableHeaderScroll() {
      if (scrollPartRef.value !== "body") {
        beforeNextFrameOnce(syncScrollState);
      } else {
        scrollPartRef.value = void 0;
      }
    }
    function handleTableBodyScroll(e) {
      var _a;
      (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);
      if (scrollPartRef.value !== "head") {
        beforeNextFrameOnce(syncScrollState);
      } else {
        scrollPartRef.value = void 0;
      }
    }
    function syncScrollState() {
      const {
        header,
        body
      } = getScrollElements();
      if (!body)
        return;
      const {
        value: tableWidth
      } = bodyWidthRef;
      if (tableWidth === null)
        return;
      if (props.maxHeight || props.flexHeight) {
        if (!header)
          return;
        const directionHead = lastScrollLeft - header.scrollLeft;
        scrollPartRef.value = directionHead !== 0 ? "head" : "body";
        if (scrollPartRef.value === "head") {
          lastScrollLeft = header.scrollLeft;
          body.scrollLeft = lastScrollLeft;
        } else {
          lastScrollLeft = body.scrollLeft;
          header.scrollLeft = lastScrollLeft;
        }
      } else {
        lastScrollLeft = body.scrollLeft;
      }
      deriveActiveLeftFixedColumn();
      deriveActiveLeftFixedChildrenColumns();
      deriveActiveRightFixedColumn();
      deriveActiveRightFixedChildrenColumns();
    }
    function setHeaderScrollLeft(left) {
      const {
        header
      } = getScrollElements();
      if (!header)
        return;
      header.scrollLeft = left;
      syncScrollState();
    }
    vue.watch(mergedCurrentPageRef, () => {
      scrollMainTableBodyToTop();
    });
    return {
      styleScrollXRef,
      fixedColumnLeftMapRef,
      fixedColumnRightMapRef,
      leftFixedColumnsRef,
      rightFixedColumnsRef,
      leftActiveFixedColKeyRef,
      leftActiveFixedChildrenColKeysRef,
      rightActiveFixedColKeyRef,
      rightActiveFixedChildrenColKeysRef,
      syncScrollState,
      handleTableBodyScroll,
      handleTableHeaderScroll,
      setHeaderScrollLeft
    };
  }
  function useResizable() {
    const resizableWidthsRef = vue.ref({});
    function getResizableWidth(key) {
      return resizableWidthsRef.value[key];
    }
    function doUpdateResizableWidth(column, width) {
      if (isColumnResizable(column) && "key" in column) {
        resizableWidthsRef.value[column.key] = width;
      }
    }
    function clearResizableWidth() {
      resizableWidthsRef.value = {};
    }
    return {
      getResizableWidth,
      doUpdateResizableWidth,
      clearResizableWidth
    };
  }
  function getRowsAndCols(columns, getResizableWidth) {
    const rows = [];
    const cols = [];
    const dataRelatedCols = [];
    const rowItemMap = /* @__PURE__ */ new WeakMap();
    let maxDepth = -1;
    let totalRowSpan = 0;
    let hasEllipsis = false;
    function ensureMaxDepth(columns2, currentDepth) {
      if (currentDepth > maxDepth) {
        rows[currentDepth] = [];
        maxDepth = currentDepth;
      }
      columns2.forEach((column, index) => {
        if ("children" in column) {
          ensureMaxDepth(column.children, currentDepth + 1);
        } else {
          const key = "key" in column ? column.key : void 0;
          cols.push({
            key: getColKey(column),
            style: createCustomWidthStyle(column, key !== void 0 ? formatLength(getResizableWidth(key)) : void 0),
            column,
            index,
            // The width property is only applied to horizontally virtual scroll table
            width: column.width === void 0 ? 128 : Number(column.width)
          });
          totalRowSpan += 1;
          if (!hasEllipsis) {
            hasEllipsis = !!column.ellipsis;
          }
          dataRelatedCols.push(column);
        }
      });
    }
    ensureMaxDepth(columns, 0);
    let currentLeafIndex = 0;
    function ensureColLayout(columns2, currentDepth) {
      let hideUntilIndex = 0;
      columns2.forEach((column) => {
        var _a;
        if ("children" in column) {
          const cachedCurrentLeafIndex = currentLeafIndex;
          const rowItem = {
            column,
            colIndex: currentLeafIndex,
            colSpan: 0,
            rowSpan: 1,
            isLast: false
          };
          ensureColLayout(column.children, currentDepth + 1);
          column.children.forEach((childColumn) => {
            var _a2, _b;
            rowItem.colSpan += (_b = (_a2 = rowItemMap.get(childColumn)) === null || _a2 === void 0 ? void 0 : _a2.colSpan) !== null && _b !== void 0 ? _b : 0;
          });
          if (cachedCurrentLeafIndex + rowItem.colSpan === totalRowSpan) {
            rowItem.isLast = true;
          }
          rowItemMap.set(column, rowItem);
          rows[currentDepth].push(rowItem);
        } else {
          if (currentLeafIndex < hideUntilIndex) {
            currentLeafIndex += 1;
            return;
          }
          let colSpan = 1;
          if ("titleColSpan" in column) {
            colSpan = (_a = column.titleColSpan) !== null && _a !== void 0 ? _a : 1;
          }
          if (colSpan > 1) {
            hideUntilIndex = currentLeafIndex + colSpan;
          }
          const isLast = currentLeafIndex + colSpan === totalRowSpan;
          const rowItem = {
            column,
            colSpan,
            colIndex: currentLeafIndex,
            rowSpan: maxDepth - currentDepth + 1,
            isLast
          };
          rowItemMap.set(column, rowItem);
          rows[currentDepth].push(rowItem);
          currentLeafIndex += 1;
        }
      });
    }
    ensureColLayout(columns, 0);
    return {
      hasEllipsis,
      rows,
      cols,
      dataRelatedCols
    };
  }
  function useGroupHeader(props, getResizableWidth) {
    const rowsAndCols = vue.computed(() => getRowsAndCols(props.columns, getResizableWidth));
    return {
      rowsRef: vue.computed(() => rowsAndCols.value.rows),
      colsRef: vue.computed(() => rowsAndCols.value.cols),
      hasEllipsisRef: vue.computed(() => rowsAndCols.value.hasEllipsis),
      dataRelatedColsRef: vue.computed(() => rowsAndCols.value.dataRelatedCols)
    };
  }
  function useExpand(props, treeMateRef) {
    const renderExpandRef = useMemo(() => {
      for (const col of props.columns) {
        if (col.type === "expand") {
          if (!col.renderExpand) {
            warn$2("data-table", "column with type `expand` has no `renderExpand` prop.");
          }
          return col.renderExpand;
        }
      }
    });
    const expandableRef = useMemo(() => {
      let expandable;
      for (const col of props.columns) {
        if (col.type === "expand") {
          expandable = col.expandable;
          break;
        }
      }
      return expandable;
    });
    const uncontrolledExpandedRowKeysRef = vue.ref(props.defaultExpandAll ? (renderExpandRef === null || renderExpandRef === void 0 ? void 0 : renderExpandRef.value) ? (() => {
      const expandedKeys = [];
      treeMateRef.value.treeNodes.forEach((tmNode) => {
        var _a;
        if ((_a = expandableRef.value) === null || _a === void 0 ? void 0 : _a.call(expandableRef, tmNode.rawNode)) {
          expandedKeys.push(tmNode.key);
        }
      });
      return expandedKeys;
    })() : treeMateRef.value.getNonLeafKeys() : props.defaultExpandedRowKeys);
    const controlledExpandedRowKeysRef = vue.toRef(props, "expandedRowKeys");
    const stickyExpandedRowsRef = vue.toRef(props, "stickyExpandedRows");
    const mergedExpandedRowKeysRef = useMergedState(controlledExpandedRowKeysRef, uncontrolledExpandedRowKeysRef);
    function doUpdateExpandedRowKeys(expandedKeys) {
      const {
        onUpdateExpandedRowKeys,
        "onUpdate:expandedRowKeys": _onUpdateExpandedRowKeys
      } = props;
      if (onUpdateExpandedRowKeys) {
        call(onUpdateExpandedRowKeys, expandedKeys);
      }
      if (_onUpdateExpandedRowKeys) {
        call(_onUpdateExpandedRowKeys, expandedKeys);
      }
      uncontrolledExpandedRowKeysRef.value = expandedKeys;
    }
    return {
      stickyExpandedRowsRef,
      mergedExpandedRowKeysRef,
      renderExpandRef,
      expandableRef,
      doUpdateExpandedRowKeys
    };
  }
  const fixedColumnStyle = createFixedColumnStyle();
  const style$X = c$1([cB("data-table", `
 width: 100%;
 font-size: var(--n-font-size);
 display: flex;
 flex-direction: column;
 position: relative;
 --n-merged-th-color: var(--n-th-color);
 --n-merged-td-color: var(--n-td-color);
 --n-merged-border-color: var(--n-border-color);
 --n-merged-th-color-sorting: var(--n-th-color-sorting);
 --n-merged-td-color-hover: var(--n-td-color-hover);
 --n-merged-td-color-sorting: var(--n-td-color-sorting);
 --n-merged-td-color-striped: var(--n-td-color-striped);
 `, [cB("data-table-wrapper", `
 flex-grow: 1;
 display: flex;
 flex-direction: column;
 `), cM("flex-height", [c$1(">", [cB("data-table-wrapper", [c$1(">", [cB("data-table-base-table", `
 display: flex;
 flex-direction: column;
 flex-grow: 1;
 `, [c$1(">", [cB("data-table-base-table-body", "flex-basis: 0;", [
    // last-child means there is no empty icon
    // body is a scrollbar, we need to override height 100%
    c$1("&:last-child", "flex-grow: 1;")
  ])])])])])])]), c$1(">", [cB("data-table-loading-wrapper", `
 color: var(--n-loading-color);
 font-size: var(--n-loading-size);
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 transition: color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 justify-content: center;
 `, [fadeInScaleUpTransition({
    originalTransform: "translateX(-50%) translateY(-50%)"
  })])]), cB("data-table-expand-placeholder", `
 margin-right: 8px;
 display: inline-block;
 width: 16px;
 height: 1px;
 `), cB("data-table-indent", `
 display: inline-block;
 height: 1px;
 `), cB("data-table-expand-trigger", `
 display: inline-flex;
 margin-right: 8px;
 cursor: pointer;
 font-size: 16px;
 vertical-align: -0.2em;
 position: relative;
 width: 16px;
 height: 16px;
 color: var(--n-td-text-color);
 transition: color .3s var(--n-bezier);
 `, [cM("expanded", [cB("icon", "transform: rotate(90deg);", [iconSwitchTransition({
    originalTransform: "rotate(90deg)"
  })]), cB("base-icon", "transform: rotate(90deg);", [iconSwitchTransition({
    originalTransform: "rotate(90deg)"
  })])]), cB("base-loading", `
 color: var(--n-loading-color);
 transition: color .3s var(--n-bezier);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [iconSwitchTransition()]), cB("icon", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [iconSwitchTransition()]), cB("base-icon", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [iconSwitchTransition()])]), cB("data-table-thead", `
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-merged-th-color);
 `), cB("data-table-tr", `
 position: relative;
 box-sizing: border-box;
 background-clip: padding-box;
 transition: background-color .3s var(--n-bezier);
 `, [cB("data-table-expand", `
 position: sticky;
 left: 0;
 overflow: hidden;
 margin: calc(var(--n-th-padding) * -1);
 padding: var(--n-th-padding);
 box-sizing: border-box;
 `), cM("striped", "background-color: var(--n-merged-td-color-striped);", [cB("data-table-td", "background-color: var(--n-merged-td-color-striped);")]), cNotM("summary", [c$1("&:hover", "background-color: var(--n-merged-td-color-hover);", [c$1(">", [cB("data-table-td", "background-color: var(--n-merged-td-color-hover);")])])])]), cB("data-table-th", `
 padding: var(--n-th-padding);
 position: relative;
 text-align: start;
 box-sizing: border-box;
 background-color: var(--n-merged-th-color);
 border-color: var(--n-merged-border-color);
 border-bottom: 1px solid var(--n-merged-border-color);
 color: var(--n-th-text-color);
 transition:
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 font-weight: var(--n-th-font-weight);
 `, [cM("filterable", `
 padding-right: 36px;
 `, [cM("sortable", `
 padding-right: calc(var(--n-th-padding) + 36px);
 `)]), fixedColumnStyle, cM("selection", `
 padding: 0;
 text-align: center;
 line-height: 0;
 z-index: 3;
 `), cE("title-wrapper", `
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 max-width: 100%;
 `, [cE("title", `
 flex: 1;
 min-width: 0;
 `)]), cE("ellipsis", `
 display: inline-block;
 vertical-align: bottom;
 text-overflow: ellipsis;
 overflow: hidden;
 white-space: nowrap;
 max-width: 100%;
 `), cM("hover", `
 background-color: var(--n-merged-th-color-hover);
 `), cM("sorting", `
 background-color: var(--n-merged-th-color-sorting);
 `), cM("sortable", `
 cursor: pointer;
 `, [cE("ellipsis", `
 max-width: calc(100% - 18px);
 `), c$1("&:hover", `
 background-color: var(--n-merged-th-color-hover);
 `)]), cB("data-table-sorter", `
 height: var(--n-sorter-size);
 width: var(--n-sorter-size);
 margin-left: 4px;
 position: relative;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 vertical-align: -0.2em;
 color: var(--n-th-icon-color);
 transition: color .3s var(--n-bezier);
 `, [cB("base-icon", "transition: transform .3s var(--n-bezier)"), cM("desc", [cB("base-icon", `
 transform: rotate(0deg);
 `)]), cM("asc", [cB("base-icon", `
 transform: rotate(-180deg);
 `)]), cM("asc, desc", `
 color: var(--n-th-icon-color-active);
 `)]), cB("data-table-resize-button", `
 width: var(--n-resizable-container-size);
 position: absolute;
 top: 0;
 right: calc(var(--n-resizable-container-size) / 2);
 bottom: 0;
 cursor: col-resize;
 user-select: none;
 `, [c$1("&::after", `
 width: var(--n-resizable-size);
 height: 50%;
 position: absolute;
 top: 50%;
 left: calc(var(--n-resizable-container-size) / 2);
 bottom: 0;
 background-color: var(--n-merged-border-color);
 transform: translateY(-50%);
 transition: background-color .3s var(--n-bezier);
 z-index: 1;
 content: '';
 `), cM("active", [c$1("&::after", ` 
 background-color: var(--n-th-icon-color-active);
 `)]), c$1("&:hover::after", `
 background-color: var(--n-th-icon-color-active);
 `)]), cB("data-table-filter", `
 position: absolute;
 z-index: auto;
 right: 0;
 width: 36px;
 top: 0;
 bottom: 0;
 cursor: pointer;
 display: flex;
 justify-content: center;
 align-items: center;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 font-size: var(--n-filter-size);
 color: var(--n-th-icon-color);
 `, [c$1("&:hover", `
 background-color: var(--n-th-button-color-hover);
 `), cM("show", `
 background-color: var(--n-th-button-color-hover);
 `), cM("active", `
 background-color: var(--n-th-button-color-hover);
 color: var(--n-th-icon-color-active);
 `)])]), cB("data-table-td", `
 padding: var(--n-td-padding);
 text-align: start;
 box-sizing: border-box;
 border: none;
 background-color: var(--n-merged-td-color);
 color: var(--n-td-text-color);
 border-bottom: 1px solid var(--n-merged-border-color);
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `, [cM("expand", [cB("data-table-expand-trigger", `
 margin-right: 0;
 `)]), cM("last-row", `
 border-bottom: 0 solid var(--n-merged-border-color);
 `, [
    // make sure there is no overlap between bottom border and
    // fixed column box shadow
    c$1("&::after", `
 bottom: 0 !important;
 `),
    c$1("&::before", `
 bottom: 0 !important;
 `)
  ]), cM("summary", `
 background-color: var(--n-merged-th-color);
 `), cM("hover", `
 background-color: var(--n-merged-td-color-hover);
 `), cM("sorting", `
 background-color: var(--n-merged-td-color-sorting);
 `), cE("ellipsis", `
 display: inline-block;
 text-overflow: ellipsis;
 overflow: hidden;
 white-space: nowrap;
 max-width: 100%;
 vertical-align: bottom;
 max-width: calc(100% - var(--indent-offset, -1.5) * 16px - 24px);
 `), cM("selection, expand", `
 text-align: center;
 padding: 0;
 line-height: 0;
 `), fixedColumnStyle]), cB("data-table-empty", `
 box-sizing: border-box;
 padding: var(--n-empty-padding);
 flex-grow: 1;
 flex-shrink: 0;
 opacity: 1;
 display: flex;
 align-items: center;
 justify-content: center;
 transition: opacity .3s var(--n-bezier);
 `, [cM("hide", `
 opacity: 0;
 `)]), cE("pagination", `
 margin: var(--n-pagination-margin);
 display: flex;
 justify-content: flex-end;
 `), cB("data-table-wrapper", `
 position: relative;
 opacity: 1;
 transition: opacity .3s var(--n-bezier), border-color .3s var(--n-bezier);
 border-top-left-radius: var(--n-border-radius);
 border-top-right-radius: var(--n-border-radius);
 line-height: var(--n-line-height);
 `), cM("loading", [cB("data-table-wrapper", `
 opacity: var(--n-opacity-loading);
 pointer-events: none;
 `)]), cM("single-column", [cB("data-table-td", `
 border-bottom: 0 solid var(--n-merged-border-color);
 `, [c$1("&::after, &::before", `
 bottom: 0 !important;
 `)])]), cNotM("single-line", [cB("data-table-th", `
 border-right: 1px solid var(--n-merged-border-color);
 `, [cM("last", `
 border-right: 0 solid var(--n-merged-border-color);
 `)]), cB("data-table-td", `
 border-right: 1px solid var(--n-merged-border-color);
 `, [cM("last-col", `
 border-right: 0 solid var(--n-merged-border-color);
 `)])]), cM("bordered", [cB("data-table-wrapper", `
 border: 1px solid var(--n-merged-border-color);
 border-bottom-left-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 overflow: hidden;
 `)]), cB("data-table-base-table", [cM("transition-disabled", [cB("data-table-th", [c$1("&::after, &::before", "transition: none;")]), cB("data-table-td", [c$1("&::after, &::before", "transition: none;")])])]), cM("bottom-bordered", [cB("data-table-td", [cM("last-row", `
 border-bottom: 1px solid var(--n-merged-border-color);
 `)])]), cB("data-table-table", `
 font-variant-numeric: tabular-nums;
 width: 100%;
 word-break: break-word;
 transition: background-color .3s var(--n-bezier);
 border-collapse: separate;
 border-spacing: 0;
 background-color: var(--n-merged-td-color);
 `), cB("data-table-base-table-header", `
 border-top-left-radius: calc(var(--n-border-radius) - 1px);
 border-top-right-radius: calc(var(--n-border-radius) - 1px);
 z-index: 3;
 overflow: scroll;
 flex-shrink: 0;
 transition: border-color .3s var(--n-bezier);
 scrollbar-width: none;
 `, [c$1("&::-webkit-scrollbar", `
 width: 0;
 height: 0;
 `)]), cB("data-table-check-extra", `
 transition: color .3s var(--n-bezier);
 color: var(--n-th-icon-color);
 position: absolute;
 font-size: 14px;
 right: -4px;
 top: 50%;
 transform: translateY(-50%);
 z-index: 1;
 `)]), cB("data-table-filter-menu", [cB("scrollbar", `
 max-height: 240px;
 `), cE("group", `
 display: flex;
 flex-direction: column;
 padding: 12px 12px 0 12px;
 `, [cB("checkbox", `
 margin-bottom: 12px;
 margin-right: 0;
 `), cB("radio", `
 margin-bottom: 12px;
 margin-right: 0;
 `)]), cE("action", `
 padding: var(--n-action-padding);
 display: flex;
 flex-wrap: nowrap;
 justify-content: space-evenly;
 border-top: 1px solid var(--n-action-divider-color);
 `, [cB("button", [c$1("&:not(:last-child)", `
 margin: var(--n-action-button-margin);
 `), c$1("&:last-child", `
 margin-right: 0;
 `)])]), cB("divider", `
 margin: 0 !important;
 `)]), insideModal(cB("data-table", `
 --n-merged-th-color: var(--n-th-color-modal);
 --n-merged-td-color: var(--n-td-color-modal);
 --n-merged-border-color: var(--n-border-color-modal);
 --n-merged-th-color-hover: var(--n-th-color-hover-modal);
 --n-merged-td-color-hover: var(--n-td-color-hover-modal);
 --n-merged-th-color-sorting: var(--n-th-color-hover-modal);
 --n-merged-td-color-sorting: var(--n-td-color-hover-modal);
 --n-merged-td-color-striped: var(--n-td-color-striped-modal);
 `)), insidePopover(cB("data-table", `
 --n-merged-th-color: var(--n-th-color-popover);
 --n-merged-td-color: var(--n-td-color-popover);
 --n-merged-border-color: var(--n-border-color-popover);
 --n-merged-th-color-hover: var(--n-th-color-hover-popover);
 --n-merged-td-color-hover: var(--n-td-color-hover-popover);
 --n-merged-th-color-sorting: var(--n-th-color-hover-popover);
 --n-merged-td-color-sorting: var(--n-td-color-hover-popover);
 --n-merged-td-color-striped: var(--n-td-color-striped-popover);
 `))]);
  function createFixedColumnStyle() {
    return [cM("fixed-left", `
 left: 0;
 position: sticky;
 z-index: 2;
 `, [c$1("&::after", `
 pointer-events: none;
 content: "";
 width: 36px;
 display: inline-block;
 position: absolute;
 top: 0;
 bottom: -1px;
 transition: box-shadow .2s var(--n-bezier);
 right: -36px;
 `)]), cM("fixed-right", `
 right: 0;
 position: sticky;
 z-index: 1;
 `, [c$1("&::before", `
 pointer-events: none;
 content: "";
 width: 36px;
 display: inline-block;
 position: absolute;
 top: 0;
 bottom: -1px;
 transition: box-shadow .2s var(--n-bezier);
 left: -36px;
 `)])];
  }
  const DataTable = vue.defineComponent({
    name: "DataTable",
    alias: ["AdvancedTable"],
    props: dataTableProps,
    setup(props, {
      slots
    }) {
      {
        vue.watchEffect(() => {
          if (props.onPageChange !== void 0) {
            warnOnce("data-table", "`on-page-change` is deprecated, please use `on-update:page` instead.");
          }
          if (props.onPageSizeChange !== void 0) {
            warnOnce("data-table", "`on-page-size-change` is deprecated, please use `on-update:page-size` instead.");
          }
          if (props.onSorterChange !== void 0) {
            warnOnce("data-table", "`on-sorter-change` is deprecated, please use `on-update:sorter` instead.");
          }
          if (props.onFiltersChange !== void 0) {
            warnOnce("data-table", "`on-filters-change` is deprecated, please use `on-update:filters` instead.");
          }
          if (props.onCheckedRowKeysChange !== void 0) {
            warnOnce("data-table", "`on-checked-row-keys-change` is deprecated, please use `on-update:checked-row-keys` instead.");
          }
        });
      }
      const {
        mergedBorderedRef,
        mergedClsPrefixRef,
        inlineThemeDisabled,
        mergedRtlRef
      } = useConfig(props);
      const rtlEnabledRef = useRtl("DataTable", mergedRtlRef, mergedClsPrefixRef);
      const mergedBottomBorderedRef = vue.computed(() => {
        const {
          bottomBordered
        } = props;
        if (mergedBorderedRef.value)
          return false;
        if (bottomBordered !== void 0)
          return bottomBordered;
        return true;
      });
      const themeRef = useTheme("DataTable", "-data-table", style$X, dataTableLight$1, props, mergedClsPrefixRef);
      const bodyWidthRef = vue.ref(null);
      const mainTableInstRef = vue.ref(null);
      const {
        getResizableWidth,
        clearResizableWidth,
        doUpdateResizableWidth
      } = useResizable();
      const {
        rowsRef,
        colsRef,
        dataRelatedColsRef,
        hasEllipsisRef
      } = useGroupHeader(props, getResizableWidth);
      const {
        treeMateRef,
        mergedCurrentPageRef,
        paginatedDataRef,
        rawPaginatedDataRef,
        selectionColumnRef,
        hoverKeyRef,
        mergedPaginationRef,
        mergedFilterStateRef,
        mergedSortStateRef,
        childTriggerColIndexRef,
        doUpdatePage,
        doUpdateFilters,
        onUnstableColumnResize,
        deriveNextSorter,
        filter,
        filters,
        clearFilter,
        clearFilters,
        clearSorter,
        page,
        sort
      } = useTableData(props, {
        dataRelatedColsRef
      });
      const downloadCsv = (options) => {
        const {
          fileName = "data.csv",
          keepOriginalData = false
        } = options || {};
        const data = keepOriginalData ? props.data : rawPaginatedDataRef.value;
        const csvData = generateCsv(props.columns, data);
        const blob = new Blob([csvData], {
          type: "text/csv;charset=utf-8"
        });
        const downloadUrl = URL.createObjectURL(blob);
        download(downloadUrl, fileName.endsWith(".csv") ? fileName : `${fileName}.csv`);
        URL.revokeObjectURL(downloadUrl);
      };
      const {
        doCheckAll,
        doUncheckAll,
        doCheck,
        doUncheck,
        headerCheckboxDisabledRef,
        someRowsCheckedRef,
        allRowsCheckedRef,
        mergedCheckedRowKeySetRef,
        mergedInderminateRowKeySetRef
      } = useCheck(props, {
        selectionColumnRef,
        treeMateRef,
        paginatedDataRef
      });
      const {
        stickyExpandedRowsRef,
        mergedExpandedRowKeysRef,
        renderExpandRef,
        expandableRef,
        doUpdateExpandedRowKeys
      } = useExpand(props, treeMateRef);
      const {
        handleTableBodyScroll,
        handleTableHeaderScroll,
        syncScrollState,
        setHeaderScrollLeft,
        leftActiveFixedColKeyRef,
        leftActiveFixedChildrenColKeysRef,
        rightActiveFixedColKeyRef,
        rightActiveFixedChildrenColKeysRef,
        leftFixedColumnsRef,
        rightFixedColumnsRef,
        fixedColumnLeftMapRef,
        fixedColumnRightMapRef
      } = useScroll(props, {
        bodyWidthRef,
        mainTableInstRef,
        mergedCurrentPageRef
      });
      const {
        localeRef
      } = useLocale("DataTable");
      const mergedTableLayoutRef = vue.computed(() => {
        if (props.virtualScroll || props.flexHeight || props.maxHeight !== void 0 || hasEllipsisRef.value) {
          return "fixed";
        }
        return props.tableLayout;
      });
      vue.provide(dataTableInjectionKey, {
        props,
        treeMateRef,
        renderExpandIconRef: vue.toRef(props, "renderExpandIcon"),
        loadingKeySetRef: vue.ref(/* @__PURE__ */ new Set()),
        slots,
        indentRef: vue.toRef(props, "indent"),
        childTriggerColIndexRef,
        bodyWidthRef,
        componentId: createId(),
        hoverKeyRef,
        mergedClsPrefixRef,
        mergedThemeRef: themeRef,
        scrollXRef: vue.computed(() => props.scrollX),
        rowsRef,
        colsRef,
        paginatedDataRef,
        leftActiveFixedColKeyRef,
        leftActiveFixedChildrenColKeysRef,
        rightActiveFixedColKeyRef,
        rightActiveFixedChildrenColKeysRef,
        leftFixedColumnsRef,
        rightFixedColumnsRef,
        fixedColumnLeftMapRef,
        fixedColumnRightMapRef,
        mergedCurrentPageRef,
        someRowsCheckedRef,
        allRowsCheckedRef,
        mergedSortStateRef,
        mergedFilterStateRef,
        loadingRef: vue.toRef(props, "loading"),
        rowClassNameRef: vue.toRef(props, "rowClassName"),
        mergedCheckedRowKeySetRef,
        mergedExpandedRowKeysRef,
        mergedInderminateRowKeySetRef,
        localeRef,
        expandableRef,
        stickyExpandedRowsRef,
        rowKeyRef: vue.toRef(props, "rowKey"),
        renderExpandRef,
        summaryRef: vue.toRef(props, "summary"),
        virtualScrollRef: vue.toRef(props, "virtualScroll"),
        virtualScrollXRef: vue.toRef(props, "virtualScrollX"),
        heightForRowRef: vue.toRef(props, "heightForRow"),
        minRowHeightRef: vue.toRef(props, "minRowHeight"),
        virtualScrollHeaderRef: vue.toRef(props, "virtualScrollHeader"),
        headerHeightRef: vue.toRef(props, "headerHeight"),
        rowPropsRef: vue.toRef(props, "rowProps"),
        stripedRef: vue.toRef(props, "striped"),
        checkOptionsRef: vue.computed(() => {
          const {
            value: selectionColumn
          } = selectionColumnRef;
          return selectionColumn === null || selectionColumn === void 0 ? void 0 : selectionColumn.options;
        }),
        rawPaginatedDataRef,
        filterMenuCssVarsRef: vue.computed(() => {
          const {
            self: {
              actionDividerColor,
              actionPadding,
              actionButtonMargin
            }
          } = themeRef.value;
          return {
            "--n-action-padding": actionPadding,
            "--n-action-button-margin": actionButtonMargin,
            "--n-action-divider-color": actionDividerColor
          };
        }),
        onLoadRef: vue.toRef(props, "onLoad"),
        mergedTableLayoutRef,
        maxHeightRef: vue.toRef(props, "maxHeight"),
        minHeightRef: vue.toRef(props, "minHeight"),
        flexHeightRef: vue.toRef(props, "flexHeight"),
        headerCheckboxDisabledRef,
        paginationBehaviorOnFilterRef: vue.toRef(props, "paginationBehaviorOnFilter"),
        summaryPlacementRef: vue.toRef(props, "summaryPlacement"),
        filterIconPopoverPropsRef: vue.toRef(props, "filterIconPopoverProps"),
        scrollbarPropsRef: vue.toRef(props, "scrollbarProps"),
        syncScrollState,
        doUpdatePage,
        doUpdateFilters,
        getResizableWidth,
        onUnstableColumnResize,
        clearResizableWidth,
        doUpdateResizableWidth,
        deriveNextSorter,
        doCheck,
        doUncheck,
        doCheckAll,
        doUncheckAll,
        doUpdateExpandedRowKeys,
        handleTableHeaderScroll,
        handleTableBodyScroll,
        setHeaderScrollLeft,
        renderCell: vue.toRef(props, "renderCell")
      });
      const exposedMethods = {
        filter,
        filters,
        clearFilters,
        clearSorter,
        page,
        sort,
        clearFilter,
        downloadCsv,
        scrollTo: (arg0, arg1) => {
          var _a;
          (_a = mainTableInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(arg0, arg1);
        }
      };
      const cssVarsRef = vue.computed(() => {
        const {
          size: size2
        } = props;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            borderColor,
            tdColorHover,
            tdColorSorting,
            tdColorSortingModal,
            tdColorSortingPopover,
            thColorSorting,
            thColorSortingModal,
            thColorSortingPopover,
            thColor,
            thColorHover,
            tdColor,
            tdTextColor,
            thTextColor,
            thFontWeight,
            thButtonColorHover,
            thIconColor,
            thIconColorActive,
            filterSize,
            borderRadius,
            lineHeight: lineHeight2,
            tdColorModal,
            thColorModal,
            borderColorModal,
            thColorHoverModal,
            tdColorHoverModal,
            borderColorPopover,
            thColorPopover,
            tdColorPopover,
            tdColorHoverPopover,
            thColorHoverPopover,
            paginationMargin,
            emptyPadding,
            boxShadowAfter,
            boxShadowBefore,
            sorterSize,
            resizableContainerSize,
            resizableSize,
            loadingColor,
            loadingSize,
            opacityLoading,
            tdColorStriped,
            tdColorStripedModal,
            tdColorStripedPopover,
            [createKey("fontSize", size2)]: fontSize2,
            [createKey("thPadding", size2)]: thPadding,
            [createKey("tdPadding", size2)]: tdPadding
          }
        } = themeRef.value;
        return {
          "--n-font-size": fontSize2,
          "--n-th-padding": thPadding,
          "--n-td-padding": tdPadding,
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-border-radius": borderRadius,
          "--n-line-height": lineHeight2,
          "--n-border-color": borderColor,
          "--n-border-color-modal": borderColorModal,
          "--n-border-color-popover": borderColorPopover,
          "--n-th-color": thColor,
          "--n-th-color-hover": thColorHover,
          "--n-th-color-modal": thColorModal,
          "--n-th-color-hover-modal": thColorHoverModal,
          "--n-th-color-popover": thColorPopover,
          "--n-th-color-hover-popover": thColorHoverPopover,
          "--n-td-color": tdColor,
          "--n-td-color-hover": tdColorHover,
          "--n-td-color-modal": tdColorModal,
          "--n-td-color-hover-modal": tdColorHoverModal,
          "--n-td-color-popover": tdColorPopover,
          "--n-td-color-hover-popover": tdColorHoverPopover,
          "--n-th-text-color": thTextColor,
          "--n-td-text-color": tdTextColor,
          "--n-th-font-weight": thFontWeight,
          "--n-th-button-color-hover": thButtonColorHover,
          "--n-th-icon-color": thIconColor,
          "--n-th-icon-color-active": thIconColorActive,
          "--n-filter-size": filterSize,
          "--n-pagination-margin": paginationMargin,
          "--n-empty-padding": emptyPadding,
          "--n-box-shadow-before": boxShadowBefore,
          "--n-box-shadow-after": boxShadowAfter,
          "--n-sorter-size": sorterSize,
          "--n-resizable-container-size": resizableContainerSize,
          "--n-resizable-size": resizableSize,
          "--n-loading-size": loadingSize,
          "--n-loading-color": loadingColor,
          "--n-opacity-loading": opacityLoading,
          "--n-td-color-striped": tdColorStriped,
          "--n-td-color-striped-modal": tdColorStripedModal,
          "--n-td-color-striped-popover": tdColorStripedPopover,
          "n-td-color-sorting": tdColorSorting,
          "n-td-color-sorting-modal": tdColorSortingModal,
          "n-td-color-sorting-popover": tdColorSortingPopover,
          "n-th-color-sorting": thColorSorting,
          "n-th-color-sorting-modal": thColorSortingModal,
          "n-th-color-sorting-popover": thColorSortingPopover
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("data-table", vue.computed(() => props.size[0]), cssVarsRef, props) : void 0;
      const mergedShowPaginationRef = vue.computed(() => {
        if (!props.pagination)
          return false;
        if (props.paginateSinglePage)
          return true;
        const mergedPagination = mergedPaginationRef.value;
        const {
          pageCount
        } = mergedPagination;
        if (pageCount !== void 0)
          return pageCount > 1;
        return mergedPagination.itemCount && mergedPagination.pageSize && mergedPagination.itemCount > mergedPagination.pageSize;
      });
      return Object.assign({
        mainTableInstRef,
        mergedClsPrefix: mergedClsPrefixRef,
        rtlEnabled: rtlEnabledRef,
        mergedTheme: themeRef,
        paginatedData: paginatedDataRef,
        mergedBordered: mergedBorderedRef,
        mergedBottomBordered: mergedBottomBorderedRef,
        mergedPagination: mergedPaginationRef,
        mergedShowPagination: mergedShowPaginationRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      }, exposedMethods);
    },
    render() {
      const {
        mergedClsPrefix,
        themeClass,
        onRender,
        $slots,
        spinProps: spinProps2
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h("div", {
        class: [`${mergedClsPrefix}-data-table`, this.rtlEnabled && `${mergedClsPrefix}-data-table--rtl`, themeClass, {
          [`${mergedClsPrefix}-data-table--bordered`]: this.mergedBordered,
          [`${mergedClsPrefix}-data-table--bottom-bordered`]: this.mergedBottomBordered,
          [`${mergedClsPrefix}-data-table--single-line`]: this.singleLine,
          [`${mergedClsPrefix}-data-table--single-column`]: this.singleColumn,
          [`${mergedClsPrefix}-data-table--loading`]: this.loading,
          [`${mergedClsPrefix}-data-table--flex-height`]: this.flexHeight
        }],
        style: this.cssVars
      }, vue.h("div", {
        class: `${mergedClsPrefix}-data-table-wrapper`
      }, vue.h(MainTable, {
        ref: "mainTableInstRef"
      })), this.mergedShowPagination ? vue.h("div", {
        class: `${mergedClsPrefix}-data-table__pagination`
      }, vue.h(NPagination, Object.assign({
        theme: this.mergedTheme.peers.Pagination,
        themeOverrides: this.mergedTheme.peerOverrides.Pagination,
        disabled: this.loading
      }, this.mergedPagination))) : null, vue.h(vue.Transition, {
        name: "fade-in-scale-up-transition"
      }, {
        default: () => {
          return this.loading ? vue.h("div", {
            class: `${mergedClsPrefix}-data-table-loading-wrapper`
          }, resolveSlot($slots.loading, () => [vue.h(NBaseLoading, Object.assign({
            clsPrefix: mergedClsPrefix,
            strokeWidth: 20
          }, spinProps2))])) : null;
        }
      }));
    }
  });
  const commonVars$8 = {
    itemFontSize: "12px",
    itemHeight: "36px",
    itemWidth: "52px",
    panelActionPadding: "8px 0"
  };
  function self$M(vars) {
    const {
      popoverColor,
      textColor2,
      primaryColor,
      hoverColor,
      dividerColor,
      opacityDisabled,
      boxShadow2,
      borderRadius,
      iconColor,
      iconColorDisabled
    } = vars;
    return Object.assign(Object.assign({}, commonVars$8), {
      panelColor: popoverColor,
      panelBoxShadow: boxShadow2,
      panelDividerColor: dividerColor,
      itemTextColor: textColor2,
      itemTextColorActive: primaryColor,
      itemColorHover: hoverColor,
      itemOpacityDisabled: opacityDisabled,
      itemBorderRadius: borderRadius,
      borderRadius,
      iconColor,
      iconColorDisabled
    });
  }
  const timePickerLight = createTheme({
    name: "TimePicker",
    common: commonLight,
    peers: {
      Scrollbar: scrollbarLight$1,
      Button: buttonLight$1,
      Input: inputLight$1
    },
    self: self$M
  });
  const timePickerLight$1 = timePickerLight;
  const commonVars$7 = {
    itemSize: "24px",
    itemCellWidth: "38px",
    itemCellHeight: "32px",
    scrollItemWidth: "80px",
    scrollItemHeight: "40px",
    panelExtraFooterPadding: "8px 12px",
    panelActionPadding: "8px 12px",
    calendarTitlePadding: "0",
    calendarTitleHeight: "28px",
    arrowSize: "14px",
    panelHeaderPadding: "8px 12px",
    calendarDaysHeight: "32px",
    calendarTitleGridTempateColumns: "28px 28px 1fr 28px 28px",
    // type
    calendarLeftPaddingDate: "6px 12px 4px 12px",
    calendarLeftPaddingDatetime: "4px 12px",
    calendarLeftPaddingDaterange: "6px 12px 4px 12px",
    calendarLeftPaddingDatetimerange: "4px 12px",
    calendarLeftPaddingMonth: "0",
    // TODO: make it actually effective
    calendarLeftPaddingYear: "0",
    calendarLeftPaddingQuarter: "0",
    calendarLeftPaddingMonthrange: "0",
    calendarLeftPaddingQuarterrange: "0",
    calendarLeftPaddingYearrange: "0",
    calendarLeftPaddingWeek: "6px 12px 4px 12px",
    calendarRightPaddingDate: "6px 12px 4px 12px",
    calendarRightPaddingDatetime: "4px 12px",
    calendarRightPaddingDaterange: "6px 12px 4px 12px",
    calendarRightPaddingDatetimerange: "4px 12px",
    calendarRightPaddingMonth: "0",
    calendarRightPaddingYear: "0",
    calendarRightPaddingQuarter: "0",
    calendarRightPaddingMonthrange: "0",
    calendarRightPaddingQuarterrange: "0",
    calendarRightPaddingYearrange: "0",
    calendarRightPaddingWeek: "0"
  };
  function self$L(vars) {
    const {
      hoverColor,
      fontSize: fontSize2,
      textColor2,
      textColorDisabled,
      popoverColor,
      primaryColor,
      borderRadiusSmall,
      iconColor,
      iconColorDisabled,
      textColor1,
      dividerColor,
      boxShadow2,
      borderRadius,
      fontWeightStrong
    } = vars;
    return Object.assign(Object.assign({}, commonVars$7), {
      itemFontSize: fontSize2,
      calendarDaysFontSize: fontSize2,
      calendarTitleFontSize: fontSize2,
      itemTextColor: textColor2,
      itemTextColorDisabled: textColorDisabled,
      itemTextColorActive: popoverColor,
      itemTextColorCurrent: primaryColor,
      itemColorIncluded: changeColor(primaryColor, {
        alpha: 0.1
      }),
      itemColorHover: hoverColor,
      itemColorDisabled: hoverColor,
      itemColorActive: primaryColor,
      itemBorderRadius: borderRadiusSmall,
      panelColor: popoverColor,
      panelTextColor: textColor2,
      arrowColor: iconColor,
      calendarTitleTextColor: textColor1,
      calendarTitleColorHover: hoverColor,
      calendarDaysTextColor: textColor2,
      panelHeaderDividerColor: dividerColor,
      calendarDaysDividerColor: dividerColor,
      calendarDividerColor: dividerColor,
      panelActionDividerColor: dividerColor,
      panelBoxShadow: boxShadow2,
      panelBorderRadius: borderRadius,
      calendarTitleFontWeight: fontWeightStrong,
      scrollItemBorderRadius: borderRadius,
      iconColor,
      iconColorDisabled
    });
  }
  const datePickerLight = createTheme({
    name: "DatePicker",
    common: commonLight,
    peers: {
      Input: inputLight$1,
      Button: buttonLight$1,
      TimePicker: timePickerLight$1,
      Scrollbar: scrollbarLight$1
    },
    self: self$L
  });
  const datePickerLight$1 = datePickerLight;
  function uniCalendarValidation(props, mergedValueRef) {
    const timePickerValidatorRef = vue.computed(() => {
      const {
        isTimeDisabled
      } = props;
      const {
        value
      } = mergedValueRef;
      if (value === null || Array.isArray(value))
        return void 0;
      return isTimeDisabled === null || isTimeDisabled === void 0 ? void 0 : isTimeDisabled(value);
    });
    const isHourDisabledRef = vue.computed(() => {
      var _a;
      return (_a = timePickerValidatorRef.value) === null || _a === void 0 ? void 0 : _a.isHourDisabled;
    });
    const isMinuteDisabledRef = vue.computed(() => {
      var _a;
      return (_a = timePickerValidatorRef.value) === null || _a === void 0 ? void 0 : _a.isMinuteDisabled;
    });
    const isSecondDisabledRef = vue.computed(() => {
      var _a;
      return (_a = timePickerValidatorRef.value) === null || _a === void 0 ? void 0 : _a.isSecondDisabled;
    });
    const isDateInvalidRef = vue.computed(() => {
      const {
        type,
        isDateDisabled
      } = props;
      const {
        value
      } = mergedValueRef;
      if (value === null || Array.isArray(value) || !["date", "datetime"].includes(type) || !isDateDisabled) {
        return false;
      }
      return isDateDisabled(value, {
        type: "input"
      });
    });
    const isTimeInvalidRef = vue.computed(() => {
      const {
        type
      } = props;
      const {
        value
      } = mergedValueRef;
      if (value === null || !(type !== "datetime") || Array.isArray(value)) {
        return false;
      }
      const time2 = new Date(value);
      const hour = time2.getHours();
      const minute = time2.getMinutes();
      const second = time2.getMinutes();
      return (isHourDisabledRef.value ? isHourDisabledRef.value(hour) : false) || (isMinuteDisabledRef.value ? isMinuteDisabledRef.value(minute, hour) : false) || (isSecondDisabledRef.value ? isSecondDisabledRef.value(second, minute, hour) : false);
    });
    const isDateTimeInvalidRef = vue.computed(() => {
      return isDateInvalidRef.value || isTimeInvalidRef.value;
    });
    const isValueInvalidRef = vue.computed(() => {
      const {
        type
      } = props;
      if (type === "date")
        return isDateInvalidRef.value;
      if (type === "datetime")
        return isDateTimeInvalidRef.value;
      return false;
    });
    return {
      // date & datetime
      isValueInvalidRef,
      isDateInvalidRef,
      // datetime only
      isTimeInvalidRef,
      isDateTimeInvalidRef,
      isHourDisabledRef,
      isMinuteDisabledRef,
      isSecondDisabledRef
    };
  }
  function dualCalendarValidation(props, mergedValueRef) {
    const timePickerValidatorRef = vue.computed(() => {
      const {
        isTimeDisabled
      } = props;
      const {
        value
      } = mergedValueRef;
      if (!Array.isArray(value) || !isTimeDisabled) {
        return [void 0, void 0];
      }
      return [isTimeDisabled === null || isTimeDisabled === void 0 ? void 0 : isTimeDisabled(value[0], "start", value), isTimeDisabled === null || isTimeDisabled === void 0 ? void 0 : isTimeDisabled(value[1], "end", value)];
    });
    const timeValidator = {
      isStartHourDisabledRef: vue.computed(() => {
        var _a;
        return (_a = timePickerValidatorRef.value[0]) === null || _a === void 0 ? void 0 : _a.isHourDisabled;
      }),
      isEndHourDisabledRef: vue.computed(() => {
        var _a;
        return (_a = timePickerValidatorRef.value[1]) === null || _a === void 0 ? void 0 : _a.isHourDisabled;
      }),
      isStartMinuteDisabledRef: vue.computed(() => {
        var _a;
        return (_a = timePickerValidatorRef.value[0]) === null || _a === void 0 ? void 0 : _a.isMinuteDisabled;
      }),
      isEndMinuteDisabledRef: vue.computed(() => {
        var _a;
        return (_a = timePickerValidatorRef.value[1]) === null || _a === void 0 ? void 0 : _a.isMinuteDisabled;
      }),
      isStartSecondDisabledRef: vue.computed(() => {
        var _a;
        return (_a = timePickerValidatorRef.value[0]) === null || _a === void 0 ? void 0 : _a.isSecondDisabled;
      }),
      isEndSecondDisabledRef: vue.computed(() => {
        var _a;
        return (_a = timePickerValidatorRef.value[1]) === null || _a === void 0 ? void 0 : _a.isSecondDisabled;
      })
    };
    const isStartDateInvalidRef = vue.computed(() => {
      const {
        type,
        isDateDisabled
      } = props;
      const {
        value
      } = mergedValueRef;
      if (value === null || !Array.isArray(value) || !["daterange", "datetimerange"].includes(type) || !isDateDisabled) {
        return false;
      }
      return isDateDisabled(value[0], "start", value);
    });
    const isEndDateInvalidRef = vue.computed(() => {
      const {
        type,
        isDateDisabled
      } = props;
      const {
        value
      } = mergedValueRef;
      if (value === null || !Array.isArray(value) || !["daterange", "datetimerange"].includes(type) || !isDateDisabled) {
        return false;
      }
      return isDateDisabled(value[1], "end", value);
    });
    const isStartTimeInvalidRef = vue.computed(() => {
      const {
        type
      } = props;
      const {
        value
      } = mergedValueRef;
      if (value === null || !Array.isArray(value) || type !== "datetimerange") {
        return false;
      }
      const startHours = getHours(value[0]);
      const startMinutes = getMinutes(value[0]);
      const startSeconds = getSeconds(value[0]);
      const {
        isStartHourDisabledRef,
        isStartMinuteDisabledRef,
        isStartSecondDisabledRef
      } = timeValidator;
      const startTimeInvalid = (isStartHourDisabledRef.value ? isStartHourDisabledRef.value(startHours) : false) || (isStartMinuteDisabledRef.value ? isStartMinuteDisabledRef.value(startMinutes, startHours) : false) || (isStartSecondDisabledRef.value ? isStartSecondDisabledRef.value(startSeconds, startMinutes, startHours) : false);
      return startTimeInvalid;
    });
    const isEndTimeInvalidRef = vue.computed(() => {
      const {
        type
      } = props;
      const {
        value
      } = mergedValueRef;
      if (value === null || !Array.isArray(value) || type !== "datetimerange") {
        return false;
      }
      const endHours = getHours(value[1]);
      const endMinutes = getMinutes(value[1]);
      const endSeconds = getSeconds(value[1]);
      const {
        isEndHourDisabledRef,
        isEndMinuteDisabledRef,
        isEndSecondDisabledRef
      } = timeValidator;
      const endTimeInvalid = (isEndHourDisabledRef.value ? isEndHourDisabledRef.value(endHours) : false) || (isEndMinuteDisabledRef.value ? isEndMinuteDisabledRef.value(endMinutes, endHours) : false) || (isEndSecondDisabledRef.value ? isEndSecondDisabledRef.value(endSeconds, endMinutes, endHours) : false);
      return endTimeInvalid;
    });
    const isStartValueInvalidRef = vue.computed(() => {
      return isStartDateInvalidRef.value || isStartTimeInvalidRef.value;
    });
    const isEndValueInvalidRef = vue.computed(() => {
      return isEndDateInvalidRef.value || isEndTimeInvalidRef.value;
    });
    const isRangeInvalidRef = vue.computed(() => {
      return isStartValueInvalidRef.value || isEndValueInvalidRef.value;
    });
    return Object.assign(Object.assign({}, timeValidator), {
      isStartDateInvalidRef,
      isEndDateInvalidRef,
      isStartTimeInvalidRef,
      isEndTimeInvalidRef,
      isStartValueInvalidRef,
      isEndValueInvalidRef,
      isRangeInvalidRef
    });
  }
  const datePickerInjectionKey = createInjectionKey("n-date-picker");
  function tzIntlTimeZoneName(length, date, options) {
    const defaultOptions2 = getDefaultOptions();
    const dtf = getDTF(length, options.timeZone, options.locale ?? defaultOptions2.locale);
    return "formatToParts" in dtf ? partsTimeZone(dtf, date) : hackyTimeZone(dtf, date);
  }
  function partsTimeZone(dtf, date) {
    const formatted = dtf.formatToParts(date);
    for (let i = formatted.length - 1; i >= 0; --i) {
      if (formatted[i].type === "timeZoneName") {
        return formatted[i].value;
      }
    }
    return void 0;
  }
  function hackyTimeZone(dtf, date) {
    const formatted = dtf.format(date).replace(/\u200E/g, "");
    const tzNameMatch = / [\w-+ ]+$/.exec(formatted);
    return tzNameMatch ? tzNameMatch[0].substr(1) : "";
  }
  function getDTF(length, timeZone, locale) {
    return new Intl.DateTimeFormat(locale ? [locale.code, "en-US"] : void 0, {
      timeZone,
      timeZoneName: length
    });
  }
  function tzTokenizeDate(date, timeZone) {
    const dtf = getDateTimeFormat(timeZone);
    return "formatToParts" in dtf ? partsOffset(dtf, date) : hackyOffset(dtf, date);
  }
  const typeToPos = {
    year: 0,
    month: 1,
    day: 2,
    hour: 3,
    minute: 4,
    second: 5
  };
  function partsOffset(dtf, date) {
    try {
      const formatted = dtf.formatToParts(date);
      const filled = [];
      for (let i = 0; i < formatted.length; i++) {
        const pos = typeToPos[formatted[i].type];
        if (pos !== void 0) {
          filled[pos] = parseInt(formatted[i].value, 10);
        }
      }
      return filled;
    } catch (error2) {
      if (error2 instanceof RangeError) {
        return [NaN];
      }
      throw error2;
    }
  }
  function hackyOffset(dtf, date) {
    const formatted = dtf.format(date);
    const parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted);
    return [
      parseInt(parsed[3], 10),
      parseInt(parsed[1], 10),
      parseInt(parsed[2], 10),
      parseInt(parsed[4], 10),
      parseInt(parsed[5], 10),
      parseInt(parsed[6], 10)
    ];
  }
  const dtfCache = {};
  const testDateFormatted = new Intl.DateTimeFormat("en-US", {
    hourCycle: "h23",
    timeZone: "America/New_York",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit"
  }).format(/* @__PURE__ */ new Date("2014-06-25T04:00:00.123Z"));
  const hourCycleSupported = testDateFormatted === "06/25/2014, 00:00:00" || testDateFormatted === "‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00";
  function getDateTimeFormat(timeZone) {
    if (!dtfCache[timeZone]) {
      dtfCache[timeZone] = hourCycleSupported ? new Intl.DateTimeFormat("en-US", {
        hourCycle: "h23",
        timeZone,
        year: "numeric",
        month: "numeric",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit"
      }) : new Intl.DateTimeFormat("en-US", {
        hour12: false,
        timeZone,
        year: "numeric",
        month: "numeric",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit"
      });
    }
    return dtfCache[timeZone];
  }
  function newDateUTC(fullYear, month, day, hour, minute, second, millisecond) {
    const utcDate = /* @__PURE__ */ new Date(0);
    utcDate.setUTCFullYear(fullYear, month, day);
    utcDate.setUTCHours(hour, minute, second, millisecond);
    return utcDate;
  }
  const MILLISECONDS_IN_HOUR$1 = 36e5;
  const MILLISECONDS_IN_MINUTE$2 = 6e4;
  const patterns$1 = {
    timezone: /([Z+-].*)$/,
    timezoneZ: /^(Z)$/,
    timezoneHH: /^([+-]\d{2})$/,
    timezoneHHMM: /^([+-])(\d{2}):?(\d{2})$/
  };
  function tzParseTimezone(timezoneString, date, isUtcDate) {
    if (!timezoneString) {
      return 0;
    }
    let token = patterns$1.timezoneZ.exec(timezoneString);
    if (token) {
      return 0;
    }
    let hours;
    let absoluteOffset;
    token = patterns$1.timezoneHH.exec(timezoneString);
    if (token) {
      hours = parseInt(token[1], 10);
      if (!validateTimezone(hours)) {
        return NaN;
      }
      return -(hours * MILLISECONDS_IN_HOUR$1);
    }
    token = patterns$1.timezoneHHMM.exec(timezoneString);
    if (token) {
      hours = parseInt(token[2], 10);
      const minutes = parseInt(token[3], 10);
      if (!validateTimezone(hours, minutes)) {
        return NaN;
      }
      absoluteOffset = Math.abs(hours) * MILLISECONDS_IN_HOUR$1 + minutes * MILLISECONDS_IN_MINUTE$2;
      return token[1] === "+" ? -absoluteOffset : absoluteOffset;
    }
    if (isValidTimezoneIANAString(timezoneString)) {
      date = new Date(date || Date.now());
      const utcDate = isUtcDate ? date : toUtcDate(date);
      const offset = calcOffset(utcDate, timezoneString);
      const fixedOffset = isUtcDate ? offset : fixOffset(date, offset, timezoneString);
      return -fixedOffset;
    }
    return NaN;
  }
  function toUtcDate(date) {
    return newDateUTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
  }
  function calcOffset(date, timezoneString) {
    const tokens = tzTokenizeDate(date, timezoneString);
    const asUTC = newDateUTC(tokens[0], tokens[1] - 1, tokens[2], tokens[3] % 24, tokens[4], tokens[5], 0).getTime();
    let asTS = date.getTime();
    const over = asTS % 1e3;
    asTS -= over >= 0 ? over : 1e3 + over;
    return asUTC - asTS;
  }
  function fixOffset(date, offset, timezoneString) {
    const localTS = date.getTime();
    let utcGuess = localTS - offset;
    const o2 = calcOffset(new Date(utcGuess), timezoneString);
    if (offset === o2) {
      return offset;
    }
    utcGuess -= o2 - offset;
    const o3 = calcOffset(new Date(utcGuess), timezoneString);
    if (o2 === o3) {
      return o2;
    }
    return Math.max(o2, o3);
  }
  function validateTimezone(hours, minutes) {
    return -23 <= hours && hours <= 23 && (minutes == null || 0 <= minutes && minutes <= 59);
  }
  const validIANATimezoneCache = {};
  function isValidTimezoneIANAString(timeZoneString) {
    if (validIANATimezoneCache[timeZoneString])
      return true;
    try {
      new Intl.DateTimeFormat(void 0, { timeZone: timeZoneString });
      validIANATimezoneCache[timeZoneString] = true;
      return true;
    } catch (error2) {
      return false;
    }
  }
  const MILLISECONDS_IN_MINUTE$1 = 60 * 1e3;
  const formatters = {
    // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
    X: function(date, token, options) {
      const timezoneOffset = getTimeZoneOffset(options.timeZone, date);
      if (timezoneOffset === 0) {
        return "Z";
      }
      switch (token) {
        case "X":
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        case "XXXX":
        case "XX":
          return formatTimezone(timezoneOffset);
        case "XXXXX":
        case "XXX":
        default:
          return formatTimezone(timezoneOffset, ":");
      }
    },
    // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
    x: function(date, token, options) {
      const timezoneOffset = getTimeZoneOffset(options.timeZone, date);
      switch (token) {
        case "x":
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        case "xxxx":
        case "xx":
          return formatTimezone(timezoneOffset);
        case "xxxxx":
        case "xxx":
        default:
          return formatTimezone(timezoneOffset, ":");
      }
    },
    // Timezone (GMT)
    O: function(date, token, options) {
      const timezoneOffset = getTimeZoneOffset(options.timeZone, date);
      switch (token) {
        case "O":
        case "OO":
        case "OOO":
          return "GMT" + formatTimezoneShort(timezoneOffset, ":");
        case "OOOO":
        default:
          return "GMT" + formatTimezone(timezoneOffset, ":");
      }
    },
    // Timezone (specific non-location)
    z: function(date, token, options) {
      switch (token) {
        case "z":
        case "zz":
        case "zzz":
          return tzIntlTimeZoneName("short", date, options);
        case "zzzz":
        default:
          return tzIntlTimeZoneName("long", date, options);
      }
    }
  };
  function getTimeZoneOffset(timeZone, originalDate) {
    const timeZoneOffset = timeZone ? tzParseTimezone(timeZone, originalDate, true) / MILLISECONDS_IN_MINUTE$1 : (originalDate == null ? void 0 : originalDate.getTimezoneOffset()) ?? 0;
    if (Number.isNaN(timeZoneOffset)) {
      throw new RangeError("Invalid time zone specified: " + timeZone);
    }
    return timeZoneOffset;
  }
  function addLeadingZeros(number, targetLength) {
    const sign = number < 0 ? "-" : "";
    let output = Math.abs(number).toString();
    while (output.length < targetLength) {
      output = "0" + output;
    }
    return sign + output;
  }
  function formatTimezone(offset, delimiter = "") {
    const sign = offset > 0 ? "-" : "+";
    const absOffset = Math.abs(offset);
    const hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
    const minutes = addLeadingZeros(Math.floor(absOffset % 60), 2);
    return sign + hours + delimiter + minutes;
  }
  function formatTimezoneWithOptionalMinutes(offset, delimiter) {
    if (offset % 60 === 0) {
      const sign = offset > 0 ? "-" : "+";
      return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
    }
    return formatTimezone(offset, delimiter);
  }
  function formatTimezoneShort(offset, delimiter = "") {
    const sign = offset > 0 ? "-" : "+";
    const absOffset = Math.abs(offset);
    const hours = Math.floor(absOffset / 60);
    const minutes = absOffset % 60;
    if (minutes === 0) {
      return sign + String(hours);
    }
    return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
  }
  function getTimezoneOffsetInMilliseconds(date) {
    const utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
    utcDate.setUTCFullYear(date.getFullYear());
    return +date - +utcDate;
  }
  const tzPattern = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/;
  const MILLISECONDS_IN_HOUR = 36e5;
  const MILLISECONDS_IN_MINUTE = 6e4;
  const DEFAULT_ADDITIONAL_DIGITS = 2;
  const patterns = {
    dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
    datePattern: /^([0-9W+-]+)(.*)/,
    plainTime: /:/,
    // year tokens
    YY: /^(\d{2})$/,
    YYY: [
      /^([+-]\d{2})$/,
      // 0 additional digits
      /^([+-]\d{3})$/,
      // 1 additional digit
      /^([+-]\d{4})$/
      // 2 additional digits
    ],
    YYYY: /^(\d{4})/,
    YYYYY: [
      /^([+-]\d{4})/,
      // 0 additional digits
      /^([+-]\d{5})/,
      // 1 additional digit
      /^([+-]\d{6})/
      // 2 additional digits
    ],
    // date tokens
    MM: /^-(\d{2})$/,
    DDD: /^-?(\d{3})$/,
    MMDD: /^-?(\d{2})-?(\d{2})$/,
    Www: /^-?W(\d{2})$/,
    WwwD: /^-?W(\d{2})-?(\d{1})$/,
    HH: /^(\d{2}([.,]\d*)?)$/,
    HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
    HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
    // time zone tokens (to identify the presence of a tz)
    timeZone: tzPattern
  };
  function toDate(argument, options = {}) {
    if (arguments.length < 1) {
      throw new TypeError("1 argument required, but only " + arguments.length + " present");
    }
    if (argument === null) {
      return /* @__PURE__ */ new Date(NaN);
    }
    const additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : Number(options.additionalDigits);
    if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
      throw new RangeError("additionalDigits must be 0, 1 or 2");
    }
    if (argument instanceof Date || typeof argument === "object" && Object.prototype.toString.call(argument) === "[object Date]") {
      return new Date(argument.getTime());
    } else if (typeof argument === "number" || Object.prototype.toString.call(argument) === "[object Number]") {
      return new Date(argument);
    } else if (!(Object.prototype.toString.call(argument) === "[object String]")) {
      return /* @__PURE__ */ new Date(NaN);
    }
    const dateStrings = splitDateString(argument);
    const { year, restDateString } = parseYear(dateStrings.date, additionalDigits);
    const date = parseDate(restDateString, year);
    if (date === null || isNaN(date.getTime())) {
      return /* @__PURE__ */ new Date(NaN);
    }
    if (date) {
      const timestamp = date.getTime();
      let time2 = 0;
      let offset;
      if (dateStrings.time) {
        time2 = parseTime(dateStrings.time);
        if (time2 === null || isNaN(time2)) {
          return /* @__PURE__ */ new Date(NaN);
        }
      }
      if (dateStrings.timeZone || options.timeZone) {
        offset = tzParseTimezone(dateStrings.timeZone || options.timeZone, new Date(timestamp + time2));
        if (isNaN(offset)) {
          return /* @__PURE__ */ new Date(NaN);
        }
      } else {
        offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time2));
        offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time2 + offset));
      }
      return new Date(timestamp + time2 + offset);
    } else {
      return /* @__PURE__ */ new Date(NaN);
    }
  }
  function splitDateString(dateString) {
    const dateStrings = {};
    let parts = patterns.dateTimePattern.exec(dateString);
    let timeString;
    if (!parts) {
      parts = patterns.datePattern.exec(dateString);
      if (parts) {
        dateStrings.date = parts[1];
        timeString = parts[2];
      } else {
        dateStrings.date = null;
        timeString = dateString;
      }
    } else {
      dateStrings.date = parts[1];
      timeString = parts[3];
    }
    if (timeString) {
      const token = patterns.timeZone.exec(timeString);
      if (token) {
        dateStrings.time = timeString.replace(token[1], "");
        dateStrings.timeZone = token[1].trim();
      } else {
        dateStrings.time = timeString;
      }
    }
    return dateStrings;
  }
  function parseYear(dateString, additionalDigits) {
    if (dateString) {
      const patternYYY = patterns.YYY[additionalDigits];
      const patternYYYYY = patterns.YYYYY[additionalDigits];
      let token = patterns.YYYY.exec(dateString) || patternYYYYY.exec(dateString);
      if (token) {
        const yearString = token[1];
        return {
          year: parseInt(yearString, 10),
          restDateString: dateString.slice(yearString.length)
        };
      }
      token = patterns.YY.exec(dateString) || patternYYY.exec(dateString);
      if (token) {
        const centuryString = token[1];
        return {
          year: parseInt(centuryString, 10) * 100,
          restDateString: dateString.slice(centuryString.length)
        };
      }
    }
    return {
      year: null
    };
  }
  function parseDate(dateString, year) {
    if (year === null) {
      return null;
    }
    let date;
    let month;
    let week;
    if (!dateString || !dateString.length) {
      date = /* @__PURE__ */ new Date(0);
      date.setUTCFullYear(year);
      return date;
    }
    let token = patterns.MM.exec(dateString);
    if (token) {
      date = /* @__PURE__ */ new Date(0);
      month = parseInt(token[1], 10) - 1;
      if (!validateDate(year, month)) {
        return /* @__PURE__ */ new Date(NaN);
      }
      date.setUTCFullYear(year, month);
      return date;
    }
    token = patterns.DDD.exec(dateString);
    if (token) {
      date = /* @__PURE__ */ new Date(0);
      const dayOfYear = parseInt(token[1], 10);
      if (!validateDayOfYearDate(year, dayOfYear)) {
        return /* @__PURE__ */ new Date(NaN);
      }
      date.setUTCFullYear(year, 0, dayOfYear);
      return date;
    }
    token = patterns.MMDD.exec(dateString);
    if (token) {
      date = /* @__PURE__ */ new Date(0);
      month = parseInt(token[1], 10) - 1;
      const day = parseInt(token[2], 10);
      if (!validateDate(year, month, day)) {
        return /* @__PURE__ */ new Date(NaN);
      }
      date.setUTCFullYear(year, month, day);
      return date;
    }
    token = patterns.Www.exec(dateString);
    if (token) {
      week = parseInt(token[1], 10) - 1;
      if (!validateWeekDate(week)) {
        return /* @__PURE__ */ new Date(NaN);
      }
      return dayOfISOWeekYear(year, week);
    }
    token = patterns.WwwD.exec(dateString);
    if (token) {
      week = parseInt(token[1], 10) - 1;
      const dayOfWeek = parseInt(token[2], 10) - 1;
      if (!validateWeekDate(week, dayOfWeek)) {
        return /* @__PURE__ */ new Date(NaN);
      }
      return dayOfISOWeekYear(year, week, dayOfWeek);
    }
    return null;
  }
  function parseTime(timeString) {
    let hours;
    let minutes;
    let token = patterns.HH.exec(timeString);
    if (token) {
      hours = parseFloat(token[1].replace(",", "."));
      if (!validateTime(hours)) {
        return NaN;
      }
      return hours % 24 * MILLISECONDS_IN_HOUR;
    }
    token = patterns.HHMM.exec(timeString);
    if (token) {
      hours = parseInt(token[1], 10);
      minutes = parseFloat(token[2].replace(",", "."));
      if (!validateTime(hours, minutes)) {
        return NaN;
      }
      return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;
    }
    token = patterns.HHMMSS.exec(timeString);
    if (token) {
      hours = parseInt(token[1], 10);
      minutes = parseInt(token[2], 10);
      const seconds = parseFloat(token[3].replace(",", "."));
      if (!validateTime(hours, minutes, seconds)) {
        return NaN;
      }
      return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1e3;
    }
    return null;
  }
  function dayOfISOWeekYear(isoWeekYear, week, day) {
    week = week || 0;
    day = day || 0;
    const date = /* @__PURE__ */ new Date(0);
    date.setUTCFullYear(isoWeekYear, 0, 4);
    const fourthOfJanuaryDay = date.getUTCDay() || 7;
    const diff = week * 7 + day + 1 - fourthOfJanuaryDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
  }
  const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  const DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function isLeapYearIndex(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
  }
  function validateDate(year, month, date) {
    if (month < 0 || month > 11) {
      return false;
    }
    if (date != null) {
      if (date < 1) {
        return false;
      }
      const isLeapYear = isLeapYearIndex(year);
      if (isLeapYear && date > DAYS_IN_MONTH_LEAP_YEAR[month]) {
        return false;
      }
      if (!isLeapYear && date > DAYS_IN_MONTH[month]) {
        return false;
      }
    }
    return true;
  }
  function validateDayOfYearDate(year, dayOfYear) {
    if (dayOfYear < 1) {
      return false;
    }
    const isLeapYear = isLeapYearIndex(year);
    if (isLeapYear && dayOfYear > 366) {
      return false;
    }
    if (!isLeapYear && dayOfYear > 365) {
      return false;
    }
    return true;
  }
  function validateWeekDate(week, day) {
    if (week < 0 || week > 52) {
      return false;
    }
    if (day != null && (day < 0 || day > 6)) {
      return false;
    }
    return true;
  }
  function validateTime(hours, minutes, seconds) {
    if (hours < 0 || hours >= 25) {
      return false;
    }
    if (minutes != null && (minutes < 0 || minutes >= 60)) {
      return false;
    }
    if (seconds != null && (seconds < 0 || seconds >= 60)) {
      return false;
    }
    return true;
  }
  const tzFormattingTokensRegExp = /([xXOz]+)|''|'(''|[^'])+('|$)/g;
  function format$2(date, formatStr, options = {}) {
    formatStr = String(formatStr);
    const matches = formatStr.match(tzFormattingTokensRegExp);
    if (matches) {
      const d = toDate(options.originalDate || date, options);
      formatStr = matches.reduce(function(result, token) {
        if (token[0] === "'") {
          return result;
        }
        const pos = result.indexOf(token);
        const precededByQuotedSection = result[pos - 1] === "'";
        const replaced = result.replace(token, "'" + formatters[token[0]](d, token, options) + "'");
        return precededByQuotedSection ? replaced.substring(0, pos - 1) + replaced.substring(pos + 1) : replaced;
      }, formatStr);
    }
    return format$3(date, formatStr, options);
  }
  function toZonedTime(date, timeZone, options) {
    date = toDate(date, options);
    const offsetMilliseconds = tzParseTimezone(timeZone, date, true);
    const d = new Date(date.getTime() - offsetMilliseconds);
    const resultDate = /* @__PURE__ */ new Date(0);
    resultDate.setFullYear(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
    resultDate.setHours(d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds());
    return resultDate;
  }
  function formatInTimeZone(date, timeZone, formatStr, options) {
    options = {
      ...options,
      timeZone,
      originalDate: date
    };
    return format$2(toZonedTime(date, timeZone, { timeZone: options.timeZone }), formatStr, options);
  }
  const time = {
    amHours: ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11"],
    pmHours: ["12", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11"],
    hours: ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"],
    minutes: ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59"],
    seconds: ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59"],
    period: ["AM", "PM"]
  };
  function getFixValue(value) {
    return `00${value}`.slice(-2);
  }
  function getTimeUnits(defaultValue, stepOrList, isHourWithAmPm) {
    if (Array.isArray(stepOrList)) {
      return (isHourWithAmPm === "am" ? stepOrList.filter((v) => v < 12) : isHourWithAmPm === "pm" ? stepOrList.filter((v) => v >= 12).map((v) => v === 12 ? 12 : v - 12) : stepOrList).map((v) => getFixValue(v));
    } else if (typeof stepOrList === "number") {
      if (isHourWithAmPm === "am") {
        return defaultValue.filter((hour) => {
          const hourAsNumber = Number(hour);
          return hourAsNumber < 12 && hourAsNumber % stepOrList === 0;
        });
      } else if (isHourWithAmPm === "pm") {
        return defaultValue.filter((hour) => {
          const hourAsNumber = Number(hour);
          return hourAsNumber >= 12 && hourAsNumber % stepOrList === 0;
        }).map((hour) => {
          const hourAsNumber = Number(hour);
          return getFixValue(hourAsNumber === 12 ? 12 : hourAsNumber - 12);
        });
      }
      return defaultValue.filter((hour) => {
        return Number(hour) % stepOrList === 0;
      });
    } else {
      return isHourWithAmPm === "am" ? defaultValue.filter((hour) => Number(hour) < 12) : isHourWithAmPm === "pm" ? defaultValue.map((hour) => Number(hour)).filter((hour) => Number(hour) >= 12).map((v) => getFixValue(v === 12 ? 12 : v - 12)) : defaultValue;
    }
  }
  function isTimeInStep(value, type, stepOrList) {
    if (!stepOrList) {
      return true;
    } else if (typeof stepOrList === "number") {
      return value % stepOrList === 0;
    } else {
      return stepOrList.includes(value);
    }
  }
  function findSimilarTime(value, type, stepOrList) {
    const list = getTimeUnits(time[type], stepOrList).map(Number);
    let lowerBound, upperBound;
    for (let i = 0; i < list.length; ++i) {
      const v = list[i];
      if (v === value) {
        return v;
      } else if (v > value) {
        upperBound = v;
        break;
      }
      lowerBound = v;
    }
    if (lowerBound === void 0) {
      if (!upperBound) {
        throwError("time-picker", "Please set 'hours' or 'minutes' or 'seconds' props");
      }
      return upperBound;
    }
    if (upperBound === void 0) {
      return lowerBound;
    }
    return upperBound - value > value - lowerBound ? lowerBound : upperBound;
  }
  function getAmPm(value) {
    return getHours(value) < 12 ? "am" : "pm";
  }
  const timePickerInjectionKey = createInjectionKey("n-time-picker");
  const PanelCol = vue.defineComponent({
    name: "TimePickerPanelCol",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      data: {
        type: Array,
        required: true
      },
      activeValue: {
        type: Number,
        default: null
      },
      // It should be required but vue's type seems to have bugs
      onItemClick: Function
    },
    render() {
      const {
        activeValue,
        onItemClick,
        clsPrefix
      } = this;
      return this.data.map((item) => {
        const {
          label,
          disabled,
          value
        } = item;
        const active = activeValue === value;
        return vue.h("div", {
          key: label,
          "data-active": active ? "" : null,
          class: [`${clsPrefix}-time-picker-col__item`, active && `${clsPrefix}-time-picker-col__item--active`, disabled && `${clsPrefix}-time-picker-col__item--disabled`],
          onClick: onItemClick && !disabled ? () => {
            onItemClick(value);
          } : void 0
        }, label);
      });
    }
  });
  const timePickerPanelProps = {
    actions: {
      type: Array,
      default: () => ["now", "confirm"]
    },
    showHour: {
      type: Boolean,
      default: true
    },
    showMinute: {
      type: Boolean,
      default: true
    },
    showSecond: {
      type: Boolean,
      default: true
    },
    showPeriod: {
      type: Boolean,
      default: true
    },
    isHourInvalid: Boolean,
    isMinuteInvalid: Boolean,
    isSecondInvalid: Boolean,
    isAmPmInvalid: Boolean,
    isValueInvalid: Boolean,
    hourValue: {
      type: Number,
      default: null
    },
    minuteValue: {
      type: Number,
      default: null
    },
    secondValue: {
      type: Number,
      default: null
    },
    amPmValue: {
      type: String,
      default: null
    },
    isHourDisabled: Function,
    isMinuteDisabled: Function,
    isSecondDisabled: Function,
    onHourClick: {
      type: Function,
      required: true
    },
    onMinuteClick: {
      type: Function,
      required: true
    },
    onSecondClick: {
      type: Function,
      required: true
    },
    onAmPmClick: {
      type: Function,
      required: true
    },
    onNowClick: Function,
    clearText: String,
    nowText: String,
    confirmText: String,
    transitionDisabled: Boolean,
    onClearClick: Function,
    onConfirmClick: Function,
    onFocusin: Function,
    onFocusout: Function,
    onFocusDetectorFocus: Function,
    onKeydown: Function,
    hours: [Number, Array],
    minutes: [Number, Array],
    seconds: [Number, Array],
    use12Hours: Boolean
  };
  const Panel = vue.defineComponent({
    name: "TimePickerPanel",
    props: timePickerPanelProps,
    setup(props) {
      const {
        mergedThemeRef,
        mergedClsPrefixRef
      } = vue.inject(timePickerInjectionKey);
      const hoursRef = vue.computed(() => {
        const {
          isHourDisabled,
          hours,
          use12Hours,
          amPmValue
        } = props;
        if (!use12Hours) {
          return getTimeUnits(time.hours, hours).map((hour) => {
            return {
              label: hour,
              value: Number(hour),
              disabled: isHourDisabled ? isHourDisabled(Number(hour)) : false
            };
          });
        } else {
          const mergedAmPmValue = amPmValue !== null && amPmValue !== void 0 ? amPmValue : getAmPm(Date.now());
          return getTimeUnits(time.hours, hours, mergedAmPmValue).map((hour) => {
            const hourAs12FormattedNumber = Number(hour);
            const hourAs24FormattedNumber = mergedAmPmValue === "pm" && hourAs12FormattedNumber !== 12 ? hourAs12FormattedNumber + 12 : hourAs12FormattedNumber;
            return {
              label: hour,
              value: hourAs24FormattedNumber,
              disabled: isHourDisabled ? isHourDisabled(hourAs24FormattedNumber) : false
            };
          });
        }
      });
      const minutesRef = vue.computed(() => {
        const {
          isMinuteDisabled,
          minutes
        } = props;
        return getTimeUnits(time.minutes, minutes).map((minute) => {
          return {
            label: minute,
            value: Number(minute),
            disabled: isMinuteDisabled ? isMinuteDisabled(Number(minute), props.hourValue) : false
          };
        });
      });
      const secondsRef = vue.computed(() => {
        const {
          isSecondDisabled,
          seconds
        } = props;
        return getTimeUnits(time.seconds, seconds).map((second) => {
          return {
            label: second,
            value: Number(second),
            disabled: isSecondDisabled ? isSecondDisabled(Number(second), props.minuteValue, props.hourValue) : false
          };
        });
      });
      const amPmRef = vue.computed(() => {
        const {
          isHourDisabled
        } = props;
        let amDisabled = true;
        let pmDisabled = true;
        for (let i = 0; i < 12; ++i) {
          if (!(isHourDisabled === null || isHourDisabled === void 0 ? void 0 : isHourDisabled(i))) {
            amDisabled = false;
            break;
          }
        }
        for (let i = 12; i < 24; ++i) {
          if (!(isHourDisabled === null || isHourDisabled === void 0 ? void 0 : isHourDisabled(i))) {
            pmDisabled = false;
            break;
          }
        }
        return [{
          label: "AM",
          value: "am",
          disabled: amDisabled
        }, {
          label: "PM",
          value: "pm",
          disabled: pmDisabled
        }];
      });
      return {
        mergedTheme: mergedThemeRef,
        mergedClsPrefix: mergedClsPrefixRef,
        hours: hoursRef,
        minutes: minutesRef,
        seconds: secondsRef,
        amPm: amPmRef,
        hourScrollRef: vue.ref(null),
        minuteScrollRef: vue.ref(null),
        secondScrollRef: vue.ref(null),
        amPmScrollRef: vue.ref(null)
      };
    },
    render() {
      var _a, _b, _c, _d;
      const {
        mergedClsPrefix,
        mergedTheme
      } = this;
      return vue.h("div", {
        tabindex: 0,
        class: `${mergedClsPrefix}-time-picker-panel`,
        onFocusin: this.onFocusin,
        onFocusout: this.onFocusout,
        onKeydown: this.onKeydown
      }, vue.h("div", {
        class: `${mergedClsPrefix}-time-picker-cols`
      }, this.showHour ? vue.h("div", {
        class: [`${mergedClsPrefix}-time-picker-col`, this.isHourInvalid && `${mergedClsPrefix}-time-picker-col--invalid`, this.transitionDisabled && `${mergedClsPrefix}-time-picker-col--transition-disabled`]
      }, vue.h(NScrollbar, {
        ref: "hourScrollRef",
        theme: mergedTheme.peers.Scrollbar,
        themeOverrides: mergedTheme.peerOverrides.Scrollbar
      }, {
        default: () => [vue.h(PanelCol, {
          clsPrefix: mergedClsPrefix,
          data: this.hours,
          activeValue: this.hourValue,
          onItemClick: this.onHourClick
        }), vue.h("div", {
          class: `${mergedClsPrefix}-time-picker-col__padding`
        })]
      })) : null, this.showMinute ? vue.h("div", {
        class: [`${mergedClsPrefix}-time-picker-col`, this.transitionDisabled && `${mergedClsPrefix}-time-picker-col--transition-disabled`, this.isMinuteInvalid && `${mergedClsPrefix}-time-picker-col--invalid`]
      }, vue.h(NScrollbar, {
        ref: "minuteScrollRef",
        theme: mergedTheme.peers.Scrollbar,
        themeOverrides: mergedTheme.peerOverrides.Scrollbar
      }, {
        default: () => [vue.h(PanelCol, {
          clsPrefix: mergedClsPrefix,
          data: this.minutes,
          activeValue: this.minuteValue,
          onItemClick: this.onMinuteClick
        }), vue.h("div", {
          class: `${mergedClsPrefix}-time-picker-col__padding`
        })]
      })) : null, this.showSecond ? vue.h("div", {
        class: [`${mergedClsPrefix}-time-picker-col`, this.isSecondInvalid && `${mergedClsPrefix}-time-picker-col--invalid`, this.transitionDisabled && `${mergedClsPrefix}-time-picker-col--transition-disabled`]
      }, vue.h(NScrollbar, {
        ref: "secondScrollRef",
        theme: mergedTheme.peers.Scrollbar,
        themeOverrides: mergedTheme.peerOverrides.Scrollbar
      }, {
        default: () => [vue.h(PanelCol, {
          clsPrefix: mergedClsPrefix,
          data: this.seconds,
          activeValue: this.secondValue,
          onItemClick: this.onSecondClick
        }), vue.h("div", {
          class: `${mergedClsPrefix}-time-picker-col__padding`
        })]
      })) : null, this.use12Hours ? vue.h("div", {
        class: [`${mergedClsPrefix}-time-picker-col`, this.isAmPmInvalid && `${mergedClsPrefix}-time-picker-col--invalid`, this.transitionDisabled && `${mergedClsPrefix}-time-picker-col--transition-disabled`]
      }, vue.h(NScrollbar, {
        ref: "amPmScrollRef",
        theme: mergedTheme.peers.Scrollbar,
        themeOverrides: mergedTheme.peerOverrides.Scrollbar
      }, {
        default: () => [vue.h(PanelCol, {
          clsPrefix: mergedClsPrefix,
          data: this.amPm,
          activeValue: this.amPmValue,
          onItemClick: this.onAmPmClick
        }), vue.h("div", {
          class: `${mergedClsPrefix}-time-picker-col__padding`
        })]
      })) : null), ((_a = this.actions) === null || _a === void 0 ? void 0 : _a.length) ? vue.h("div", {
        class: `${mergedClsPrefix}-time-picker-actions`
      }, ((_b = this.actions) === null || _b === void 0 ? void 0 : _b.includes("clear")) ? vue.h(NButton, {
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        size: "tiny",
        onClick: this.onClearClick
      }, {
        default: () => this.clearText
      }) : null, ((_c = this.actions) === null || _c === void 0 ? void 0 : _c.includes("now")) ? vue.h(NButton, {
        size: "tiny",
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        onClick: this.onNowClick
      }, {
        default: () => this.nowText
      }) : null, ((_d = this.actions) === null || _d === void 0 ? void 0 : _d.includes("confirm")) ? vue.h(NButton, {
        size: "tiny",
        type: "primary",
        class: `${mergedClsPrefix}-time-picker-actions__confirm`,
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        disabled: this.isValueInvalid,
        onClick: this.onConfirmClick
      }, {
        default: () => this.confirmText
      }) : null) : null, vue.h(FocusDetector, {
        onFocus: this.onFocusDetectorFocus
      }));
    }
  });
  const style$W = c$1([cB("time-picker", `
 z-index: auto;
 position: relative;
 `, [cB("time-picker-icon", `
 color: var(--n-icon-color-override);
 transition: color .3s var(--n-bezier);
 `), cM("disabled", [cB("time-picker-icon", `
 color: var(--n-icon-color-disabled-override);
 `)])]), cB("time-picker-panel", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 outline: none;
 font-size: var(--n-item-font-size);
 border-radius: var(--n-border-radius);
 margin: 4px 0;
 min-width: 104px;
 overflow: hidden;
 background-color: var(--n-panel-color);
 box-shadow: var(--n-panel-box-shadow);
 `, [fadeInScaleUpTransition(), cB("time-picker-actions", `
 padding: var(--n-panel-action-padding);
 align-items: center;
 display: flex;
 justify-content: space-evenly;
 `), cB("time-picker-cols", `
 height: calc(var(--n-item-height) * 6);
 display: flex;
 position: relative;
 transition: border-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-panel-divider-color);
 `), cB("time-picker-col", `
 flex-grow: 1;
 min-width: var(--n-item-width);
 height: calc(var(--n-item-height) * 6);
 flex-direction: column;
 transition: box-shadow .3s var(--n-bezier);
 `, [cM("transition-disabled", [cE("item", "transition: none;", [c$1("&::before", "transition: none;")])]), cE("padding", `
 height: calc(var(--n-item-height) * 5);
 `), c$1("&:first-child", "min-width: calc(var(--n-item-width) + 4px);", [cE("item", [c$1("&::before", "left: 4px;")])]), cE("item", `
 cursor: pointer;
 height: var(--n-item-height);
 display: flex;
 align-items: center;
 justify-content: center;
 transition: 
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier);
 background: #0000;
 text-decoration-color: #0000;
 color: var(--n-item-text-color);
 z-index: 0;
 box-sizing: border-box;
 padding-top: 4px;
 position: relative;
 `, [c$1("&::before", `
 content: "";
 transition: background-color .3s var(--n-bezier);
 z-index: -1;
 position: absolute;
 left: 0;
 right: 4px;
 top: 4px;
 bottom: 0;
 border-radius: var(--n-item-border-radius);
 `), cNotM("disabled", [c$1("&:hover::before", `
 background-color: var(--n-item-color-hover);
 `)]), cM("active", `
 color: var(--n-item-text-color-active);
 `, [c$1("&::before", `
 background-color: var(--n-item-color-hover);
 `)]), cM("disabled", `
 opacity: var(--n-item-opacity-disabled);
 cursor: not-allowed;
 `)]), cM("invalid", [cE("item", [cM("active", `
 text-decoration: line-through;
 text-decoration-color: var(--n-item-text-color-active);
 `)])])])])]);
  function validateUnits(value, max) {
    if (value === void 0) {
      return true;
    }
    if (Array.isArray(value)) {
      return value.every((v) => v >= 0 && v <= max);
    } else {
      return value >= 0 && value <= max;
    }
  }
  const timePickerProps = Object.assign(Object.assign({}, useTheme.props), {
    to: useAdjustedTo.propTo,
    bordered: {
      type: Boolean,
      default: void 0
    },
    actions: Array,
    defaultValue: {
      type: Number,
      default: null
    },
    defaultFormattedValue: String,
    placeholder: String,
    placement: {
      type: String,
      default: "bottom-start"
    },
    value: Number,
    format: {
      type: String,
      default: "HH:mm:ss"
    },
    valueFormat: String,
    formattedValue: String,
    isHourDisabled: Function,
    size: String,
    isMinuteDisabled: Function,
    isSecondDisabled: Function,
    inputReadonly: Boolean,
    clearable: Boolean,
    status: String,
    "onUpdate:value": [Function, Array],
    onUpdateValue: [Function, Array],
    "onUpdate:show": [Function, Array],
    onUpdateShow: [Function, Array],
    onUpdateFormattedValue: [Function, Array],
    "onUpdate:formattedValue": [Function, Array],
    onBlur: [Function, Array],
    onConfirm: [Function, Array],
    onClear: Function,
    onFocus: [Function, Array],
    // https://www.iana.org/time-zones
    timeZone: String,
    showIcon: {
      type: Boolean,
      default: true
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    show: {
      type: Boolean,
      default: void 0
    },
    hours: {
      type: [Number, Array],
      validator: (value) => validateUnits(value, 23)
    },
    minutes: {
      type: [Number, Array],
      validator: (value) => validateUnits(value, 59)
    },
    seconds: {
      type: [Number, Array],
      validator: (value) => validateUnits(value, 59)
    },
    use12Hours: Boolean,
    // private
    stateful: {
      type: Boolean,
      default: true
    },
    // deprecated
    onChange: [Function, Array]
  });
  const NTimePicker = vue.defineComponent({
    name: "TimePicker",
    props: timePickerProps,
    setup(props) {
      {
        vue.watchEffect(() => {
          if (props.onChange !== void 0) {
            warnOnce("time-picker", "`on-change` is deprecated, please use `on-update:value` instead.");
          }
        });
      }
      const {
        mergedBorderedRef,
        mergedClsPrefixRef,
        namespaceRef,
        inlineThemeDisabled
      } = useConfig(props);
      const {
        localeRef,
        dateLocaleRef
      } = useLocale("TimePicker");
      const formItem = useFormItem(props);
      const {
        mergedSizeRef,
        mergedDisabledRef,
        mergedStatusRef
      } = formItem;
      const themeRef = useTheme("TimePicker", "-time-picker", style$W, timePickerLight$1, props, mergedClsPrefixRef);
      const keyboardState = useKeyboard$1();
      const inputInstRef = vue.ref(null);
      const panelInstRef = vue.ref(null);
      const dateFnsOptionsRef = vue.computed(() => {
        return {
          locale: dateLocaleRef.value.locale
        };
      });
      function getTimestampFromFormattedValue(value) {
        if (value === null)
          return null;
        return strictParse(value, props.valueFormat || props.format, /* @__PURE__ */ new Date(), dateFnsOptionsRef.value).getTime();
      }
      const {
        defaultValue,
        defaultFormattedValue
      } = props;
      const uncontrolledValueRef = vue.ref(defaultFormattedValue !== void 0 ? getTimestampFromFormattedValue(defaultFormattedValue) : defaultValue);
      const mergedValueRef = vue.computed(() => {
        const {
          formattedValue
        } = props;
        if (formattedValue !== void 0) {
          return getTimestampFromFormattedValue(formattedValue);
        }
        const {
          value
        } = props;
        if (value !== void 0) {
          return value;
        }
        return uncontrolledValueRef.value;
      });
      const mergedFormatRef = vue.computed(() => {
        const {
          timeZone
        } = props;
        if (timeZone) {
          return (date, format2, options) => {
            return formatInTimeZone(date, timeZone, format2, options);
          };
        } else {
          return (date, _format, options) => {
            return format$3(date, _format, options);
          };
        }
      });
      const displayTimeStringRef = vue.ref("");
      vue.watch(() => props.timeZone, () => {
        const mergedValue = mergedValueRef.value;
        displayTimeStringRef.value = mergedValue === null ? "" : mergedFormatRef.value(mergedValue, props.format, dateFnsOptionsRef.value);
      }, {
        immediate: true
      });
      const uncontrolledShowRef = vue.ref(false);
      const controlledShowRef = vue.toRef(props, "show");
      const mergedShowRef = useMergedState(controlledShowRef, uncontrolledShowRef);
      const memorizedValueRef = vue.ref(mergedValueRef.value);
      const transitionDisabledRef = vue.ref(false);
      const localizedClearRef = vue.computed(() => {
        return localeRef.value.clear;
      });
      const localizedNowRef = vue.computed(() => {
        return localeRef.value.now;
      });
      const localizedPlaceholderRef = vue.computed(() => {
        if (props.placeholder !== void 0)
          return props.placeholder;
        return localeRef.value.placeholder;
      });
      const localizedNegativeTextRef = vue.computed(() => {
        return localeRef.value.negativeText;
      });
      const localizedPositiveTextRef = vue.computed(() => {
        return localeRef.value.positiveText;
      });
      const hourInFormatRef = vue.computed(() => {
        return /H|h|K|k/.test(props.format);
      });
      const minuteInFormatRef = vue.computed(() => {
        return props.format.includes("m");
      });
      const secondInFormatRef = vue.computed(() => {
        return props.format.includes("s");
      });
      const hourValueRef = vue.computed(() => {
        const {
          value
        } = mergedValueRef;
        if (value === null)
          return null;
        return Number(mergedFormatRef.value(value, "HH", dateFnsOptionsRef.value));
      });
      const minuteValueRef = vue.computed(() => {
        const {
          value
        } = mergedValueRef;
        if (value === null)
          return null;
        return Number(mergedFormatRef.value(value, "mm", dateFnsOptionsRef.value));
      });
      const secondValueRef = vue.computed(() => {
        const {
          value
        } = mergedValueRef;
        if (value === null)
          return null;
        return Number(mergedFormatRef.value(value, "ss", dateFnsOptionsRef.value));
      });
      const isHourInvalidRef = vue.computed(() => {
        const {
          isHourDisabled
        } = props;
        if (hourValueRef.value === null)
          return false;
        if (!isTimeInStep(hourValueRef.value, "hours", props.hours))
          return true;
        if (!isHourDisabled)
          return false;
        return isHourDisabled(hourValueRef.value);
      });
      const isMinuteInvalidRef = vue.computed(() => {
        const {
          value: minuteValue
        } = minuteValueRef;
        const {
          value: hourValue
        } = hourValueRef;
        if (minuteValue === null || hourValue === null)
          return false;
        if (!isTimeInStep(minuteValue, "minutes", props.minutes))
          return true;
        const {
          isMinuteDisabled
        } = props;
        if (!isMinuteDisabled)
          return false;
        return isMinuteDisabled(minuteValue, hourValue);
      });
      const isSecondInvalidRef = vue.computed(() => {
        const {
          value: minuteValue
        } = minuteValueRef;
        const {
          value: hourValue
        } = hourValueRef;
        const {
          value: secondValue
        } = secondValueRef;
        if (secondValue === null || minuteValue === null || hourValue === null) {
          return false;
        }
        if (!isTimeInStep(secondValue, "seconds", props.seconds))
          return true;
        const {
          isSecondDisabled
        } = props;
        if (!isSecondDisabled)
          return false;
        return isSecondDisabled(secondValue, minuteValue, hourValue);
      });
      const isValueInvalidRef = vue.computed(() => {
        return isHourInvalidRef.value || isMinuteInvalidRef.value || isSecondInvalidRef.value;
      });
      const mergedAttrSizeRef = vue.computed(() => {
        return props.format.length + 4;
      });
      const amPmValueRef = vue.computed(() => {
        const {
          value
        } = mergedValueRef;
        if (value === null)
          return null;
        return getHours(value) < 12 ? "am" : "pm";
      });
      function doUpdateFormattedValue(value, timestampValue) {
        const {
          onUpdateFormattedValue,
          "onUpdate:formattedValue": _onUpdateFormattedValue
        } = props;
        if (onUpdateFormattedValue) {
          call(onUpdateFormattedValue, value, timestampValue);
        }
        if (_onUpdateFormattedValue) {
          call(_onUpdateFormattedValue, value, timestampValue);
        }
      }
      function createFormattedValue(value) {
        return value === null ? null : mergedFormatRef.value(value, props.valueFormat || props.format);
      }
      function doUpdateValue(value) {
        const {
          onUpdateValue,
          "onUpdate:value": _onUpdateValue,
          onChange
        } = props;
        const {
          nTriggerFormChange,
          nTriggerFormInput
        } = formItem;
        const formattedValue = createFormattedValue(value);
        if (onUpdateValue) {
          call(onUpdateValue, value, formattedValue);
        }
        if (_onUpdateValue) {
          call(_onUpdateValue, value, formattedValue);
        }
        if (onChange)
          call(onChange, value, formattedValue);
        doUpdateFormattedValue(formattedValue, value);
        uncontrolledValueRef.value = value;
        nTriggerFormChange();
        nTriggerFormInput();
      }
      function doFocus(e) {
        const {
          onFocus
        } = props;
        const {
          nTriggerFormFocus
        } = formItem;
        if (onFocus)
          call(onFocus, e);
        nTriggerFormFocus();
      }
      function doBlur(e) {
        const {
          onBlur
        } = props;
        const {
          nTriggerFormBlur
        } = formItem;
        if (onBlur)
          call(onBlur, e);
        nTriggerFormBlur();
      }
      function doConfirm() {
        const {
          onConfirm
        } = props;
        if (onConfirm) {
          call(onConfirm, mergedValueRef.value, createFormattedValue(mergedValueRef.value));
        }
      }
      function handleTimeInputClear(e) {
        var _a;
        e.stopPropagation();
        doUpdateValue(null);
        deriveInputValue(null);
        (_a = props.onClear) === null || _a === void 0 ? void 0 : _a.call(props);
      }
      function handleFocusDetectorFocus() {
        closePanel({
          returnFocus: true
        });
      }
      function clearSelectedValue() {
        doUpdateValue(null);
        deriveInputValue(null);
        closePanel({
          returnFocus: true
        });
      }
      function handleInputKeydown(e) {
        if (e.key === "Escape" && mergedShowRef.value) {
          markEventEffectPerformed(e);
        }
      }
      function handleMenuKeydown(e) {
        var _a;
        switch (e.key) {
          case "Escape":
            if (mergedShowRef.value) {
              markEventEffectPerformed(e);
              closePanel({
                returnFocus: true
              });
            }
            break;
          case "Tab":
            if (keyboardState.shift && e.target === ((_a = panelInstRef.value) === null || _a === void 0 ? void 0 : _a.$el)) {
              e.preventDefault();
              closePanel({
                returnFocus: true
              });
            }
            break;
        }
      }
      function disableTransitionOneTick() {
        transitionDisabledRef.value = true;
        void vue.nextTick(() => {
          transitionDisabledRef.value = false;
        });
      }
      function handleTriggerClick(e) {
        if (mergedDisabledRef.value || happensIn(e, "clear"))
          return;
        if (!mergedShowRef.value) {
          openPanel();
        }
      }
      function handleHourClick(hour) {
        if (typeof hour === "string")
          return;
        if (mergedValueRef.value === null) {
          doUpdateValue(getTime(setHours(startOfHour(/* @__PURE__ */ new Date()), hour)));
        } else {
          doUpdateValue(getTime(setHours(mergedValueRef.value, hour)));
        }
      }
      function handleMinuteClick(minute) {
        if (typeof minute === "string")
          return;
        if (mergedValueRef.value === null) {
          doUpdateValue(getTime(setMinutes(startOfMinute(/* @__PURE__ */ new Date()), minute)));
        } else {
          doUpdateValue(getTime(setMinutes(mergedValueRef.value, minute)));
        }
      }
      function handleSecondClick(second) {
        if (typeof second === "string")
          return;
        if (mergedValueRef.value === null) {
          doUpdateValue(getTime(setSeconds(startOfSecond(/* @__PURE__ */ new Date()), second)));
        } else {
          doUpdateValue(getTime(setSeconds(mergedValueRef.value, second)));
        }
      }
      function handleAmPmClick(amPm) {
        const {
          value: mergedValue
        } = mergedValueRef;
        if (mergedValue === null) {
          const now2 = /* @__PURE__ */ new Date();
          const hours = getHours(now2);
          if (amPm === "pm" && hours < 12) {
            doUpdateValue(getTime(setHours(now2, hours + 12)));
          } else if (amPm === "am" && hours >= 12) {
            doUpdateValue(getTime(setHours(now2, hours - 12)));
          }
          doUpdateValue(getTime(now2));
        } else {
          const hours = getHours(mergedValue);
          if (amPm === "pm" && hours < 12) {
            doUpdateValue(getTime(setHours(mergedValue, hours + 12)));
          } else if (amPm === "am" && hours >= 12) {
            doUpdateValue(getTime(setHours(mergedValue, hours - 12)));
          }
        }
      }
      function deriveInputValue(time2) {
        if (time2 === void 0)
          time2 = mergedValueRef.value;
        if (time2 === null) {
          displayTimeStringRef.value = "";
        } else {
          displayTimeStringRef.value = mergedFormatRef.value(time2, props.format, dateFnsOptionsRef.value);
        }
      }
      function handleTimeInputFocus(e) {
        if (isInternalFocusSwitch(e))
          return;
        doFocus(e);
      }
      function handleTimeInputBlur(e) {
        var _a;
        if (isInternalFocusSwitch(e))
          return;
        if (mergedShowRef.value) {
          const panelEl = (_a = panelInstRef.value) === null || _a === void 0 ? void 0 : _a.$el;
          if (!(panelEl === null || panelEl === void 0 ? void 0 : panelEl.contains(e.relatedTarget))) {
            deriveInputValue();
            doBlur(e);
            closePanel({
              returnFocus: false
            });
          }
        } else {
          deriveInputValue();
          doBlur(e);
        }
      }
      function handleTimeInputActivate() {
        if (mergedDisabledRef.value)
          return;
        if (!mergedShowRef.value) {
          openPanel();
        }
      }
      function handleTimeInputDeactivate() {
        if (mergedDisabledRef.value)
          return;
        deriveInputValue();
        closePanel({
          returnFocus: false
        });
      }
      function scrollTimer() {
        if (!panelInstRef.value)
          return;
        const {
          hourScrollRef,
          minuteScrollRef,
          secondScrollRef,
          amPmScrollRef
        } = panelInstRef.value;
        [hourScrollRef, minuteScrollRef, secondScrollRef, amPmScrollRef].forEach((itemScrollRef) => {
          var _a;
          if (!itemScrollRef)
            return;
          const activeItemEl = (_a = itemScrollRef.contentRef) === null || _a === void 0 ? void 0 : _a.querySelector("[data-active]");
          if (activeItemEl) {
            itemScrollRef.scrollTo({
              top: activeItemEl.offsetTop
            });
          }
        });
      }
      function doUpdateShow(value) {
        uncontrolledShowRef.value = value;
        const {
          onUpdateShow,
          "onUpdate:show": _onUpdateShow
        } = props;
        if (onUpdateShow)
          call(onUpdateShow, value);
        if (_onUpdateShow)
          call(_onUpdateShow, value);
      }
      function isInternalFocusSwitch(e) {
        var _a, _b, _c;
        return !!(((_b = (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.wrapperElRef) === null || _b === void 0 ? void 0 : _b.contains(e.relatedTarget)) || ((_c = panelInstRef.value) === null || _c === void 0 ? void 0 : _c.$el.contains(e.relatedTarget)));
      }
      function openPanel() {
        memorizedValueRef.value = mergedValueRef.value;
        doUpdateShow(true);
        void vue.nextTick(scrollTimer);
      }
      function handleClickOutside(e) {
        var _a, _b;
        if (mergedShowRef.value && !((_b = (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.wrapperElRef) === null || _b === void 0 ? void 0 : _b.contains(getPreciseEventTarget(e)))) {
          closePanel({
            returnFocus: false
          });
        }
      }
      function closePanel({
        returnFocus
      }) {
        var _a;
        if (mergedShowRef.value) {
          doUpdateShow(false);
          if (returnFocus) {
            (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
          }
        }
      }
      function handleTimeInputUpdateValue(v) {
        if (v === "") {
          doUpdateValue(null);
          return;
        }
        const time2 = strictParse(v, props.format, /* @__PURE__ */ new Date(), dateFnsOptionsRef.value);
        displayTimeStringRef.value = v;
        if (isValid(time2)) {
          const {
            value: mergedValue
          } = mergedValueRef;
          if (mergedValue !== null) {
            const newTime = set(mergedValue, {
              hours: getHours(time2),
              minutes: getMinutes(time2),
              seconds: getSeconds(time2),
              milliseconds: getMilliseconds(time2)
            });
            doUpdateValue(getTime(newTime));
          } else {
            doUpdateValue(getTime(time2));
          }
        }
      }
      function handleCancelClick() {
        doUpdateValue(memorizedValueRef.value);
        doUpdateShow(false);
      }
      function handleNowClick() {
        const now2 = /* @__PURE__ */ new Date();
        const getNowTime = {
          hours: getHours,
          minutes: getMinutes,
          seconds: getSeconds
        };
        const [mergeHours, mergeMinutes, mergeSeconds] = ["hours", "minutes", "seconds"].map((i) => !props[i] || isTimeInStep(getNowTime[i](now2), i, props[i]) ? getNowTime[i](now2) : findSimilarTime(getNowTime[i](now2), i, props[i]));
        const newValue = setSeconds(setMinutes(setHours(mergedValueRef.value ? mergedValueRef.value : getTime(now2), mergeHours), mergeMinutes), mergeSeconds);
        doUpdateValue(getTime(newValue));
      }
      function handleConfirmClick() {
        deriveInputValue();
        doConfirm();
        closePanel({
          returnFocus: true
        });
      }
      function handleMenuFocusOut(e) {
        if (isInternalFocusSwitch(e))
          return;
        deriveInputValue();
        doBlur(e);
        closePanel({
          returnFocus: false
        });
      }
      vue.watch(mergedValueRef, (value) => {
        deriveInputValue(value);
        disableTransitionOneTick();
        void vue.nextTick(scrollTimer);
      });
      vue.watch(mergedShowRef, () => {
        if (isValueInvalidRef.value) {
          doUpdateValue(memorizedValueRef.value);
        }
      });
      vue.provide(timePickerInjectionKey, {
        mergedThemeRef: themeRef,
        mergedClsPrefixRef
      });
      const exposedMethods = {
        focus: () => {
          var _a;
          (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
        },
        blur: () => {
          var _a;
          (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.blur();
        }
      };
      const triggerCssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            iconColor,
            iconColorDisabled
          }
        } = themeRef.value;
        return {
          "--n-icon-color-override": iconColor,
          "--n-icon-color-disabled-override": iconColorDisabled,
          "--n-bezier": cubicBezierEaseInOut2
        };
      });
      const triggerThemeClassHandle = inlineThemeDisabled ? useThemeClass("time-picker-trigger", void 0, triggerCssVarsRef, props) : void 0;
      const cssVarsRef = vue.computed(() => {
        const {
          self: {
            panelColor,
            itemTextColor,
            itemTextColorActive,
            itemColorHover,
            panelDividerColor,
            panelBoxShadow,
            itemOpacityDisabled,
            borderRadius,
            itemFontSize,
            itemWidth,
            itemHeight,
            panelActionPadding,
            itemBorderRadius
          },
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-border-radius": borderRadius,
          "--n-item-color-hover": itemColorHover,
          "--n-item-font-size": itemFontSize,
          "--n-item-height": itemHeight,
          "--n-item-opacity-disabled": itemOpacityDisabled,
          "--n-item-text-color": itemTextColor,
          "--n-item-text-color-active": itemTextColorActive,
          "--n-item-width": itemWidth,
          "--n-panel-action-padding": panelActionPadding,
          "--n-panel-box-shadow": panelBoxShadow,
          "--n-panel-color": panelColor,
          "--n-panel-divider-color": panelDividerColor,
          "--n-item-border-radius": itemBorderRadius
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("time-picker", void 0, cssVarsRef, props) : void 0;
      return {
        focus: exposedMethods.focus,
        blur: exposedMethods.blur,
        mergedStatus: mergedStatusRef,
        mergedBordered: mergedBorderedRef,
        mergedClsPrefix: mergedClsPrefixRef,
        namespace: namespaceRef,
        uncontrolledValue: uncontrolledValueRef,
        mergedValue: mergedValueRef,
        isMounted: isMounted(),
        inputInstRef,
        panelInstRef,
        adjustedTo: useAdjustedTo(props),
        mergedShow: mergedShowRef,
        localizedClear: localizedClearRef,
        localizedNow: localizedNowRef,
        localizedPlaceholder: localizedPlaceholderRef,
        localizedNegativeText: localizedNegativeTextRef,
        localizedPositiveText: localizedPositiveTextRef,
        hourInFormat: hourInFormatRef,
        minuteInFormat: minuteInFormatRef,
        secondInFormat: secondInFormatRef,
        mergedAttrSize: mergedAttrSizeRef,
        displayTimeString: displayTimeStringRef,
        mergedSize: mergedSizeRef,
        mergedDisabled: mergedDisabledRef,
        isValueInvalid: isValueInvalidRef,
        isHourInvalid: isHourInvalidRef,
        isMinuteInvalid: isMinuteInvalidRef,
        isSecondInvalid: isSecondInvalidRef,
        transitionDisabled: transitionDisabledRef,
        hourValue: hourValueRef,
        minuteValue: minuteValueRef,
        secondValue: secondValueRef,
        amPmValue: amPmValueRef,
        handleInputKeydown,
        handleTimeInputFocus,
        handleTimeInputBlur,
        handleNowClick,
        handleConfirmClick,
        handleTimeInputUpdateValue,
        handleMenuFocusOut,
        handleCancelClick,
        handleClickOutside,
        handleTimeInputActivate,
        handleTimeInputDeactivate,
        handleHourClick,
        handleMinuteClick,
        handleSecondClick,
        handleAmPmClick,
        handleTimeInputClear,
        handleFocusDetectorFocus,
        handleMenuKeydown,
        handleTriggerClick,
        mergedTheme: themeRef,
        triggerCssVars: inlineThemeDisabled ? void 0 : triggerCssVarsRef,
        triggerThemeClass: triggerThemeClassHandle === null || triggerThemeClassHandle === void 0 ? void 0 : triggerThemeClassHandle.themeClass,
        triggerOnRender: triggerThemeClassHandle === null || triggerThemeClassHandle === void 0 ? void 0 : triggerThemeClassHandle.onRender,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
        clearSelectedValue
      };
    },
    render() {
      const {
        mergedClsPrefix,
        $slots,
        triggerOnRender
      } = this;
      triggerOnRender === null || triggerOnRender === void 0 ? void 0 : triggerOnRender();
      return vue.h("div", {
        class: [`${mergedClsPrefix}-time-picker`, this.triggerThemeClass],
        style: this.triggerCssVars
      }, vue.h(VBinder, null, {
        default: () => [vue.h(VTarget, null, {
          default: () => vue.h(NInput, {
            ref: "inputInstRef",
            status: this.mergedStatus,
            value: this.displayTimeString,
            bordered: this.mergedBordered,
            passivelyActivated: true,
            attrSize: this.mergedAttrSize,
            theme: this.mergedTheme.peers.Input,
            themeOverrides: this.mergedTheme.peerOverrides.Input,
            stateful: this.stateful,
            size: this.mergedSize,
            placeholder: this.localizedPlaceholder,
            clearable: this.clearable,
            disabled: this.mergedDisabled,
            textDecoration: this.isValueInvalid ? "line-through" : void 0,
            onFocus: this.handleTimeInputFocus,
            onBlur: this.handleTimeInputBlur,
            onActivate: this.handleTimeInputActivate,
            onDeactivate: this.handleTimeInputDeactivate,
            onUpdateValue: this.handleTimeInputUpdateValue,
            onClear: this.handleTimeInputClear,
            internalDeactivateOnEnter: true,
            internalForceFocus: this.mergedShow,
            readonly: this.inputReadonly || this.mergedDisabled,
            onClick: this.handleTriggerClick,
            onKeydown: this.handleInputKeydown
          }, this.showIcon ? {
            [this.clearable ? "clear-icon-placeholder" : "suffix"]: () => vue.h(NBaseIcon, {
              clsPrefix: mergedClsPrefix,
              class: `${mergedClsPrefix}-time-picker-icon`
            }, {
              default: () => $slots.icon ? $slots.icon() : vue.h(TimeIcon, null)
            })
          } : null)
        }), vue.h(VFollower, {
          teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey,
          show: this.mergedShow,
          to: this.adjustedTo,
          containerClass: this.namespace,
          placement: this.placement
        }, {
          default: () => vue.h(vue.Transition, {
            name: "fade-in-scale-up-transition",
            appear: this.isMounted
          }, {
            default: () => {
              var _a;
              if (this.mergedShow) {
                (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
                return vue.withDirectives(vue.h(Panel, {
                  ref: "panelInstRef",
                  actions: this.actions,
                  class: this.themeClass,
                  style: this.cssVars,
                  seconds: this.seconds,
                  minutes: this.minutes,
                  hours: this.hours,
                  transitionDisabled: this.transitionDisabled,
                  hourValue: this.hourValue,
                  showHour: this.hourInFormat,
                  isHourInvalid: this.isHourInvalid,
                  isHourDisabled: this.isHourDisabled,
                  minuteValue: this.minuteValue,
                  showMinute: this.minuteInFormat,
                  isMinuteInvalid: this.isMinuteInvalid,
                  isMinuteDisabled: this.isMinuteDisabled,
                  secondValue: this.secondValue,
                  amPmValue: this.amPmValue,
                  showSecond: this.secondInFormat,
                  isSecondInvalid: this.isSecondInvalid,
                  isSecondDisabled: this.isSecondDisabled,
                  isValueInvalid: this.isValueInvalid,
                  clearText: this.localizedClear,
                  nowText: this.localizedNow,
                  confirmText: this.localizedPositiveText,
                  use12Hours: this.use12Hours,
                  onFocusout: this.handleMenuFocusOut,
                  onKeydown: this.handleMenuKeydown,
                  onHourClick: this.handleHourClick,
                  onMinuteClick: this.handleMinuteClick,
                  onSecondClick: this.handleSecondClick,
                  onAmPmClick: this.handleAmPmClick,
                  onNowClick: this.handleNowClick,
                  onConfirmClick: this.handleConfirmClick,
                  onClearClick: this.clearSelectedValue,
                  onFocusDetectorFocus: this.handleFocusDetectorFocus
                }), [[clickoutside$1, this.handleClickOutside, void 0, {
                  capture: true
                }]]);
              }
              return null;
            }
          })
        })]
      }));
    }
  });
  const MONTH_ITEM_HEIGHT = 40;
  const TIME_FORMAT = "HH:mm:ss";
  const usePanelCommonProps = {
    active: Boolean,
    dateFormat: String,
    timerPickerFormat: {
      type: String,
      value: TIME_FORMAT
    },
    value: {
      type: [Array, Number],
      default: null
    },
    shortcuts: Object,
    defaultTime: [Number, String, Array],
    inputReadonly: Boolean,
    onClear: Function,
    onConfirm: Function,
    onClose: Function,
    onTabOut: Function,
    onUpdateValue: {
      type: Function,
      required: true
    },
    themeClass: String,
    onRender: Function,
    panel: Boolean,
    onNextMonth: Function,
    onPrevMonth: Function,
    onNextYear: Function,
    onPrevYear: Function
  };
  function usePanelCommon(props) {
    const {
      dateLocaleRef,
      timePickerSizeRef,
      timePickerPropsRef,
      localeRef,
      mergedClsPrefixRef,
      mergedThemeRef
    } = vue.inject(datePickerInjectionKey);
    const dateFnsOptionsRef = vue.computed(() => {
      return {
        locale: dateLocaleRef.value.locale
      };
    });
    const selfRef = vue.ref(null);
    const keyboardState = useKeyboard$1();
    function doClear() {
      const {
        onClear
      } = props;
      if (onClear)
        onClear();
    }
    function doConfirm() {
      const {
        onConfirm,
        value
      } = props;
      if (onConfirm)
        onConfirm(value);
    }
    function doUpdateValue(value, doUpdate) {
      const {
        onUpdateValue
      } = props;
      onUpdateValue(value, doUpdate);
    }
    function doClose(disableUpdateOnClose = false) {
      const {
        onClose
      } = props;
      if (onClose)
        onClose(disableUpdateOnClose);
    }
    function doTabOut() {
      const {
        onTabOut
      } = props;
      if (onTabOut)
        onTabOut();
    }
    function handleClearClick() {
      doUpdateValue(null, true);
      doClose(true);
      doClear();
    }
    function handleFocusDetectorFocus() {
      doTabOut();
    }
    function disableTransitionOneTick() {
      if (props.active || props.panel) {
        void vue.nextTick(() => {
          const {
            value: selfEl
          } = selfRef;
          if (!selfEl)
            return;
          const dateEls = selfEl.querySelectorAll("[data-n-date]");
          dateEls.forEach((el) => {
            el.classList.add("transition-disabled");
          });
          void selfEl.offsetWidth;
          dateEls.forEach((el) => {
            el.classList.remove("transition-disabled");
          });
        });
      }
    }
    function handlePanelKeyDown(e) {
      if (e.key === "Tab" && e.target === selfRef.value && keyboardState.shift) {
        e.preventDefault();
        doTabOut();
      }
    }
    function handlePanelFocus(e) {
      const {
        value: el
      } = selfRef;
      if (keyboardState.tab && e.target === el && (el === null || el === void 0 ? void 0 : el.contains(e.relatedTarget))) {
        doTabOut();
      }
    }
    let cachedValue = null;
    let cached = false;
    function cachePendingValue() {
      cachedValue = props.value;
      cached = true;
    }
    function clearPendingValue() {
      cached = false;
    }
    function restorePendingValue() {
      if (cached) {
        doUpdateValue(cachedValue, false);
        cached = false;
      }
    }
    function getShortcutValue(shortcut) {
      if (typeof shortcut === "function") {
        return shortcut();
      }
      return shortcut;
    }
    const showMonthYearPanel = vue.ref(false);
    function handleOpenQuickSelectMonthPanel() {
      showMonthYearPanel.value = !showMonthYearPanel.value;
    }
    return {
      mergedTheme: mergedThemeRef,
      mergedClsPrefix: mergedClsPrefixRef,
      dateFnsOptions: dateFnsOptionsRef,
      timePickerSize: timePickerSizeRef,
      timePickerProps: timePickerPropsRef,
      selfRef,
      locale: localeRef,
      doConfirm,
      doClose,
      doUpdateValue,
      doTabOut,
      handleClearClick,
      handleFocusDetectorFocus,
      disableTransitionOneTick,
      handlePanelKeyDown,
      handlePanelFocus,
      cachePendingValue,
      clearPendingValue,
      restorePendingValue,
      getShortcutValue,
      handleShortcutMouseleave: restorePendingValue,
      showMonthYearPanel,
      handleOpenQuickSelectMonthPanel
    };
  }
  const useCalendarProps = Object.assign(Object.assign({}, usePanelCommonProps), {
    defaultCalendarStartTime: Number,
    actions: {
      type: Array,
      default: () => ["now", "clear", "confirm"]
    }
  });
  function useCalendar(props, type) {
    var _a;
    const panelCommon = usePanelCommon(props);
    const {
      isValueInvalidRef,
      isDateDisabledRef,
      isDateInvalidRef,
      isTimeInvalidRef,
      isDateTimeInvalidRef,
      isHourDisabledRef,
      isMinuteDisabledRef,
      isSecondDisabledRef,
      localeRef,
      firstDayOfWeekRef,
      datePickerSlots,
      yearFormatRef,
      monthFormatRef,
      quarterFormatRef,
      yearRangeRef
    } = vue.inject(datePickerInjectionKey);
    const validation = {
      isValueInvalid: isValueInvalidRef,
      isDateDisabled: isDateDisabledRef,
      isDateInvalid: isDateInvalidRef,
      isTimeInvalid: isTimeInvalidRef,
      isDateTimeInvalid: isDateTimeInvalidRef,
      isHourDisabled: isHourDisabledRef,
      isMinuteDisabled: isMinuteDisabledRef,
      isSecondDisabled: isSecondDisabledRef
    };
    const mergedDateFormatRef = vue.computed(() => props.dateFormat || localeRef.value.dateFormat);
    const dateInputValueRef = vue.ref(props.value === null || Array.isArray(props.value) ? "" : format$3(props.value, mergedDateFormatRef.value));
    const calendarValueRef = vue.ref(props.value === null || Array.isArray(props.value) ? (_a = props.defaultCalendarStartTime) !== null && _a !== void 0 ? _a : Date.now() : props.value);
    const yearVlRef = vue.ref(null);
    const yearScrollbarRef = vue.ref(null);
    const monthScrollbarRef = vue.ref(null);
    const nowRef = vue.ref(Date.now());
    const dateArrayRef = vue.computed(() => {
      var _a2;
      return dateArray(calendarValueRef.value, props.value, nowRef.value, (_a2 = firstDayOfWeekRef.value) !== null && _a2 !== void 0 ? _a2 : localeRef.value.firstDayOfWeek, false, type === "week");
    });
    const monthArrayRef = vue.computed(() => {
      const {
        value
      } = props;
      return monthArray(calendarValueRef.value, Array.isArray(value) ? null : value, nowRef.value, {
        monthFormat: monthFormatRef.value
      });
    });
    const yearArrayRef = vue.computed(() => {
      const {
        value
      } = props;
      return yearArray(Array.isArray(value) ? null : value, nowRef.value, {
        yearFormat: yearFormatRef.value
      }, yearRangeRef);
    });
    const quarterArrayRef = vue.computed(() => {
      const {
        value
      } = props;
      return quarterArray(calendarValueRef.value, Array.isArray(value) ? null : value, nowRef.value, {
        quarterFormat: quarterFormatRef.value
      });
    });
    const weekdaysRef = vue.computed(() => {
      return dateArrayRef.value.slice(0, 7).map((dateItem2) => {
        const {
          ts
        } = dateItem2;
        return format$3(ts, localeRef.value.dayFormat, panelCommon.dateFnsOptions.value);
      });
    });
    const calendarMonthRef = vue.computed(() => {
      return format$3(calendarValueRef.value, localeRef.value.monthFormat, panelCommon.dateFnsOptions.value);
    });
    const calendarYearRef = vue.computed(() => {
      return format$3(calendarValueRef.value, localeRef.value.yearFormat, panelCommon.dateFnsOptions.value);
    });
    vue.watch(calendarValueRef, (value, oldValue) => {
      if (type === "date" || type === "datetime") {
        if (!isSameMonth(value, oldValue)) {
          panelCommon.disableTransitionOneTick();
        }
      }
    });
    vue.watch(vue.computed(() => props.value), (value) => {
      if (value !== null && !Array.isArray(value)) {
        dateInputValueRef.value = format$3(value, mergedDateFormatRef.value, panelCommon.dateFnsOptions.value);
        calendarValueRef.value = value;
      } else {
        dateInputValueRef.value = "";
      }
    });
    function sanitizeValue(value) {
      var _a2;
      if (type === "datetime")
        return getTime(startOfSecond(value));
      if (type === "month")
        return getTime(startOfMonth(value));
      if (type === "year")
        return getTime(startOfYear(value));
      if (type === "quarter")
        return getTime(startOfQuarter(value));
      if (type === "week") {
        const weekStartsOn = (((_a2 = firstDayOfWeekRef.value) !== null && _a2 !== void 0 ? _a2 : localeRef.value.firstDayOfWeek) + 1) % 7;
        return getTime(startOfWeek(value, {
          weekStartsOn
        }));
      }
      return getTime(startOfDay(value));
    }
    function mergedIsDateDisabled(ts, detail) {
      const {
        isDateDisabled: {
          value: isDateDisabled
        }
      } = validation;
      if (!isDateDisabled)
        return false;
      return isDateDisabled(ts, detail);
    }
    function handleDateInput(value) {
      const date = strictParse(value, mergedDateFormatRef.value, /* @__PURE__ */ new Date(), panelCommon.dateFnsOptions.value);
      if (isValid(date)) {
        if (props.value === null) {
          panelCommon.doUpdateValue(getTime(sanitizeValue(Date.now())), props.panel);
        } else if (!Array.isArray(props.value)) {
          const newDateTime = set(props.value, {
            year: getYear(date),
            month: getMonth(date),
            date: getDate(date)
          });
          panelCommon.doUpdateValue(getTime(sanitizeValue(getTime(newDateTime))), props.panel);
        }
      } else {
        dateInputValueRef.value = value;
      }
    }
    function handleDateInputBlur() {
      const date = strictParse(dateInputValueRef.value, mergedDateFormatRef.value, /* @__PURE__ */ new Date(), panelCommon.dateFnsOptions.value);
      if (isValid(date)) {
        if (props.value === null) {
          panelCommon.doUpdateValue(getTime(sanitizeValue(Date.now())), false);
        } else if (!Array.isArray(props.value)) {
          const newDateTime = set(props.value, {
            year: getYear(date),
            month: getMonth(date),
            date: getDate(date)
          });
          panelCommon.doUpdateValue(getTime(sanitizeValue(getTime(newDateTime))), false);
        }
      } else {
        deriveDateInputValue();
      }
    }
    function clearSelectedDateTime() {
      panelCommon.doUpdateValue(null, true);
      dateInputValueRef.value = "";
      panelCommon.doClose(true);
      panelCommon.handleClearClick();
    }
    function handleNowClick() {
      panelCommon.doUpdateValue(getTime(sanitizeValue(Date.now())), true);
      const now2 = Date.now();
      calendarValueRef.value = now2;
      panelCommon.doClose(true);
      if (props.panel && (type === "month" || type === "quarter" || type === "year")) {
        panelCommon.disableTransitionOneTick();
        justifyColumnsScrollState(now2);
      }
    }
    const hoveredWeekRef = vue.ref(null);
    function handleDateMouseEnter(dateItem2) {
      if (dateItem2.type === "date" && type === "week") {
        hoveredWeekRef.value = sanitizeValue(getTime(dateItem2.ts));
      }
    }
    function isWeekHovered(dateItem2) {
      if (dateItem2.type === "date" && type === "week") {
        return sanitizeValue(getTime(dateItem2.ts)) === hoveredWeekRef.value;
      }
      return false;
    }
    function handleDateClick(dateItem2) {
      if (mergedIsDateDisabled(dateItem2.ts, dateItem2.type === "date" ? {
        type: "date",
        year: dateItem2.dateObject.year,
        month: dateItem2.dateObject.month,
        date: dateItem2.dateObject.date
      } : dateItem2.type === "month" ? {
        type: "month",
        year: dateItem2.dateObject.year,
        month: dateItem2.dateObject.month
      } : dateItem2.type === "year" ? {
        type: "year",
        year: dateItem2.dateObject.year
      } : {
        type: "quarter",
        year: dateItem2.dateObject.year,
        quarter: dateItem2.dateObject.quarter
      })) {
        return;
      }
      let newValue;
      if (props.value !== null && !Array.isArray(props.value)) {
        newValue = props.value;
      } else {
        newValue = Date.now();
      }
      if (type === "datetime" && props.defaultTime !== null && !Array.isArray(props.defaultTime)) {
        const time2 = getDefaultTime(props.defaultTime);
        if (time2) {
          newValue = getTime(set(newValue, time2));
        }
      }
      newValue = getTime(dateItem2.type === "quarter" && dateItem2.dateObject.quarter ? setQuarter(setYear(newValue, dateItem2.dateObject.year), dateItem2.dateObject.quarter) : set(newValue, dateItem2.dateObject));
      panelCommon.doUpdateValue(sanitizeValue(newValue), props.panel || type === "date" || type === "week" || type === "year");
      switch (type) {
        case "date":
        case "week":
          panelCommon.doClose();
          break;
        case "year":
          if (props.panel) {
            panelCommon.disableTransitionOneTick();
          }
          panelCommon.doClose();
          break;
        case "month":
          panelCommon.disableTransitionOneTick();
          justifyColumnsScrollState(newValue);
          break;
        case "quarter":
          panelCommon.disableTransitionOneTick();
          justifyColumnsScrollState(newValue);
          break;
      }
    }
    function handleQuickMonthClick(dateItem2, updatePanelValue) {
      let newValue;
      if (props.value !== null && !Array.isArray(props.value)) {
        newValue = props.value;
      } else {
        newValue = Date.now();
      }
      newValue = getTime(dateItem2.type === "month" ? setMonth(newValue, dateItem2.dateObject.month) : setYear(newValue, dateItem2.dateObject.year));
      updatePanelValue(newValue);
      justifyColumnsScrollState(newValue);
    }
    function onUpdateCalendarValue(value) {
      calendarValueRef.value = value;
    }
    function deriveDateInputValue(time2) {
      if (props.value === null || Array.isArray(props.value)) {
        dateInputValueRef.value = "";
        return;
      }
      if (time2 === void 0) {
        time2 = props.value;
      }
      dateInputValueRef.value = format$3(time2, mergedDateFormatRef.value, panelCommon.dateFnsOptions.value);
    }
    function handleConfirmClick() {
      if (validation.isDateInvalid.value || validation.isTimeInvalid.value) {
        return;
      }
      panelCommon.doConfirm();
      closeCalendar();
    }
    function closeCalendar() {
      if (props.active) {
        panelCommon.doClose();
      }
    }
    function nextYear() {
      var _a2;
      calendarValueRef.value = getTime(addYears(calendarValueRef.value, 1));
      (_a2 = props.onNextYear) === null || _a2 === void 0 ? void 0 : _a2.call(props);
    }
    function prevYear() {
      var _a2;
      calendarValueRef.value = getTime(addYears(calendarValueRef.value, -1));
      (_a2 = props.onPrevYear) === null || _a2 === void 0 ? void 0 : _a2.call(props);
    }
    function nextMonth() {
      var _a2;
      calendarValueRef.value = getTime(addMonths(calendarValueRef.value, 1));
      (_a2 = props.onNextMonth) === null || _a2 === void 0 ? void 0 : _a2.call(props);
    }
    function prevMonth() {
      var _a2;
      calendarValueRef.value = getTime(addMonths(calendarValueRef.value, -1));
      (_a2 = props.onPrevMonth) === null || _a2 === void 0 ? void 0 : _a2.call(props);
    }
    function virtualListContainer() {
      const {
        value
      } = yearVlRef;
      return (value === null || value === void 0 ? void 0 : value.listElRef) || null;
    }
    function virtualListContent() {
      const {
        value
      } = yearVlRef;
      return (value === null || value === void 0 ? void 0 : value.itemsElRef) || null;
    }
    function handleVirtualListScroll() {
      var _a2;
      (_a2 = yearScrollbarRef.value) === null || _a2 === void 0 ? void 0 : _a2.sync();
    }
    function handleTimePickerChange(value) {
      if (value === null)
        return;
      panelCommon.doUpdateValue(value, props.panel);
    }
    function handleSingleShortcutMouseenter(shortcut) {
      panelCommon.cachePendingValue();
      const shortcutValue = panelCommon.getShortcutValue(shortcut);
      if (typeof shortcutValue !== "number")
        return;
      panelCommon.doUpdateValue(shortcutValue, false);
    }
    function handleSingleShortcutClick(shortcut) {
      const shortcutValue = panelCommon.getShortcutValue(shortcut);
      if (typeof shortcutValue !== "number")
        return;
      panelCommon.doUpdateValue(shortcutValue, props.panel);
      panelCommon.clearPendingValue();
      handleConfirmClick();
    }
    function justifyColumnsScrollState(value) {
      const {
        value: mergedValue
      } = props;
      if (monthScrollbarRef.value) {
        const monthIndex = value === void 0 ? mergedValue === null ? getMonth(Date.now()) : getMonth(mergedValue) : getMonth(value);
        monthScrollbarRef.value.scrollTo({
          top: monthIndex * MONTH_ITEM_HEIGHT
        });
      }
      if (yearVlRef.value) {
        const yearIndex = (value === void 0 ? mergedValue === null ? getYear(Date.now()) : getYear(mergedValue) : getYear(value)) - yearRangeRef.value[0];
        yearVlRef.value.scrollTo({
          top: yearIndex * MONTH_ITEM_HEIGHT
        });
      }
    }
    const childComponentRefs = {
      monthScrollbarRef,
      yearScrollbarRef,
      yearVlRef
    };
    return Object.assign(Object.assign(Object.assign(Object.assign({
      dateArray: dateArrayRef,
      monthArray: monthArrayRef,
      yearArray: yearArrayRef,
      quarterArray: quarterArrayRef,
      calendarYear: calendarYearRef,
      calendarMonth: calendarMonthRef,
      weekdays: weekdaysRef,
      mergedIsDateDisabled,
      nextYear,
      prevYear,
      nextMonth,
      prevMonth,
      handleNowClick,
      handleConfirmClick,
      handleSingleShortcutMouseenter,
      handleSingleShortcutClick
    }, validation), panelCommon), childComponentRefs), {
      // datetime only
      handleDateClick,
      handleDateInputBlur,
      handleDateInput,
      handleDateMouseEnter,
      isWeekHovered,
      handleTimePickerChange,
      clearSelectedDateTime,
      virtualListContainer,
      virtualListContent,
      handleVirtualListScroll,
      timePickerSize: panelCommon.timePickerSize,
      dateInputValue: dateInputValueRef,
      datePickerSlots,
      handleQuickMonthClick,
      justifyColumnsScrollState,
      calendarValue: calendarValueRef,
      onUpdateCalendarValue
    });
  }
  const MonthPanel = vue.defineComponent({
    name: "MonthPanel",
    props: Object.assign(Object.assign({}, useCalendarProps), {
      type: {
        type: String,
        required: true
      },
      // panelHeader prop
      useAsQuickJump: Boolean
    }),
    setup(props) {
      const useCalendarRef = useCalendar(props, props.type);
      const {
        dateLocaleRef
      } = useLocale("DatePicker");
      const getRenderContent = (item) => {
        switch (item.type) {
          case "year":
            return getYearString(item.dateObject.year, item.yearFormat, dateLocaleRef.value.locale);
          case "month":
            return getMonthString(item.dateObject.month, item.monthFormat, dateLocaleRef.value.locale);
          case "quarter":
            return getQuarterString(item.dateObject.quarter, item.quarterFormat, dateLocaleRef.value.locale);
        }
      };
      const {
        useAsQuickJump
      } = props;
      const renderItem = (item, i, mergedClsPrefix) => {
        const {
          mergedIsDateDisabled,
          handleDateClick,
          handleQuickMonthClick
        } = useCalendarRef;
        return vue.h("div", {
          "data-n-date": true,
          key: i,
          class: [`${mergedClsPrefix}-date-panel-month-calendar__picker-col-item`, item.isCurrent && `${mergedClsPrefix}-date-panel-month-calendar__picker-col-item--current`, item.selected && `${mergedClsPrefix}-date-panel-month-calendar__picker-col-item--selected`, !useAsQuickJump && mergedIsDateDisabled(item.ts, item.type === "year" ? {
            type: "year",
            year: item.dateObject.year
          } : item.type === "month" ? {
            type: "month",
            year: item.dateObject.year,
            month: item.dateObject.month
          } : item.type === "quarter" ? {
            type: "month",
            year: item.dateObject.year,
            month: item.dateObject.quarter
          } : null) && `${mergedClsPrefix}-date-panel-month-calendar__picker-col-item--disabled`],
          onClick: () => {
            if (useAsQuickJump) {
              handleQuickMonthClick(item, (value) => {
                props.onUpdateValue(value, false);
              });
            } else {
              handleDateClick(item);
            }
          }
        }, getRenderContent(item));
      };
      vue.onMounted(() => {
        useCalendarRef.justifyColumnsScrollState();
      });
      return Object.assign(Object.assign({}, useCalendarRef), {
        renderItem
      });
    },
    render() {
      const {
        mergedClsPrefix,
        mergedTheme,
        shortcuts,
        actions,
        renderItem,
        type,
        onRender
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h("div", {
        ref: "selfRef",
        tabindex: 0,
        class: [`${mergedClsPrefix}-date-panel`, `${mergedClsPrefix}-date-panel--month`, !this.panel && `${mergedClsPrefix}-date-panel--shadow`, this.themeClass],
        onFocus: this.handlePanelFocus,
        onKeydown: this.handlePanelKeyDown
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month-calendar`
      }, vue.h(NScrollbar, {
        ref: "yearScrollbarRef",
        class: `${mergedClsPrefix}-date-panel-month-calendar__picker-col`,
        theme: mergedTheme.peers.Scrollbar,
        themeOverrides: mergedTheme.peerOverrides.Scrollbar,
        container: this.virtualListContainer,
        content: this.virtualListContent,
        horizontalRailStyle: {
          zIndex: 1
        },
        verticalRailStyle: {
          zIndex: 1
        }
      }, {
        default: () => vue.h(VVirtualList, {
          ref: "yearVlRef",
          items: this.yearArray,
          itemSize: MONTH_ITEM_HEIGHT,
          showScrollbar: false,
          keyField: "ts",
          onScroll: this.handleVirtualListScroll,
          paddingBottom: 4
        }, {
          default: ({
            item,
            index
          }) => {
            return renderItem(item, index, mergedClsPrefix);
          }
        })
      }), type === "month" || type === "quarter" ? vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month-calendar__picker-col`
      }, vue.h(NScrollbar, {
        ref: "monthScrollbarRef",
        theme: mergedTheme.peers.Scrollbar,
        themeOverrides: mergedTheme.peerOverrides.Scrollbar
      }, {
        default: () => [(type === "month" ? this.monthArray : this.quarterArray).map((item, i) => renderItem(item, i, mergedClsPrefix)), vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-${type}-calendar__padding`
        })]
      })) : null), this.datePickerSlots.footer ? vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-footer`
      }, {
        default: this.datePickerSlots.footer
      }) : null, (actions === null || actions === void 0 ? void 0 : actions.length) || shortcuts ? vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-actions`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-actions__prefix`
      }, shortcuts && Object.keys(shortcuts).map((key) => {
        const shortcut = shortcuts[key];
        return Array.isArray(shortcut) ? null : vue.h(XButton, {
          size: "tiny",
          onMouseenter: () => {
            this.handleSingleShortcutMouseenter(shortcut);
          },
          onClick: () => {
            this.handleSingleShortcutClick(shortcut);
          },
          onMouseleave: () => {
            this.handleShortcutMouseleave();
          }
        }, {
          default: () => key
        });
      })), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-actions__suffix`
      }, (actions === null || actions === void 0 ? void 0 : actions.includes("clear")) ? resolveSlotWithProps(this.$slots.now, {
        onClear: this.handleClearClick,
        text: this.locale.clear
      }, () => [vue.h(NButton, {
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        size: "tiny",
        onClick: this.handleClearClick
      }, {
        default: () => this.locale.clear
      })]) : null, (actions === null || actions === void 0 ? void 0 : actions.includes("now")) ? resolveSlotWithProps(this.$slots.now, {
        onNow: this.handleNowClick,
        text: this.locale.now
      }, () => [vue.h(NButton, {
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        size: "tiny",
        onClick: this.handleNowClick
      }, {
        default: () => this.locale.now
      })]) : null, (actions === null || actions === void 0 ? void 0 : actions.includes("confirm")) ? resolveSlotWithProps(this.$slots.confirm, {
        onConfirm: this.handleConfirmClick,
        disabled: this.isDateInvalid,
        text: this.locale.confirm
      }, () => [vue.h(NButton, {
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        size: "tiny",
        type: "primary",
        disabled: this.isDateInvalid,
        onClick: this.handleConfirmClick
      }, {
        default: () => this.locale.confirm
      })]) : null)) : null, vue.h(FocusDetector, {
        onFocus: this.handleFocusDetectorFocus
      }));
    }
  });
  const PanelHeader = vue.defineComponent({
    props: {
      mergedClsPrefix: {
        type: String,
        required: true
      },
      value: Number,
      monthBeforeYear: {
        type: Boolean,
        required: true
      },
      calendarMonth: {
        type: String,
        required: true
      },
      calendarYear: {
        type: String,
        required: true
      },
      onUpdateValue: {
        type: Function,
        required: true
      }
    },
    setup() {
      const triggerRef = vue.ref(null);
      const monthPanelRef = vue.ref(null);
      const showRef = vue.ref(false);
      function handleClickOutside(e) {
        var _a;
        if (showRef.value && !((_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(e)))) {
          showRef.value = false;
        }
      }
      function handleHeaderClick() {
        showRef.value = !showRef.value;
      }
      return {
        show: showRef,
        triggerRef,
        monthPanelRef,
        handleHeaderClick,
        handleClickOutside
      };
    },
    render() {
      const {
        handleClickOutside,
        mergedClsPrefix
      } = this;
      return vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month__month-year`,
        ref: "triggerRef"
      }, vue.h(VBinder, null, {
        default: () => [vue.h(VTarget, null, {
          default: () => vue.h("div", {
            class: [`${mergedClsPrefix}-date-panel-month__text`, this.show && `${mergedClsPrefix}-date-panel-month__text--active`],
            onClick: this.handleHeaderClick
          }, this.monthBeforeYear ? [this.calendarMonth, " ", this.calendarYear] : [this.calendarYear, " ", this.calendarMonth])
        }), vue.h(VFollower, {
          show: this.show,
          teleportDisabled: true
        }, {
          default: () => vue.h(vue.Transition, {
            name: "fade-in-scale-up-transition",
            appear: true
          }, {
            default: () => this.show ? vue.withDirectives(vue.h(MonthPanel, {
              ref: "monthPanelRef",
              onUpdateValue: this.onUpdateValue,
              actions: [],
              // month and year click show month type
              type: "month",
              key: "month",
              useAsQuickJump: true,
              value: this.value
            }), [[clickoutside$1, handleClickOutside, void 0, {
              capture: true
            }]]) : null
          })
        })]
      }));
    }
  });
  const DatetimePanel = vue.defineComponent({
    name: "DateTimePanel",
    props: useCalendarProps,
    setup(props) {
      return useCalendar(props, "datetime");
    },
    render() {
      var _a, _b, _c, _d;
      const {
        mergedClsPrefix,
        mergedTheme,
        shortcuts,
        timePickerProps: timePickerProps2,
        onRender,
        $slots
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h("div", {
        ref: "selfRef",
        tabindex: 0,
        class: [`${mergedClsPrefix}-date-panel`, `${mergedClsPrefix}-date-panel--datetime`, !this.panel && `${mergedClsPrefix}-date-panel--shadow`, this.themeClass],
        onKeydown: this.handlePanelKeyDown,
        onFocus: this.handlePanelFocus
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-header`
      }, vue.h(NInput, {
        value: this.dateInputValue,
        theme: mergedTheme.peers.Input,
        themeOverrides: mergedTheme.peerOverrides.Input,
        stateful: false,
        size: this.timePickerSize,
        readonly: this.inputReadonly,
        class: `${mergedClsPrefix}-date-panel-date-input`,
        textDecoration: this.isDateInvalid ? "line-through" : "",
        placeholder: this.locale.selectDate,
        onBlur: this.handleDateInputBlur,
        onUpdateValue: this.handleDateInput
      }), vue.h(NTimePicker, Object.assign({
        size: this.timePickerSize,
        placeholder: this.locale.selectTime,
        format: this.timerPickerFormat
      }, Array.isArray(timePickerProps2) ? void 0 : timePickerProps2, {
        showIcon: false,
        to: false,
        theme: mergedTheme.peers.TimePicker,
        themeOverrides: mergedTheme.peerOverrides.TimePicker,
        value: Array.isArray(this.value) ? null : this.value,
        isHourDisabled: this.isHourDisabled,
        isMinuteDisabled: this.isMinuteDisabled,
        isSecondDisabled: this.isSecondDisabled,
        onUpdateValue: this.handleTimePickerChange,
        stateful: false
      }))), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-calendar`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month__fast-prev`,
        onClick: this.prevYear
      }, resolveSlot($slots["prev-year"], () => [vue.h(FastBackwardIcon, null)])), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month__prev`,
        onClick: this.prevMonth
      }, resolveSlot($slots["prev-month"], () => [vue.h(BackwardIcon, null)])), vue.h(PanelHeader, {
        monthBeforeYear: this.locale.monthBeforeYear,
        value: this.calendarValue,
        onUpdateValue: this.onUpdateCalendarValue,
        mergedClsPrefix,
        calendarMonth: this.calendarMonth,
        calendarYear: this.calendarYear
      }), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month__next`,
        onClick: this.nextMonth
      }, resolveSlot($slots["next-month"], () => [vue.h(ForwardIcon, null)])), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month__fast-next`,
        onClick: this.nextYear
      }, resolveSlot($slots["next-year"], () => [vue.h(FastForwardIcon, null)]))), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-weekdays`
      }, this.weekdays.map((weekday) => vue.h("div", {
        key: weekday,
        class: `${mergedClsPrefix}-date-panel-weekdays__day`
      }, weekday))), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-dates`
      }, this.dateArray.map((dateItem2, i) => vue.h("div", {
        "data-n-date": true,
        key: i,
        class: [`${mergedClsPrefix}-date-panel-date`, {
          [`${mergedClsPrefix}-date-panel-date--current`]: dateItem2.isCurrentDate,
          [`${mergedClsPrefix}-date-panel-date--selected`]: dateItem2.selected,
          [`${mergedClsPrefix}-date-panel-date--excluded`]: !dateItem2.inCurrentMonth,
          [`${mergedClsPrefix}-date-panel-date--disabled`]: this.mergedIsDateDisabled(dateItem2.ts, {
            type: "date",
            year: dateItem2.dateObject.year,
            month: dateItem2.dateObject.month,
            date: dateItem2.dateObject.date
          })
        }],
        onClick: () => {
          this.handleDateClick(dateItem2);
        }
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-date__trigger`
      }), dateItem2.dateObject.date, dateItem2.isCurrentDate ? vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-date__sup`
      }) : null)))), this.datePickerSlots.footer ? vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-footer`
      }, this.datePickerSlots.footer()) : null, ((_a = this.actions) === null || _a === void 0 ? void 0 : _a.length) || shortcuts ? vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-actions`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-actions__prefix`
      }, shortcuts && Object.keys(shortcuts).map((key) => {
        const shortcut = shortcuts[key];
        return Array.isArray(shortcut) ? null : vue.h(XButton, {
          size: "tiny",
          onMouseenter: () => {
            this.handleSingleShortcutMouseenter(shortcut);
          },
          onClick: () => {
            this.handleSingleShortcutClick(shortcut);
          },
          onMouseleave: () => {
            this.handleShortcutMouseleave();
          }
        }, {
          default: () => key
        });
      })), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-actions__suffix`
      }, ((_b = this.actions) === null || _b === void 0 ? void 0 : _b.includes("clear")) ? resolveSlotWithProps(this.$slots.clear, {
        onClear: this.clearSelectedDateTime,
        text: this.locale.clear
      }, () => [vue.h(NButton, {
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        size: "tiny",
        onClick: this.clearSelectedDateTime
      }, {
        default: () => this.locale.clear
      })]) : null, ((_c = this.actions) === null || _c === void 0 ? void 0 : _c.includes("now")) ? resolveSlotWithProps($slots.now, {
        onNow: this.handleNowClick,
        text: this.locale.now
      }, () => [vue.h(NButton, {
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        size: "tiny",
        onClick: this.handleNowClick
      }, {
        default: () => this.locale.now
      })]) : null, ((_d = this.actions) === null || _d === void 0 ? void 0 : _d.includes("confirm")) ? resolveSlotWithProps($slots.confirm, {
        onConfirm: this.handleConfirmClick,
        disabled: this.isDateInvalid,
        text: this.locale.confirm
      }, () => [vue.h(NButton, {
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        size: "tiny",
        type: "primary",
        disabled: this.isDateInvalid,
        onClick: this.handleConfirmClick
      }, {
        default: () => this.locale.confirm
      })]) : null)) : null, vue.h(FocusDetector, {
        onFocus: this.handleFocusDetectorFocus
      }));
    }
  });
  const useDualCalendarProps = Object.assign(Object.assign({}, usePanelCommonProps), {
    defaultCalendarStartTime: Number,
    defaultCalendarEndTime: Number,
    bindCalendarMonths: Boolean,
    actions: {
      type: Array,
      default: () => ["clear", "confirm"]
    }
  });
  function useDualCalendar(props, type) {
    var _a, _b;
    const {
      isDateDisabledRef,
      isStartHourDisabledRef,
      isEndHourDisabledRef,
      isStartMinuteDisabledRef,
      isEndMinuteDisabledRef,
      isStartSecondDisabledRef,
      isEndSecondDisabledRef,
      isStartDateInvalidRef,
      isEndDateInvalidRef,
      isStartTimeInvalidRef,
      isEndTimeInvalidRef,
      isStartValueInvalidRef,
      isEndValueInvalidRef,
      isRangeInvalidRef,
      localeRef,
      rangesRef,
      closeOnSelectRef,
      updateValueOnCloseRef,
      firstDayOfWeekRef,
      datePickerSlots,
      monthFormatRef,
      yearFormatRef,
      quarterFormatRef,
      yearRangeRef
    } = vue.inject(datePickerInjectionKey);
    const validation = {
      isDateDisabled: isDateDisabledRef,
      isStartHourDisabled: isStartHourDisabledRef,
      isEndHourDisabled: isEndHourDisabledRef,
      isStartMinuteDisabled: isStartMinuteDisabledRef,
      isEndMinuteDisabled: isEndMinuteDisabledRef,
      isStartSecondDisabled: isStartSecondDisabledRef,
      isEndSecondDisabled: isEndSecondDisabledRef,
      isStartDateInvalid: isStartDateInvalidRef,
      isEndDateInvalid: isEndDateInvalidRef,
      isStartTimeInvalid: isStartTimeInvalidRef,
      isEndTimeInvalid: isEndTimeInvalidRef,
      isStartValueInvalid: isStartValueInvalidRef,
      isEndValueInvalid: isEndValueInvalidRef,
      isRangeInvalid: isRangeInvalidRef
    };
    const panelCommon = usePanelCommon(props);
    const startDatesElRef = vue.ref(null);
    const endDatesElRef = vue.ref(null);
    const startYearScrollbarRef = vue.ref(null);
    const endYearScrollbarRef = vue.ref(null);
    const startYearVlRef = vue.ref(null);
    const endYearVlRef = vue.ref(null);
    const startMonthScrollbarRef = vue.ref(null);
    const endMonthScrollbarRef = vue.ref(null);
    const {
      value
    } = props;
    const defaultCalendarStartTime = (_a = props.defaultCalendarStartTime) !== null && _a !== void 0 ? _a : Array.isArray(value) && typeof value[0] === "number" ? value[0] : Date.now();
    const startCalendarDateTimeRef = vue.ref(defaultCalendarStartTime);
    const endCalendarDateTimeRef = vue.ref((_b = props.defaultCalendarEndTime) !== null && _b !== void 0 ? _b : Array.isArray(value) && typeof value[1] === "number" ? value[1] : getTime(addMonths(defaultCalendarStartTime, 1)));
    adjustCalendarTimes(true);
    const nowRef = vue.ref(Date.now());
    const isSelectingRef = vue.ref(false);
    const memorizedStartDateTimeRef = vue.ref(0);
    const mergedDateFormatRef = vue.computed(() => props.dateFormat || localeRef.value.dateFormat);
    const startDateInput = vue.ref(Array.isArray(value) ? format$3(value[0], mergedDateFormatRef.value, panelCommon.dateFnsOptions.value) : "");
    const endDateInputRef = vue.ref(Array.isArray(value) ? format$3(value[1], mergedDateFormatRef.value, panelCommon.dateFnsOptions.value) : "");
    const selectingPhaseRef = vue.computed(() => {
      if (isSelectingRef.value)
        return "end";
      else
        return "start";
    });
    const startDateArrayRef = vue.computed(() => {
      var _a2;
      return dateArray(startCalendarDateTimeRef.value, props.value, nowRef.value, (_a2 = firstDayOfWeekRef.value) !== null && _a2 !== void 0 ? _a2 : localeRef.value.firstDayOfWeek);
    });
    const endDateArrayRef = vue.computed(() => {
      var _a2;
      return dateArray(endCalendarDateTimeRef.value, props.value, nowRef.value, (_a2 = firstDayOfWeekRef.value) !== null && _a2 !== void 0 ? _a2 : localeRef.value.firstDayOfWeek);
    });
    const weekdaysRef = vue.computed(() => {
      return startDateArrayRef.value.slice(0, 7).map((dateItem2) => {
        const {
          ts
        } = dateItem2;
        return format$3(ts, localeRef.value.dayFormat, panelCommon.dateFnsOptions.value);
      });
    });
    const startCalendarMonthRef = vue.computed(() => {
      return format$3(startCalendarDateTimeRef.value, localeRef.value.monthFormat, panelCommon.dateFnsOptions.value);
    });
    const endCalendarMonthRef = vue.computed(() => {
      return format$3(endCalendarDateTimeRef.value, localeRef.value.monthFormat, panelCommon.dateFnsOptions.value);
    });
    const startCalendarYearRef = vue.computed(() => {
      return format$3(startCalendarDateTimeRef.value, localeRef.value.yearFormat, panelCommon.dateFnsOptions.value);
    });
    const endCalendarYearRef = vue.computed(() => {
      return format$3(endCalendarDateTimeRef.value, localeRef.value.yearFormat, panelCommon.dateFnsOptions.value);
    });
    const startTimeValueRef = vue.computed(() => {
      const {
        value: value2
      } = props;
      if (Array.isArray(value2))
        return value2[0];
      return null;
    });
    const endTimeValueRef = vue.computed(() => {
      const {
        value: value2
      } = props;
      if (Array.isArray(value2))
        return value2[1];
      return null;
    });
    const shortcutsRef = vue.computed(() => {
      const {
        shortcuts
      } = props;
      return shortcuts || rangesRef.value;
    });
    const startYearArrayRef = vue.computed(() => {
      return yearArray(pluckValueFromRange(props.value, "start"), nowRef.value, {
        yearFormat: yearFormatRef.value
      }, yearRangeRef);
    });
    const endYearArrayRef = vue.computed(() => {
      return yearArray(pluckValueFromRange(props.value, "end"), nowRef.value, {
        yearFormat: yearFormatRef.value
      }, yearRangeRef);
    });
    const startQuarterArrayRef = vue.computed(() => {
      const startValue = pluckValueFromRange(props.value, "start");
      return quarterArray(startValue !== null && startValue !== void 0 ? startValue : Date.now(), startValue, nowRef.value, {
        quarterFormat: quarterFormatRef.value
      });
    });
    const endQuarterArrayRef = vue.computed(() => {
      const endValue = pluckValueFromRange(props.value, "end");
      return quarterArray(endValue !== null && endValue !== void 0 ? endValue : Date.now(), endValue, nowRef.value, {
        quarterFormat: quarterFormatRef.value
      });
    });
    const startMonthArrayRef = vue.computed(() => {
      const startValue = pluckValueFromRange(props.value, "start");
      return monthArray(startValue !== null && startValue !== void 0 ? startValue : Date.now(), startValue, nowRef.value, {
        monthFormat: monthFormatRef.value
      });
    });
    const endMonthArrayRef = vue.computed(() => {
      const endValue = pluckValueFromRange(props.value, "end");
      return monthArray(endValue !== null && endValue !== void 0 ? endValue : Date.now(), endValue, nowRef.value, {
        monthFormat: monthFormatRef.value
      });
    });
    vue.watch(vue.computed(() => props.value), (value2) => {
      if (value2 !== null && Array.isArray(value2)) {
        const [startMoment, endMoment] = value2;
        startDateInput.value = format$3(startMoment, mergedDateFormatRef.value, panelCommon.dateFnsOptions.value);
        endDateInputRef.value = format$3(endMoment, mergedDateFormatRef.value, panelCommon.dateFnsOptions.value);
        if (!isSelectingRef.value) {
          syncCalendarTimeWithValue(value2);
        }
      } else {
        startDateInput.value = "";
        endDateInputRef.value = "";
      }
    });
    function handleCalendarChange(value2, oldValue) {
      if (type === "daterange" || type === "datetimerange") {
        if (getYear(value2) !== getYear(oldValue) || getMonth(value2) !== getMonth(oldValue)) {
          panelCommon.disableTransitionOneTick();
        }
      }
    }
    vue.watch(startCalendarDateTimeRef, handleCalendarChange);
    vue.watch(endCalendarDateTimeRef, handleCalendarChange);
    function adjustCalendarTimes(byStartCalendarTime) {
      const startTime = startOfMonth(startCalendarDateTimeRef.value);
      const endTime = startOfMonth(endCalendarDateTimeRef.value);
      if (props.bindCalendarMonths || startTime >= endTime) {
        if (byStartCalendarTime) {
          endCalendarDateTimeRef.value = getTime(addMonths(startTime, 1));
        } else {
          startCalendarDateTimeRef.value = getTime(addMonths(endTime, -1));
        }
      }
    }
    function startCalendarNextYear() {
      startCalendarDateTimeRef.value = getTime(addMonths(startCalendarDateTimeRef.value, 12));
      adjustCalendarTimes(true);
    }
    function startCalendarPrevYear() {
      startCalendarDateTimeRef.value = getTime(addMonths(startCalendarDateTimeRef.value, -12));
      adjustCalendarTimes(true);
    }
    function startCalendarNextMonth() {
      startCalendarDateTimeRef.value = getTime(addMonths(startCalendarDateTimeRef.value, 1));
      adjustCalendarTimes(true);
    }
    function startCalendarPrevMonth() {
      startCalendarDateTimeRef.value = getTime(addMonths(startCalendarDateTimeRef.value, -1));
      adjustCalendarTimes(true);
    }
    function endCalendarNextYear() {
      endCalendarDateTimeRef.value = getTime(addMonths(endCalendarDateTimeRef.value, 12));
      adjustCalendarTimes(false);
    }
    function endCalendarPrevYear() {
      endCalendarDateTimeRef.value = getTime(addMonths(endCalendarDateTimeRef.value, -12));
      adjustCalendarTimes(false);
    }
    function endCalendarNextMonth() {
      endCalendarDateTimeRef.value = getTime(addMonths(endCalendarDateTimeRef.value, 1));
      adjustCalendarTimes(false);
    }
    function endCalendarPrevMonth() {
      endCalendarDateTimeRef.value = getTime(addMonths(endCalendarDateTimeRef.value, -1));
      adjustCalendarTimes(false);
    }
    function onUpdateStartCalendarValue(value2) {
      startCalendarDateTimeRef.value = value2;
      adjustCalendarTimes(true);
    }
    function onUpdateEndCalendarValue(value2) {
      endCalendarDateTimeRef.value = value2;
      adjustCalendarTimes(false);
    }
    function mergedIsDateDisabled(ts) {
      const isDateDisabled = isDateDisabledRef.value;
      if (!isDateDisabled)
        return false;
      if (!Array.isArray(props.value)) {
        return isDateDisabled(ts, "start", null);
      }
      if (selectingPhaseRef.value === "start") {
        return isDateDisabled(ts, "start", null);
      } else {
        const {
          value: memorizedStartDateTime
        } = memorizedStartDateTimeRef;
        if (ts < memorizedStartDateTimeRef.value) {
          return isDateDisabled(ts, "start", [memorizedStartDateTime, memorizedStartDateTime]);
        } else {
          return isDateDisabled(ts, "end", [memorizedStartDateTime, memorizedStartDateTime]);
        }
      }
    }
    function syncCalendarTimeWithValue(value2) {
      if (value2 === null)
        return;
      const [startMoment, endMoment] = value2;
      startCalendarDateTimeRef.value = startMoment;
      if (startOfMonth(endMoment) <= startOfMonth(startMoment)) {
        endCalendarDateTimeRef.value = getTime(startOfMonth(addMonths(startMoment, 1)));
      } else {
        endCalendarDateTimeRef.value = getTime(startOfMonth(endMoment));
      }
    }
    function handleDateClick(dateItem2) {
      if (!isSelectingRef.value) {
        isSelectingRef.value = true;
        memorizedStartDateTimeRef.value = dateItem2.ts;
        changeStartEndTime(dateItem2.ts, dateItem2.ts, "done");
      } else {
        isSelectingRef.value = false;
        const {
          value: value2
        } = props;
        if (props.panel && Array.isArray(value2)) {
          changeStartEndTime(value2[0], value2[1], "done");
        } else {
          if (closeOnSelectRef.value && type === "daterange") {
            if (updateValueOnCloseRef.value) {
              closeCalendar();
            } else {
              handleConfirmClick();
            }
          }
        }
      }
    }
    function handleDateMouseEnter(dateItem2) {
      if (isSelectingRef.value) {
        if (mergedIsDateDisabled(dateItem2.ts))
          return;
        if (dateItem2.ts >= memorizedStartDateTimeRef.value) {
          changeStartEndTime(memorizedStartDateTimeRef.value, dateItem2.ts, "wipPreview");
        } else {
          changeStartEndTime(dateItem2.ts, memorizedStartDateTimeRef.value, "wipPreview");
        }
      }
    }
    function handleConfirmClick() {
      if (isRangeInvalidRef.value) {
        return;
      }
      panelCommon.doConfirm();
      closeCalendar();
    }
    function closeCalendar() {
      isSelectingRef.value = false;
      if (props.active) {
        panelCommon.doClose();
      }
    }
    function changeStartDateTime(time2) {
      if (typeof time2 !== "number") {
        time2 = getTime(time2);
      }
      if (props.value === null) {
        panelCommon.doUpdateValue([time2, time2], props.panel);
      } else if (Array.isArray(props.value)) {
        panelCommon.doUpdateValue([time2, Math.max(props.value[1], time2)], props.panel);
      }
    }
    function changeEndDateTime(time2) {
      if (typeof time2 !== "number") {
        time2 = getTime(time2);
      }
      if (props.value === null) {
        panelCommon.doUpdateValue([time2, time2], props.panel);
      } else if (Array.isArray(props.value)) {
        panelCommon.doUpdateValue([Math.min(props.value[0], time2), time2], props.panel);
      }
    }
    function changeStartEndTime(startTime, endTime, source) {
      if (typeof startTime !== "number") {
        startTime = getTime(startTime);
      }
      if (source !== "shortcutPreview") {
        let startDefaultTime;
        let endDefaultTime;
        if (type === "datetimerange") {
          const {
            defaultTime
          } = props;
          if (Array.isArray(defaultTime)) {
            startDefaultTime = getDefaultTime(defaultTime[0]);
            endDefaultTime = getDefaultTime(defaultTime[1]);
          } else {
            startDefaultTime = getDefaultTime(defaultTime);
            endDefaultTime = startDefaultTime;
          }
        }
        if (startDefaultTime) {
          startTime = getTime(set(startTime, startDefaultTime));
        }
        if (endDefaultTime) {
          endTime = getTime(set(endTime, endDefaultTime));
        }
      }
      panelCommon.doUpdateValue([startTime, endTime], props.panel && source === "done");
    }
    function sanitizeValue(datetime) {
      if (type === "datetimerange") {
        return getTime(startOfSecond(datetime));
      } else if (type === "monthrange") {
        return getTime(startOfMonth(datetime));
      } else {
        return getTime(startOfDay(datetime));
      }
    }
    function handleStartDateInput(value2) {
      const date = strictParse(value2, mergedDateFormatRef.value, /* @__PURE__ */ new Date(), panelCommon.dateFnsOptions.value);
      if (isValid(date)) {
        if (!props.value) {
          const newValue = set(/* @__PURE__ */ new Date(), {
            year: getYear(date),
            month: getMonth(date),
            date: getDate(date)
          });
          changeStartDateTime(sanitizeValue(getTime(newValue)));
        } else if (Array.isArray(props.value)) {
          const newValue = set(props.value[0], {
            year: getYear(date),
            month: getMonth(date),
            date: getDate(date)
          });
          changeStartDateTime(sanitizeValue(getTime(newValue)));
        }
      } else {
        startDateInput.value = value2;
      }
    }
    function handleEndDateInput(value2) {
      const date = strictParse(value2, mergedDateFormatRef.value, /* @__PURE__ */ new Date(), panelCommon.dateFnsOptions.value);
      if (isValid(date)) {
        if (props.value === null) {
          const newValue = set(/* @__PURE__ */ new Date(), {
            year: getYear(date),
            month: getMonth(date),
            date: getDate(date)
          });
          changeEndDateTime(sanitizeValue(getTime(newValue)));
        } else if (Array.isArray(props.value)) {
          const newValue = set(props.value[1], {
            year: getYear(date),
            month: getMonth(date),
            date: getDate(date)
          });
          changeEndDateTime(sanitizeValue(getTime(newValue)));
        }
      } else {
        endDateInputRef.value = value2;
      }
    }
    function handleStartDateInputBlur() {
      const date = strictParse(startDateInput.value, mergedDateFormatRef.value, /* @__PURE__ */ new Date(), panelCommon.dateFnsOptions.value);
      const {
        value: value2
      } = props;
      if (isValid(date)) {
        if (value2 === null) {
          const newValue = set(/* @__PURE__ */ new Date(), {
            year: getYear(date),
            month: getMonth(date),
            date: getDate(date)
          });
          changeStartDateTime(sanitizeValue(getTime(newValue)));
        } else if (Array.isArray(value2)) {
          const newValue = set(value2[0], {
            year: getYear(date),
            month: getMonth(date),
            date: getDate(date)
          });
          changeStartDateTime(sanitizeValue(getTime(newValue)));
        }
      } else {
        refreshDisplayDateString();
      }
    }
    function handleEndDateInputBlur() {
      const date = strictParse(endDateInputRef.value, mergedDateFormatRef.value, /* @__PURE__ */ new Date(), panelCommon.dateFnsOptions.value);
      const {
        value: value2
      } = props;
      if (isValid(date)) {
        if (value2 === null) {
          const newValue = set(/* @__PURE__ */ new Date(), {
            year: getYear(date),
            month: getMonth(date),
            date: getDate(date)
          });
          changeEndDateTime(sanitizeValue(getTime(newValue)));
        } else if (Array.isArray(value2)) {
          const newValue = set(value2[1], {
            year: getYear(date),
            month: getMonth(date),
            date: getDate(date)
          });
          changeEndDateTime(sanitizeValue(getTime(newValue)));
        }
      } else {
        refreshDisplayDateString();
      }
    }
    function refreshDisplayDateString(times) {
      const {
        value: value2
      } = props;
      if (value2 === null || !Array.isArray(value2)) {
        startDateInput.value = "";
        endDateInputRef.value = "";
        return;
      }
      if (times === void 0) {
        times = value2;
      }
      startDateInput.value = format$3(times[0], mergedDateFormatRef.value, panelCommon.dateFnsOptions.value);
      endDateInputRef.value = format$3(times[1], mergedDateFormatRef.value, panelCommon.dateFnsOptions.value);
    }
    function handleStartTimePickerChange(value2) {
      if (value2 === null)
        return;
      changeStartDateTime(value2);
    }
    function handleEndTimePickerChange(value2) {
      if (value2 === null)
        return;
      changeEndDateTime(value2);
    }
    function handleRangeShortcutMouseenter(shortcut) {
      panelCommon.cachePendingValue();
      const shortcutValue = panelCommon.getShortcutValue(shortcut);
      if (!Array.isArray(shortcutValue))
        return;
      changeStartEndTime(shortcutValue[0], shortcutValue[1], "shortcutPreview");
    }
    function handleRangeShortcutClick(shortcut) {
      const shortcutValue = panelCommon.getShortcutValue(shortcut);
      if (!Array.isArray(shortcutValue))
        return;
      changeStartEndTime(shortcutValue[0], shortcutValue[1], "done");
      panelCommon.clearPendingValue();
      handleConfirmClick();
    }
    function justifyColumnsScrollState(value2, type3) {
      const mergedValue = value2 === void 0 ? props.value : value2;
      if (value2 === void 0 || type3 === "start") {
        if (startMonthScrollbarRef.value) {
          const monthIndex = !Array.isArray(mergedValue) ? getMonth(Date.now()) : getMonth(mergedValue[0]);
          startMonthScrollbarRef.value.scrollTo({
            debounce: false,
            index: monthIndex,
            elSize: MONTH_ITEM_HEIGHT
          });
        }
        if (startYearVlRef.value) {
          const yearIndex = (!Array.isArray(mergedValue) ? getYear(Date.now()) : getYear(mergedValue[0])) - yearRangeRef.value[0];
          startYearVlRef.value.scrollTo({
            index: yearIndex,
            debounce: false
          });
        }
      }
      if (value2 === void 0 || type3 === "end") {
        if (endMonthScrollbarRef.value) {
          const monthIndex = !Array.isArray(mergedValue) ? getMonth(Date.now()) : getMonth(mergedValue[1]);
          endMonthScrollbarRef.value.scrollTo({
            debounce: false,
            index: monthIndex,
            elSize: MONTH_ITEM_HEIGHT
          });
        }
        if (endYearVlRef.value) {
          const yearIndex = (!Array.isArray(mergedValue) ? getYear(Date.now()) : getYear(mergedValue[1])) - yearRangeRef.value[0];
          endYearVlRef.value.scrollTo({
            index: yearIndex,
            debounce: false
          });
        }
      }
    }
    function handleColItemClick(dateItem2, clickType) {
      const {
        value: value2
      } = props;
      const noCurrentValue = !Array.isArray(value2);
      const itemTs = dateItem2.type === "year" && type !== "yearrange" ? noCurrentValue ? set(dateItem2.ts, {
        month: getMonth(type === "quarterrange" ? startOfQuarter(/* @__PURE__ */ new Date()) : /* @__PURE__ */ new Date())
      }).valueOf() : set(dateItem2.ts, {
        month: getMonth(type === "quarterrange" ? startOfQuarter(value2[clickType === "start" ? 0 : 1]) : value2[clickType === "start" ? 0 : 1])
      }).valueOf() : dateItem2.ts;
      if (noCurrentValue) {
        const partialValue = sanitizeValue(itemTs);
        const nextValue2 = [partialValue, partialValue];
        panelCommon.doUpdateValue(nextValue2, props.panel);
        justifyColumnsScrollState(nextValue2, "start");
        justifyColumnsScrollState(nextValue2, "end");
        panelCommon.disableTransitionOneTick();
        return;
      }
      const nextValue = [value2[0], value2[1]];
      let otherPartsChanged = false;
      if (clickType === "start") {
        nextValue[0] = sanitizeValue(itemTs);
        if (nextValue[0] > nextValue[1]) {
          nextValue[1] = nextValue[0];
          otherPartsChanged = true;
        }
      } else {
        nextValue[1] = sanitizeValue(itemTs);
        if (nextValue[0] > nextValue[1]) {
          nextValue[0] = nextValue[1];
          otherPartsChanged = true;
        }
      }
      panelCommon.doUpdateValue(nextValue, props.panel);
      switch (type) {
        case "monthrange":
        case "quarterrange":
          panelCommon.disableTransitionOneTick();
          if (otherPartsChanged) {
            justifyColumnsScrollState(nextValue, "start");
            justifyColumnsScrollState(nextValue, "end");
          } else {
            justifyColumnsScrollState(nextValue, clickType);
          }
          break;
        case "yearrange":
          panelCommon.disableTransitionOneTick();
          justifyColumnsScrollState(nextValue, "start");
          justifyColumnsScrollState(nextValue, "end");
      }
    }
    function handleStartYearVlScroll() {
      var _a2;
      (_a2 = startYearScrollbarRef.value) === null || _a2 === void 0 ? void 0 : _a2.sync();
    }
    function handleEndYearVlScroll() {
      var _a2;
      (_a2 = endYearScrollbarRef.value) === null || _a2 === void 0 ? void 0 : _a2.sync();
    }
    function virtualListContainer(type3) {
      var _a2, _b2;
      if (type3 === "start") {
        return ((_a2 = startYearVlRef.value) === null || _a2 === void 0 ? void 0 : _a2.listElRef) || null;
      } else {
        return ((_b2 = endYearVlRef.value) === null || _b2 === void 0 ? void 0 : _b2.listElRef) || null;
      }
    }
    function virtualListContent(type3) {
      var _a2, _b2;
      if (type3 === "start") {
        return ((_a2 = startYearVlRef.value) === null || _a2 === void 0 ? void 0 : _a2.itemsElRef) || null;
      } else {
        return ((_b2 = endYearVlRef.value) === null || _b2 === void 0 ? void 0 : _b2.itemsElRef) || null;
      }
    }
    const childComponentRefs = {
      startYearVlRef,
      endYearVlRef,
      startMonthScrollbarRef,
      endMonthScrollbarRef,
      startYearScrollbarRef,
      endYearScrollbarRef
    };
    return Object.assign(Object.assign(Object.assign(Object.assign({
      startDatesElRef,
      endDatesElRef,
      handleDateClick,
      handleColItemClick,
      handleDateMouseEnter,
      handleConfirmClick,
      startCalendarPrevYear,
      startCalendarPrevMonth,
      startCalendarNextYear,
      startCalendarNextMonth,
      endCalendarPrevYear,
      endCalendarPrevMonth,
      endCalendarNextMonth,
      endCalendarNextYear,
      mergedIsDateDisabled,
      changeStartEndTime,
      ranges: rangesRef,
      startCalendarMonth: startCalendarMonthRef,
      startCalendarYear: startCalendarYearRef,
      endCalendarMonth: endCalendarMonthRef,
      endCalendarYear: endCalendarYearRef,
      weekdays: weekdaysRef,
      startDateArray: startDateArrayRef,
      endDateArray: endDateArrayRef,
      startYearArray: startYearArrayRef,
      startMonthArray: startMonthArrayRef,
      startQuarterArray: startQuarterArrayRef,
      endYearArray: endYearArrayRef,
      endMonthArray: endMonthArrayRef,
      endQuarterArray: endQuarterArrayRef,
      isSelecting: isSelectingRef,
      handleRangeShortcutMouseenter,
      handleRangeShortcutClick
    }, panelCommon), validation), childComponentRefs), {
      // datetimerangeonly
      startDateDisplayString: startDateInput,
      endDateInput: endDateInputRef,
      timePickerSize: panelCommon.timePickerSize,
      startTimeValue: startTimeValueRef,
      endTimeValue: endTimeValueRef,
      datePickerSlots,
      shortcuts: shortcutsRef,
      startCalendarDateTime: startCalendarDateTimeRef,
      endCalendarDateTime: endCalendarDateTimeRef,
      justifyColumnsScrollState,
      handleFocusDetectorFocus: panelCommon.handleFocusDetectorFocus,
      handleStartTimePickerChange,
      handleEndTimePickerChange,
      handleStartDateInput,
      handleStartDateInputBlur,
      handleEndDateInput,
      handleEndDateInputBlur,
      handleStartYearVlScroll,
      handleEndYearVlScroll,
      virtualListContainer,
      virtualListContent,
      onUpdateStartCalendarValue,
      onUpdateEndCalendarValue
    });
  }
  const DatetimerangePanel = vue.defineComponent({
    name: "DateTimeRangePanel",
    props: useDualCalendarProps,
    setup(props) {
      {
        vue.watchEffect(() => {
          var _a;
          if ((_a = props.actions) === null || _a === void 0 ? void 0 : _a.includes("now")) {
            warnOnce("date-picker", "The `now` action is not supported for n-date-picker of `datetimerange` type");
          }
        });
      }
      return useDualCalendar(props, "datetimerange");
    },
    render() {
      var _a, _b, _c;
      const {
        mergedClsPrefix,
        mergedTheme,
        shortcuts,
        timePickerProps: timePickerProps2,
        onRender,
        $slots
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h("div", {
        ref: "selfRef",
        tabindex: 0,
        class: [`${mergedClsPrefix}-date-panel`, `${mergedClsPrefix}-date-panel--datetimerange`, !this.panel && `${mergedClsPrefix}-date-panel--shadow`, this.themeClass],
        onKeydown: this.handlePanelKeyDown,
        onFocus: this.handlePanelFocus
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-header`
      }, vue.h(NInput, {
        value: this.startDateDisplayString,
        theme: mergedTheme.peers.Input,
        themeOverrides: mergedTheme.peerOverrides.Input,
        size: this.timePickerSize,
        stateful: false,
        readonly: this.inputReadonly,
        class: `${mergedClsPrefix}-date-panel-date-input`,
        textDecoration: this.isStartValueInvalid ? "line-through" : "",
        placeholder: this.locale.selectDate,
        onBlur: this.handleStartDateInputBlur,
        onUpdateValue: this.handleStartDateInput
      }), vue.h(NTimePicker, Object.assign({
        placeholder: this.locale.selectTime,
        format: this.timerPickerFormat,
        size: this.timePickerSize
      }, Array.isArray(timePickerProps2) ? timePickerProps2[0] : timePickerProps2, {
        value: this.startTimeValue,
        to: false,
        showIcon: false,
        disabled: this.isSelecting,
        theme: mergedTheme.peers.TimePicker,
        themeOverrides: mergedTheme.peerOverrides.TimePicker,
        stateful: false,
        isHourDisabled: this.isStartHourDisabled,
        isMinuteDisabled: this.isStartMinuteDisabled,
        isSecondDisabled: this.isStartSecondDisabled,
        onUpdateValue: this.handleStartTimePickerChange
      })), vue.h(NInput, {
        value: this.endDateInput,
        theme: mergedTheme.peers.Input,
        themeOverrides: mergedTheme.peerOverrides.Input,
        stateful: false,
        size: this.timePickerSize,
        readonly: this.inputReadonly,
        class: `${mergedClsPrefix}-date-panel-date-input`,
        textDecoration: this.isEndValueInvalid ? "line-through" : "",
        placeholder: this.locale.selectDate,
        onBlur: this.handleEndDateInputBlur,
        onUpdateValue: this.handleEndDateInput
      }), vue.h(NTimePicker, Object.assign({
        placeholder: this.locale.selectTime,
        format: this.timerPickerFormat,
        size: this.timePickerSize
      }, Array.isArray(timePickerProps2) ? timePickerProps2[1] : timePickerProps2, {
        disabled: this.isSelecting,
        showIcon: false,
        theme: mergedTheme.peers.TimePicker,
        themeOverrides: mergedTheme.peerOverrides.TimePicker,
        to: false,
        stateful: false,
        value: this.endTimeValue,
        isHourDisabled: this.isEndHourDisabled,
        isMinuteDisabled: this.isEndMinuteDisabled,
        isSecondDisabled: this.isEndSecondDisabled,
        onUpdateValue: this.handleEndTimePickerChange
      }))), vue.h("div", {
        ref: "startDatesElRef",
        class: `${mergedClsPrefix}-date-panel-calendar ${mergedClsPrefix}-date-panel-calendar--start`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month__fast-prev`,
        onClick: this.startCalendarPrevYear
      }, resolveSlot($slots["prev-year"], () => [vue.h(FastBackwardIcon, null)])), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month__prev`,
        onClick: this.startCalendarPrevMonth
      }, resolveSlot($slots["prev-month"], () => [vue.h(BackwardIcon, null)])), vue.h(PanelHeader, {
        monthBeforeYear: this.locale.monthBeforeYear,
        value: this.startCalendarDateTime,
        onUpdateValue: this.onUpdateStartCalendarValue,
        mergedClsPrefix,
        calendarMonth: this.startCalendarMonth,
        calendarYear: this.startCalendarYear
      }), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month__next`,
        onClick: this.startCalendarNextMonth
      }, resolveSlot($slots["next-month"], () => [vue.h(ForwardIcon, null)])), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month__fast-next`,
        onClick: this.startCalendarNextYear
      }, resolveSlot($slots["next-year"], () => [vue.h(FastForwardIcon, null)]))), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-weekdays`
      }, this.weekdays.map((weekday) => vue.h("div", {
        key: weekday,
        class: `${mergedClsPrefix}-date-panel-weekdays__day`
      }, weekday))), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel__divider`
      }), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-dates`
      }, this.startDateArray.map((dateItem2, i) => {
        const disabled = this.mergedIsDateDisabled(dateItem2.ts);
        return vue.h("div", {
          "data-n-date": true,
          key: i,
          class: [`${mergedClsPrefix}-date-panel-date`, {
            [`${mergedClsPrefix}-date-panel-date--excluded`]: !dateItem2.inCurrentMonth,
            [`${mergedClsPrefix}-date-panel-date--current`]: dateItem2.isCurrentDate,
            [`${mergedClsPrefix}-date-panel-date--selected`]: dateItem2.selected,
            [`${mergedClsPrefix}-date-panel-date--covered`]: dateItem2.inSpan,
            [`${mergedClsPrefix}-date-panel-date--start`]: dateItem2.startOfSpan,
            [`${mergedClsPrefix}-date-panel-date--end`]: dateItem2.endOfSpan,
            [`${mergedClsPrefix}-date-panel-date--disabled`]: disabled
          }],
          onClick: disabled ? void 0 : () => {
            this.handleDateClick(dateItem2);
          },
          onMouseenter: disabled ? void 0 : () => {
            this.handleDateMouseEnter(dateItem2);
          }
        }, vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-date__trigger`
        }), dateItem2.dateObject.date, dateItem2.isCurrentDate ? vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-date__sup`
        }) : null);
      }))), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel__vertical-divider`
      }), vue.h("div", {
        ref: "endDatesElRef",
        class: `${mergedClsPrefix}-date-panel-calendar ${mergedClsPrefix}-date-panel-calendar--end`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month__fast-prev`,
        onClick: this.endCalendarPrevYear
      }, resolveSlot($slots["prev-year"], () => [vue.h(FastBackwardIcon, null)])), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month__prev`,
        onClick: this.endCalendarPrevMonth
      }, resolveSlot($slots["prev-month"], () => [vue.h(BackwardIcon, null)])), vue.h(PanelHeader, {
        monthBeforeYear: this.locale.monthBeforeYear,
        value: this.endCalendarDateTime,
        onUpdateValue: this.onUpdateEndCalendarValue,
        mergedClsPrefix,
        calendarMonth: this.endCalendarMonth,
        calendarYear: this.endCalendarYear
      }), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month__next`,
        onClick: this.endCalendarNextMonth
      }, resolveSlot($slots["next-month"], () => [vue.h(ForwardIcon, null)])), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month__fast-next`,
        onClick: this.endCalendarNextYear
      }, resolveSlot($slots["next-year"], () => [vue.h(FastForwardIcon, null)]))), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-weekdays`
      }, this.weekdays.map((weekday) => vue.h("div", {
        key: weekday,
        class: `${mergedClsPrefix}-date-panel-weekdays__day`
      }, weekday))), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel__divider`
      }), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-dates`
      }, this.endDateArray.map((dateItem2, i) => {
        const disabled = this.mergedIsDateDisabled(dateItem2.ts);
        return vue.h("div", {
          "data-n-date": true,
          key: i,
          class: [`${mergedClsPrefix}-date-panel-date`, {
            [`${mergedClsPrefix}-date-panel-date--excluded`]: !dateItem2.inCurrentMonth,
            [`${mergedClsPrefix}-date-panel-date--current`]: dateItem2.isCurrentDate,
            [`${mergedClsPrefix}-date-panel-date--selected`]: dateItem2.selected,
            [`${mergedClsPrefix}-date-panel-date--covered`]: dateItem2.inSpan,
            [`${mergedClsPrefix}-date-panel-date--start`]: dateItem2.startOfSpan,
            [`${mergedClsPrefix}-date-panel-date--end`]: dateItem2.endOfSpan,
            [`${mergedClsPrefix}-date-panel-date--disabled`]: disabled
          }],
          onClick: disabled ? void 0 : () => {
            this.handleDateClick(dateItem2);
          },
          onMouseenter: disabled ? void 0 : () => {
            this.handleDateMouseEnter(dateItem2);
          }
        }, vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-date__trigger`
        }), dateItem2.dateObject.date, dateItem2.isCurrentDate ? vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-date__sup`
        }) : null);
      }))), this.datePickerSlots.footer ? vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-footer`
      }, this.datePickerSlots.footer()) : null, ((_a = this.actions) === null || _a === void 0 ? void 0 : _a.length) || shortcuts ? vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-actions`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-actions__prefix`
      }, shortcuts && Object.keys(shortcuts).map((key) => {
        const shortcut = shortcuts[key];
        return Array.isArray(shortcut) || typeof shortcut === "function" ? vue.h(XButton, {
          size: "tiny",
          onMouseenter: () => {
            this.handleRangeShortcutMouseenter(shortcut);
          },
          onClick: () => {
            this.handleRangeShortcutClick(shortcut);
          },
          onMouseleave: () => {
            this.handleShortcutMouseleave();
          }
        }, {
          default: () => key
        }) : null;
      })), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-actions__suffix`
      }, ((_b = this.actions) === null || _b === void 0 ? void 0 : _b.includes("clear")) ? resolveSlotWithProps($slots.clear, {
        onClear: this.handleClearClick,
        text: this.locale.clear
      }, () => [vue.h(NButton, {
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        size: "tiny",
        onClick: this.handleClearClick
      }, {
        default: () => this.locale.clear
      })]) : null, ((_c = this.actions) === null || _c === void 0 ? void 0 : _c.includes("confirm")) ? resolveSlotWithProps($slots.confirm, {
        onConfirm: this.handleConfirmClick,
        disabled: this.isRangeInvalid || this.isSelecting,
        text: this.locale.confirm
      }, () => [vue.h(NButton, {
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        size: "tiny",
        type: "primary",
        disabled: this.isRangeInvalid || this.isSelecting,
        onClick: this.handleConfirmClick
      }, {
        default: () => this.locale.confirm
      })]) : null)) : null, vue.h(FocusDetector, {
        onFocus: this.handleFocusDetectorFocus
      }));
    }
  });
  const DatePanel = vue.defineComponent({
    name: "DatePanel",
    props: Object.assign(Object.assign({}, useCalendarProps), {
      type: {
        type: String,
        required: true
      }
    }),
    setup(props) {
      {
        vue.watchEffect(() => {
          var _a;
          if ((_a = props.actions) === null || _a === void 0 ? void 0 : _a.includes("confirm")) {
            warnOnce("date-picker", "The `confirm` action is not supported for n-date-picker of `date` type");
          }
        });
      }
      return useCalendar(props, props.type);
    },
    render() {
      var _a, _b, _c;
      const {
        mergedClsPrefix,
        mergedTheme,
        shortcuts,
        onRender,
        $slots,
        type
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h("div", {
        ref: "selfRef",
        tabindex: 0,
        class: [`${mergedClsPrefix}-date-panel`, `${mergedClsPrefix}-date-panel--${type}`, !this.panel && `${mergedClsPrefix}-date-panel--shadow`, this.themeClass],
        onFocus: this.handlePanelFocus,
        onKeydown: this.handlePanelKeyDown
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-calendar`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month__fast-prev`,
        onClick: this.prevYear
      }, resolveSlot($slots["prev-year"], () => [vue.h(FastBackwardIcon, null)])), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month__prev`,
        onClick: this.prevMonth
      }, resolveSlot($slots["prev-month"], () => [vue.h(BackwardIcon, null)])), vue.h(PanelHeader, {
        monthBeforeYear: this.locale.monthBeforeYear,
        value: this.calendarValue,
        onUpdateValue: this.onUpdateCalendarValue,
        mergedClsPrefix,
        calendarMonth: this.calendarMonth,
        calendarYear: this.calendarYear
      }), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month__next`,
        onClick: this.nextMonth
      }, resolveSlot($slots["next-month"], () => [vue.h(ForwardIcon, null)])), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month__fast-next`,
        onClick: this.nextYear
      }, resolveSlot($slots["next-year"], () => [vue.h(FastForwardIcon, null)]))), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-weekdays`
      }, this.weekdays.map((weekday) => vue.h("div", {
        key: weekday,
        class: `${mergedClsPrefix}-date-panel-weekdays__day`
      }, weekday))), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-dates`
      }, this.dateArray.map((dateItem2, i) => vue.h("div", {
        "data-n-date": true,
        key: i,
        class: [`${mergedClsPrefix}-date-panel-date`, {
          [`${mergedClsPrefix}-date-panel-date--current`]: dateItem2.isCurrentDate,
          [`${mergedClsPrefix}-date-panel-date--selected`]: dateItem2.selected,
          [`${mergedClsPrefix}-date-panel-date--excluded`]: !dateItem2.inCurrentMonth,
          [`${mergedClsPrefix}-date-panel-date--disabled`]: this.mergedIsDateDisabled(dateItem2.ts, {
            type: "date",
            year: dateItem2.dateObject.year,
            month: dateItem2.dateObject.month,
            date: dateItem2.dateObject.date
          }),
          [`${mergedClsPrefix}-date-panel-date--week-hovered`]: this.isWeekHovered(dateItem2),
          [`${mergedClsPrefix}-date-panel-date--week-selected`]: dateItem2.inSelectedWeek
        }],
        onClick: () => {
          this.handleDateClick(dateItem2);
        },
        onMouseenter: () => {
          this.handleDateMouseEnter(dateItem2);
        }
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-date__trigger`
      }), dateItem2.dateObject.date, dateItem2.isCurrentDate ? vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-date__sup`
      }) : null)))), this.datePickerSlots.footer ? vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-footer`
      }, this.datePickerSlots.footer()) : null, ((_a = this.actions) === null || _a === void 0 ? void 0 : _a.length) || shortcuts ? vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-actions`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-actions__prefix`
      }, shortcuts && Object.keys(shortcuts).map((key) => {
        const shortcut = shortcuts[key];
        return Array.isArray(shortcut) ? null : vue.h(XButton, {
          size: "tiny",
          onMouseenter: () => {
            this.handleSingleShortcutMouseenter(shortcut);
          },
          onClick: () => {
            this.handleSingleShortcutClick(shortcut);
          },
          onMouseleave: () => {
            this.handleShortcutMouseleave();
          }
        }, {
          default: () => key
        });
      })), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-actions__suffix`
      }, ((_b = this.actions) === null || _b === void 0 ? void 0 : _b.includes("clear")) ? resolveSlotWithProps(this.$slots.clear, {
        onClear: this.handleClearClick,
        text: this.locale.clear
      }, () => [vue.h(NButton, {
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        size: "tiny",
        onClick: this.handleClearClick
      }, {
        default: () => this.locale.clear
      })]) : null, ((_c = this.actions) === null || _c === void 0 ? void 0 : _c.includes("now")) ? resolveSlotWithProps(this.$slots.now, {
        onNow: this.handleNowClick,
        text: this.locale.now
      }, () => [vue.h(NButton, {
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        size: "tiny",
        onClick: this.handleNowClick
      }, {
        default: () => this.locale.now
      })]) : null)) : null, vue.h(FocusDetector, {
        onFocus: this.handleFocusDetectorFocus
      }));
    }
  });
  const DaterangePanel = vue.defineComponent({
    name: "DateRangePanel",
    props: useDualCalendarProps,
    setup(props) {
      {
        vue.watchEffect(() => {
          var _a;
          if ((_a = props.actions) === null || _a === void 0 ? void 0 : _a.includes("now")) {
            warnOnce("date-picker", "The `now` action is not supported for n-date-picker of `daterange` type");
          }
        });
      }
      return useDualCalendar(props, "daterange");
    },
    render() {
      var _a, _b, _c;
      const {
        mergedClsPrefix,
        mergedTheme,
        shortcuts,
        onRender,
        $slots
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h("div", {
        ref: "selfRef",
        tabindex: 0,
        class: [`${mergedClsPrefix}-date-panel`, `${mergedClsPrefix}-date-panel--daterange`, !this.panel && `${mergedClsPrefix}-date-panel--shadow`, this.themeClass],
        onKeydown: this.handlePanelKeyDown,
        onFocus: this.handlePanelFocus
      }, vue.h("div", {
        ref: "startDatesElRef",
        class: `${mergedClsPrefix}-date-panel-calendar ${mergedClsPrefix}-date-panel-calendar--start`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month__fast-prev`,
        onClick: this.startCalendarPrevYear
      }, resolveSlot($slots["prev-year"], () => [vue.h(FastBackwardIcon, null)])), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month__prev`,
        onClick: this.startCalendarPrevMonth
      }, resolveSlot($slots["prev-month"], () => [vue.h(BackwardIcon, null)])), vue.h(PanelHeader, {
        monthBeforeYear: this.locale.monthBeforeYear,
        value: this.startCalendarDateTime,
        onUpdateValue: this.onUpdateStartCalendarValue,
        mergedClsPrefix,
        calendarMonth: this.startCalendarMonth,
        calendarYear: this.startCalendarYear
      }), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month__next`,
        onClick: this.startCalendarNextMonth
      }, resolveSlot($slots["next-month"], () => [vue.h(ForwardIcon, null)])), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month__fast-next`,
        onClick: this.startCalendarNextYear
      }, resolveSlot($slots["next-year"], () => [vue.h(FastForwardIcon, null)]))), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-weekdays`
      }, this.weekdays.map((weekday) => vue.h("div", {
        key: weekday,
        class: `${mergedClsPrefix}-date-panel-weekdays__day`
      }, weekday))), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel__divider`
      }), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-dates`
      }, this.startDateArray.map((dateItem2, i) => vue.h("div", {
        "data-n-date": true,
        key: i,
        class: [`${mergedClsPrefix}-date-panel-date`, {
          [`${mergedClsPrefix}-date-panel-date--excluded`]: !dateItem2.inCurrentMonth,
          [`${mergedClsPrefix}-date-panel-date--current`]: dateItem2.isCurrentDate,
          [`${mergedClsPrefix}-date-panel-date--selected`]: dateItem2.selected,
          [`${mergedClsPrefix}-date-panel-date--covered`]: dateItem2.inSpan,
          [`${mergedClsPrefix}-date-panel-date--start`]: dateItem2.startOfSpan,
          [`${mergedClsPrefix}-date-panel-date--end`]: dateItem2.endOfSpan,
          [`${mergedClsPrefix}-date-panel-date--disabled`]: this.mergedIsDateDisabled(dateItem2.ts)
        }],
        onClick: () => {
          this.handleDateClick(dateItem2);
        },
        onMouseenter: () => {
          this.handleDateMouseEnter(dateItem2);
        }
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-date__trigger`
      }), dateItem2.dateObject.date, dateItem2.isCurrentDate ? vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-date__sup`
      }) : null)))), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel__vertical-divider`
      }), vue.h("div", {
        ref: "endDatesElRef",
        class: `${mergedClsPrefix}-date-panel-calendar ${mergedClsPrefix}-date-panel-calendar--end`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month__fast-prev`,
        onClick: this.endCalendarPrevYear
      }, resolveSlot($slots["prev-year"], () => [vue.h(FastBackwardIcon, null)])), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month__prev`,
        onClick: this.endCalendarPrevMonth
      }, resolveSlot($slots["prev-month"], () => [vue.h(BackwardIcon, null)])), vue.h(PanelHeader, {
        monthBeforeYear: this.locale.monthBeforeYear,
        value: this.endCalendarDateTime,
        onUpdateValue: this.onUpdateEndCalendarValue,
        mergedClsPrefix,
        calendarMonth: this.endCalendarMonth,
        calendarYear: this.endCalendarYear
      }), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month__next`,
        onClick: this.endCalendarNextMonth
      }, resolveSlot($slots["next-month"], () => [vue.h(ForwardIcon, null)])), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month__fast-next`,
        onClick: this.endCalendarNextYear
      }, resolveSlot($slots["next-year"], () => [vue.h(FastForwardIcon, null)]))), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-weekdays`
      }, this.weekdays.map((weekday) => vue.h("div", {
        key: weekday,
        class: `${mergedClsPrefix}-date-panel-weekdays__day`
      }, weekday))), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel__divider`
      }), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-dates`
      }, this.endDateArray.map((dateItem2, i) => vue.h("div", {
        "data-n-date": true,
        key: i,
        class: [`${mergedClsPrefix}-date-panel-date`, {
          [`${mergedClsPrefix}-date-panel-date--excluded`]: !dateItem2.inCurrentMonth,
          [`${mergedClsPrefix}-date-panel-date--current`]: dateItem2.isCurrentDate,
          [`${mergedClsPrefix}-date-panel-date--selected`]: dateItem2.selected,
          [`${mergedClsPrefix}-date-panel-date--covered`]: dateItem2.inSpan,
          [`${mergedClsPrefix}-date-panel-date--start`]: dateItem2.startOfSpan,
          [`${mergedClsPrefix}-date-panel-date--end`]: dateItem2.endOfSpan,
          [`${mergedClsPrefix}-date-panel-date--disabled`]: this.mergedIsDateDisabled(dateItem2.ts)
        }],
        onClick: () => {
          this.handleDateClick(dateItem2);
        },
        onMouseenter: () => {
          this.handleDateMouseEnter(dateItem2);
        }
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-date__trigger`
      }), dateItem2.dateObject.date, dateItem2.isCurrentDate ? vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-date__sup`
      }) : null)))), this.datePickerSlots.footer ? vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-footer`
      }, this.datePickerSlots.footer()) : null, ((_a = this.actions) === null || _a === void 0 ? void 0 : _a.length) || shortcuts ? vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-actions`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-actions__prefix`
      }, shortcuts && Object.keys(shortcuts).map((key) => {
        const shortcut = shortcuts[key];
        return Array.isArray(shortcut) || typeof shortcut === "function" ? vue.h(XButton, {
          size: "tiny",
          onMouseenter: () => {
            this.handleRangeShortcutMouseenter(shortcut);
          },
          onClick: () => {
            this.handleRangeShortcutClick(shortcut);
          },
          onMouseleave: () => {
            this.handleShortcutMouseleave();
          }
        }, {
          default: () => key
        }) : null;
      })), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-actions__suffix`
      }, ((_b = this.actions) === null || _b === void 0 ? void 0 : _b.includes("clear")) ? resolveSlotWithProps($slots.clear, {
        onClear: this.handleClearClick,
        text: this.locale.clear
      }, () => [vue.h(NButton, {
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        size: "tiny",
        onClick: this.handleClearClick
      }, {
        default: () => this.locale.clear
      })]) : null, ((_c = this.actions) === null || _c === void 0 ? void 0 : _c.includes("confirm")) ? resolveSlotWithProps($slots.confirm, {
        onConfirm: this.handleConfirmClick,
        disabled: this.isRangeInvalid || this.isSelecting,
        text: this.locale.confirm
      }, () => [vue.h(NButton, {
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        size: "tiny",
        type: "primary",
        disabled: this.isRangeInvalid || this.isSelecting,
        onClick: this.handleConfirmClick
      }, {
        default: () => this.locale.confirm
      })]) : null)) : null, vue.h(FocusDetector, {
        onFocus: this.handleFocusDetectorFocus
      }));
    }
  });
  const MonthRangePanel = vue.defineComponent({
    name: "MonthRangePanel",
    props: Object.assign(Object.assign({}, useDualCalendarProps), {
      type: {
        type: String,
        required: true
      }
    }),
    setup(props) {
      {
        vue.watchEffect(() => {
          var _a;
          if ((_a = props.actions) === null || _a === void 0 ? void 0 : _a.includes("now")) {
            warnOnce("date-picker", `The \`now\` action is not supported for n-date-picker of ${props.type}type`);
          }
        });
      }
      const useCalendarRef = useDualCalendar(props, props.type);
      const {
        dateLocaleRef
      } = useLocale("DatePicker");
      const renderItem = (item, i, mergedClsPrefix, type) => {
        const {
          handleColItemClick
        } = useCalendarRef;
        const disabled = false;
        return vue.h("div", {
          "data-n-date": true,
          key: i,
          class: [`${mergedClsPrefix}-date-panel-month-calendar__picker-col-item`, item.isCurrent && `${mergedClsPrefix}-date-panel-month-calendar__picker-col-item--current`, item.selected && `${mergedClsPrefix}-date-panel-month-calendar__picker-col-item--selected`, disabled],
          onClick: () => {
            handleColItemClick(item, type);
          }
        }, item.type === "month" ? getMonthString(item.dateObject.month, item.monthFormat, dateLocaleRef.value.locale) : item.type === "quarter" ? getQuarterString(item.dateObject.quarter, item.quarterFormat, dateLocaleRef.value.locale) : getYearString(item.dateObject.year, item.yearFormat, dateLocaleRef.value.locale));
      };
      vue.onMounted(() => {
        useCalendarRef.justifyColumnsScrollState();
      });
      return Object.assign(Object.assign({}, useCalendarRef), {
        renderItem
      });
    },
    render() {
      var _a, _b, _c;
      const {
        mergedClsPrefix,
        mergedTheme,
        shortcuts,
        type,
        renderItem,
        onRender
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h("div", {
        ref: "selfRef",
        tabindex: 0,
        class: [`${mergedClsPrefix}-date-panel`, `${mergedClsPrefix}-date-panel--daterange`, !this.panel && `${mergedClsPrefix}-date-panel--shadow`, this.themeClass],
        onKeydown: this.handlePanelKeyDown,
        onFocus: this.handlePanelFocus
      }, vue.h("div", {
        ref: "startDatesElRef",
        class: `${mergedClsPrefix}-date-panel-calendar ${mergedClsPrefix}-date-panel-calendar--start`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month-calendar`
      }, vue.h(NScrollbar, {
        ref: "startYearScrollbarRef",
        class: `${mergedClsPrefix}-date-panel-month-calendar__picker-col`,
        theme: mergedTheme.peers.Scrollbar,
        themeOverrides: mergedTheme.peerOverrides.Scrollbar,
        container: () => this.virtualListContainer("start"),
        content: () => this.virtualListContent("start"),
        horizontalRailStyle: {
          zIndex: 1
        },
        verticalRailStyle: {
          zIndex: 1
        }
      }, {
        default: () => vue.h(VVirtualList, {
          ref: "startYearVlRef",
          items: this.startYearArray,
          itemSize: MONTH_ITEM_HEIGHT,
          showScrollbar: false,
          keyField: "ts",
          onScroll: this.handleStartYearVlScroll,
          paddingBottom: 4
        }, {
          default: ({
            item,
            index
          }) => {
            return renderItem(item, index, mergedClsPrefix, "start");
          }
        })
      }), type === "monthrange" || type === "quarterrange" ? vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month-calendar__picker-col`
      }, vue.h(NScrollbar, {
        ref: "startMonthScrollbarRef",
        theme: mergedTheme.peers.Scrollbar,
        themeOverrides: mergedTheme.peerOverrides.Scrollbar
      }, {
        default: () => [(type === "monthrange" ? this.startMonthArray : this.startQuarterArray).map((item, i) => renderItem(item, i, mergedClsPrefix, "start")), type === "monthrange" && vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month-calendar__padding`
        })]
      })) : null)), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel__vertical-divider`
      }), vue.h("div", {
        ref: "endDatesElRef",
        class: `${mergedClsPrefix}-date-panel-calendar ${mergedClsPrefix}-date-panel-calendar--end`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month-calendar`
      }, vue.h(NScrollbar, {
        ref: "endYearScrollbarRef",
        class: `${mergedClsPrefix}-date-panel-month-calendar__picker-col`,
        theme: mergedTheme.peers.Scrollbar,
        themeOverrides: mergedTheme.peerOverrides.Scrollbar,
        container: () => this.virtualListContainer("end"),
        content: () => this.virtualListContent("end"),
        horizontalRailStyle: {
          zIndex: 1
        },
        verticalRailStyle: {
          zIndex: 1
        }
      }, {
        default: () => vue.h(VVirtualList, {
          ref: "endYearVlRef",
          items: this.endYearArray,
          itemSize: MONTH_ITEM_HEIGHT,
          showScrollbar: false,
          keyField: "ts",
          onScroll: this.handleEndYearVlScroll,
          paddingBottom: 4
        }, {
          default: ({
            item,
            index
          }) => {
            return renderItem(item, index, mergedClsPrefix, "end");
          }
        })
      }), type === "monthrange" || type === "quarterrange" ? vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-month-calendar__picker-col`
      }, vue.h(NScrollbar, {
        ref: "endMonthScrollbarRef",
        theme: mergedTheme.peers.Scrollbar,
        themeOverrides: mergedTheme.peerOverrides.Scrollbar
      }, {
        default: () => [(type === "monthrange" ? this.endMonthArray : this.endQuarterArray).map((item, i) => renderItem(item, i, mergedClsPrefix, "end")), type === "monthrange" && vue.h("div", {
          class: `${mergedClsPrefix}-date-panel-month-calendar__padding`
        })]
      })) : null)), this.datePickerSlots.footer ? vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-footer`
      }, vue.renderSlot(this.datePickerSlots, "footer")) : null, ((_a = this.actions) === null || _a === void 0 ? void 0 : _a.length) || shortcuts ? vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-actions`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-actions__prefix`
      }, shortcuts && Object.keys(shortcuts).map((key) => {
        const shortcut = shortcuts[key];
        return Array.isArray(shortcut) || typeof shortcut === "function" ? vue.h(XButton, {
          size: "tiny",
          onMouseenter: () => {
            this.handleRangeShortcutMouseenter(shortcut);
          },
          onClick: () => {
            this.handleRangeShortcutClick(shortcut);
          },
          onMouseleave: () => {
            this.handleShortcutMouseleave();
          }
        }, {
          default: () => key
        }) : null;
      })), vue.h("div", {
        class: `${mergedClsPrefix}-date-panel-actions__suffix`
      }, ((_b = this.actions) === null || _b === void 0 ? void 0 : _b.includes("clear")) ? resolveSlotWithProps(this.$slots.clear, {
        onClear: this.handleClearClick,
        text: this.locale.clear
      }, () => [vue.h(XButton, {
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        size: "tiny",
        onClick: this.handleClearClick
      }, {
        default: () => this.locale.clear
      })]) : null, ((_c = this.actions) === null || _c === void 0 ? void 0 : _c.includes("confirm")) ? resolveSlotWithProps(this.$slots.confirm, {
        disabled: this.isRangeInvalid,
        onConfirm: this.handleConfirmClick,
        text: this.locale.confirm
      }, () => [vue.h(XButton, {
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        size: "tiny",
        type: "primary",
        disabled: this.isRangeInvalid,
        onClick: this.handleConfirmClick
      }, {
        default: () => this.locale.confirm
      })]) : null)) : null, vue.h(FocusDetector, {
        onFocus: this.handleFocusDetectorFocus
      }));
    }
  });
  const style$V = c$1([cB("date-picker", `
 position: relative;
 z-index: auto;
 `, [cB("date-picker-icon", `
 color: var(--n-icon-color-override);
 transition: color .3s var(--n-bezier);
 `), cB("icon", `
 color: var(--n-icon-color-override);
 transition: color .3s var(--n-bezier);
 `), cM("disabled", [cB("date-picker-icon", `
 color: var(--n-icon-color-disabled-override);
 `), cB("icon", `
 color: var(--n-icon-color-disabled-override);
 `)])]), cB("date-panel", `
 width: fit-content;
 outline: none;
 margin: 4px 0;
 display: grid;
 grid-template-columns: 0fr;
 border-radius: var(--n-panel-border-radius);
 background-color: var(--n-panel-color);
 color: var(--n-panel-text-color);
 user-select: none;
 `, [fadeInScaleUpTransition(), cM("shadow", `
 box-shadow: var(--n-panel-box-shadow);
 `), cB("date-panel-calendar", {
    padding: "var(--n-calendar-left-padding)",
    display: "grid",
    gridTemplateColumns: "1fr",
    gridArea: "left-calendar"
  }, [cM("end", {
    padding: "var(--n-calendar-right-padding)",
    gridArea: "right-calendar"
  })]), cB("date-panel-month-calendar", {
    display: "flex",
    gridArea: "left-calendar"
  }, [cE("picker-col", `
 min-width: var(--n-scroll-item-width);
 height: calc(var(--n-scroll-item-height) * 6);
 user-select: none;
 -webkit-user-select: none;
 `, [c$1("&:first-child", `
 min-width: calc(var(--n-scroll-item-width) + 4px);
 `, [cE("picker-col-item", [c$1("&::before", "left: 4px;")])]), cE("padding", `
 height: calc(var(--n-scroll-item-height) * 5)
 `)]), cE("picker-col-item", `
 z-index: 0;
 cursor: pointer;
 height: var(--n-scroll-item-height);
 box-sizing: border-box;
 padding-top: 4px;
 display: flex;
 align-items: center;
 justify-content: center;
 position: relative;
 transition: 
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 background: #0000;
 color: var(--n-item-text-color);
 `, [c$1("&::before", `
 z-index: -1;
 content: "";
 position: absolute;
 left: 0;
 right: 4px;
 top: 4px;
 bottom: 0;
 border-radius: var(--n-scroll-item-border-radius);
 transition: 
 background-color .3s var(--n-bezier);
 `), cNotM("disabled", [c$1("&:hover::before", `
 background-color: var(--n-item-color-hover);
 `), cM("selected", `
 color: var(--n-item-color-active);
 `, [c$1("&::before", "background-color: var(--n-item-color-hover);")])]), cM("disabled", `
 color: var(--n-item-text-color-disabled);
 cursor: not-allowed;
 `, [cM("selected", [c$1("&::before", `
 background-color: var(--n-item-color-disabled);
 `)])])])]), cM("date", {
    gridTemplateAreas: `
 "left-calendar"
 "footer"
 "action"
 `
  }), cM("week", {
    gridTemplateAreas: `
 "left-calendar"
 "footer"
 "action"
 `
  }), cM("daterange", {
    gridTemplateAreas: `
 "left-calendar divider right-calendar"
 "footer footer footer"
 "action action action"
 `
  }), cM("datetime", {
    gridTemplateAreas: `
 "header"
 "left-calendar"
 "footer"
 "action"
 `
  }), cM("datetimerange", {
    gridTemplateAreas: `
 "header header header"
 "left-calendar divider right-calendar"
 "footer footer footer"
 "action action action"
 `
  }), cM("month", {
    gridTemplateAreas: `
 "left-calendar"
 "footer"
 "action"
 `
  }), cB("date-panel-footer", {
    gridArea: "footer"
  }), cB("date-panel-actions", {
    gridArea: "action"
  }), cB("date-panel-header", {
    gridArea: "header"
  }), cB("date-panel-header", `
 box-sizing: border-box;
 width: 100%;
 align-items: center;
 padding: var(--n-panel-header-padding);
 display: flex;
 justify-content: space-between;
 border-bottom: 1px solid var(--n-panel-header-divider-color);
 `, [c$1(">", [c$1("*:not(:last-child)", {
    marginRight: "10px"
  }), c$1("*", {
    flex: 1,
    width: 0
  }), cB("time-picker", {
    zIndex: 1
  })])]), cB("date-panel-month", `
 box-sizing: border-box;
 display: grid;
 grid-template-columns: var(--n-calendar-title-grid-template-columns);
 align-items: center;
 justify-items: center;
 padding: var(--n-calendar-title-padding);
 height: var(--n-calendar-title-height);
 `, [cE("prev, next, fast-prev, fast-next", `
 line-height: 0;
 cursor: pointer;
 width: var(--n-arrow-size);
 height: var(--n-arrow-size);
 color: var(--n-arrow-color);
 `), cE("month-year", `
 user-select: none;
 -webkit-user-select: none;
 flex-grow: 1;
 position: relative;
 `, [cE("text", `
 font-size: var(--n-calendar-title-font-size);
 line-height: var(--n-calendar-title-font-size);
 font-weight: var(--n-calendar-title-font-weight);
 padding: 6px 8px;
 text-align: center;
 color: var(--n-calendar-title-text-color);
 cursor: pointer;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-panel-border-radius);
 `, [cM("active", `
 background-color: var(--n-calendar-title-color-hover);
 `), c$1("&:hover", `
 background-color: var(--n-calendar-title-color-hover);
 `)])])]), cB("date-panel-weekdays", `
 display: grid;
 margin: auto;
 grid-template-columns: repeat(7, var(--n-item-cell-width));
 grid-template-rows: repeat(1, var(--n-item-cell-height));
 align-items: center;
 justify-items: center;
 margin-bottom: 4px;
 border-bottom: 1px solid var(--n-calendar-days-divider-color);
 `, [cE("day", `
 user-select: none;
 -webkit-user-select: none;
 line-height: 15px;
 width: var(--n-item-size);
 text-align: center;
 font-size: var(--n-calendar-days-font-size);
 color: var(--n-item-text-color);
 `)]), cB("date-panel-dates", `
 margin: auto;
 display: grid;
 grid-template-columns: repeat(7, var(--n-item-cell-width));
 grid-template-rows: repeat(6, var(--n-item-cell-height));
 align-items: center;
 justify-items: center;
 flex-wrap: wrap;
 `, [cB("date-panel-date", `
 user-select: none;
 -webkit-user-select: none;
 position: relative;
 width: var(--n-item-size);
 height: var(--n-item-size);
 line-height: var(--n-item-size);
 text-align: center;
 font-size: var(--n-item-font-size);
 border-radius: var(--n-item-border-radius);
 z-index: 0;
 cursor: pointer;
 transition:
 background-color .2s var(--n-bezier),
 color .2s var(--n-bezier);
 `, [cE("trigger", `
 position: absolute;
 left: calc(var(--n-item-size) / 2 - var(--n-item-cell-width) / 2);
 top: calc(var(--n-item-size) / 2 - var(--n-item-cell-height) / 2);
 width: var(--n-item-cell-width);
 height: var(--n-item-cell-height);
 `), cM("current", [cE("sup", `
 position: absolute;
 top: 2px;
 right: 2px;
 content: "";
 height: 4px;
 width: 4px;
 border-radius: 2px;
 background-color: var(--n-item-color-active);
 transition:
 background-color .2s var(--n-bezier);
 `)]), c$1("&::after", `
 content: "";
 z-index: -1;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 transition: background-color .3s var(--n-bezier);
 `), cM("covered, start, end", [cNotM("excluded", [c$1("&::before", `
 content: "";
 z-index: -2;
 position: absolute;
 left: calc((var(--n-item-size) - var(--n-item-cell-width)) / 2);
 right: calc((var(--n-item-size) - var(--n-item-cell-width)) / 2);
 top: 0;
 bottom: 0;
 background-color: var(--n-item-color-included);
 `), c$1("&:nth-child(7n + 1)::before", {
    borderTopLeftRadius: "var(--n-item-border-radius)",
    borderBottomLeftRadius: "var(--n-item-border-radius)"
  }), c$1("&:nth-child(7n + 7)::before", {
    borderTopRightRadius: "var(--n-item-border-radius)",
    borderBottomRightRadius: "var(--n-item-border-radius)"
  })])]), cM("selected", {
    color: "var(--n-item-text-color-active)"
  }, [c$1("&::after", {
    backgroundColor: "var(--n-item-color-active)"
  }), cM("start", [c$1("&::before", {
    left: "50%"
  })]), cM("end", [c$1("&::before", {
    right: "50%"
  })]), cE("sup", {
    backgroundColor: "var(--n-panel-color)"
  })]), cM("excluded", {
    color: "var(--n-item-text-color-disabled)"
  }, [cM("selected", [c$1("&::after", {
    backgroundColor: "var(--n-item-color-disabled)"
  })])]), cM("disabled", {
    cursor: "not-allowed",
    color: "var(--n-item-text-color-disabled)"
  }, [cM("covered", [c$1("&::before", {
    backgroundColor: "var(--n-item-color-disabled)"
  })]), cM("selected", [c$1("&::before", {
    backgroundColor: "var(--n-item-color-disabled)"
  }), c$1("&::after", {
    backgroundColor: "var(--n-item-color-disabled)"
  })])]), cM("week-hovered", [c$1("&::before", `
 background-color: var(--n-item-color-included);
 `), c$1("&:nth-child(7n + 1)::before", `
 border-top-left-radius: var(--n-item-border-radius);
 border-bottom-left-radius: var(--n-item-border-radius);
 `), c$1("&:nth-child(7n + 7)::before", `
 border-top-right-radius: var(--n-item-border-radius);
 border-bottom-right-radius: var(--n-item-border-radius);
 `)]), cM("week-selected", `
 color: var(--n-item-text-color-active)
 `, [c$1("&::before", `
 background-color: var(--n-item-color-active);
 `), c$1("&:nth-child(7n + 1)::before", `
 border-top-left-radius: var(--n-item-border-radius);
 border-bottom-left-radius: var(--n-item-border-radius);
 `), c$1("&:nth-child(7n + 7)::before", `
 border-top-right-radius: var(--n-item-border-radius);
 border-bottom-right-radius: var(--n-item-border-radius);
 `)])])]), cNotM("week", [cB("date-panel-dates", [cB("date-panel-date", [cNotM("disabled", [cNotM("selected", [c$1("&:hover", `
 background-color: var(--n-item-color-hover);
 `)])])])])]), cM("week", [cB("date-panel-dates", [cB("date-panel-date", [c$1("&::before", `
 content: "";
 z-index: -2;
 position: absolute;
 left: calc((var(--n-item-size) - var(--n-item-cell-width)) / 2);
 right: calc((var(--n-item-size) - var(--n-item-cell-width)) / 2);
 top: 0;
 bottom: 0;
 transition: background-color .3s var(--n-bezier);
 `)])])]), cE("vertical-divider", `
 grid-area: divider;
 height: 100%;
 width: 1px;
 background-color: var(--n-calendar-divider-color);
 `), cB("date-panel-footer", `
 border-top: 1px solid var(--n-panel-action-divider-color);
 padding: var(--n-panel-extra-footer-padding);
 `), cB("date-panel-actions", `
 flex: 1;
 padding: var(--n-panel-action-padding);
 display: flex;
 align-items: center;
 justify-content: space-between;
 border-top: 1px solid var(--n-panel-action-divider-color);
 `, [cE("prefix, suffix", `
 display: flex;
 margin-bottom: -8px;
 `), cE("suffix", `
 align-self: flex-end;
 `), cE("prefix", `
 flex-wrap: wrap;
 `), cB("button", `
 margin-bottom: 8px;
 `, [c$1("&:not(:last-child)", `
 margin-right: 8px;
 `)])])]), c$1("[data-n-date].transition-disabled", {
    transition: "none !important"
  }, [c$1("&::before, &::after", {
    transition: "none !important"
  })])]);
  const datePickerProps = Object.assign(Object.assign({}, useTheme.props), {
    to: useAdjustedTo.propTo,
    bordered: {
      type: Boolean,
      default: void 0
    },
    clearable: Boolean,
    updateValueOnClose: Boolean,
    defaultValue: [Number, Array],
    defaultFormattedValue: [String, Array],
    defaultTime: [Number, String, Array],
    disabled: {
      type: Boolean,
      default: void 0
    },
    placement: {
      type: String,
      default: "bottom-start"
    },
    value: [Number, Array],
    formattedValue: [String, Array],
    size: String,
    type: {
      type: String,
      default: "date"
    },
    valueFormat: String,
    separator: String,
    placeholder: String,
    startPlaceholder: String,
    endPlaceholder: String,
    format: String,
    dateFormat: String,
    timerPickerFormat: String,
    actions: Array,
    shortcuts: Object,
    isDateDisabled: Function,
    isTimeDisabled: Function,
    show: {
      type: Boolean,
      default: void 0
    },
    panel: Boolean,
    ranges: Object,
    firstDayOfWeek: Number,
    inputReadonly: Boolean,
    closeOnSelect: Boolean,
    status: String,
    timePickerProps: [Object, Array],
    onClear: Function,
    onConfirm: Function,
    defaultCalendarStartTime: Number,
    defaultCalendarEndTime: Number,
    bindCalendarMonths: Boolean,
    monthFormat: {
      type: String,
      default: "M"
    },
    yearFormat: {
      type: String,
      default: "y"
    },
    quarterFormat: {
      type: String,
      default: "'Q'Q"
    },
    yearRange: {
      type: Array,
      default: () => [1901, 2100]
    },
    "onUpdate:show": [Function, Array],
    onUpdateShow: [Function, Array],
    "onUpdate:formattedValue": [Function, Array],
    onUpdateFormattedValue: [Function, Array],
    "onUpdate:value": [Function, Array],
    onUpdateValue: [Function, Array],
    onFocus: [Function, Array],
    onBlur: [Function, Array],
    onNextMonth: Function,
    onPrevMonth: Function,
    onNextYear: Function,
    onPrevYear: Function,
    // deprecated
    onChange: [Function, Array]
  });
  const DatePicker = vue.defineComponent({
    name: "DatePicker",
    props: datePickerProps,
    setup(props, {
      slots
    }) {
      var _a;
      {
        vue.watchEffect(() => {
          if (props.onChange !== void 0) {
            warnOnce("date-picker", "`on-change` is deprecated, please use `on-update:value` instead.");
          }
        });
      }
      const {
        localeRef,
        dateLocaleRef
      } = useLocale("DatePicker");
      const formItem = useFormItem(props);
      const {
        mergedSizeRef,
        mergedDisabledRef,
        mergedStatusRef
      } = formItem;
      const {
        mergedComponentPropsRef,
        mergedClsPrefixRef,
        mergedBorderedRef,
        namespaceRef,
        inlineThemeDisabled
      } = useConfig(props);
      const panelInstRef = vue.ref(null);
      const triggerElRef = vue.ref(null);
      const inputInstRef = vue.ref(null);
      const uncontrolledShowRef = vue.ref(false);
      const controlledShowRef = vue.toRef(props, "show");
      const mergedShowRef = useMergedState(controlledShowRef, uncontrolledShowRef);
      const dateFnsOptionsRef = vue.computed(() => {
        return {
          locale: dateLocaleRef.value.locale,
          useAdditionalWeekYearTokens: true
        };
      });
      const mergedFormatRef = vue.computed(() => {
        const {
          format: format2
        } = props;
        if (format2)
          return format2;
        switch (props.type) {
          case "date":
          case "daterange":
            return localeRef.value.dateFormat;
          case "datetime":
          case "datetimerange":
            return localeRef.value.dateTimeFormat;
          case "year":
          case "yearrange":
            return localeRef.value.yearTypeFormat;
          case "month":
          case "monthrange":
            return localeRef.value.monthTypeFormat;
          case "quarter":
          case "quarterrange":
            return localeRef.value.quarterFormat;
          case "week":
            return localeRef.value.weekFormat;
        }
      });
      const mergedValueFormatRef = vue.computed(() => {
        var _a2;
        return (_a2 = props.valueFormat) !== null && _a2 !== void 0 ? _a2 : mergedFormatRef.value;
      });
      function getTimestampValue(value) {
        if (value === null)
          return null;
        const {
          value: mergedValueFormat
        } = mergedValueFormatRef;
        const {
          value: dateFnsOptions
        } = dateFnsOptionsRef;
        if (Array.isArray(value)) {
          return [strictParse(value[0], mergedValueFormat, /* @__PURE__ */ new Date(), dateFnsOptions).getTime(), strictParse(value[1], mergedValueFormat, /* @__PURE__ */ new Date(), dateFnsOptions).getTime()];
        }
        return strictParse(value, mergedValueFormat, /* @__PURE__ */ new Date(), dateFnsOptions).getTime();
      }
      const {
        defaultFormattedValue,
        defaultValue
      } = props;
      const uncontrolledValueRef = vue.ref((_a = defaultFormattedValue !== void 0 ? getTimestampValue(defaultFormattedValue) : defaultValue) !== null && _a !== void 0 ? _a : null);
      const controlledValueRef = vue.computed(() => {
        const {
          formattedValue
        } = props;
        if (formattedValue !== void 0) {
          return getTimestampValue(formattedValue);
        }
        return props.value;
      });
      const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
      const pendingValueRef = vue.ref(null);
      vue.watchEffect(() => {
        pendingValueRef.value = mergedValueRef.value;
      });
      const singleInputValueRef = vue.ref("");
      const rangeStartInputValueRef = vue.ref("");
      const rangeEndInputValueRef = vue.ref("");
      const themeRef = useTheme("DatePicker", "-date-picker", style$V, datePickerLight$1, props, mergedClsPrefixRef);
      const timePickerSizeRef = vue.computed(() => {
        var _a2, _b;
        return ((_b = (_a2 = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a2 === void 0 ? void 0 : _a2.DatePicker) === null || _b === void 0 ? void 0 : _b.timePickerSize) || "small";
      });
      const isRangeRef = vue.computed(() => {
        return ["daterange", "datetimerange", "monthrange", "quarterrange", "yearrange"].includes(props.type);
      });
      const localizedPlacehoderRef = vue.computed(() => {
        const {
          placeholder
        } = props;
        if (placeholder === void 0) {
          const {
            type
          } = props;
          switch (type) {
            case "date":
              return localeRef.value.datePlaceholder;
            case "datetime":
              return localeRef.value.datetimePlaceholder;
            case "month":
              return localeRef.value.monthPlaceholder;
            case "year":
              return localeRef.value.yearPlaceholder;
            case "quarter":
              return localeRef.value.quarterPlaceholder;
            case "week":
              return localeRef.value.weekPlaceholder;
            default:
              return "";
          }
        } else {
          return placeholder;
        }
      });
      const localizedStartPlaceholderRef = vue.computed(() => {
        if (props.startPlaceholder === void 0) {
          if (props.type === "daterange") {
            return localeRef.value.startDatePlaceholder;
          } else if (props.type === "datetimerange") {
            return localeRef.value.startDatetimePlaceholder;
          } else if (props.type === "monthrange") {
            return localeRef.value.startMonthPlaceholder;
          }
          return "";
        } else {
          return props.startPlaceholder;
        }
      });
      const localizedEndPlaceholderRef = vue.computed(() => {
        if (props.endPlaceholder === void 0) {
          if (props.type === "daterange") {
            return localeRef.value.endDatePlaceholder;
          } else if (props.type === "datetimerange") {
            return localeRef.value.endDatetimePlaceholder;
          } else if (props.type === "monthrange") {
            return localeRef.value.endMonthPlaceholder;
          }
          return "";
        } else {
          return props.endPlaceholder;
        }
      });
      const mergedActionsRef = vue.computed(() => {
        const {
          actions,
          type,
          clearable
        } = props;
        if (actions === null)
          return [];
        if (actions !== void 0)
          return actions;
        const result = clearable ? ["clear"] : [];
        switch (type) {
          case "date":
          case "week": {
            result.push("now");
            return result;
          }
          case "datetime": {
            result.push("now", "confirm");
            return result;
          }
          case "daterange": {
            result.push("confirm");
            return result;
          }
          case "datetimerange": {
            result.push("confirm");
            return result;
          }
          case "month": {
            result.push("now", "confirm");
            return result;
          }
          case "year": {
            result.push("now");
            return result;
          }
          case "quarter": {
            result.push("now", "confirm");
            return result;
          }
          case "monthrange":
          case "yearrange":
          case "quarterrange": {
            result.push("confirm");
            return result;
          }
          default: {
            warn$2("date-picker", "The type is wrong, n-date-picker's type only supports `date`, `datetime`, `daterange` and `datetimerange`.");
            break;
          }
        }
      });
      function getFormattedValue(value) {
        if (value === null)
          return null;
        if (Array.isArray(value)) {
          const {
            value: mergedValueFormat
          } = mergedValueFormatRef;
          const {
            value: dateFnsOptions
          } = dateFnsOptionsRef;
          return [format$3(value[0], mergedValueFormat, dateFnsOptions), format$3(value[1], mergedValueFormat, dateFnsOptionsRef.value)];
        } else {
          return format$3(value, mergedValueFormatRef.value, dateFnsOptionsRef.value);
        }
      }
      function doUpdatePendingValue(value) {
        pendingValueRef.value = value;
      }
      function doUpdateFormattedValue(value, timestampValue) {
        const {
          "onUpdate:formattedValue": _onUpdateFormattedValue,
          onUpdateFormattedValue
        } = props;
        if (_onUpdateFormattedValue) {
          call(_onUpdateFormattedValue, value, timestampValue);
        }
        if (onUpdateFormattedValue) {
          call(onUpdateFormattedValue, value, timestampValue);
        }
      }
      function doUpdateValue(value, options) {
        const {
          "onUpdate:value": _onUpdateValue,
          onUpdateValue,
          onChange
        } = props;
        const {
          nTriggerFormChange,
          nTriggerFormInput
        } = formItem;
        const formattedValue = getFormattedValue(value);
        if (options.doConfirm) {
          doConfirm(value, formattedValue);
        }
        if (onUpdateValue) {
          call(onUpdateValue, value, formattedValue);
        }
        if (_onUpdateValue) {
          call(_onUpdateValue, value, formattedValue);
        }
        if (onChange)
          call(onChange, value, formattedValue);
        uncontrolledValueRef.value = value;
        doUpdateFormattedValue(formattedValue, value);
        nTriggerFormChange();
        nTriggerFormInput();
      }
      function doClear() {
        const {
          onClear
        } = props;
        onClear === null || onClear === void 0 ? void 0 : onClear();
      }
      function doConfirm(value, formattedValue) {
        const {
          onConfirm
        } = props;
        if (onConfirm)
          onConfirm(value, formattedValue);
      }
      function doFocus(e) {
        const {
          onFocus
        } = props;
        const {
          nTriggerFormFocus
        } = formItem;
        if (onFocus)
          call(onFocus, e);
        nTriggerFormFocus();
      }
      function doBlur(e) {
        const {
          onBlur
        } = props;
        const {
          nTriggerFormBlur
        } = formItem;
        if (onBlur)
          call(onBlur, e);
        nTriggerFormBlur();
      }
      function doUpdateShow(show) {
        const {
          "onUpdate:show": _onUpdateShow,
          onUpdateShow
        } = props;
        if (_onUpdateShow)
          call(_onUpdateShow, show);
        if (onUpdateShow)
          call(onUpdateShow, show);
        uncontrolledShowRef.value = show;
      }
      function handleKeydown(e) {
        if (e.key === "Escape") {
          if (mergedShowRef.value) {
            markEventEffectPerformed(e);
            closeCalendar({
              returnFocus: true
            });
          }
        }
      }
      function handleInputKeydown(e) {
        if (e.key === "Escape" && mergedShowRef.value) {
          markEventEffectPerformed(e);
        }
      }
      function handleClear() {
        var _a2;
        doUpdateShow(false);
        (_a2 = inputInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.deactivate();
        doClear();
      }
      function handlePanelClear() {
        var _a2;
        (_a2 = inputInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.deactivate();
        doClear();
      }
      function handlePanelTabOut() {
        closeCalendar({
          returnFocus: true
        });
      }
      function handleClickOutside(e) {
        var _a2;
        if (mergedShowRef.value && !((_a2 = triggerElRef.value) === null || _a2 === void 0 ? void 0 : _a2.contains(getPreciseEventTarget(e)))) {
          closeCalendar({
            returnFocus: false
          });
        }
      }
      function handlePanelClose(disableUpdateOnClose) {
        closeCalendar({
          returnFocus: true,
          disableUpdateOnClose
        });
      }
      function handlePanelUpdateValue(value, doUpdate) {
        if (doUpdate) {
          doUpdateValue(value, {
            doConfirm: false
          });
        } else {
          doUpdatePendingValue(value);
        }
      }
      function handlePanelConfirm() {
        const pendingValue = pendingValueRef.value;
        doUpdateValue(Array.isArray(pendingValue) ? [pendingValue[0], pendingValue[1]] : pendingValue, {
          doConfirm: true
        });
      }
      function deriveInputState() {
        const {
          value
        } = pendingValueRef;
        if (isRangeRef.value) {
          if (Array.isArray(value) || value === null) {
            deriveRangeInputState(value);
          }
        } else {
          if (!Array.isArray(value)) {
            deriveSingleInputState(value);
          }
        }
      }
      function deriveSingleInputState(value) {
        if (value === null) {
          singleInputValueRef.value = "";
        } else {
          singleInputValueRef.value = format$3(value, mergedFormatRef.value, dateFnsOptionsRef.value);
        }
      }
      function deriveRangeInputState(values) {
        if (values === null) {
          rangeStartInputValueRef.value = "";
          rangeEndInputValueRef.value = "";
        } else {
          const dateFnsOptions = dateFnsOptionsRef.value;
          rangeStartInputValueRef.value = format$3(values[0], mergedFormatRef.value, dateFnsOptions);
          rangeEndInputValueRef.value = format$3(values[1], mergedFormatRef.value, dateFnsOptions);
        }
      }
      function handleInputActivate() {
        if (!mergedShowRef.value) {
          openCalendar();
        }
      }
      function handleInputBlur(e) {
        var _a2;
        if (!((_a2 = panelInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.$el.contains(e.relatedTarget))) {
          doBlur(e);
          deriveInputState();
          closeCalendar({
            returnFocus: false
          });
        }
      }
      function handleInputDeactivate() {
        if (mergedDisabledRef.value)
          return;
        deriveInputState();
        closeCalendar({
          returnFocus: false
        });
      }
      function handleSingleUpdateValue(v) {
        if (v === "") {
          doUpdateValue(null, {
            doConfirm: false
          });
          pendingValueRef.value = null;
          singleInputValueRef.value = "";
          return;
        }
        const newSelectedDateTime = strictParse(v, mergedFormatRef.value, /* @__PURE__ */ new Date(), dateFnsOptionsRef.value);
        if (isValid(newSelectedDateTime)) {
          doUpdateValue(getTime(newSelectedDateTime), {
            doConfirm: false
          });
          deriveInputState();
        } else {
          singleInputValueRef.value = v;
        }
      }
      function handleRangeUpdateValue(v, {
        source
      }) {
        if (v[0] === "" && v[1] === "") {
          doUpdateValue(null, {
            doConfirm: false
          });
          pendingValueRef.value = null;
          rangeStartInputValueRef.value = "";
          rangeEndInputValueRef.value = "";
          return;
        }
        const [startTime, endTime] = v;
        const newStartTime = strictParse(startTime, mergedFormatRef.value, /* @__PURE__ */ new Date(), dateFnsOptionsRef.value);
        const newEndTime = strictParse(endTime, mergedFormatRef.value, /* @__PURE__ */ new Date(), dateFnsOptionsRef.value);
        if (isValid(newStartTime) && isValid(newEndTime)) {
          let newStartTs = getTime(newStartTime);
          let newEndTs = getTime(newEndTime);
          if (newEndTime < newStartTime) {
            if (source === 0) {
              newEndTs = newStartTs;
            } else {
              newStartTs = newEndTs;
            }
          }
          doUpdateValue([newStartTs, newEndTs], {
            doConfirm: false
          });
          deriveInputState();
        } else {
          [rangeStartInputValueRef.value, rangeEndInputValueRef.value] = v;
        }
      }
      function handleTriggerClick(e) {
        if (mergedDisabledRef.value)
          return;
        if (happensIn(e, "clear"))
          return;
        if (!mergedShowRef.value) {
          openCalendar();
        }
      }
      function handleInputFocus(e) {
        if (mergedDisabledRef.value)
          return;
        doFocus(e);
      }
      function openCalendar() {
        if (mergedDisabledRef.value || mergedShowRef.value)
          return;
        doUpdateShow(true);
      }
      function closeCalendar({
        returnFocus,
        disableUpdateOnClose
      }) {
        var _a2;
        if (mergedShowRef.value) {
          doUpdateShow(false);
          if (props.type !== "date" && props.updateValueOnClose && !disableUpdateOnClose) {
            handlePanelConfirm();
          }
          if (returnFocus) {
            (_a2 = inputInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
          }
        }
      }
      vue.watch(pendingValueRef, () => {
        deriveInputState();
      });
      deriveInputState();
      vue.watch(mergedShowRef, (value) => {
        if (!value) {
          pendingValueRef.value = mergedValueRef.value;
        }
      });
      const uniVaidation = uniCalendarValidation(props, pendingValueRef);
      const dualValidation = dualCalendarValidation(props, pendingValueRef);
      vue.provide(datePickerInjectionKey, Object.assign(Object.assign(Object.assign({
        mergedClsPrefixRef,
        mergedThemeRef: themeRef,
        timePickerSizeRef,
        localeRef,
        dateLocaleRef,
        firstDayOfWeekRef: vue.toRef(props, "firstDayOfWeek"),
        isDateDisabledRef: vue.toRef(props, "isDateDisabled"),
        rangesRef: vue.toRef(props, "ranges"),
        timePickerPropsRef: vue.toRef(props, "timePickerProps"),
        closeOnSelectRef: vue.toRef(props, "closeOnSelect"),
        updateValueOnCloseRef: vue.toRef(props, "updateValueOnClose"),
        monthFormatRef: vue.toRef(props, "monthFormat"),
        yearFormatRef: vue.toRef(props, "yearFormat"),
        quarterFormatRef: vue.toRef(props, "quarterFormat"),
        yearRangeRef: vue.toRef(props, "yearRange")
      }, uniVaidation), dualValidation), {
        datePickerSlots: slots
      }));
      const exposedMethods = {
        focus: () => {
          var _a2;
          (_a2 = inputInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
        },
        blur: () => {
          var _a2;
          (_a2 = inputInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
        }
      };
      const triggerCssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            iconColor,
            iconColorDisabled
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-icon-color-override": iconColor,
          "--n-icon-color-disabled-override": iconColorDisabled
        };
      });
      const triggerThemeClassHandle = inlineThemeDisabled ? useThemeClass("date-picker-trigger", void 0, triggerCssVarsRef, props) : void 0;
      const cssVarsRef = vue.computed(() => {
        const {
          type
        } = props;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            calendarTitleFontSize,
            calendarDaysFontSize,
            itemFontSize,
            itemTextColor,
            itemColorDisabled,
            itemColorIncluded,
            itemColorHover,
            itemColorActive,
            itemBorderRadius,
            itemTextColorDisabled,
            itemTextColorActive,
            panelColor,
            panelTextColor,
            arrowColor,
            calendarTitleTextColor,
            panelActionDividerColor,
            panelHeaderDividerColor,
            calendarDaysDividerColor,
            panelBoxShadow,
            panelBorderRadius,
            calendarTitleFontWeight,
            panelExtraFooterPadding,
            panelActionPadding,
            itemSize,
            itemCellWidth,
            itemCellHeight,
            scrollItemWidth,
            scrollItemHeight,
            calendarTitlePadding,
            calendarTitleHeight,
            calendarDaysHeight,
            calendarDaysTextColor,
            arrowSize: arrowSize2,
            panelHeaderPadding,
            calendarDividerColor,
            calendarTitleGridTempateColumns,
            iconColor,
            iconColorDisabled,
            scrollItemBorderRadius,
            calendarTitleColorHover,
            [createKey("calendarLeftPadding", type)]: calendarLeftPadding,
            [createKey("calendarRightPadding", type)]: calendarRightPadding
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-panel-border-radius": panelBorderRadius,
          "--n-panel-color": panelColor,
          "--n-panel-box-shadow": panelBoxShadow,
          "--n-panel-text-color": panelTextColor,
          // panel header
          "--n-panel-header-padding": panelHeaderPadding,
          "--n-panel-header-divider-color": panelHeaderDividerColor,
          // panel calendar
          "--n-calendar-left-padding": calendarLeftPadding,
          "--n-calendar-right-padding": calendarRightPadding,
          "--n-calendar-title-color-hover": calendarTitleColorHover,
          "--n-calendar-title-height": calendarTitleHeight,
          "--n-calendar-title-padding": calendarTitlePadding,
          "--n-calendar-title-font-size": calendarTitleFontSize,
          "--n-calendar-title-font-weight": calendarTitleFontWeight,
          "--n-calendar-title-text-color": calendarTitleTextColor,
          "--n-calendar-title-grid-template-columns": calendarTitleGridTempateColumns,
          "--n-calendar-days-height": calendarDaysHeight,
          "--n-calendar-days-divider-color": calendarDaysDividerColor,
          "--n-calendar-days-font-size": calendarDaysFontSize,
          "--n-calendar-days-text-color": calendarDaysTextColor,
          "--n-calendar-divider-color": calendarDividerColor,
          // panel action
          "--n-panel-action-padding": panelActionPadding,
          "--n-panel-extra-footer-padding": panelExtraFooterPadding,
          "--n-panel-action-divider-color": panelActionDividerColor,
          // panel item
          "--n-item-font-size": itemFontSize,
          "--n-item-border-radius": itemBorderRadius,
          "--n-item-size": itemSize,
          "--n-item-cell-width": itemCellWidth,
          "--n-item-cell-height": itemCellHeight,
          "--n-item-text-color": itemTextColor,
          "--n-item-color-included": itemColorIncluded,
          "--n-item-color-disabled": itemColorDisabled,
          "--n-item-color-hover": itemColorHover,
          "--n-item-color-active": itemColorActive,
          "--n-item-text-color-disabled": itemTextColorDisabled,
          "--n-item-text-color-active": itemTextColorActive,
          // scroll item
          "--n-scroll-item-width": scrollItemWidth,
          "--n-scroll-item-height": scrollItemHeight,
          "--n-scroll-item-border-radius": scrollItemBorderRadius,
          // panel arrow
          "--n-arrow-size": arrowSize2,
          "--n-arrow-color": arrowColor,
          // icon in trigger
          "--n-icon-color": iconColor,
          "--n-icon-color-disabled": iconColorDisabled
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("date-picker", vue.computed(() => {
        return props.type;
      }), cssVarsRef, props) : void 0;
      return Object.assign(Object.assign({}, exposedMethods), {
        mergedStatus: mergedStatusRef,
        mergedClsPrefix: mergedClsPrefixRef,
        mergedBordered: mergedBorderedRef,
        namespace: namespaceRef,
        uncontrolledValue: uncontrolledValueRef,
        pendingValue: pendingValueRef,
        panelInstRef,
        triggerElRef,
        inputInstRef,
        isMounted: isMounted(),
        displayTime: singleInputValueRef,
        displayStartTime: rangeStartInputValueRef,
        displayEndTime: rangeEndInputValueRef,
        mergedShow: mergedShowRef,
        adjustedTo: useAdjustedTo(props),
        isRange: isRangeRef,
        localizedStartPlaceholder: localizedStartPlaceholderRef,
        localizedEndPlaceholder: localizedEndPlaceholderRef,
        mergedSize: mergedSizeRef,
        mergedDisabled: mergedDisabledRef,
        localizedPlacehoder: localizedPlacehoderRef,
        isValueInvalid: uniVaidation.isValueInvalidRef,
        isStartValueInvalid: dualValidation.isStartValueInvalidRef,
        isEndValueInvalid: dualValidation.isEndValueInvalidRef,
        handleInputKeydown,
        handleClickOutside,
        handleKeydown,
        handleClear,
        handlePanelClear,
        handleTriggerClick,
        handleInputActivate,
        handleInputDeactivate,
        handleInputFocus,
        handleInputBlur,
        handlePanelTabOut,
        handlePanelClose,
        handleRangeUpdateValue,
        handleSingleUpdateValue,
        handlePanelUpdateValue,
        handlePanelConfirm,
        mergedTheme: themeRef,
        actions: mergedActionsRef,
        triggerCssVars: inlineThemeDisabled ? void 0 : triggerCssVarsRef,
        triggerThemeClass: triggerThemeClassHandle === null || triggerThemeClassHandle === void 0 ? void 0 : triggerThemeClassHandle.themeClass,
        triggerOnRender: triggerThemeClassHandle === null || triggerThemeClassHandle === void 0 ? void 0 : triggerThemeClassHandle.onRender,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
        onNextMonth: props.onNextMonth,
        onPrevMonth: props.onPrevMonth,
        onNextYear: props.onNextYear,
        onPrevYear: props.onPrevYear
      });
    },
    render() {
      const {
        clearable,
        triggerOnRender,
        mergedClsPrefix,
        $slots
      } = this;
      const commonPanelProps = {
        onUpdateValue: this.handlePanelUpdateValue,
        onTabOut: this.handlePanelTabOut,
        onClose: this.handlePanelClose,
        onClear: this.handlePanelClear,
        onKeydown: this.handleKeydown,
        onConfirm: this.handlePanelConfirm,
        ref: "panelInstRef",
        value: this.pendingValue,
        active: this.mergedShow,
        actions: this.actions,
        shortcuts: this.shortcuts,
        style: this.cssVars,
        defaultTime: this.defaultTime,
        themeClass: this.themeClass,
        panel: this.panel,
        inputReadonly: this.inputReadonly || this.mergedDisabled,
        onRender: this.onRender,
        onNextMonth: this.onNextMonth,
        onPrevMonth: this.onPrevMonth,
        onNextYear: this.onNextYear,
        onPrevYear: this.onPrevYear,
        timerPickerFormat: this.timerPickerFormat
      };
      const renderPanel = () => {
        const {
          type
        } = this;
        return type === "datetime" ? vue.h(DatetimePanel, Object.assign({}, commonPanelProps, {
          defaultCalendarStartTime: this.defaultCalendarStartTime
        }), $slots) : type === "daterange" ? vue.h(DaterangePanel, Object.assign({}, commonPanelProps, {
          defaultCalendarStartTime: this.defaultCalendarStartTime,
          defaultCalendarEndTime: this.defaultCalendarEndTime,
          bindCalendarMonths: this.bindCalendarMonths
        }), $slots) : type === "datetimerange" ? vue.h(DatetimerangePanel, Object.assign({}, commonPanelProps, {
          defaultCalendarStartTime: this.defaultCalendarStartTime,
          defaultCalendarEndTime: this.defaultCalendarEndTime,
          bindCalendarMonths: this.bindCalendarMonths
        }), $slots) : type === "month" || type === "year" || type === "quarter" ? vue.h(MonthPanel, Object.assign({}, commonPanelProps, {
          type,
          key: type
        })) : type === "monthrange" || type === "yearrange" || type === "quarterrange" ? vue.h(MonthRangePanel, Object.assign({}, commonPanelProps, {
          type
        })) : vue.h(DatePanel, Object.assign({}, commonPanelProps, {
          type,
          defaultCalendarStartTime: this.defaultCalendarStartTime
        }), $slots);
      };
      if (this.panel) {
        return renderPanel();
      }
      triggerOnRender === null || triggerOnRender === void 0 ? void 0 : triggerOnRender();
      const commonInputProps = {
        bordered: this.mergedBordered,
        size: this.mergedSize,
        passivelyActivated: true,
        disabled: this.mergedDisabled,
        readonly: this.inputReadonly || this.mergedDisabled,
        clearable,
        onClear: this.handleClear,
        onClick: this.handleTriggerClick,
        onKeydown: this.handleInputKeydown,
        onActivate: this.handleInputActivate,
        onDeactivate: this.handleInputDeactivate,
        onFocus: this.handleInputFocus,
        onBlur: this.handleInputBlur
      };
      return vue.h("div", {
        ref: "triggerElRef",
        class: [`${mergedClsPrefix}-date-picker`, this.mergedDisabled && `${mergedClsPrefix}-date-picker--disabled`, this.isRange && `${mergedClsPrefix}-date-picker--range`, this.triggerThemeClass],
        style: this.triggerCssVars,
        onKeydown: this.handleKeydown
      }, vue.h(VBinder, null, {
        default: () => [vue.h(VTarget, null, {
          default: () => this.isRange ? vue.h(NInput, Object.assign({
            ref: "inputInstRef",
            status: this.mergedStatus,
            value: [this.displayStartTime, this.displayEndTime],
            placeholder: [this.localizedStartPlaceholder, this.localizedEndPlaceholder],
            textDecoration: [this.isStartValueInvalid ? "line-through" : "", this.isEndValueInvalid ? "line-through" : ""],
            pair: true,
            onUpdateValue: this.handleRangeUpdateValue,
            theme: this.mergedTheme.peers.Input,
            themeOverrides: this.mergedTheme.peerOverrides.Input,
            internalForceFocus: this.mergedShow,
            internalDeactivateOnEnter: true
          }, commonInputProps), {
            separator: () => this.separator === void 0 ? resolveSlot($slots.separator, () => [vue.h(NBaseIcon, {
              clsPrefix: mergedClsPrefix,
              class: `${mergedClsPrefix}-date-picker-icon`
            }, {
              default: () => vue.h(ToIcon, null)
            })]) : this.separator,
            [clearable ? "clear-icon-placeholder" : "suffix"]: () => resolveSlot($slots["date-icon"], () => [vue.h(NBaseIcon, {
              clsPrefix: mergedClsPrefix,
              class: `${mergedClsPrefix}-date-picker-icon`
            }, {
              default: () => vue.h(DateIcon, null)
            })])
          }) : vue.h(NInput, Object.assign({
            ref: "inputInstRef",
            status: this.mergedStatus,
            value: this.displayTime,
            placeholder: this.localizedPlacehoder,
            textDecoration: this.isValueInvalid && !this.isRange ? "line-through" : "",
            onUpdateValue: this.handleSingleUpdateValue,
            theme: this.mergedTheme.peers.Input,
            themeOverrides: this.mergedTheme.peerOverrides.Input,
            internalForceFocus: this.mergedShow,
            internalDeactivateOnEnter: true
          }, commonInputProps), {
            [clearable ? "clear-icon-placeholder" : "suffix"]: () => vue.h(NBaseIcon, {
              clsPrefix: mergedClsPrefix,
              class: `${mergedClsPrefix}-date-picker-icon`
            }, {
              default: () => resolveSlot($slots["date-icon"], () => [vue.h(DateIcon, null)])
            })
          })
        }), vue.h(VFollower, {
          show: this.mergedShow,
          containerClass: this.namespace,
          to: this.adjustedTo,
          teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey,
          placement: this.placement
        }, {
          default: () => vue.h(vue.Transition, {
            name: "fade-in-scale-up-transition",
            appear: this.isMounted
          }, {
            default: () => {
              if (!this.mergedShow)
                return null;
              return vue.withDirectives(renderPanel(), [[clickoutside$1, this.handleClickOutside, void 0, {
                capture: true
              }]]);
            }
          })
        })]
      }));
    }
  });
  const commonVariables$7 = {
    thPaddingBorderedSmall: "8px 12px",
    thPaddingBorderedMedium: "12px 16px",
    thPaddingBorderedLarge: "16px 24px",
    thPaddingSmall: "0",
    thPaddingMedium: "0",
    thPaddingLarge: "0",
    tdPaddingBorderedSmall: "8px 12px",
    tdPaddingBorderedMedium: "12px 16px",
    tdPaddingBorderedLarge: "16px 24px",
    tdPaddingSmall: "0 0 8px 0",
    tdPaddingMedium: "0 0 12px 0",
    tdPaddingLarge: "0 0 16px 0"
  };
  function self$K(vars) {
    const {
      tableHeaderColor,
      textColor2,
      textColor1,
      cardColor,
      modalColor,
      popoverColor,
      dividerColor,
      borderRadius,
      fontWeightStrong,
      lineHeight: lineHeight2,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge
    } = vars;
    return Object.assign(Object.assign({}, commonVariables$7), {
      lineHeight: lineHeight2,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      titleTextColor: textColor1,
      thColor: composite(cardColor, tableHeaderColor),
      thColorModal: composite(modalColor, tableHeaderColor),
      thColorPopover: composite(popoverColor, tableHeaderColor),
      thTextColor: textColor1,
      thFontWeight: fontWeightStrong,
      tdTextColor: textColor2,
      tdColor: cardColor,
      tdColorModal: modalColor,
      tdColorPopover: popoverColor,
      borderColor: composite(cardColor, dividerColor),
      borderColorModal: composite(modalColor, dividerColor),
      borderColorPopover: composite(popoverColor, dividerColor),
      borderRadius
    });
  }
  const descriptionsLight = {
    name: "Descriptions",
    common: commonLight,
    self: self$K
  };
  const descriptionsLight$1 = descriptionsLight;
  const DESCRIPTION_ITEM_FLAG = "DESCRIPTION_ITEM_FLAG";
  function isDescriptionsItem(vNode) {
    if (typeof vNode === "object" && vNode && !Array.isArray(vNode)) {
      return vNode.type && vNode.type[DESCRIPTION_ITEM_FLAG];
    }
    return false;
  }
  const style$U = c$1([cB("descriptions", {
    fontSize: "var(--n-font-size)"
  }, [cB("descriptions-separator", `
 display: inline-block;
 margin: 0 8px 0 2px;
 `), cB("descriptions-table-wrapper", [cB("descriptions-table", [cB("descriptions-table-row", [cB("descriptions-table-header", {
    padding: "var(--n-th-padding)"
  }), cB("descriptions-table-content", {
    padding: "var(--n-td-padding)"
  })])])]), cNotM("bordered", [cB("descriptions-table-wrapper", [cB("descriptions-table", [cB("descriptions-table-row", [c$1("&:last-child", [cB("descriptions-table-content", {
    paddingBottom: 0
  })])])])])]), cM("left-label-placement", [cB("descriptions-table-content", [c$1("> *", {
    verticalAlign: "top"
  })])]), cM("left-label-align", [c$1("th", {
    textAlign: "left"
  })]), cM("center-label-align", [c$1("th", {
    textAlign: "center"
  })]), cM("right-label-align", [c$1("th", {
    textAlign: "right"
  })]), cM("bordered", [cB("descriptions-table-wrapper", `
 border-radius: var(--n-border-radius);
 overflow: hidden;
 background: var(--n-merged-td-color);
 border: 1px solid var(--n-merged-border-color);
 `, [cB("descriptions-table", [cB("descriptions-table-row", [c$1("&:not(:last-child)", [cB("descriptions-table-content", {
    borderBottom: "1px solid var(--n-merged-border-color)"
  }), cB("descriptions-table-header", {
    borderBottom: "1px solid var(--n-merged-border-color)"
  })]), cB("descriptions-table-header", `
 font-weight: 400;
 background-clip: padding-box;
 background-color: var(--n-merged-th-color);
 `, [c$1("&:not(:last-child)", {
    borderRight: "1px solid var(--n-merged-border-color)"
  })]), cB("descriptions-table-content", [c$1("&:not(:last-child)", {
    borderRight: "1px solid var(--n-merged-border-color)"
  })])])])])]), cB("descriptions-header", `
 font-weight: var(--n-th-font-weight);
 font-size: 18px;
 transition: color .3s var(--n-bezier);
 line-height: var(--n-line-height);
 margin-bottom: 16px;
 color: var(--n-title-text-color);
 `), cB("descriptions-table-wrapper", `
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cB("descriptions-table", `
 width: 100%;
 border-collapse: separate;
 border-spacing: 0;
 box-sizing: border-box;
 `, [cB("descriptions-table-row", `
 box-sizing: border-box;
 transition: border-color .3s var(--n-bezier);
 `, [cB("descriptions-table-header", `
 font-weight: var(--n-th-font-weight);
 line-height: var(--n-line-height);
 display: table-cell;
 box-sizing: border-box;
 color: var(--n-th-text-color);
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `), cB("descriptions-table-content", `
 vertical-align: top;
 line-height: var(--n-line-height);
 display: table-cell;
 box-sizing: border-box;
 color: var(--n-td-text-color);
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cE("content", `
 transition: color .3s var(--n-bezier);
 display: inline-block;
 color: var(--n-td-text-color);
 `)]), cE("label", `
 font-weight: var(--n-th-font-weight);
 transition: color .3s var(--n-bezier);
 display: inline-block;
 margin-right: 14px;
 color: var(--n-th-text-color);
 `)])])])]), cB("descriptions-table-wrapper", `
 --n-merged-th-color: var(--n-th-color);
 --n-merged-td-color: var(--n-td-color);
 --n-merged-border-color: var(--n-border-color);
 `), insideModal(cB("descriptions-table-wrapper", `
 --n-merged-th-color: var(--n-th-color-modal);
 --n-merged-td-color: var(--n-td-color-modal);
 --n-merged-border-color: var(--n-border-color-modal);
 `)), insidePopover(cB("descriptions-table-wrapper", `
 --n-merged-th-color: var(--n-th-color-popover);
 --n-merged-td-color: var(--n-td-color-popover);
 --n-merged-border-color: var(--n-border-color-popover);
 `))]);
  const descriptionsProps = Object.assign(Object.assign({}, useTheme.props), {
    title: String,
    column: {
      type: Number,
      default: 3
    },
    columns: Number,
    labelPlacement: {
      type: String,
      default: "top"
    },
    labelAlign: {
      type: String,
      default: "left"
    },
    separator: {
      type: String,
      default: ":"
    },
    size: {
      type: String,
      default: "medium"
    },
    bordered: Boolean,
    labelClass: String,
    labelStyle: [Object, String],
    contentClass: String,
    contentStyle: [Object, String]
  });
  const Descriptions = vue.defineComponent({
    name: "Descriptions",
    props: descriptionsProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Descriptions", "-descriptions", style$U, descriptionsLight$1, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          size: size2,
          bordered
        } = props;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            titleTextColor,
            thColor,
            thColorModal,
            thColorPopover,
            thTextColor,
            thFontWeight,
            tdTextColor,
            tdColor,
            tdColorModal,
            tdColorPopover,
            borderColor,
            borderColorModal,
            borderColorPopover,
            borderRadius,
            lineHeight: lineHeight2,
            [createKey("fontSize", size2)]: fontSize2,
            [createKey(bordered ? "thPaddingBordered" : "thPadding", size2)]: thPadding,
            [createKey(bordered ? "tdPaddingBordered" : "tdPadding", size2)]: tdPadding
          }
        } = themeRef.value;
        return {
          "--n-title-text-color": titleTextColor,
          "--n-th-padding": thPadding,
          "--n-td-padding": tdPadding,
          "--n-font-size": fontSize2,
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-th-font-weight": thFontWeight,
          "--n-line-height": lineHeight2,
          "--n-th-text-color": thTextColor,
          "--n-td-text-color": tdTextColor,
          "--n-th-color": thColor,
          "--n-th-color-modal": thColorModal,
          "--n-th-color-popover": thColorPopover,
          "--n-td-color": tdColor,
          "--n-td-color-modal": tdColorModal,
          "--n-td-color-popover": tdColorPopover,
          "--n-border-radius": borderRadius,
          "--n-border-color": borderColor,
          "--n-border-color-modal": borderColorModal,
          "--n-border-color-popover": borderColorPopover
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("descriptions", vue.computed(() => {
        let hash = "";
        const {
          size: size2,
          bordered
        } = props;
        if (bordered)
          hash += "a";
        hash += size2[0];
        return hash;
      }), cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
        compitableColumn: useCompitable(props, ["columns", "column"]),
        inlineThemeDisabled
      };
    },
    render() {
      const defaultSlots = this.$slots.default;
      const children = defaultSlots ? flatten$3(defaultSlots()) : [];
      const memorizedLength = children.length;
      const {
        contentClass,
        labelClass,
        compitableColumn,
        labelPlacement,
        labelAlign,
        size: size2,
        bordered,
        title,
        cssVars,
        mergedClsPrefix,
        separator,
        onRender
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      const filteredChildren = children.filter((child) => isDescriptionsItem(child));
      if (memorizedLength !== filteredChildren.length) {
        warn$2("descriptions", "`n-descriptions` only takes `n-descriptions-item` as children.");
      }
      const defaultState = {
        span: 0,
        row: [],
        secondRow: [],
        rows: []
      };
      const itemState = filteredChildren.reduce((state, vNode, index) => {
        const props = vNode.props || {};
        const isLastIteration = filteredChildren.length - 1 === index;
        const itemLabel = ["label" in props ? props.label : getVNodeChildren(vNode, "label")];
        const itemChildren = [getVNodeChildren(vNode)];
        const itemSpan = props.span || 1;
        const memorizedSpan = state.span;
        state.span += itemSpan;
        const labelStyle = props.labelStyle || props["label-style"] || this.labelStyle;
        const contentStyle = props.contentStyle || props["content-style"] || this.contentStyle;
        if (labelPlacement === "left") {
          if (bordered) {
            state.row.push(vue.h("th", {
              class: [`${mergedClsPrefix}-descriptions-table-header`, labelClass],
              colspan: 1,
              style: labelStyle
            }, itemLabel), vue.h("td", {
              class: [`${mergedClsPrefix}-descriptions-table-content`, contentClass],
              colspan: isLastIteration ? (compitableColumn - memorizedSpan) * 2 + 1 : itemSpan * 2 - 1,
              style: contentStyle
            }, itemChildren));
          } else {
            state.row.push(vue.h("td", {
              class: `${mergedClsPrefix}-descriptions-table-content`,
              colspan: isLastIteration ? (compitableColumn - memorizedSpan) * 2 : itemSpan * 2
            }, vue.h("span", {
              class: [`${mergedClsPrefix}-descriptions-table-content__label`, labelClass],
              style: labelStyle
            }, [...itemLabel, separator && vue.h("span", {
              class: `${mergedClsPrefix}-descriptions-separator`
            }, separator)]), vue.h("span", {
              class: [`${mergedClsPrefix}-descriptions-table-content__content`, contentClass],
              style: contentStyle
            }, itemChildren)));
          }
        } else {
          const colspan = isLastIteration ? (compitableColumn - memorizedSpan) * 2 : itemSpan * 2;
          state.row.push(vue.h("th", {
            class: [`${mergedClsPrefix}-descriptions-table-header`, labelClass],
            colspan,
            style: labelStyle
          }, itemLabel));
          state.secondRow.push(vue.h("td", {
            class: [`${mergedClsPrefix}-descriptions-table-content`, contentClass],
            colspan,
            style: contentStyle
          }, itemChildren));
        }
        if (state.span >= compitableColumn || isLastIteration) {
          state.span = 0;
          if (state.row.length) {
            state.rows.push(state.row);
            state.row = [];
          }
          if (labelPlacement !== "left") {
            if (state.secondRow.length) {
              state.rows.push(state.secondRow);
              state.secondRow = [];
            }
          }
        }
        return state;
      }, defaultState);
      const rows = itemState.rows.map((row) => vue.h("tr", {
        class: `${mergedClsPrefix}-descriptions-table-row`
      }, row));
      return vue.h("div", {
        style: cssVars,
        class: [`${mergedClsPrefix}-descriptions`, this.themeClass, `${mergedClsPrefix}-descriptions--${labelPlacement}-label-placement`, `${mergedClsPrefix}-descriptions--${labelAlign}-label-align`, `${mergedClsPrefix}-descriptions--${size2}-size`, bordered && `${mergedClsPrefix}-descriptions--bordered`]
      }, title || this.$slots.header ? vue.h("div", {
        class: `${mergedClsPrefix}-descriptions-header`
      }, title || getSlot$1(this, "header")) : null, vue.h("div", {
        class: `${mergedClsPrefix}-descriptions-table-wrapper`
      }, vue.h("table", {
        class: `${mergedClsPrefix}-descriptions-table`
      }, vue.h("tbody", null, labelPlacement === "top" && vue.h("tr", {
        class: `${mergedClsPrefix}-descriptions-table-row`,
        style: {
          visibility: "collapse"
        }
      }, repeat(compitableColumn * 2, vue.h("td", null))), rows))));
    }
  });
  const descriptionsItemProps = {
    label: String,
    span: {
      type: Number,
      default: 1
    },
    labelClass: String,
    labelStyle: [Object, String],
    contentClass: String,
    contentStyle: [Object, String]
  };
  const DescriptionsItem = vue.defineComponent({
    name: "DescriptionsItem",
    [DESCRIPTION_ITEM_FLAG]: true,
    props: descriptionsItemProps,
    render() {
      return null;
    }
  });
  const commonVars$6 = {
    titleFontSize: "18px",
    padding: "16px 28px 20px 28px",
    iconSize: "28px",
    actionSpace: "12px",
    contentMargin: "8px 0 16px 0",
    iconMargin: "0 4px 0 0",
    iconMarginIconTop: "4px 0 8px 0",
    closeSize: "22px",
    closeIconSize: "18px",
    closeMargin: "20px 26px 0 0",
    closeMarginIconTop: "10px 16px 0 0"
  };
  function self$J(vars) {
    const {
      textColor1,
      textColor2,
      modalColor,
      closeIconColor,
      closeIconColorHover,
      closeIconColorPressed,
      closeColorHover,
      closeColorPressed,
      infoColor,
      successColor,
      warningColor,
      errorColor,
      primaryColor,
      dividerColor,
      borderRadius,
      fontWeightStrong,
      lineHeight: lineHeight2,
      fontSize: fontSize2
    } = vars;
    return Object.assign(Object.assign({}, commonVars$6), {
      fontSize: fontSize2,
      lineHeight: lineHeight2,
      border: `1px solid ${dividerColor}`,
      titleTextColor: textColor1,
      textColor: textColor2,
      color: modalColor,
      closeColorHover,
      closeColorPressed,
      closeIconColor,
      closeIconColorHover,
      closeIconColorPressed,
      closeBorderRadius: borderRadius,
      iconColor: primaryColor,
      iconColorInfo: infoColor,
      iconColorSuccess: successColor,
      iconColorWarning: warningColor,
      iconColorError: errorColor,
      borderRadius,
      titleFontWeight: fontWeightStrong
    });
  }
  const dialogLight = createTheme({
    name: "Dialog",
    common: commonLight,
    peers: {
      Button: buttonLight$1
    },
    self: self$J
  });
  const dialogLight$1 = dialogLight;
  const dialogProps = {
    icon: Function,
    type: {
      type: String,
      default: "default"
    },
    title: [String, Function],
    closable: {
      type: Boolean,
      default: true
    },
    negativeText: String,
    positiveText: String,
    positiveButtonProps: Object,
    negativeButtonProps: Object,
    content: [String, Function],
    action: Function,
    showIcon: {
      type: Boolean,
      default: true
    },
    loading: Boolean,
    bordered: Boolean,
    iconPlacement: String,
    titleClass: [String, Array],
    titleStyle: [String, Object],
    contentClass: [String, Array],
    contentStyle: [String, Object],
    actionClass: [String, Array],
    actionStyle: [String, Object],
    onPositiveClick: Function,
    onNegativeClick: Function,
    onClose: Function
  };
  const dialogPropKeys = keysOf(dialogProps);
  const style$T = c$1([cB("dialog", `
 --n-icon-margin: var(--n-icon-margin-top) var(--n-icon-margin-right) var(--n-icon-margin-bottom) var(--n-icon-margin-left);
 word-break: break-word;
 line-height: var(--n-line-height);
 position: relative;
 background: var(--n-color);
 color: var(--n-text-color);
 box-sizing: border-box;
 margin: auto;
 border-radius: var(--n-border-radius);
 padding: var(--n-padding);
 transition: 
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `, [cE("icon", {
    color: "var(--n-icon-color)"
  }), cM("bordered", {
    border: "var(--n-border)"
  }), cM("icon-top", [cE("close", {
    margin: "var(--n-close-margin)"
  }), cE("icon", {
    margin: "var(--n-icon-margin)"
  }), cE("content", {
    textAlign: "center"
  }), cE("title", {
    justifyContent: "center"
  }), cE("action", {
    justifyContent: "center"
  })]), cM("icon-left", [cE("icon", {
    margin: "var(--n-icon-margin)"
  }), cM("closable", [cE("title", `
 padding-right: calc(var(--n-close-size) + 6px);
 `)])]), cE("close", `
 position: absolute;
 right: 0;
 top: 0;
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 z-index: 1;
 `), cE("content", `
 font-size: var(--n-font-size);
 margin: var(--n-content-margin);
 position: relative;
 word-break: break-word;
 `, [cM("last", "margin-bottom: 0;")]), cE("action", `
 display: flex;
 justify-content: flex-end;
 `, [c$1("> *:not(:last-child)", `
 margin-right: var(--n-action-space);
 `)]), cE("icon", `
 font-size: var(--n-icon-size);
 transition: color .3s var(--n-bezier);
 `), cE("title", `
 transition: color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 font-size: var(--n-title-font-size);
 font-weight: var(--n-title-font-weight);
 color: var(--n-title-text-color);
 `), cB("dialog-icon-container", `
 display: flex;
 justify-content: center;
 `)]), insideModal(cB("dialog", `
 width: 446px;
 max-width: calc(100vw - 32px);
 `)), cB("dialog", [asModal(`
 width: 446px;
 max-width: calc(100vw - 32px);
 `)])]);
  const iconRenderMap$3 = {
    default: () => vue.h(InfoIcon, null),
    info: () => vue.h(InfoIcon, null),
    success: () => vue.h(SuccessIcon, null),
    warning: () => vue.h(WarningIcon, null),
    error: () => vue.h(ErrorIcon, null)
  };
  const NDialog = vue.defineComponent({
    name: "Dialog",
    alias: [
      "NimbusConfirmCard",
      // deprecated
      "Confirm"
      // deprecated
    ],
    props: Object.assign(Object.assign({}, useTheme.props), dialogProps),
    setup(props) {
      const {
        mergedComponentPropsRef,
        mergedClsPrefixRef,
        inlineThemeDisabled,
        mergedRtlRef
      } = useConfig(props);
      const rtlEnabledRef = useRtl("Dialog", mergedRtlRef, mergedClsPrefixRef);
      const mergedIconPlacementRef = vue.computed(() => {
        var _a, _b;
        const {
          iconPlacement
        } = props;
        return iconPlacement || ((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.Dialog) === null || _b === void 0 ? void 0 : _b.iconPlacement) || "left";
      });
      function handlePositiveClick(e) {
        const {
          onPositiveClick
        } = props;
        if (onPositiveClick)
          onPositiveClick(e);
      }
      function handleNegativeClick(e) {
        const {
          onNegativeClick
        } = props;
        if (onNegativeClick)
          onNegativeClick(e);
      }
      function handleCloseClick() {
        const {
          onClose
        } = props;
        if (onClose)
          onClose();
      }
      const themeRef = useTheme("Dialog", "-dialog", style$T, dialogLight$1, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          type
        } = props;
        const iconPlacement = mergedIconPlacementRef.value;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            fontSize: fontSize2,
            lineHeight: lineHeight2,
            border,
            titleTextColor,
            textColor,
            color,
            closeBorderRadius,
            closeColorHover,
            closeColorPressed,
            closeIconColor,
            closeIconColorHover,
            closeIconColorPressed,
            closeIconSize,
            borderRadius,
            titleFontWeight,
            titleFontSize,
            padding,
            iconSize,
            actionSpace,
            contentMargin,
            closeSize,
            [iconPlacement === "top" ? "iconMarginIconTop" : "iconMargin"]: iconMargin,
            [iconPlacement === "top" ? "closeMarginIconTop" : "closeMargin"]: closeMargin,
            [createKey("iconColor", type)]: iconColor
          }
        } = themeRef.value;
        const iconMarginDiscrete = getMargin(iconMargin);
        return {
          "--n-font-size": fontSize2,
          "--n-icon-color": iconColor,
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-close-margin": closeMargin,
          "--n-icon-margin-top": iconMarginDiscrete.top,
          "--n-icon-margin-right": iconMarginDiscrete.right,
          "--n-icon-margin-bottom": iconMarginDiscrete.bottom,
          "--n-icon-margin-left": iconMarginDiscrete.left,
          "--n-icon-size": iconSize,
          "--n-close-size": closeSize,
          "--n-close-icon-size": closeIconSize,
          "--n-close-border-radius": closeBorderRadius,
          "--n-close-color-hover": closeColorHover,
          "--n-close-color-pressed": closeColorPressed,
          "--n-close-icon-color": closeIconColor,
          "--n-close-icon-color-hover": closeIconColorHover,
          "--n-close-icon-color-pressed": closeIconColorPressed,
          "--n-color": color,
          "--n-text-color": textColor,
          "--n-border-radius": borderRadius,
          "--n-padding": padding,
          "--n-line-height": lineHeight2,
          "--n-border": border,
          "--n-content-margin": contentMargin,
          "--n-title-font-size": titleFontSize,
          "--n-title-font-weight": titleFontWeight,
          "--n-title-text-color": titleTextColor,
          "--n-action-space": actionSpace
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("dialog", vue.computed(() => `${props.type[0]}${mergedIconPlacementRef.value[0]}`), cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        rtlEnabled: rtlEnabledRef,
        mergedIconPlacement: mergedIconPlacementRef,
        mergedTheme: themeRef,
        handlePositiveClick,
        handleNegativeClick,
        handleCloseClick,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a;
      const {
        bordered,
        mergedIconPlacement,
        cssVars,
        closable,
        showIcon,
        title,
        content,
        action,
        negativeText,
        positiveText,
        positiveButtonProps,
        negativeButtonProps,
        handlePositiveClick,
        handleNegativeClick,
        mergedTheme,
        loading,
        type,
        mergedClsPrefix
      } = this;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      const icon = showIcon ? vue.h(NBaseIcon, {
        clsPrefix: mergedClsPrefix,
        class: `${mergedClsPrefix}-dialog__icon`
      }, {
        default: () => resolveWrappedSlot(this.$slots.icon, (children) => children || (this.icon ? render$1(this.icon) : iconRenderMap$3[this.type]()))
      }) : null;
      const actionNode = resolveWrappedSlot(this.$slots.action, (children) => children || positiveText || negativeText || action ? vue.h("div", {
        class: [`${mergedClsPrefix}-dialog__action`, this.actionClass],
        style: this.actionStyle
      }, children || (action ? [render$1(action)] : [this.negativeText && vue.h(NButton, Object.assign({
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        ghost: true,
        size: "small",
        onClick: handleNegativeClick
      }, negativeButtonProps), {
        default: () => render$1(this.negativeText)
      }), this.positiveText && vue.h(NButton, Object.assign({
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        size: "small",
        type: type === "default" ? "primary" : type,
        disabled: loading,
        loading,
        onClick: handlePositiveClick
      }, positiveButtonProps), {
        default: () => render$1(this.positiveText)
      })])) : null);
      return vue.h("div", {
        class: [`${mergedClsPrefix}-dialog`, this.themeClass, this.closable && `${mergedClsPrefix}-dialog--closable`, `${mergedClsPrefix}-dialog--icon-${mergedIconPlacement}`, bordered && `${mergedClsPrefix}-dialog--bordered`, this.rtlEnabled && `${mergedClsPrefix}-dialog--rtl`],
        style: cssVars,
        role: "dialog"
      }, closable ? resolveWrappedSlot(this.$slots.close, (node) => {
        const classNames = [`${mergedClsPrefix}-dialog__close`, this.rtlEnabled && `${mergedClsPrefix}-dialog--rtl`];
        return node ? vue.h("div", {
          class: classNames
        }, node) : vue.h(NBaseClose, {
          clsPrefix: mergedClsPrefix,
          class: classNames,
          onClick: this.handleCloseClick
        });
      }) : null, showIcon && mergedIconPlacement === "top" ? vue.h("div", {
        class: `${mergedClsPrefix}-dialog-icon-container`
      }, icon) : null, vue.h("div", {
        class: [`${mergedClsPrefix}-dialog__title`, this.titleClass],
        style: this.titleStyle
      }, showIcon && mergedIconPlacement === "left" ? icon : null, resolveSlot(this.$slots.header, () => [render$1(title)])), vue.h("div", {
        class: [`${mergedClsPrefix}-dialog__content`, actionNode ? "" : `${mergedClsPrefix}-dialog__content--last`, this.contentClass],
        style: this.contentStyle
      }, resolveSlot(this.$slots.default, () => [render$1(content)])), actionNode);
    }
  });
  const dialogProviderInjectionKey = createInjectionKey("n-dialog-provider");
  const dialogApiInjectionKey = createInjectionKey("n-dialog-api");
  const dialogReactiveListInjectionKey = createInjectionKey("n-dialog-reactive-list");
  function self$I(vars) {
    const {
      modalColor,
      textColor2,
      boxShadow3
    } = vars;
    return {
      color: modalColor,
      textColor: textColor2,
      boxShadow: boxShadow3
    };
  }
  const modalLight = createTheme({
    name: "Modal",
    common: commonLight,
    peers: {
      Scrollbar: scrollbarLight$1,
      Dialog: dialogLight$1,
      Card: cardLight$1
    },
    self: self$I
  });
  const modalLight$1 = modalLight;
  const presetProps = Object.assign(Object.assign({}, cardBaseProps), dialogProps);
  const presetPropsKeys = keysOf(presetProps);
  const NModalBodyWrapper = vue.defineComponent({
    name: "ModalBody",
    inheritAttrs: false,
    props: Object.assign(Object.assign({
      show: {
        type: Boolean,
        required: true
      },
      preset: String,
      displayDirective: {
        type: String,
        required: true
      },
      trapFocus: {
        type: Boolean,
        default: true
      },
      autoFocus: {
        type: Boolean,
        default: true
      },
      blockScroll: Boolean
    }, presetProps), {
      renderMask: Function,
      // events
      onClickoutside: Function,
      onBeforeLeave: {
        type: Function,
        required: true
      },
      onAfterLeave: {
        type: Function,
        required: true
      },
      onPositiveClick: {
        type: Function,
        required: true
      },
      onNegativeClick: {
        type: Function,
        required: true
      },
      onClose: {
        type: Function,
        required: true
      },
      onAfterEnter: Function,
      onEsc: Function
    }),
    setup(props) {
      const bodyRef = vue.ref(null);
      const scrollbarRef = vue.ref(null);
      const displayedRef = vue.ref(props.show);
      const transformOriginXRef = vue.ref(null);
      const transformOriginYRef = vue.ref(null);
      vue.watch(vue.toRef(props, "show"), (value) => {
        if (value)
          displayedRef.value = true;
      });
      useLockHtmlScroll(vue.computed(() => props.blockScroll && displayedRef.value));
      const NModal2 = vue.inject(modalInjectionKey);
      function styleTransformOrigin() {
        if (NModal2.transformOriginRef.value === "center") {
          return "";
        }
        const {
          value: transformOriginX
        } = transformOriginXRef;
        const {
          value: transformOriginY
        } = transformOriginYRef;
        if (transformOriginX === null || transformOriginY === null) {
          return "";
        } else if (scrollbarRef.value) {
          const scrollTop = scrollbarRef.value.containerScrollTop;
          return `${transformOriginX}px ${transformOriginY + scrollTop}px`;
        }
        return "";
      }
      function syncTransformOrigin(el) {
        if (NModal2.transformOriginRef.value === "center") {
          return;
        }
        const mousePosition = NModal2.getMousePosition();
        if (!mousePosition) {
          return;
        }
        if (!scrollbarRef.value)
          return;
        const scrollTop = scrollbarRef.value.containerScrollTop;
        const {
          offsetLeft,
          offsetTop
        } = el;
        if (mousePosition) {
          const top = mousePosition.y;
          const left = mousePosition.x;
          transformOriginXRef.value = -(offsetLeft - left);
          transformOriginYRef.value = -(offsetTop - top - scrollTop);
        }
        el.style.transformOrigin = styleTransformOrigin();
      }
      function handleEnter(el) {
        void vue.nextTick(() => {
          syncTransformOrigin(el);
        });
      }
      function handleBeforeLeave(el) {
        el.style.transformOrigin = styleTransformOrigin();
        props.onBeforeLeave();
      }
      function handleAfterLeave() {
        displayedRef.value = false;
        transformOriginXRef.value = null;
        transformOriginYRef.value = null;
        props.onAfterLeave();
      }
      function handleCloseClick() {
        const {
          onClose
        } = props;
        if (onClose) {
          onClose();
        }
      }
      function handleNegativeClick() {
        props.onNegativeClick();
      }
      function handlePositiveClick() {
        props.onPositiveClick();
      }
      const childNodeRef = vue.ref(null);
      vue.watch(childNodeRef, (node) => {
        if (node) {
          void vue.nextTick(() => {
            const el = node.el;
            if (el && bodyRef.value !== el) {
              bodyRef.value = el;
            }
          });
        }
      });
      vue.provide(modalBodyInjectionKey, bodyRef);
      vue.provide(drawerBodyInjectionKey, null);
      vue.provide(popoverBodyInjectionKey, null);
      return {
        mergedTheme: NModal2.mergedThemeRef,
        appear: NModal2.appearRef,
        isMounted: NModal2.isMountedRef,
        mergedClsPrefix: NModal2.mergedClsPrefixRef,
        bodyRef,
        scrollbarRef,
        displayed: displayedRef,
        childNodeRef,
        handlePositiveClick,
        handleNegativeClick,
        handleCloseClick,
        handleAfterLeave,
        handleBeforeLeave,
        handleEnter
      };
    },
    render() {
      const {
        $slots,
        $attrs,
        handleEnter,
        handleAfterLeave,
        handleBeforeLeave,
        preset,
        mergedClsPrefix
      } = this;
      let childNode = null;
      if (!preset) {
        childNode = getFirstSlotVNode($slots);
        if (!childNode) {
          warn$2("modal", "default slot is empty");
          return;
        }
        childNode = vue.cloneVNode(childNode);
        childNode.props = vue.mergeProps({
          class: `${mergedClsPrefix}-modal`
        }, $attrs, childNode.props || {});
      }
      return this.displayDirective === "show" || this.displayed || this.show ? vue.withDirectives(vue.h("div", {
        role: "none",
        class: `${mergedClsPrefix}-modal-body-wrapper`
      }, vue.h(NScrollbar, {
        ref: "scrollbarRef",
        theme: this.mergedTheme.peers.Scrollbar,
        themeOverrides: this.mergedTheme.peerOverrides.Scrollbar,
        contentClass: `${mergedClsPrefix}-modal-scroll-content`
      }, {
        default: () => {
          var _a;
          return [(_a = this.renderMask) === null || _a === void 0 ? void 0 : _a.call(this), vue.h(FocusTrap, {
            disabled: !this.trapFocus,
            active: this.show,
            onEsc: this.onEsc,
            autoFocus: this.autoFocus
          }, {
            default: () => {
              var _a2;
              return vue.h(vue.Transition, {
                name: "fade-in-scale-up-transition",
                appear: (_a2 = this.appear) !== null && _a2 !== void 0 ? _a2 : this.isMounted,
                onEnter: handleEnter,
                onAfterEnter: this.onAfterEnter,
                onAfterLeave: handleAfterLeave,
                onBeforeLeave: handleBeforeLeave
              }, {
                default: () => {
                  const dirs = [[vue.vShow, this.show]];
                  const {
                    onClickoutside
                  } = this;
                  if (onClickoutside) {
                    dirs.push([clickoutside$1, this.onClickoutside, void 0, {
                      capture: true
                    }]);
                  }
                  return vue.withDirectives(this.preset === "confirm" || this.preset === "dialog" ? vue.h(NDialog, Object.assign({}, this.$attrs, {
                    class: [`${mergedClsPrefix}-modal`, this.$attrs.class],
                    ref: "bodyRef",
                    theme: this.mergedTheme.peers.Dialog,
                    themeOverrides: this.mergedTheme.peerOverrides.Dialog
                  }, keep(this.$props, dialogPropKeys), {
                    "aria-modal": "true"
                  }), $slots) : this.preset === "card" ? vue.h(NCard, Object.assign({}, this.$attrs, {
                    ref: "bodyRef",
                    class: [`${mergedClsPrefix}-modal`, this.$attrs.class],
                    theme: this.mergedTheme.peers.Card,
                    themeOverrides: this.mergedTheme.peerOverrides.Card
                  }, keep(this.$props, cardBasePropKeys), {
                    "aria-modal": "true",
                    role: "dialog"
                  }), $slots) : this.childNodeRef = childNode, dirs);
                }
              });
            }
          })];
        }
      })), [[vue.vShow, this.displayDirective === "if" || this.displayed || this.show]]) : null;
    }
  });
  const style$S = c$1([cB("modal-container", `
 position: fixed;
 left: 0;
 top: 0;
 height: 0;
 width: 0;
 display: flex;
 `), cB("modal-mask", `
 position: fixed;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 background-color: rgba(0, 0, 0, .4);
 `, [fadeInTransition({
    enterDuration: ".25s",
    leaveDuration: ".25s",
    enterCubicBezier: "var(--n-bezier-ease-out)",
    leaveCubicBezier: "var(--n-bezier-ease-out)"
  })]), cB("modal-body-wrapper", `
 position: fixed;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 overflow: visible;
 `, [cB("modal-scroll-content", `
 min-height: 100%;
 display: flex;
 position: relative;
 `)]), cB("modal", `
 position: relative;
 align-self: center;
 color: var(--n-text-color);
 margin: auto;
 box-shadow: var(--n-box-shadow);
 `, [fadeInScaleUpTransition({
    duration: ".25s",
    enterScale: ".5"
  })])]);
  const modalProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), {
    show: Boolean,
    unstableShowMask: {
      type: Boolean,
      default: true
    },
    maskClosable: {
      type: Boolean,
      default: true
    },
    preset: String,
    to: [String, Object],
    displayDirective: {
      type: String,
      default: "if"
    },
    transformOrigin: {
      type: String,
      default: "mouse"
    },
    zIndex: Number,
    autoFocus: {
      type: Boolean,
      default: true
    },
    trapFocus: {
      type: Boolean,
      default: true
    },
    closeOnEsc: {
      type: Boolean,
      default: true
    },
    blockScroll: {
      type: Boolean,
      default: true
    }
  }), presetProps), {
    // events
    onEsc: Function,
    "onUpdate:show": [Function, Array],
    onUpdateShow: [Function, Array],
    onAfterEnter: Function,
    onBeforeLeave: Function,
    onAfterLeave: Function,
    onClose: Function,
    onPositiveClick: Function,
    onNegativeClick: Function,
    onMaskClick: Function,
    // private
    internalDialog: Boolean,
    internalModal: Boolean,
    internalAppear: {
      type: Boolean,
      default: void 0
    },
    // deprecated
    overlayStyle: [String, Object],
    onBeforeHide: Function,
    onAfterHide: Function,
    onHide: Function
  });
  const NModal = vue.defineComponent({
    name: "Modal",
    inheritAttrs: false,
    props: modalProps,
    setup(props) {
      {
        if (props.onHide) {
          warnOnce("modal", "`on-hide` is deprecated.");
        }
        if (props.onAfterHide) {
          warnOnce("modal", "`on-after-hide` is deprecated, please use `on-after-leave` instead.");
        }
        if (props.onBeforeHide) {
          warnOnce("modal", "`on-before-hide` is deprecated, please use `on-before-leave` instead.");
        }
        if (props.overlayStyle) {
          warnOnce("modal", "`overlay-style` is deprecated, please use `style` instead.");
        }
      }
      const containerRef = vue.ref(null);
      const {
        mergedClsPrefixRef,
        namespaceRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Modal", "-modal", style$S, modalLight$1, props, mergedClsPrefixRef);
      const clickedRef = useClicked(64);
      const clickedPositionRef = useClickPosition();
      const isMountedRef = isMounted();
      const NDialogProvider2 = props.internalDialog ? vue.inject(dialogProviderInjectionKey, null) : null;
      const NModalProvider2 = props.internalModal ? vue.inject(modalProviderInjectionKey$1, null) : null;
      const isComposingRef2 = useIsComposing();
      function doUpdateShow(show) {
        const {
          onUpdateShow,
          "onUpdate:show": _onUpdateShow,
          onHide
        } = props;
        if (onUpdateShow)
          call(onUpdateShow, show);
        if (_onUpdateShow)
          call(_onUpdateShow, show);
        if (onHide && !show)
          onHide(show);
      }
      function handleCloseClick() {
        const {
          onClose
        } = props;
        if (onClose) {
          void Promise.resolve(onClose()).then((value) => {
            if (value === false)
              return;
            doUpdateShow(false);
          });
        } else {
          doUpdateShow(false);
        }
      }
      function handlePositiveClick() {
        const {
          onPositiveClick
        } = props;
        if (onPositiveClick) {
          void Promise.resolve(onPositiveClick()).then((value) => {
            if (value === false)
              return;
            doUpdateShow(false);
          });
        } else {
          doUpdateShow(false);
        }
      }
      function handleNegativeClick() {
        const {
          onNegativeClick
        } = props;
        if (onNegativeClick) {
          void Promise.resolve(onNegativeClick()).then((value) => {
            if (value === false)
              return;
            doUpdateShow(false);
          });
        } else {
          doUpdateShow(false);
        }
      }
      function handleBeforeLeave() {
        const {
          onBeforeLeave,
          onBeforeHide
        } = props;
        if (onBeforeLeave)
          call(onBeforeLeave);
        if (onBeforeHide)
          onBeforeHide();
      }
      function handleAfterLeave() {
        const {
          onAfterLeave,
          onAfterHide
        } = props;
        if (onAfterLeave)
          call(onAfterLeave);
        if (onAfterHide)
          onAfterHide();
      }
      function handleClickoutside(e) {
        var _a;
        const {
          onMaskClick
        } = props;
        if (onMaskClick) {
          onMaskClick(e);
        }
        if (props.maskClosable) {
          if ((_a = containerRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(e))) {
            doUpdateShow(false);
          }
        }
      }
      function handleEsc(e) {
        var _a;
        (_a = props.onEsc) === null || _a === void 0 ? void 0 : _a.call(props);
        if (props.show && props.closeOnEsc && eventEffectNotPerformed(e)) {
          if (!isComposingRef2.value) {
            doUpdateShow(false);
          }
        }
      }
      vue.provide(modalInjectionKey, {
        getMousePosition: () => {
          const mergedProvider = NDialogProvider2 || NModalProvider2;
          if (mergedProvider) {
            const {
              clickedRef: clickedRef2,
              clickedPositionRef: clickedPositionRef2
            } = mergedProvider;
            if (clickedRef2.value && clickedPositionRef2.value) {
              return clickedPositionRef2.value;
            }
          }
          if (clickedRef.value) {
            return clickedPositionRef.value;
          }
          return null;
        },
        mergedClsPrefixRef,
        mergedThemeRef: themeRef,
        isMountedRef,
        appearRef: vue.toRef(props, "internalAppear"),
        transformOriginRef: vue.toRef(props, "transformOrigin")
      });
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseOut: cubicBezierEaseOut2
          },
          self: {
            boxShadow,
            color,
            textColor
          }
        } = themeRef.value;
        return {
          "--n-bezier-ease-out": cubicBezierEaseOut2,
          "--n-box-shadow": boxShadow,
          "--n-color": color,
          "--n-text-color": textColor
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("theme-class", void 0, cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        namespace: namespaceRef,
        isMounted: isMountedRef,
        containerRef,
        presetProps: vue.computed(() => {
          const pickedProps = keep(props, presetPropsKeys);
          return pickedProps;
        }),
        handleEsc,
        handleAfterLeave,
        handleClickoutside,
        handleBeforeLeave,
        doUpdateShow,
        handleNegativeClick,
        handlePositiveClick,
        handleCloseClick,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      const {
        mergedClsPrefix
      } = this;
      return vue.h(LazyTeleport, {
        to: this.to,
        show: this.show
      }, {
        default: () => {
          var _a;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          const {
            unstableShowMask
          } = this;
          return vue.withDirectives(vue.h("div", {
            role: "none",
            ref: "containerRef",
            class: [`${mergedClsPrefix}-modal-container`, this.themeClass, this.namespace],
            style: this.cssVars
          }, vue.h(NModalBodyWrapper, Object.assign({
            style: this.overlayStyle
          }, this.$attrs, {
            ref: "bodyWrapper",
            displayDirective: this.displayDirective,
            show: this.show,
            preset: this.preset,
            autoFocus: this.autoFocus,
            trapFocus: this.trapFocus,
            blockScroll: this.blockScroll
          }, this.presetProps, {
            onEsc: this.handleEsc,
            onClose: this.handleCloseClick,
            onNegativeClick: this.handleNegativeClick,
            onPositiveClick: this.handlePositiveClick,
            onBeforeLeave: this.handleBeforeLeave,
            onAfterEnter: this.onAfterEnter,
            onAfterLeave: this.handleAfterLeave,
            onClickoutside: unstableShowMask ? void 0 : this.handleClickoutside,
            renderMask: unstableShowMask ? () => {
              var _a2;
              return vue.h(vue.Transition, {
                name: "fade-in-transition",
                key: "mask",
                appear: (_a2 = this.internalAppear) !== null && _a2 !== void 0 ? _a2 : this.isMounted
              }, {
                default: () => {
                  return this.show ? vue.h("div", {
                    "aria-hidden": true,
                    ref: "containerRef",
                    class: `${mergedClsPrefix}-modal-mask`,
                    onClick: this.handleClickoutside
                  }) : null;
                }
              });
            } : void 0
          }), this.$slots)), [[zindexable$1, {
            zIndex: this.zIndex,
            enabled: this.show
          }]]);
        }
      });
    }
  });
  const exposedDialogEnvProps = Object.assign(Object.assign({}, dialogProps), {
    onAfterEnter: Function,
    onAfterLeave: Function,
    transformOrigin: String,
    blockScroll: {
      type: Boolean,
      default: true
    },
    closeOnEsc: {
      type: Boolean,
      default: true
    },
    onEsc: Function,
    autoFocus: {
      type: Boolean,
      default: true
    },
    internalStyle: [String, Object],
    maskClosable: {
      type: Boolean,
      default: true
    },
    onPositiveClick: Function,
    onNegativeClick: Function,
    onClose: Function,
    onMaskClick: Function
  });
  const NDialogEnvironment = vue.defineComponent({
    name: "DialogEnvironment",
    props: Object.assign(Object.assign({}, exposedDialogEnvProps), {
      internalKey: {
        type: String,
        required: true
      },
      to: [String, Object],
      // private
      onInternalAfterLeave: {
        type: Function,
        required: true
      }
    }),
    setup(props) {
      const showRef = vue.ref(true);
      function handleAfterLeave() {
        const {
          onInternalAfterLeave,
          internalKey,
          onAfterLeave
        } = props;
        if (onInternalAfterLeave)
          onInternalAfterLeave(internalKey);
        if (onAfterLeave)
          onAfterLeave();
      }
      function handlePositiveClick(e) {
        const {
          onPositiveClick
        } = props;
        if (onPositiveClick) {
          void Promise.resolve(onPositiveClick(e)).then((result) => {
            if (result === false)
              return;
            hide();
          });
        } else {
          hide();
        }
      }
      function handleNegativeClick(e) {
        const {
          onNegativeClick
        } = props;
        if (onNegativeClick) {
          void Promise.resolve(onNegativeClick(e)).then((result) => {
            if (result === false)
              return;
            hide();
          });
        } else {
          hide();
        }
      }
      function handleCloseClick() {
        const {
          onClose
        } = props;
        if (onClose) {
          void Promise.resolve(onClose()).then((result) => {
            if (result === false)
              return;
            hide();
          });
        } else {
          hide();
        }
      }
      function handleMaskClick(e) {
        const {
          onMaskClick,
          maskClosable
        } = props;
        if (onMaskClick) {
          onMaskClick(e);
          if (maskClosable) {
            hide();
          }
        }
      }
      function handleEsc() {
        const {
          onEsc
        } = props;
        if (onEsc) {
          onEsc();
        }
      }
      function hide() {
        showRef.value = false;
      }
      function handleUpdateShow(value) {
        showRef.value = value;
      }
      return {
        show: showRef,
        hide,
        handleUpdateShow,
        handleAfterLeave,
        handleCloseClick,
        handleNegativeClick,
        handlePositiveClick,
        handleMaskClick,
        handleEsc
      };
    },
    render() {
      const {
        handlePositiveClick,
        handleUpdateShow,
        handleNegativeClick,
        handleCloseClick,
        handleAfterLeave,
        handleMaskClick,
        handleEsc,
        to,
        maskClosable,
        show
      } = this;
      return vue.h(NModal, {
        show,
        onUpdateShow: handleUpdateShow,
        onMaskClick: handleMaskClick,
        onEsc: handleEsc,
        to,
        maskClosable,
        onAfterEnter: this.onAfterEnter,
        onAfterLeave: handleAfterLeave,
        closeOnEsc: this.closeOnEsc,
        blockScroll: this.blockScroll,
        autoFocus: this.autoFocus,
        transformOrigin: this.transformOrigin,
        internalAppear: true,
        internalDialog: true
      }, {
        default: () => vue.h(NDialog, Object.assign({}, keep(this.$props, dialogPropKeys), {
          style: this.internalStyle,
          onClose: handleCloseClick,
          onNegativeClick: handleNegativeClick,
          onPositiveClick: handlePositiveClick
        }))
      });
    }
  });
  const dialogProviderProps = {
    injectionKey: String,
    to: [String, Object]
  };
  const NDialogProvider = vue.defineComponent({
    name: "DialogProvider",
    props: dialogProviderProps,
    setup() {
      const dialogListRef = vue.ref([]);
      const dialogInstRefs = {};
      function create2(options = {}) {
        const key = createId();
        const dialogReactive = vue.reactive(Object.assign(Object.assign({}, options), {
          key,
          destroy: () => {
            var _a;
            (_a = dialogInstRefs[`n-dialog-${key}`]) === null || _a === void 0 ? void 0 : _a.hide();
          }
        }));
        dialogListRef.value.push(dialogReactive);
        return dialogReactive;
      }
      const typedApi = ["info", "success", "warning", "error"].map((type) => (options) => {
        return create2(Object.assign(Object.assign({}, options), {
          type
        }));
      });
      function handleAfterLeave(key) {
        const {
          value: dialogList
        } = dialogListRef;
        dialogList.splice(dialogList.findIndex((dialog) => dialog.key === key), 1);
      }
      function destroyAll() {
        Object.values(dialogInstRefs).forEach((dialogInstRef) => {
          dialogInstRef === null || dialogInstRef === void 0 ? void 0 : dialogInstRef.hide();
        });
      }
      const api = {
        create: create2,
        destroyAll,
        info: typedApi[0],
        success: typedApi[1],
        warning: typedApi[2],
        error: typedApi[3]
      };
      vue.provide(dialogApiInjectionKey, api);
      vue.provide(dialogProviderInjectionKey, {
        clickedRef: useClicked(64),
        clickedPositionRef: useClickPosition()
      });
      vue.provide(dialogReactiveListInjectionKey, dialogListRef);
      return Object.assign(Object.assign({}, api), {
        dialogList: dialogListRef,
        dialogInstRefs,
        handleAfterLeave
      });
    },
    render() {
      var _a, _b;
      return vue.h(vue.Fragment, null, [this.dialogList.map((dialog) => vue.h(NDialogEnvironment, omit(dialog, ["destroy", "style"], {
        internalStyle: dialog.style,
        to: this.to,
        ref: (inst) => {
          if (inst === null) {
            delete this.dialogInstRefs[`n-dialog-${dialog.key}`];
          } else {
            this.dialogInstRefs[`n-dialog-${dialog.key}`] = inst;
          }
        },
        internalKey: dialog.key,
        onInternalAfterLeave: this.handleAfterLeave
      }))), (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a)]);
    }
  });
  function useDialog() {
    const dialog = vue.inject(dialogApiInjectionKey, null);
    if (dialog === null) {
      throwError("use-dialog", "No outer <n-dialog-provider /> founded.");
    }
    return dialog;
  }
  function useDialogReactiveList() {
    const dialogReactiveList = vue.inject(dialogReactiveListInjectionKey, null);
    if (dialogReactiveList === null) {
      throwError("use-dialog-reactive-list", "No outer <n-dialog-provider /> founded.");
    }
    return dialogReactiveList;
  }
  function self$H(vars) {
    const {
      textColor1,
      dividerColor,
      fontWeightStrong
    } = vars;
    return {
      textColor: textColor1,
      color: dividerColor,
      fontWeight: fontWeightStrong
    };
  }
  const dividerLight = {
    name: "Divider",
    common: commonLight,
    self: self$H
  };
  const dividerLight$1 = dividerLight;
  const style$R = cB("divider", `
 position: relative;
 display: flex;
 width: 100%;
 box-sizing: border-box;
 font-size: 16px;
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
`, [cNotM("vertical", `
 margin-top: 24px;
 margin-bottom: 24px;
 `, [cNotM("no-title", `
 display: flex;
 align-items: center;
 `)]), cE("title", `
 display: flex;
 align-items: center;
 margin-left: 12px;
 margin-right: 12px;
 white-space: nowrap;
 font-weight: var(--n-font-weight);
 `), cM("title-position-left", [cE("line", [cM("left", {
    width: "28px"
  })])]), cM("title-position-right", [cE("line", [cM("right", {
    width: "28px"
  })])]), cM("dashed", [cE("line", `
 background-color: #0000;
 height: 0px;
 width: 100%;
 border-style: dashed;
 border-width: 1px 0 0;
 `)]), cM("vertical", `
 display: inline-block;
 height: 1em;
 margin: 0 8px;
 vertical-align: middle;
 width: 1px;
 `), cE("line", `
 border: none;
 transition: background-color .3s var(--n-bezier), border-color .3s var(--n-bezier);
 height: 1px;
 width: 100%;
 margin: 0;
 `), cNotM("dashed", [cE("line", {
    backgroundColor: "var(--n-color)"
  })]), cM("dashed", [cE("line", {
    borderColor: "var(--n-color)"
  })]), cM("vertical", {
    backgroundColor: "var(--n-color)"
  })]);
  const dividerProps = Object.assign(Object.assign({}, useTheme.props), {
    titlePlacement: {
      type: String,
      default: "center"
    },
    dashed: Boolean,
    vertical: Boolean
  });
  const NDivider = vue.defineComponent({
    name: "Divider",
    props: dividerProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Divider", "-divider", style$R, dividerLight$1, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            color,
            textColor,
            fontWeight
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-color": color,
          "--n-text-color": textColor,
          "--n-font-weight": fontWeight
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("divider", void 0, cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a;
      const {
        $slots,
        titlePlacement,
        vertical,
        dashed,
        cssVars,
        mergedClsPrefix
      } = this;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      return vue.h("div", {
        role: "separator",
        class: [`${mergedClsPrefix}-divider`, this.themeClass, {
          [`${mergedClsPrefix}-divider--vertical`]: vertical,
          [`${mergedClsPrefix}-divider--no-title`]: !$slots.default,
          [`${mergedClsPrefix}-divider--dashed`]: dashed,
          [`${mergedClsPrefix}-divider--title-position-${titlePlacement}`]: $slots.default && titlePlacement
        }],
        style: cssVars
      }, !vertical ? vue.h("div", {
        class: `${mergedClsPrefix}-divider__line ${mergedClsPrefix}-divider__line--left`
      }) : null, !vertical && $slots.default ? vue.h(vue.Fragment, null, vue.h("div", {
        class: `${mergedClsPrefix}-divider__title`
      }, this.$slots), vue.h("div", {
        class: `${mergedClsPrefix}-divider__line ${mergedClsPrefix}-divider__line--right`
      })) : null);
    }
  });
  function self$G(vars) {
    const {
      modalColor,
      textColor1,
      textColor2,
      boxShadow3,
      lineHeight: lineHeight2,
      fontWeightStrong,
      dividerColor,
      closeColorHover,
      closeColorPressed,
      closeIconColor,
      closeIconColorHover,
      closeIconColorPressed,
      borderRadius,
      primaryColorHover
    } = vars;
    return {
      bodyPadding: "16px 24px",
      borderRadius,
      headerPadding: "16px 24px",
      footerPadding: "16px 24px",
      color: modalColor,
      textColor: textColor2,
      titleTextColor: textColor1,
      titleFontSize: "18px",
      titleFontWeight: fontWeightStrong,
      boxShadow: boxShadow3,
      lineHeight: lineHeight2,
      headerBorderBottom: `1px solid ${dividerColor}`,
      footerBorderTop: `1px solid ${dividerColor}`,
      closeIconColor,
      closeIconColorHover,
      closeIconColorPressed,
      closeSize: "22px",
      closeIconSize: "18px",
      closeColorHover,
      closeColorPressed,
      closeBorderRadius: borderRadius,
      resizableTriggerColorHover: primaryColorHover
    };
  }
  const drawerLight = createTheme({
    name: "Drawer",
    common: commonLight,
    peers: {
      Scrollbar: scrollbarLight$1
    },
    self: self$G
  });
  const drawerLight$1 = drawerLight;
  const NDrawerBodyWrapper = vue.defineComponent({
    name: "NDrawerContent",
    inheritAttrs: false,
    props: {
      blockScroll: Boolean,
      show: {
        type: Boolean,
        default: void 0
      },
      displayDirective: {
        type: String,
        required: true
      },
      placement: {
        type: String,
        required: true
      },
      contentClass: String,
      contentStyle: [Object, String],
      nativeScrollbar: {
        type: Boolean,
        required: true
      },
      scrollbarProps: Object,
      trapFocus: {
        type: Boolean,
        default: true
      },
      autoFocus: {
        type: Boolean,
        default: true
      },
      showMask: {
        type: [Boolean, String],
        required: true
      },
      maxWidth: Number,
      maxHeight: Number,
      minWidth: Number,
      minHeight: Number,
      resizable: Boolean,
      onClickoutside: Function,
      onAfterLeave: Function,
      onAfterEnter: Function,
      onEsc: Function
    },
    setup(props) {
      const displayedRef = vue.ref(!!props.show);
      const bodyRef = vue.ref(null);
      const NDrawer = vue.inject(drawerInjectionKey);
      let startPosition = 0;
      let memoizedBodyStyleCursor = "";
      let hoverTimerId = null;
      const isHoverOnResizeTriggerRef = vue.ref(false);
      const isDraggingRef = vue.ref(false);
      const isVertical = vue.computed(() => {
        return props.placement === "top" || props.placement === "bottom";
      });
      const {
        mergedClsPrefixRef,
        mergedRtlRef
      } = useConfig(props);
      const rtlEnabledRef = useRtl("Drawer", mergedRtlRef, mergedClsPrefixRef);
      const handleBodyMouseleave = handleBodyMouseup;
      const handleMousedownResizeTrigger = (e) => {
        isDraggingRef.value = true;
        startPosition = isVertical.value ? e.clientY : e.clientX;
        memoizedBodyStyleCursor = document.body.style.cursor;
        document.body.style.cursor = isVertical.value ? "ns-resize" : "ew-resize";
        document.body.addEventListener("mousemove", handleBodyMousemove);
        document.body.addEventListener("mouseleave", handleBodyMouseleave);
        document.body.addEventListener("mouseup", handleBodyMouseup);
      };
      const handleMouseenterResizeTrigger = () => {
        if (hoverTimerId !== null) {
          window.clearTimeout(hoverTimerId);
          hoverTimerId = null;
        }
        if (isDraggingRef.value) {
          isHoverOnResizeTriggerRef.value = true;
        } else {
          hoverTimerId = window.setTimeout(() => {
            isHoverOnResizeTriggerRef.value = true;
          }, 300);
        }
      };
      const handleMouseleaveResizeTrigger = () => {
        if (hoverTimerId !== null) {
          window.clearTimeout(hoverTimerId);
          hoverTimerId = null;
        }
        isHoverOnResizeTriggerRef.value = false;
      };
      const {
        doUpdateHeight,
        doUpdateWidth
      } = NDrawer;
      const regulateWidth = (size2) => {
        const {
          maxWidth
        } = props;
        if (maxWidth && size2 > maxWidth)
          return maxWidth;
        const {
          minWidth
        } = props;
        if (minWidth && size2 < minWidth)
          return minWidth;
        return size2;
      };
      const regulateHeight = (size2) => {
        const {
          maxHeight
        } = props;
        if (maxHeight && size2 > maxHeight)
          return maxHeight;
        const {
          minHeight
        } = props;
        if (minHeight && size2 < minHeight)
          return minHeight;
        return size2;
      };
      function handleBodyMousemove(e) {
        var _a, _b;
        if (isDraggingRef.value) {
          if (isVertical.value) {
            let height = ((_a = bodyRef.value) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0;
            const increment = startPosition - e.clientY;
            height += props.placement === "bottom" ? increment : -increment;
            height = regulateHeight(height);
            doUpdateHeight(height);
            startPosition = e.clientY;
          } else {
            let width = ((_b = bodyRef.value) === null || _b === void 0 ? void 0 : _b.offsetWidth) || 0;
            const increment = startPosition - e.clientX;
            width += props.placement === "right" ? increment : -increment;
            width = regulateWidth(width);
            doUpdateWidth(width);
            startPosition = e.clientX;
          }
        }
      }
      function handleBodyMouseup() {
        if (isDraggingRef.value) {
          startPosition = 0;
          isDraggingRef.value = false;
          document.body.style.cursor = memoizedBodyStyleCursor;
          document.body.removeEventListener("mousemove", handleBodyMousemove);
          document.body.removeEventListener("mouseup", handleBodyMouseup);
          document.body.removeEventListener("mouseleave", handleBodyMouseleave);
        }
      }
      vue.watchEffect(() => {
        if (props.show)
          displayedRef.value = true;
      });
      vue.watch(() => props.show, (value) => {
        if (!value) {
          handleBodyMouseup();
        }
      });
      vue.onBeforeUnmount(() => {
        handleBodyMouseup();
      });
      const bodyDirectivesRef = vue.computed(() => {
        const {
          show
        } = props;
        const directives = [[vue.vShow, show]];
        if (!props.showMask) {
          directives.push([clickoutside$1, props.onClickoutside, void 0, {
            capture: true
          }]);
        }
        return directives;
      });
      function handleAfterLeave() {
        var _a;
        displayedRef.value = false;
        (_a = props.onAfterLeave) === null || _a === void 0 ? void 0 : _a.call(props);
      }
      useLockHtmlScroll(vue.computed(() => props.blockScroll && displayedRef.value));
      vue.provide(drawerBodyInjectionKey, bodyRef);
      vue.provide(popoverBodyInjectionKey, null);
      vue.provide(modalBodyInjectionKey, null);
      return {
        bodyRef,
        rtlEnabled: rtlEnabledRef,
        mergedClsPrefix: NDrawer.mergedClsPrefixRef,
        isMounted: NDrawer.isMountedRef,
        mergedTheme: NDrawer.mergedThemeRef,
        displayed: displayedRef,
        transitionName: vue.computed(() => {
          return {
            right: "slide-in-from-right-transition",
            left: "slide-in-from-left-transition",
            top: "slide-in-from-top-transition",
            bottom: "slide-in-from-bottom-transition"
          }[props.placement];
        }),
        handleAfterLeave,
        bodyDirectives: bodyDirectivesRef,
        handleMousedownResizeTrigger,
        handleMouseenterResizeTrigger,
        handleMouseleaveResizeTrigger,
        isDragging: isDraggingRef,
        isHoverOnResizeTrigger: isHoverOnResizeTriggerRef
      };
    },
    render() {
      const {
        $slots,
        mergedClsPrefix
      } = this;
      return this.displayDirective === "show" || this.displayed || this.show ? vue.withDirectives(
        /* Keep the wrapper dom. Make sure the drawer has a host.
          Nor the detached content will disappear without transition */
        vue.h("div", {
          role: "none"
        }, vue.h(FocusTrap, {
          disabled: !this.showMask || !this.trapFocus,
          active: this.show,
          autoFocus: this.autoFocus,
          onEsc: this.onEsc
        }, {
          default: () => vue.h(vue.Transition, {
            name: this.transitionName,
            appear: this.isMounted,
            onAfterEnter: this.onAfterEnter,
            onAfterLeave: this.handleAfterLeave
          }, {
            default: () => vue.withDirectives(vue.h("div", vue.mergeProps(this.$attrs, {
              role: "dialog",
              ref: "bodyRef",
              "aria-modal": "true",
              class: [
                `${mergedClsPrefix}-drawer`,
                this.rtlEnabled && `${mergedClsPrefix}-drawer--rtl`,
                `${mergedClsPrefix}-drawer--${this.placement}-placement`,
                /**
                 * When the mouse is pressed to resize the drawer,
                 * disable text selection
                 */
                this.isDragging && `${mergedClsPrefix}-drawer--unselectable`,
                this.nativeScrollbar && `${mergedClsPrefix}-drawer--native-scrollbar`
              ]
            }), [this.resizable ? vue.h("div", {
              class: [`${mergedClsPrefix}-drawer__resize-trigger`, (this.isDragging || this.isHoverOnResizeTrigger) && `${mergedClsPrefix}-drawer__resize-trigger--hover`],
              onMouseenter: this.handleMouseenterResizeTrigger,
              onMouseleave: this.handleMouseleaveResizeTrigger,
              onMousedown: this.handleMousedownResizeTrigger
            }) : null, this.nativeScrollbar ? vue.h("div", {
              class: [`${mergedClsPrefix}-drawer-content-wrapper`, this.contentClass],
              style: this.contentStyle,
              role: "none"
            }, $slots) : vue.h(NScrollbar, Object.assign({}, this.scrollbarProps, {
              contentStyle: this.contentStyle,
              contentClass: [`${mergedClsPrefix}-drawer-content-wrapper`, this.contentClass],
              theme: this.mergedTheme.peers.Scrollbar,
              themeOverrides: this.mergedTheme.peerOverrides.Scrollbar
            }), $slots)]), this.bodyDirectives)
          })
        })),
        [[vue.vShow, this.displayDirective === "if" || this.displayed || this.show]]
      ) : null;
    }
  });
  const {
    cubicBezierEaseIn: cubicBezierEaseIn$3,
    cubicBezierEaseOut: cubicBezierEaseOut$3
  } = commonVariables$m;
  function slideInFromRightTransition({
    duration: duration2 = "0.3s",
    leaveDuration = "0.2s",
    name = "slide-in-from-right"
  } = {}) {
    return [c$1(`&.${name}-transition-leave-active`, {
      transition: `transform ${leaveDuration} ${cubicBezierEaseIn$3}`
    }), c$1(`&.${name}-transition-enter-active`, {
      transition: `transform ${duration2} ${cubicBezierEaseOut$3}`
    }), c$1(`&.${name}-transition-enter-to`, {
      transform: "translateX(0)"
    }), c$1(`&.${name}-transition-enter-from`, {
      transform: "translateX(100%)"
    }), c$1(`&.${name}-transition-leave-from`, {
      transform: "translateX(0)"
    }), c$1(`&.${name}-transition-leave-to`, {
      transform: "translateX(100%)"
    })];
  }
  const {
    cubicBezierEaseIn: cubicBezierEaseIn$2,
    cubicBezierEaseOut: cubicBezierEaseOut$2
  } = commonVariables$m;
  function slideInFromLeftTransition({
    duration: duration2 = "0.3s",
    leaveDuration = "0.2s",
    name = "slide-in-from-left"
  } = {}) {
    return [c$1(`&.${name}-transition-leave-active`, {
      transition: `transform ${leaveDuration} ${cubicBezierEaseIn$2}`
    }), c$1(`&.${name}-transition-enter-active`, {
      transition: `transform ${duration2} ${cubicBezierEaseOut$2}`
    }), c$1(`&.${name}-transition-enter-to`, {
      transform: "translateX(0)"
    }), c$1(`&.${name}-transition-enter-from`, {
      transform: "translateX(-100%)"
    }), c$1(`&.${name}-transition-leave-from`, {
      transform: "translateX(0)"
    }), c$1(`&.${name}-transition-leave-to`, {
      transform: "translateX(-100%)"
    })];
  }
  const {
    cubicBezierEaseIn: cubicBezierEaseIn$1,
    cubicBezierEaseOut: cubicBezierEaseOut$1
  } = commonVariables$m;
  function slideInFromTopTransition({
    duration: duration2 = "0.3s",
    leaveDuration = "0.2s",
    name = "slide-in-from-top"
  } = {}) {
    return [c$1(`&.${name}-transition-leave-active`, {
      transition: `transform ${leaveDuration} ${cubicBezierEaseIn$1}`
    }), c$1(`&.${name}-transition-enter-active`, {
      transition: `transform ${duration2} ${cubicBezierEaseOut$1}`
    }), c$1(`&.${name}-transition-enter-to`, {
      transform: "translateY(0)"
    }), c$1(`&.${name}-transition-enter-from`, {
      transform: "translateY(-100%)"
    }), c$1(`&.${name}-transition-leave-from`, {
      transform: "translateY(0)"
    }), c$1(`&.${name}-transition-leave-to`, {
      transform: "translateY(-100%)"
    })];
  }
  const {
    cubicBezierEaseIn,
    cubicBezierEaseOut
  } = commonVariables$m;
  function slideInFromBottomTransition({
    duration: duration2 = "0.3s",
    leaveDuration = "0.2s",
    name = "slide-in-from-bottom"
  } = {}) {
    return [c$1(`&.${name}-transition-leave-active`, {
      transition: `transform ${leaveDuration} ${cubicBezierEaseIn}`
    }), c$1(`&.${name}-transition-enter-active`, {
      transition: `transform ${duration2} ${cubicBezierEaseOut}`
    }), c$1(`&.${name}-transition-enter-to`, {
      transform: "translateY(0)"
    }), c$1(`&.${name}-transition-enter-from`, {
      transform: "translateY(100%)"
    }), c$1(`&.${name}-transition-leave-from`, {
      transform: "translateY(0)"
    }), c$1(`&.${name}-transition-leave-to`, {
      transform: "translateY(100%)"
    })];
  }
  const style$Q = c$1([cB("drawer", `
 word-break: break-word;
 line-height: var(--n-line-height);
 position: absolute;
 pointer-events: all;
 box-shadow: var(--n-box-shadow);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 background-color: var(--n-color);
 color: var(--n-text-color);
 box-sizing: border-box;
 `, [slideInFromRightTransition(), slideInFromLeftTransition(), slideInFromTopTransition(), slideInFromBottomTransition(), cM("unselectable", `
 user-select: none; 
 -webkit-user-select: none;
 `), cM("native-scrollbar", [cB("drawer-content-wrapper", `
 overflow: auto;
 height: 100%;
 `)]), cE("resize-trigger", `
 position: absolute;
 background-color: #0000;
 transition: background-color .3s var(--n-bezier);
 `, [cM("hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `)]), cB("drawer-content-wrapper", `
 box-sizing: border-box;
 `), cB("drawer-content", `
 height: 100%;
 display: flex;
 flex-direction: column;
 `, [cM("native-scrollbar", [cB("drawer-body-content-wrapper", `
 height: 100%;
 overflow: auto;
 `)]), cB("drawer-body", `
 flex: 1 0 0;
 overflow: hidden;
 `), cB("drawer-body-content-wrapper", `
 box-sizing: border-box;
 padding: var(--n-body-padding);
 `), cB("drawer-header", `
 font-weight: var(--n-title-font-weight);
 line-height: 1;
 font-size: var(--n-title-font-size);
 color: var(--n-title-text-color);
 padding: var(--n-header-padding);
 transition: border .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-divider-color);
 border-bottom: var(--n-header-border-bottom);
 display: flex;
 justify-content: space-between;
 align-items: center;
 `, [cE("main", `
 flex: 1;
 `), cE("close", `
 margin-left: 6px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), cB("drawer-footer", `
 display: flex;
 justify-content: flex-end;
 border-top: var(--n-footer-border-top);
 transition: border .3s var(--n-bezier);
 padding: var(--n-footer-padding);
 `)]), cM("right-placement", `
 top: 0;
 bottom: 0;
 right: 0;
 border-top-left-radius: var(--n-border-radius);
 border-bottom-left-radius: var(--n-border-radius);
 `, [cE("resize-trigger", `
 width: 3px;
 height: 100%;
 top: 0;
 left: 0;
 transform: translateX(-1.5px);
 cursor: ew-resize;
 `)]), cM("left-placement", `
 top: 0;
 bottom: 0;
 left: 0;
 border-top-right-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `, [cE("resize-trigger", `
 width: 3px;
 height: 100%;
 top: 0;
 right: 0;
 transform: translateX(1.5px);
 cursor: ew-resize;
 `)]), cM("top-placement", `
 top: 0;
 left: 0;
 right: 0;
 border-bottom-left-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `, [cE("resize-trigger", `
 width: 100%;
 height: 3px;
 bottom: 0;
 left: 0;
 transform: translateY(1.5px);
 cursor: ns-resize;
 `)]), cM("bottom-placement", `
 left: 0;
 bottom: 0;
 right: 0;
 border-top-left-radius: var(--n-border-radius);
 border-top-right-radius: var(--n-border-radius);
 `, [cE("resize-trigger", `
 width: 100%;
 height: 3px;
 top: 0;
 left: 0;
 transform: translateY(-1.5px);
 cursor: ns-resize;
 `)])]), c$1("body", [c$1(">", [cB("drawer-container", `
 position: fixed;
 `)])]), cB("drawer-container", `
 position: relative;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 `, [c$1("> *", `
 pointer-events: all;
 `)]), cB("drawer-mask", `
 background-color: rgba(0, 0, 0, .3);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [cM("invisible", `
 background-color: rgba(0, 0, 0, 0)
 `), fadeInTransition({
    enterDuration: "0.2s",
    leaveDuration: "0.2s",
    enterCubicBezier: "var(--n-bezier-in)",
    leaveCubicBezier: "var(--n-bezier-out)"
  })])]);
  const drawerProps = Object.assign(Object.assign({}, useTheme.props), {
    show: Boolean,
    width: [Number, String],
    height: [Number, String],
    placement: {
      type: String,
      default: "right"
    },
    maskClosable: {
      type: Boolean,
      default: true
    },
    showMask: {
      type: [Boolean, String],
      default: true
    },
    to: [String, Object],
    displayDirective: {
      type: String,
      default: "if"
    },
    nativeScrollbar: {
      type: Boolean,
      default: true
    },
    zIndex: Number,
    onMaskClick: Function,
    scrollbarProps: Object,
    contentClass: String,
    contentStyle: [Object, String],
    trapFocus: {
      type: Boolean,
      default: true
    },
    onEsc: Function,
    autoFocus: {
      type: Boolean,
      default: true
    },
    closeOnEsc: {
      type: Boolean,
      default: true
    },
    blockScroll: {
      type: Boolean,
      default: true
    },
    maxWidth: Number,
    maxHeight: Number,
    minWidth: Number,
    minHeight: Number,
    resizable: Boolean,
    defaultWidth: {
      type: [Number, String],
      default: 251
    },
    defaultHeight: {
      type: [Number, String],
      default: 251
    },
    onUpdateWidth: [Function, Array],
    onUpdateHeight: [Function, Array],
    "onUpdate:width": [Function, Array],
    "onUpdate:height": [Function, Array],
    "onUpdate:show": [Function, Array],
    onUpdateShow: [Function, Array],
    onAfterEnter: Function,
    onAfterLeave: Function,
    /** @deprecated */
    drawerStyle: [String, Object],
    drawerClass: String,
    target: null,
    onShow: Function,
    onHide: Function
  });
  const Drawer = vue.defineComponent({
    name: "Drawer",
    inheritAttrs: false,
    props: drawerProps,
    setup(props) {
      {
        vue.watchEffect(() => {
          if (props.drawerStyle !== void 0) {
            warnOnce("drawer", "`drawer-style` is deprecated, please use `style` instead.");
          }
          if (props.drawerClass !== void 0) {
            warnOnce("drawer", "`drawer-class` is deprecated, please use `class` instead.");
          }
          if (props.target !== void 0) {
            warnOnce("drawer", "`target` is deprecated, please use `to` instead.");
          }
          if (props.onShow !== void 0) {
            warnOnce("drawer", "`on-show` is deprecated, please use `on-update:show` instead.");
          }
          if (props.onHide !== void 0) {
            warnOnce("drawer", "`on-hide` is deprecated, please use `on-update:show` instead.");
          }
        });
      }
      const {
        mergedClsPrefixRef,
        namespaceRef,
        inlineThemeDisabled
      } = useConfig(props);
      const isMountedRef = isMounted();
      const themeRef = useTheme("Drawer", "-drawer", style$Q, drawerLight$1, props, mergedClsPrefixRef);
      const uncontrolledWidthRef = vue.ref(props.defaultWidth);
      const uncontrolledHeightRef = vue.ref(props.defaultHeight);
      const mergedWidthRef = useMergedState(vue.toRef(props, "width"), uncontrolledWidthRef);
      const mergedHeightRef = useMergedState(vue.toRef(props, "height"), uncontrolledHeightRef);
      const styleWidthRef = vue.computed(() => {
        const {
          placement
        } = props;
        if (placement === "top" || placement === "bottom")
          return "";
        return formatLength(mergedWidthRef.value);
      });
      const styleHeightRef = vue.computed(() => {
        const {
          placement
        } = props;
        if (placement === "left" || placement === "right")
          return "";
        return formatLength(mergedHeightRef.value);
      });
      const doUpdateWidth = (value) => {
        const {
          onUpdateWidth,
          "onUpdate:width": _onUpdateWidth
        } = props;
        if (onUpdateWidth)
          call(onUpdateWidth, value);
        if (_onUpdateWidth)
          call(_onUpdateWidth, value);
        uncontrolledWidthRef.value = value;
      };
      const doUpdateHeight = (value) => {
        const {
          onUpdateHeight,
          "onUpdate:width": _onUpdateHeight
        } = props;
        if (onUpdateHeight)
          call(onUpdateHeight, value);
        if (_onUpdateHeight)
          call(_onUpdateHeight, value);
        uncontrolledHeightRef.value = value;
      };
      const mergedBodyStyleRef = vue.computed(() => {
        return [{
          width: styleWidthRef.value,
          height: styleHeightRef.value
        }, props.drawerStyle || ""];
      });
      function handleMaskClick(e) {
        const {
          onMaskClick,
          maskClosable
        } = props;
        if (maskClosable) {
          doUpdateShow(false);
        }
        if (onMaskClick)
          onMaskClick(e);
      }
      function handleOutsideClick(e) {
        handleMaskClick(e);
      }
      const isComposingRef2 = useIsComposing();
      function handleEsc(e) {
        var _a;
        (_a = props.onEsc) === null || _a === void 0 ? void 0 : _a.call(props);
        if (props.show && props.closeOnEsc && eventEffectNotPerformed(e)) {
          if (!isComposingRef2.value) {
            doUpdateShow(false);
          }
        }
      }
      function doUpdateShow(show) {
        const {
          onHide,
          onUpdateShow,
          "onUpdate:show": _onUpdateShow
        } = props;
        if (onUpdateShow)
          call(onUpdateShow, show);
        if (_onUpdateShow)
          call(_onUpdateShow, show);
        if (onHide && !show)
          call(onHide, show);
      }
      vue.provide(drawerInjectionKey, {
        isMountedRef,
        mergedThemeRef: themeRef,
        mergedClsPrefixRef,
        doUpdateShow,
        doUpdateHeight,
        doUpdateWidth
      });
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2,
            cubicBezierEaseIn: cubicBezierEaseIn2,
            cubicBezierEaseOut: cubicBezierEaseOut2
          },
          self: {
            color,
            textColor,
            boxShadow,
            lineHeight: lineHeight2,
            headerPadding,
            footerPadding,
            borderRadius,
            bodyPadding,
            titleFontSize,
            titleTextColor,
            titleFontWeight,
            headerBorderBottom,
            footerBorderTop,
            closeIconColor,
            closeIconColorHover,
            closeIconColorPressed,
            closeColorHover,
            closeColorPressed,
            closeIconSize,
            closeSize,
            closeBorderRadius,
            resizableTriggerColorHover
          }
        } = themeRef.value;
        return {
          "--n-line-height": lineHeight2,
          "--n-color": color,
          "--n-border-radius": borderRadius,
          "--n-text-color": textColor,
          "--n-box-shadow": boxShadow,
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-bezier-out": cubicBezierEaseOut2,
          "--n-bezier-in": cubicBezierEaseIn2,
          "--n-header-padding": headerPadding,
          "--n-body-padding": bodyPadding,
          "--n-footer-padding": footerPadding,
          "--n-title-text-color": titleTextColor,
          "--n-title-font-size": titleFontSize,
          "--n-title-font-weight": titleFontWeight,
          "--n-header-border-bottom": headerBorderBottom,
          "--n-footer-border-top": footerBorderTop,
          "--n-close-icon-color": closeIconColor,
          "--n-close-icon-color-hover": closeIconColorHover,
          "--n-close-icon-color-pressed": closeIconColorPressed,
          "--n-close-size": closeSize,
          "--n-close-color-hover": closeColorHover,
          "--n-close-color-pressed": closeColorPressed,
          "--n-close-icon-size": closeIconSize,
          "--n-close-border-radius": closeBorderRadius,
          "--n-resize-trigger-color-hover": resizableTriggerColorHover
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("drawer", void 0, cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        namespace: namespaceRef,
        mergedBodyStyle: mergedBodyStyleRef,
        handleOutsideClick,
        handleMaskClick,
        handleEsc,
        mergedTheme: themeRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
        isMounted: isMountedRef
      };
    },
    render() {
      const {
        mergedClsPrefix
      } = this;
      return vue.h(LazyTeleport, {
        to: this.to,
        show: this.show
      }, {
        default: () => {
          var _a;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.withDirectives(vue.h("div", {
            class: [`${mergedClsPrefix}-drawer-container`, this.namespace, this.themeClass],
            style: this.cssVars,
            role: "none"
          }, this.showMask ? vue.h(vue.Transition, {
            name: "fade-in-transition",
            appear: this.isMounted
          }, {
            default: () => this.show ? vue.h("div", {
              "aria-hidden": true,
              class: [`${mergedClsPrefix}-drawer-mask`, this.showMask === "transparent" && `${mergedClsPrefix}-drawer-mask--invisible`],
              onClick: this.handleMaskClick
            }) : null
          }) : null, vue.h(NDrawerBodyWrapper, Object.assign({}, this.$attrs, {
            class: [this.drawerClass, this.$attrs.class],
            style: [this.mergedBodyStyle, this.$attrs.style],
            blockScroll: this.blockScroll,
            contentStyle: this.contentStyle,
            contentClass: this.contentClass,
            placement: this.placement,
            scrollbarProps: this.scrollbarProps,
            show: this.show,
            displayDirective: this.displayDirective,
            nativeScrollbar: this.nativeScrollbar,
            onAfterEnter: this.onAfterEnter,
            onAfterLeave: this.onAfterLeave,
            trapFocus: this.trapFocus,
            autoFocus: this.autoFocus,
            resizable: this.resizable,
            maxHeight: this.maxHeight,
            minHeight: this.minHeight,
            maxWidth: this.maxWidth,
            minWidth: this.minWidth,
            showMask: this.showMask,
            onEsc: this.handleEsc,
            onClickoutside: this.handleOutsideClick
          }), this.$slots)), [[zindexable$1, {
            zIndex: this.zIndex,
            enabled: this.show
          }]]);
        }
      });
    }
  });
  const drawerContentProps = {
    title: String,
    headerClass: String,
    headerStyle: [Object, String],
    footerClass: String,
    footerStyle: [Object, String],
    bodyClass: String,
    bodyStyle: [Object, String],
    bodyContentClass: String,
    bodyContentStyle: [Object, String],
    nativeScrollbar: {
      type: Boolean,
      default: true
    },
    scrollbarProps: Object,
    closable: Boolean
  };
  const DrawerContent = vue.defineComponent({
    name: "DrawerContent",
    props: drawerContentProps,
    setup() {
      const NDrawer = vue.inject(drawerInjectionKey, null);
      if (!NDrawer) {
        throwError("drawer-content", "`n-drawer-content` must be placed inside `n-drawer`.");
      }
      const {
        doUpdateShow
      } = NDrawer;
      function handleCloseClick() {
        doUpdateShow(false);
      }
      return {
        handleCloseClick,
        mergedTheme: NDrawer.mergedThemeRef,
        mergedClsPrefix: NDrawer.mergedClsPrefixRef
      };
    },
    render() {
      const {
        title,
        mergedClsPrefix,
        nativeScrollbar,
        mergedTheme,
        bodyClass,
        bodyStyle,
        bodyContentClass,
        bodyContentStyle,
        headerClass,
        headerStyle,
        footerClass,
        footerStyle,
        scrollbarProps: scrollbarProps2,
        closable,
        $slots
      } = this;
      return vue.h("div", {
        role: "none",
        class: [`${mergedClsPrefix}-drawer-content`, nativeScrollbar && `${mergedClsPrefix}-drawer-content--native-scrollbar`]
      }, $slots.header || title || closable ? vue.h("div", {
        class: [`${mergedClsPrefix}-drawer-header`, headerClass],
        style: headerStyle,
        role: "none"
      }, vue.h("div", {
        class: `${mergedClsPrefix}-drawer-header__main`,
        role: "heading",
        "aria-level": "1"
      }, $slots.header !== void 0 ? $slots.header() : title), closable && vue.h(NBaseClose, {
        onClick: this.handleCloseClick,
        clsPrefix: mergedClsPrefix,
        class: `${mergedClsPrefix}-drawer-header__close`,
        absolute: true
      })) : null, nativeScrollbar ? vue.h("div", {
        class: [`${mergedClsPrefix}-drawer-body`, bodyClass],
        style: bodyStyle,
        role: "none"
      }, vue.h("div", {
        class: [`${mergedClsPrefix}-drawer-body-content-wrapper`, bodyContentClass],
        style: bodyContentStyle,
        role: "none"
      }, $slots)) : vue.h(NScrollbar, Object.assign({
        themeOverrides: mergedTheme.peerOverrides.Scrollbar,
        theme: mergedTheme.peers.Scrollbar
      }, scrollbarProps2, {
        class: `${mergedClsPrefix}-drawer-body`,
        contentClass: [`${mergedClsPrefix}-drawer-body-content-wrapper`, bodyContentClass],
        contentStyle: bodyContentStyle
      }), $slots), $slots.footer ? vue.h("div", {
        class: [`${mergedClsPrefix}-drawer-footer`, footerClass],
        style: footerStyle,
        role: "none"
      }, $slots.footer()) : null);
    }
  });
  const commonVariables$6 = {
    actionMargin: "0 0 0 20px",
    actionMarginRtl: "0 20px 0 0"
  };
  function self$F() {
    return commonVariables$6;
  }
  const dynamicInputLight = createTheme({
    name: "DynamicInput",
    common: commonLight,
    peers: {
      Input: inputLight$1,
      Button: buttonLight$1
    },
    self: self$F
  });
  const dynamicInputLight$1 = dynamicInputLight;
  const dynamicInputInjectionKey = createInjectionKey("n-dynamic-input");
  const NDynamicInputInputPreset = vue.defineComponent({
    name: "DynamicInputInputPreset",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      value: {
        type: String,
        default: ""
      },
      disabled: Boolean,
      parentPath: String,
      path: String,
      onUpdateValue: {
        type: Function,
        required: true
      }
    },
    setup() {
      const {
        mergedThemeRef,
        placeholderRef
      } = vue.inject(dynamicInputInjectionKey);
      return {
        mergedTheme: mergedThemeRef,
        placeholder: placeholderRef
      };
    },
    render() {
      const {
        mergedTheme,
        placeholder,
        value,
        clsPrefix,
        onUpdateValue,
        disabled
      } = this;
      return vue.h("div", {
        class: `${clsPrefix}-dynamic-input-preset-input`
      }, vue.h(NInput, {
        theme: mergedTheme.peers.Input,
        "theme-overrides": mergedTheme.peerOverrides.Input,
        value,
        placeholder,
        onUpdateValue,
        disabled
      }));
    }
  });
  const NDynamicInputPairPreset = vue.defineComponent({
    name: "DynamicInputPairPreset",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      value: {
        type: Object,
        default: () => ({
          key: "",
          value: ""
        })
      },
      disabled: Boolean,
      parentPath: String,
      path: String,
      onUpdateValue: {
        type: Function,
        required: true
      }
    },
    setup(props) {
      const {
        mergedThemeRef,
        keyPlaceholderRef,
        valuePlaceholderRef
      } = vue.inject(dynamicInputInjectionKey);
      return {
        mergedTheme: mergedThemeRef,
        keyPlaceholder: keyPlaceholderRef,
        valuePlaceholder: valuePlaceholderRef,
        handleKeyInput(key) {
          props.onUpdateValue({
            key,
            value: props.value.value
          });
        },
        handleValueInput(value) {
          props.onUpdateValue({
            key: props.value.key,
            value
          });
        }
      };
    },
    render() {
      const {
        mergedTheme,
        keyPlaceholder,
        valuePlaceholder,
        value,
        clsPrefix,
        disabled
      } = this;
      return vue.h("div", {
        class: `${clsPrefix}-dynamic-input-preset-pair`
      }, vue.h(NInput, {
        theme: mergedTheme.peers.Input,
        "theme-overrides": mergedTheme.peerOverrides.Input,
        value: value.key,
        class: `${clsPrefix}-dynamic-input-pair-input`,
        placeholder: keyPlaceholder,
        onUpdateValue: this.handleKeyInput,
        disabled
      }), vue.h(NInput, {
        theme: mergedTheme.peers.Input,
        "theme-overrides": mergedTheme.peerOverrides.Input,
        value: value.value,
        class: `${clsPrefix}-dynamic-input-pair-input`,
        placeholder: valuePlaceholder,
        onUpdateValue: this.handleValueInput,
        disabled
      }));
    }
  });
  const style$P = cB("dynamic-input", {
    width: "100%"
  }, [cB("dynamic-input-item", `
 margin-bottom: 10px;
 display: flex;
 flex-wrap: nowrap;
 `, [cB("dynamic-input-preset-input", {
    flex: 1,
    alignItems: "center"
  }), cB("dynamic-input-preset-pair", `
 flex: 1;
 display: flex;
 align-items: center;
 `, [cB("dynamic-input-pair-input", [c$1("&:first-child", {
    "margin-right": "12px"
  })])]), cE("action", `
 align-self: flex-start;
 display: flex;
 justify-content: flex-end;
 flex-shrink: 0;
 flex-grow: 0;
 margin: var(--action-margin);
 `, [cM("icon", {
    cursor: "pointer"
  })]), c$1("&:last-child", {
    marginBottom: 0
  })]), cB("form-item", `
 padding-top: 0 !important;
 margin-right: 0 !important;
 `, [cB("form-item-blank", {
    paddingTop: "0 !important"
  })])]);
  const globalDataKeyMap = /* @__PURE__ */ new WeakMap();
  const dynamicInputProps = Object.assign(Object.assign({}, useTheme.props), {
    max: Number,
    min: {
      type: Number,
      default: 0
    },
    value: Array,
    // TODO: make it robust for different types
    defaultValue: {
      type: Array,
      default: () => []
    },
    preset: {
      type: String,
      default: "input"
    },
    keyField: String,
    itemClass: String,
    itemStyle: [String, Object],
    // for preset pair
    keyPlaceholder: {
      type: String,
      default: ""
    },
    valuePlaceholder: {
      type: String,
      default: ""
    },
    // for preset input
    placeholder: {
      type: String,
      default: ""
    },
    disabled: Boolean,
    showSortButton: Boolean,
    createButtonProps: Object,
    onCreate: Function,
    onRemove: Function,
    "onUpdate:value": [Function, Array],
    onUpdateValue: [Function, Array],
    // deprecated
    onClear: Function,
    onInput: [Function, Array]
  });
  const DynamicInput = vue.defineComponent({
    name: "DynamicInput",
    props: dynamicInputProps,
    setup(props, {
      slots
    }) {
      {
        vue.watchEffect(() => {
          if (props.onClear !== void 0) {
            warnOnce("dynamic-input", "`on-clear` is deprecated, it is out of usage anymore.");
          }
          if (props.onInput !== void 0) {
            warnOnce("dynamic-input", "`on-input` is deprecated, please use `on-update:value` instead.");
          }
        });
      }
      const {
        mergedComponentPropsRef,
        mergedClsPrefixRef,
        mergedRtlRef,
        inlineThemeDisabled
      } = useConfig();
      const NFormItem2 = vue.inject(formItemInjectionKey, null);
      const uncontrolledValueRef = vue.ref(props.defaultValue);
      const controlledValueRef = vue.toRef(props, "value");
      const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
      const themeRef = useTheme("DynamicInput", "-dynamic-input", style$P, dynamicInputLight$1, props, mergedClsPrefixRef);
      const insertionDisabledRef = vue.computed(() => {
        const {
          value: mergedValue
        } = mergedValueRef;
        if (Array.isArray(mergedValue)) {
          const {
            max
          } = props;
          return max !== void 0 && mergedValue.length >= max;
        }
        return false;
      });
      const removeDisabledRef = vue.computed(() => {
        const {
          value: mergedValue
        } = mergedValueRef;
        if (Array.isArray(mergedValue))
          return mergedValue.length <= props.min;
        return true;
      });
      const buttonSizeRef = vue.computed(() => {
        var _a, _b;
        return (_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.DynamicInput) === null || _b === void 0 ? void 0 : _b.buttonSize;
      });
      function doUpdateValue(value) {
        const {
          onInput,
          "onUpdate:value": _onUpdateValue,
          onUpdateValue
        } = props;
        if (onInput)
          call(onInput, value);
        if (_onUpdateValue)
          call(_onUpdateValue, value);
        if (onUpdateValue)
          call(onUpdateValue, value);
        uncontrolledValueRef.value = value;
      }
      function ensureKey(value, index) {
        if (value === void 0 || value === null)
          return index;
        if (typeof value !== "object")
          return index;
        const rawValue = vue.isProxy(value) ? vue.toRaw(value) : value;
        let key = globalDataKeyMap.get(rawValue);
        if (key === void 0) {
          globalDataKeyMap.set(rawValue, key = createId());
        }
        return key;
      }
      function handleValueChange(index, value) {
        const {
          value: mergedValue
        } = mergedValueRef;
        const newValue = Array.from(mergedValue !== null && mergedValue !== void 0 ? mergedValue : []);
        const originalItem = newValue[index];
        newValue[index] = value;
        if (originalItem && value && typeof originalItem === "object" && typeof value === "object") {
          const rawOriginal = vue.isProxy(originalItem) ? vue.toRaw(originalItem) : originalItem;
          const rawNew = vue.isProxy(value) ? vue.toRaw(value) : value;
          const originalKey = globalDataKeyMap.get(rawOriginal);
          if (originalKey !== void 0) {
            globalDataKeyMap.set(rawNew, originalKey);
          }
        }
        doUpdateValue(newValue);
      }
      function handleCreateClick() {
        createItem(-1);
      }
      function createItem(index) {
        const {
          value: mergedValue
        } = mergedValueRef;
        const {
          onCreate
        } = props;
        const newValue = Array.from(mergedValue !== null && mergedValue !== void 0 ? mergedValue : []);
        if (onCreate) {
          newValue.splice(index + 1, 0, onCreate(index + 1));
          doUpdateValue(newValue);
        } else if (slots.default) {
          newValue.splice(index + 1, 0, null);
          doUpdateValue(newValue);
        } else {
          switch (props.preset) {
            case "input":
              newValue.splice(index + 1, 0, "");
              doUpdateValue(newValue);
              break;
            case "pair":
              newValue.splice(index + 1, 0, {
                key: "",
                value: ""
              });
              doUpdateValue(newValue);
              break;
          }
        }
      }
      function remove(index) {
        const {
          value: mergedValue
        } = mergedValueRef;
        if (!Array.isArray(mergedValue))
          return;
        const {
          min
        } = props;
        if (mergedValue.length <= min)
          return;
        const {
          onRemove
        } = props;
        if (onRemove) {
          onRemove(index);
        }
        const newValue = Array.from(mergedValue);
        newValue.splice(index, 1);
        doUpdateValue(newValue);
      }
      function swap(array, currentIndex, targetIndex) {
        if (currentIndex < 0 || targetIndex < 0 || currentIndex >= array.length || targetIndex >= array.length) {
          return;
        }
        if (currentIndex === targetIndex)
          return;
        const currentItem = array[currentIndex];
        array[currentIndex] = array[targetIndex];
        array[targetIndex] = currentItem;
      }
      function move2(type, index) {
        const {
          value: mergedValue
        } = mergedValueRef;
        if (!Array.isArray(mergedValue))
          return;
        const newValue = Array.from(mergedValue);
        if (type === "up") {
          swap(newValue, index, index - 1);
        }
        if (type === "down") {
          swap(newValue, index, index + 1);
        }
        doUpdateValue(newValue);
      }
      vue.provide(dynamicInputInjectionKey, {
        mergedThemeRef: themeRef,
        keyPlaceholderRef: vue.toRef(props, "keyPlaceholder"),
        valuePlaceholderRef: vue.toRef(props, "valuePlaceholder"),
        placeholderRef: vue.toRef(props, "placeholder")
      });
      const rtlEnabledRef = useRtl("DynamicInput", mergedRtlRef, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          self: {
            actionMargin,
            actionMarginRtl
          }
        } = themeRef.value;
        return {
          "--action-margin": actionMargin,
          "--action-margin-rtl": actionMarginRtl
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("dynamic-input", void 0, cssVarsRef, props) : void 0;
      return {
        locale: useLocale("DynamicInput").localeRef,
        rtlEnabled: rtlEnabledRef,
        buttonSize: buttonSizeRef,
        mergedClsPrefix: mergedClsPrefixRef,
        NFormItem: NFormItem2,
        uncontrolledValue: uncontrolledValueRef,
        mergedValue: mergedValueRef,
        insertionDisabled: insertionDisabledRef,
        removeDisabled: removeDisabledRef,
        handleCreateClick,
        ensureKey,
        handleValueChange,
        remove,
        move: move2,
        createItem,
        mergedTheme: themeRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      const {
        $slots,
        itemClass,
        buttonSize,
        mergedClsPrefix,
        mergedValue,
        locale,
        mergedTheme,
        keyField,
        itemStyle,
        preset,
        showSortButton,
        NFormItem: NFormItem2,
        ensureKey,
        handleValueChange,
        remove,
        createItem,
        move: move2,
        onRender,
        disabled
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h("div", {
        class: [`${mergedClsPrefix}-dynamic-input`, this.rtlEnabled && `${mergedClsPrefix}-dynamic-input--rtl`, this.themeClass],
        style: this.cssVars
      }, !Array.isArray(mergedValue) || mergedValue.length === 0 ? vue.h(NButton, Object.assign({
        block: true,
        ghost: true,
        dashed: true,
        size: buttonSize
      }, this.createButtonProps, {
        disabled: this.insertionDisabled || disabled,
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        onClick: this.handleCreateClick
      }), {
        default: () => resolveSlot($slots["create-button-default"], () => [locale.create]),
        icon: () => resolveSlot($slots["create-button-icon"], () => [vue.h(NBaseIcon, {
          clsPrefix: mergedClsPrefix
        }, {
          default: () => vue.h(AddIcon, null)
        })])
      }) : mergedValue.map((_, index) => vue.h("div", {
        key: keyField ? _[keyField] : ensureKey(_, index),
        "data-key": keyField ? _[keyField] : ensureKey(_, index),
        class: [`${mergedClsPrefix}-dynamic-input-item`, itemClass],
        style: itemStyle
      }, resolveSlotWithProps($slots.default, {
        value: mergedValue[index],
        index
      }, () => {
        return [preset === "input" ? vue.h(NDynamicInputInputPreset, {
          disabled,
          clsPrefix: mergedClsPrefix,
          value: mergedValue[index],
          parentPath: NFormItem2 ? NFormItem2.path.value : void 0,
          path: (NFormItem2 === null || NFormItem2 === void 0 ? void 0 : NFormItem2.path.value) ? `${NFormItem2.path.value}[${index}]` : void 0,
          onUpdateValue: (v) => {
            handleValueChange(index, v);
          }
        }) : preset === "pair" ? vue.h(NDynamicInputPairPreset, {
          disabled,
          clsPrefix: mergedClsPrefix,
          value: mergedValue[index],
          parentPath: NFormItem2 ? NFormItem2.path.value : void 0,
          path: (NFormItem2 === null || NFormItem2 === void 0 ? void 0 : NFormItem2.path.value) ? `${NFormItem2.path.value}[${index}]` : void 0,
          onUpdateValue: (v) => {
            handleValueChange(index, v);
          }
        }) : null];
      }), resolveSlotWithProps($slots.action, {
        value: mergedValue[index],
        index,
        create: createItem,
        remove,
        move: move2
      }, () => [vue.h("div", {
        class: `${mergedClsPrefix}-dynamic-input-item__action`
      }, vue.h(NButtonGroup, {
        size: buttonSize
      }, {
        default: () => [vue.h(NButton, {
          disabled: this.removeDisabled || disabled,
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          circle: true,
          onClick: () => {
            remove(index);
          }
        }, {
          icon: () => vue.h(NBaseIcon, {
            clsPrefix: mergedClsPrefix
          }, {
            default: () => vue.h(RemoveIcon, null)
          })
        }), vue.h(NButton, {
          disabled: this.insertionDisabled || disabled,
          circle: true,
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          onClick: () => {
            createItem(index);
          }
        }, {
          icon: () => vue.h(NBaseIcon, {
            clsPrefix: mergedClsPrefix
          }, {
            default: () => vue.h(AddIcon, null)
          })
        }), showSortButton ? vue.h(NButton, {
          disabled: index === 0 || disabled,
          circle: true,
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          onClick: () => {
            move2("up", index);
          }
        }, {
          icon: () => vue.h(NBaseIcon, {
            clsPrefix: mergedClsPrefix
          }, {
            default: () => vue.h(ArrowUpIcon, null)
          })
        }) : null, showSortButton ? vue.h(NButton, {
          disabled: index === mergedValue.length - 1 || disabled,
          circle: true,
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          onClick: () => {
            move2("down", index);
          }
        }, {
          icon: () => vue.h(NBaseIcon, {
            clsPrefix: mergedClsPrefix
          }, {
            default: () => vue.h(ArrowDownIcon, null)
          })
        }) : null]
      }))]))));
    }
  });
  const commonVars$5 = {
    gapSmall: "4px 8px",
    gapMedium: "8px 12px",
    gapLarge: "12px 16px"
  };
  function self$E() {
    return commonVars$5;
  }
  const spaceLight = {
    name: "Space",
    self: self$E
  };
  const spaceLight$1 = spaceLight;
  let supportFlexGap;
  function ensureSupportFlexGap() {
    if (!isBrowser$2)
      return true;
    if (supportFlexGap === void 0) {
      const flex = document.createElement("div");
      flex.style.display = "flex";
      flex.style.flexDirection = "column";
      flex.style.rowGap = "1px";
      flex.appendChild(document.createElement("div"));
      flex.appendChild(document.createElement("div"));
      document.body.appendChild(flex);
      const isSupported = flex.scrollHeight === 1;
      document.body.removeChild(flex);
      return supportFlexGap = isSupported;
    }
    return supportFlexGap;
  }
  const spaceProps = Object.assign(Object.assign({}, useTheme.props), {
    align: String,
    justify: {
      type: String,
      default: "start"
    },
    inline: Boolean,
    vertical: Boolean,
    reverse: Boolean,
    size: {
      type: [String, Number, Array],
      default: "medium"
    },
    wrapItem: {
      type: Boolean,
      default: true
    },
    itemClass: String,
    itemStyle: [String, Object],
    wrap: {
      type: Boolean,
      default: true
    },
    // internal
    internalUseGap: {
      type: Boolean,
      default: void 0
    }
  });
  const NSpace = vue.defineComponent({
    name: "Space",
    props: spaceProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        mergedRtlRef
      } = useConfig(props);
      const themeRef = useTheme("Space", "-space", void 0, spaceLight$1, props, mergedClsPrefixRef);
      const rtlEnabledRef = useRtl("Space", mergedRtlRef, mergedClsPrefixRef);
      return {
        useGap: ensureSupportFlexGap(),
        rtlEnabled: rtlEnabledRef,
        mergedClsPrefix: mergedClsPrefixRef,
        margin: vue.computed(() => {
          const {
            size: size2
          } = props;
          if (Array.isArray(size2)) {
            return {
              horizontal: size2[0],
              vertical: size2[1]
            };
          }
          if (typeof size2 === "number") {
            return {
              horizontal: size2,
              vertical: size2
            };
          }
          const {
            self: {
              [createKey("gap", size2)]: gap
            }
          } = themeRef.value;
          const {
            row,
            col
          } = getGap(gap);
          return {
            horizontal: depx(col),
            vertical: depx(row)
          };
        })
      };
    },
    render() {
      const {
        vertical,
        reverse,
        align,
        inline,
        justify,
        itemClass,
        itemStyle,
        margin,
        wrap,
        mergedClsPrefix,
        rtlEnabled,
        useGap,
        wrapItem,
        internalUseGap
      } = this;
      const children = flatten$3(getSlot$1(this), false);
      if (!children.length)
        return null;
      const horizontalMargin = `${margin.horizontal}px`;
      const semiHorizontalMargin = `${margin.horizontal / 2}px`;
      const verticalMargin = `${margin.vertical}px`;
      const semiVerticalMargin = `${margin.vertical / 2}px`;
      const lastIndex = children.length - 1;
      const isJustifySpace = justify.startsWith("space-");
      return vue.h("div", {
        role: "none",
        class: [`${mergedClsPrefix}-space`, rtlEnabled && `${mergedClsPrefix}-space--rtl`],
        style: {
          display: inline ? "inline-flex" : "flex",
          flexDirection: (() => {
            if (vertical && !reverse)
              return "column";
            if (vertical && reverse)
              return "column-reverse";
            if (!vertical && reverse)
              return "row-reverse";
            else
              return "row";
          })(),
          justifyContent: ["start", "end"].includes(justify) ? `flex-${justify}` : justify,
          flexWrap: !wrap || vertical ? "nowrap" : "wrap",
          marginTop: useGap || vertical ? "" : `-${semiVerticalMargin}`,
          marginBottom: useGap || vertical ? "" : `-${semiVerticalMargin}`,
          alignItems: align,
          gap: useGap ? `${margin.vertical}px ${margin.horizontal}px` : ""
        }
      }, !wrapItem && (useGap || internalUseGap) ? children : children.map((child, index) => child.type === vue.Comment ? child : vue.h("div", {
        role: "none",
        class: itemClass,
        style: [itemStyle, {
          maxWidth: "100%"
        }, useGap ? "" : vertical ? {
          marginBottom: index !== lastIndex ? verticalMargin : ""
        } : rtlEnabled ? {
          marginLeft: isJustifySpace ? justify === "space-between" && index === lastIndex ? "" : semiHorizontalMargin : index !== lastIndex ? horizontalMargin : "",
          marginRight: isJustifySpace ? justify === "space-between" && index === 0 ? "" : semiHorizontalMargin : "",
          paddingTop: semiVerticalMargin,
          paddingBottom: semiVerticalMargin
        } : {
          marginRight: isJustifySpace ? justify === "space-between" && index === lastIndex ? "" : semiHorizontalMargin : index !== lastIndex ? horizontalMargin : "",
          marginLeft: isJustifySpace ? justify === "space-between" && index === 0 ? "" : semiHorizontalMargin : "",
          paddingTop: semiVerticalMargin,
          paddingBottom: semiVerticalMargin
        }]
      }, child)));
    }
  });
  const dynamicTagsLight = createTheme({
    name: "DynamicTags",
    common: commonLight,
    peers: {
      Input: inputLight$1,
      Button: buttonLight$1,
      Tag: tagLight$1,
      Space: spaceLight$1
    },
    self() {
      return {
        inputWidth: "64px"
      };
    }
  });
  const dynamicTagsLight$1 = dynamicTagsLight;
  const style$O = cB("dynamic-tags", [cB("input", {
    minWidth: "var(--n-input-width)"
  })]);
  const dynamicTagsProps = Object.assign(Object.assign(Object.assign({}, useTheme.props), commonProps), {
    size: {
      type: String,
      default: "medium"
    },
    closable: {
      type: Boolean,
      default: true
    },
    defaultValue: {
      type: Array,
      default: () => []
    },
    value: Array,
    inputClass: String,
    inputStyle: [String, Object],
    inputProps: Object,
    max: Number,
    tagClass: String,
    tagStyle: [String, Object],
    renderTag: Function,
    onCreate: {
      type: Function,
      default: (label) => label
    },
    "onUpdate:value": [Function, Array],
    onUpdateValue: [Function, Array],
    // deprecated
    onChange: [Function, Array]
  });
  const DynamicTags = vue.defineComponent({
    name: "DynamicTags",
    props: dynamicTagsProps,
    setup(props) {
      {
        vue.watchEffect(() => {
          if (props.onChange !== void 0) {
            warnOnce("dynamic-tags", "`on-change` is deprecated, please use `on-update:value` instead.");
          }
        });
      }
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const {
        localeRef
      } = useLocale("DynamicTags");
      const formItem = useFormItem(props);
      const {
        mergedDisabledRef
      } = formItem;
      const inputValueRef = vue.ref("");
      const showInputRef = vue.ref(false);
      const inputForceFocusedRef = vue.ref(true);
      const inputInstRef = vue.ref(null);
      const themeRef = useTheme("DynamicTags", "-dynamic-tags", style$O, dynamicTagsLight$1, props, mergedClsPrefixRef);
      const uncontrolledValueRef = vue.ref(props.defaultValue);
      const controlledValueRef = vue.toRef(props, "value");
      const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
      const localizedAddRef = vue.computed(() => {
        return localeRef.value.add;
      });
      const inputSizeRef = vue.computed(() => {
        return smallerSize(props.size);
      });
      const triggerDisabledRef = vue.computed(() => {
        return mergedDisabledRef.value || !!props.max && mergedValueRef.value.length >= props.max;
      });
      function doChange(value) {
        const {
          onChange,
          "onUpdate:value": _onUpdateValue,
          onUpdateValue
        } = props;
        const {
          nTriggerFormInput,
          nTriggerFormChange
        } = formItem;
        if (onChange)
          call(onChange, value);
        if (onUpdateValue)
          call(onUpdateValue, value);
        if (_onUpdateValue)
          call(_onUpdateValue, value);
        uncontrolledValueRef.value = value;
        nTriggerFormInput();
        nTriggerFormChange();
      }
      function handleCloseClick(index) {
        const tags = mergedValueRef.value.slice(0);
        tags.splice(index, 1);
        doChange(tags);
      }
      function handleInputKeyDown(e) {
        switch (e.key) {
          case "Enter":
            handleInputConfirm();
        }
      }
      function handleInputConfirm(externalValue) {
        const nextValue = externalValue !== null && externalValue !== void 0 ? externalValue : inputValueRef.value;
        if (nextValue) {
          const tags = mergedValueRef.value.slice(0);
          tags.push(props.onCreate(nextValue));
          doChange(tags);
        }
        showInputRef.value = false;
        inputForceFocusedRef.value = true;
        inputValueRef.value = "";
      }
      function handleInputBlur() {
        handleInputConfirm();
      }
      function handleAddClick() {
        showInputRef.value = true;
        void vue.nextTick(() => {
          var _a;
          (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
          inputForceFocusedRef.value = false;
        });
      }
      const cssVarsRef = vue.computed(() => {
        const {
          self: {
            inputWidth
          }
        } = themeRef.value;
        return {
          "--n-input-width": inputWidth
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("dynamic-tags", void 0, cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        inputInstRef,
        localizedAdd: localizedAddRef,
        inputSize: inputSizeRef,
        inputValue: inputValueRef,
        showInput: showInputRef,
        inputForceFocused: inputForceFocusedRef,
        mergedValue: mergedValueRef,
        mergedDisabled: mergedDisabledRef,
        triggerDisabled: triggerDisabledRef,
        handleInputKeyDown,
        handleAddClick,
        handleInputBlur,
        handleCloseClick,
        handleInputConfirm,
        mergedTheme: themeRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      const {
        mergedTheme,
        cssVars,
        mergedClsPrefix,
        onRender,
        renderTag
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h(NSpace, {
        class: [`${mergedClsPrefix}-dynamic-tags`, this.themeClass],
        size: "small",
        style: cssVars,
        theme: mergedTheme.peers.Space,
        themeOverrides: mergedTheme.peerOverrides.Space,
        itemStyle: "display: flex;"
      }, {
        default: () => {
          const {
            mergedTheme: mergedTheme2,
            tagClass,
            tagStyle,
            type,
            round: round2,
            size: size2,
            color,
            closable,
            mergedDisabled,
            showInput,
            inputValue,
            inputClass,
            inputStyle,
            inputSize,
            inputForceFocused,
            triggerDisabled,
            handleInputKeyDown,
            handleInputBlur,
            handleAddClick,
            handleCloseClick,
            handleInputConfirm,
            $slots
          } = this;
          return this.mergedValue.map((tag, index) => renderTag ? renderTag(tag, index) : vue.h(NTag, {
            key: index,
            theme: mergedTheme2.peers.Tag,
            themeOverrides: mergedTheme2.peerOverrides.Tag,
            class: tagClass,
            style: tagStyle,
            type,
            round: round2,
            size: size2,
            color,
            closable,
            disabled: mergedDisabled,
            onClose: () => {
              handleCloseClick(index);
            }
          }, {
            default: () => typeof tag === "string" ? tag : tag.label
          })).concat(showInput ? $slots.input ? $slots.input({
            submit: handleInputConfirm,
            deactivate: handleInputBlur
          }) : vue.h(NInput, Object.assign({
            placeholder: "",
            size: inputSize,
            style: inputStyle,
            class: inputClass,
            autosize: true
          }, this.inputProps, {
            ref: "inputInstRef",
            value: inputValue,
            onUpdateValue: (v) => {
              this.inputValue = v;
            },
            theme: mergedTheme2.peers.Input,
            themeOverrides: mergedTheme2.peerOverrides.Input,
            onKeydown: handleInputKeyDown,
            onBlur: handleInputBlur,
            internalForceFocus: inputForceFocused
          })) : $slots.trigger ? $slots.trigger({
            activate: handleAddClick,
            disabled: triggerDisabled
          }) : vue.h(NButton, {
            dashed: true,
            disabled: triggerDisabled,
            theme: mergedTheme2.peers.Button,
            themeOverrides: mergedTheme2.peerOverrides.Button,
            size: inputSize,
            onClick: handleAddClick
          }, {
            icon: () => vue.h(NBaseIcon, {
              clsPrefix: mergedClsPrefix
            }, {
              default: () => vue.h(AddIcon, null)
            })
          }));
        }
      });
    }
  });
  const elementLight = {
    name: "Element",
    common: commonLight
  };
  const elementLight$1 = elementLight;
  const elementProps = Object.assign(Object.assign({}, useTheme.props), {
    tag: {
      type: String,
      default: "div"
    }
  });
  const NElement = vue.defineComponent({
    name: "Element",
    alias: ["El"],
    props: elementProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Element", "-element", void 0, elementLight$1, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          common: common2
        } = themeRef.value;
        return Object.keys(common2).reduce((prevValue, key) => {
          prevValue[`--${kebabCase(key)}`] = common2[key];
          return prevValue;
        }, {});
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("element", void 0, cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a;
      const {
        tag,
        mergedClsPrefix,
        cssVars,
        themeClass,
        onRender,
        $slots
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h(tag, {
        role: "none",
        class: [`${mergedClsPrefix}-element`, themeClass],
        style: cssVars
      }, (_a = $slots.default) === null || _a === void 0 ? void 0 : _a.call($slots));
    }
  });
  const commonVars$4 = {
    gapSmall: "4px 8px",
    gapMedium: "8px 12px",
    gapLarge: "12px 16px"
  };
  function self$D() {
    return commonVars$4;
  }
  const flexLight = {
    name: "Flex",
    self: self$D
  };
  const flexLight$1 = flexLight;
  const flexProps = Object.assign(Object.assign({}, useTheme.props), {
    align: String,
    justify: {
      type: String,
      default: "start"
    },
    inline: Boolean,
    vertical: Boolean,
    reverse: Boolean,
    size: {
      type: [String, Number, Array],
      default: "medium"
    },
    wrap: {
      type: Boolean,
      default: true
    }
  });
  const Flex = vue.defineComponent({
    name: "Flex",
    props: flexProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        mergedRtlRef
      } = useConfig(props);
      const themeRef = useTheme("Flex", "-flex", void 0, flexLight$1, props, mergedClsPrefixRef);
      const rtlEnabledRef = useRtl("Flex", mergedRtlRef, mergedClsPrefixRef);
      return {
        rtlEnabled: rtlEnabledRef,
        mergedClsPrefix: mergedClsPrefixRef,
        margin: vue.computed(() => {
          const {
            size: size2
          } = props;
          if (Array.isArray(size2)) {
            return {
              horizontal: size2[0],
              vertical: size2[1]
            };
          }
          if (typeof size2 === "number") {
            return {
              horizontal: size2,
              vertical: size2
            };
          }
          const {
            self: {
              [createKey("gap", size2)]: gap
            }
          } = themeRef.value;
          const {
            row,
            col
          } = getGap(gap);
          return {
            horizontal: depx(col),
            vertical: depx(row)
          };
        })
      };
    },
    render() {
      const {
        vertical,
        reverse,
        align,
        inline,
        justify,
        margin,
        wrap,
        mergedClsPrefix,
        rtlEnabled
      } = this;
      const children = flatten$3(getSlot$1(this), false);
      if (!children.length)
        return null;
      return vue.h("div", {
        role: "none",
        class: [`${mergedClsPrefix}-flex`, rtlEnabled && `${mergedClsPrefix}-flex--rtl`],
        style: {
          display: inline ? "inline-flex" : "flex",
          flexDirection: (() => {
            if (vertical && !reverse)
              return "column";
            if (vertical && reverse)
              return "column-reverse";
            if (!vertical && reverse)
              return "row-reverse";
            else
              return "row";
          })(),
          justifyContent: justify,
          flexWrap: !wrap || vertical ? "nowrap" : "wrap",
          alignItems: align,
          gap: `${margin.vertical}px ${margin.horizontal}px`
        }
      }, children);
    }
  });
  const commonVariables$5 = {
    feedbackPadding: "4px 0 0 2px",
    feedbackHeightSmall: "24px",
    feedbackHeightMedium: "24px",
    feedbackHeightLarge: "26px",
    feedbackFontSizeSmall: "13px",
    feedbackFontSizeMedium: "14px",
    feedbackFontSizeLarge: "14px",
    labelFontSizeLeftSmall: "14px",
    labelFontSizeLeftMedium: "14px",
    labelFontSizeLeftLarge: "15px",
    labelFontSizeTopSmall: "13px",
    labelFontSizeTopMedium: "14px",
    labelFontSizeTopLarge: "14px",
    labelHeightSmall: "24px",
    labelHeightMedium: "26px",
    labelHeightLarge: "28px",
    labelPaddingVertical: "0 0 6px 2px",
    labelPaddingHorizontal: "0 12px 0 0",
    labelTextAlignVertical: "left",
    labelTextAlignHorizontal: "right",
    labelFontWeight: "400"
  };
  function self$C(vars) {
    const {
      heightSmall,
      heightMedium,
      heightLarge,
      textColor1,
      errorColor,
      warningColor,
      lineHeight: lineHeight2,
      textColor3
    } = vars;
    return Object.assign(Object.assign({}, commonVariables$5), {
      blankHeightSmall: heightSmall,
      blankHeightMedium: heightMedium,
      blankHeightLarge: heightLarge,
      lineHeight: lineHeight2,
      labelTextColor: textColor1,
      asteriskColor: errorColor,
      feedbackTextColorError: errorColor,
      feedbackTextColorWarning: warningColor,
      feedbackTextColor: textColor3
    });
  }
  const formLight = {
    name: "Form",
    common: commonLight,
    self: self$C
  };
  const formLight$1 = formLight;
  const style$N = cB("form", [cM("inline", `
 width: 100%;
 display: inline-flex;
 align-items: flex-start;
 align-content: space-around;
 `, [cB("form-item", {
    width: "auto",
    marginRight: "18px"
  }, [c$1("&:last-child", {
    marginRight: 0
  })])])]);
  const formInjectionKey = createInjectionKey("n-form");
  const formItemInstsInjectionKey = createInjectionKey("n-form-item-insts");
  var __awaiter$7 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  const formProps = Object.assign(Object.assign({}, useTheme.props), {
    inline: Boolean,
    labelWidth: [Number, String],
    labelAlign: String,
    labelPlacement: {
      type: String,
      default: "top"
    },
    model: {
      type: Object,
      default: () => {
      }
    },
    rules: Object,
    disabled: Boolean,
    size: String,
    showRequireMark: {
      type: Boolean,
      default: void 0
    },
    requireMarkPlacement: String,
    showFeedback: {
      type: Boolean,
      default: true
    },
    onSubmit: {
      type: Function,
      default: (e) => {
        e.preventDefault();
      }
    },
    showLabel: {
      type: Boolean,
      default: void 0
    },
    validateMessages: Object
  });
  const Form = vue.defineComponent({
    name: "Form",
    props: formProps,
    setup(props) {
      const {
        mergedClsPrefixRef
      } = useConfig(props);
      useTheme("Form", "-form", style$N, formLight$1, props, mergedClsPrefixRef);
      const formItems = {};
      const maxChildLabelWidthRef = vue.ref(void 0);
      const deriveMaxChildLabelWidth = (currentWidth) => {
        const currentMaxChildLabelWidth = maxChildLabelWidthRef.value;
        if (currentMaxChildLabelWidth === void 0 || currentWidth >= currentMaxChildLabelWidth) {
          maxChildLabelWidthRef.value = currentWidth;
        }
      };
      function validate(validateCallback_1) {
        return __awaiter$7(this, arguments, void 0, function* (validateCallback, shouldRuleBeApplied = () => true) {
          return yield new Promise((resolve, reject) => {
            const formItemValidationPromises = [];
            for (const key of keysOf(formItems)) {
              const formItemInstances = formItems[key];
              for (const formItemInstance of formItemInstances) {
                if (formItemInstance.path) {
                  formItemValidationPromises.push(formItemInstance.internalValidate(null, shouldRuleBeApplied));
                }
              }
            }
            void Promise.all(formItemValidationPromises).then((results) => {
              const formInvalid = results.some((result) => !result.valid);
              const errors = [];
              const warnings = [];
              results.forEach((result) => {
                var _a, _b;
                if ((_a = result.errors) === null || _a === void 0 ? void 0 : _a.length) {
                  errors.push(result.errors);
                }
                if ((_b = result.warnings) === null || _b === void 0 ? void 0 : _b.length) {
                  warnings.push(result.warnings);
                }
              });
              if (validateCallback) {
                validateCallback(errors.length ? errors : void 0, {
                  warnings: warnings.length ? warnings : void 0
                });
              }
              if (formInvalid) {
                reject(errors.length ? errors : void 0);
              } else {
                resolve({
                  warnings: warnings.length ? warnings : void 0
                });
              }
            });
          });
        });
      }
      function restoreValidation() {
        for (const key of keysOf(formItems)) {
          const formItemInstances = formItems[key];
          for (const formItemInstance of formItemInstances) {
            formItemInstance.restoreValidation();
          }
        }
      }
      vue.provide(formInjectionKey, {
        props,
        maxChildLabelWidthRef,
        deriveMaxChildLabelWidth
      });
      vue.provide(formItemInstsInjectionKey, {
        formItems
      });
      const formExposedMethod = {
        validate,
        restoreValidation
      };
      return Object.assign(formExposedMethod, {
        mergedClsPrefix: mergedClsPrefixRef
      });
    },
    render() {
      const {
        mergedClsPrefix
      } = this;
      return vue.h("form", {
        class: [`${mergedClsPrefix}-form`, this.inline && `${mergedClsPrefix}-form--inline`],
        onSubmit: this.onSubmit
      }, this.$slots);
    }
  });
  var define_process_env_default = {};
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf(o);
  }
  function _setPrototypeOf(o, p2) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p22) {
      o2.__proto__ = p22;
      return o2;
    };
    return _setPrototypeOf(o, p2);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      _construct = function _construct2(Parent2, args2, Class2) {
        var a2 = [null];
        a2.push.apply(a2, args2);
        var Constructor = Function.bind.apply(Parent2, a2);
        var instance = new Constructor();
        if (Class2)
          _setPrototypeOf(instance, Class2.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
    _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
      if (Class2 === null || !_isNativeFunction(Class2))
        return Class2;
      if (typeof Class2 !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class2))
          return _cache.get(Class2);
        _cache.set(Class2, Wrapper2);
      }
      function Wrapper2() {
        return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
      }
      Wrapper2.prototype = Object.create(Class2.prototype, {
        constructor: {
          value: Wrapper2,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper2, Class2);
    };
    return _wrapNativeSuper(Class);
  }
  var formatRegExp = /%[sdj%]/g;
  var warning = function warning2() {
  };
  if (typeof process !== "undefined" && define_process_env_default && true && typeof window !== "undefined" && typeof document !== "undefined") {
    warning = function warning3(type4, errors) {
      if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
        if (errors.every(function(e) {
          return typeof e === "string";
        })) {
          console.warn(type4, errors);
        }
      }
    };
  }
  function convertFieldsError(errors) {
    if (!errors || !errors.length)
      return null;
    var fields = {};
    errors.forEach(function(error2) {
      var field = error2.field;
      fields[field] = fields[field] || [];
      fields[field].push(error2);
    });
    return fields;
  }
  function format$1(template) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    var i = 0;
    var len2 = args.length;
    if (typeof template === "function") {
      return template.apply(null, args);
    }
    if (typeof template === "string") {
      var str = template.replace(formatRegExp, function(x) {
        if (x === "%%") {
          return "%";
        }
        if (i >= len2) {
          return x;
        }
        switch (x) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return "[Circular]";
            }
            break;
          default:
            return x;
        }
      });
      return str;
    }
    return template;
  }
  function isNativeStringType(type4) {
    return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
  }
  function isEmptyValue(value, type4) {
    if (value === void 0 || value === null) {
      return true;
    }
    if (type4 === "array" && Array.isArray(value) && !value.length) {
      return true;
    }
    if (isNativeStringType(type4) && typeof value === "string" && !value) {
      return true;
    }
    return false;
  }
  function asyncParallelArray(arr, func, callback) {
    var results = [];
    var total = 0;
    var arrLength = arr.length;
    function count(errors) {
      results.push.apply(results, errors || []);
      total++;
      if (total === arrLength) {
        callback(results);
      }
    }
    arr.forEach(function(a2) {
      func(a2, count);
    });
  }
  function asyncSerialArray(arr, func, callback) {
    var index = 0;
    var arrLength = arr.length;
    function next(errors) {
      if (errors && errors.length) {
        callback(errors);
        return;
      }
      var original = index;
      index = index + 1;
      if (original < arrLength) {
        func(arr[original], next);
      } else {
        callback([]);
      }
    }
    next([]);
  }
  function flattenObjArr(objArr) {
    var ret = [];
    Object.keys(objArr).forEach(function(k) {
      ret.push.apply(ret, objArr[k] || []);
    });
    return ret;
  }
  var AsyncValidationError = /* @__PURE__ */ function(_Error) {
    _inheritsLoose(AsyncValidationError2, _Error);
    function AsyncValidationError2(errors, fields) {
      var _this;
      _this = _Error.call(this, "Async Validation Error") || this;
      _this.errors = errors;
      _this.fields = fields;
      return _this;
    }
    return AsyncValidationError2;
  }(/* @__PURE__ */ _wrapNativeSuper(Error));
  function asyncMap(objArr, option, func, callback, source) {
    if (option.first) {
      var _pending = new Promise(function(resolve, reject) {
        var next = function next2(errors) {
          callback(errors);
          return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
        };
        var flattenArr = flattenObjArr(objArr);
        asyncSerialArray(flattenArr, func, next);
      });
      _pending["catch"](function(e) {
        return e;
      });
      return _pending;
    }
    var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
    var objArrKeys = Object.keys(objArr);
    var objArrLength = objArrKeys.length;
    var total = 0;
    var results = [];
    var pending = new Promise(function(resolve, reject) {
      var next = function next2(errors) {
        results.push.apply(results, errors);
        total++;
        if (total === objArrLength) {
          callback(results);
          return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
        }
      };
      if (!objArrKeys.length) {
        callback(results);
        resolve(source);
      }
      objArrKeys.forEach(function(key) {
        var arr = objArr[key];
        if (firstFields.indexOf(key) !== -1) {
          asyncSerialArray(arr, func, next);
        } else {
          asyncParallelArray(arr, func, next);
        }
      });
    });
    pending["catch"](function(e) {
      return e;
    });
    return pending;
  }
  function isErrorObj(obj) {
    return !!(obj && obj.message !== void 0);
  }
  function getValue(value, path) {
    var v = value;
    for (var i = 0; i < path.length; i++) {
      if (v == void 0) {
        return v;
      }
      v = v[path[i]];
    }
    return v;
  }
  function complementError(rule, source) {
    return function(oe) {
      var fieldValue;
      if (rule.fullFields) {
        fieldValue = getValue(source, rule.fullFields);
      } else {
        fieldValue = source[oe.field || rule.fullField];
      }
      if (isErrorObj(oe)) {
        oe.field = oe.field || rule.fullField;
        oe.fieldValue = fieldValue;
        return oe;
      }
      return {
        message: typeof oe === "function" ? oe() : oe,
        fieldValue,
        field: oe.field || rule.fullField
      };
    };
  }
  function deepMerge(target, source) {
    if (source) {
      for (var s in source) {
        if (source.hasOwnProperty(s)) {
          var value = source[s];
          if (typeof value === "object" && typeof target[s] === "object") {
            target[s] = _extends({}, target[s], value);
          } else {
            target[s] = value;
          }
        }
      }
    }
    return target;
  }
  var required$1 = function required(rule, value, source, errors, options, type4) {
    if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
      errors.push(format$1(options.messages.required, rule.fullField));
    }
  };
  var whitespace = function whitespace2(rule, value, source, errors, options) {
    if (/^\s+$/.test(value) || value === "") {
      errors.push(format$1(options.messages.whitespace, rule.fullField));
    }
  };
  var urlReg;
  var getUrlRegex = function() {
    if (urlReg) {
      return urlReg;
    }
    var word = "[a-fA-F\\d:]";
    var b = function b2(options) {
      return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
    };
    var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
    var v6seg = "[a-fA-F\\d]{1,4}";
    var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
    var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
    var v4exact = new RegExp("^" + v4 + "$");
    var v6exact = new RegExp("^" + v6 + "$");
    var ip = function ip2(options) {
      return options && options.exact ? v46Exact : new RegExp("(?:" + b(options) + v4 + b(options) + ")|(?:" + b(options) + v6 + b(options) + ")", "g");
    };
    ip.v4 = function(options) {
      return options && options.exact ? v4exact : new RegExp("" + b(options) + v4 + b(options), "g");
    };
    ip.v6 = function(options) {
      return options && options.exact ? v6exact : new RegExp("" + b(options) + v6 + b(options), "g");
    };
    var protocol = "(?:(?:[a-z]+:)?//)";
    var auth = "(?:\\S+(?::\\S*)?@)?";
    var ipv4 = ip.v4().source;
    var ipv6 = ip.v6().source;
    var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
    var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
    var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
    var port = "(?::\\d{2,5})?";
    var path = '(?:[/?#][^\\s"]*)?';
    var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
    urlReg = new RegExp("(?:^" + regex + "$)", "i");
    return urlReg;
  };
  var pattern$2 = {
    // http://emailregex.com/
    email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
    // url: new RegExp(
    //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
    //   'i',
    // ),
    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
  };
  var types = {
    integer: function integer(value) {
      return types.number(value) && parseInt(value, 10) === value;
    },
    "float": function float2(value) {
      return types.number(value) && !types.integer(value);
    },
    array: function array(value) {
      return Array.isArray(value);
    },
    regexp: function regexp(value) {
      if (value instanceof RegExp) {
        return true;
      }
      try {
        return !!new RegExp(value);
      } catch (e) {
        return false;
      }
    },
    date: function date(value) {
      return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
    },
    number: function number(value) {
      if (isNaN(value)) {
        return false;
      }
      return typeof value === "number";
    },
    object: function object(value) {
      return typeof value === "object" && !types.array(value);
    },
    method: function method(value) {
      return typeof value === "function";
    },
    email: function email(value) {
      return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
    },
    url: function url(value) {
      return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
    },
    hex: function hex2(value) {
      return typeof value === "string" && !!value.match(pattern$2.hex);
    }
  };
  var type$1 = function type(rule, value, source, errors, options) {
    if (rule.required && value === void 0) {
      required$1(rule, value, source, errors, options);
      return;
    }
    var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
    var ruleType = rule.type;
    if (custom.indexOf(ruleType) > -1) {
      if (!types[ruleType](value)) {
        errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
      }
    } else if (ruleType && typeof value !== rule.type) {
      errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
    }
  };
  var range = function range2(rule, value, source, errors, options) {
    var len2 = typeof rule.len === "number";
    var min = typeof rule.min === "number";
    var max = typeof rule.max === "number";
    var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var val = value;
    var key = null;
    var num = typeof value === "number";
    var str = typeof value === "string";
    var arr = Array.isArray(value);
    if (num) {
      key = "number";
    } else if (str) {
      key = "string";
    } else if (arr) {
      key = "array";
    }
    if (!key) {
      return false;
    }
    if (arr) {
      val = value.length;
    }
    if (str) {
      val = value.replace(spRegexp, "_").length;
    }
    if (len2) {
      if (val !== rule.len) {
        errors.push(format$1(options.messages[key].len, rule.fullField, rule.len));
      }
    } else if (min && !max && val < rule.min) {
      errors.push(format$1(options.messages[key].min, rule.fullField, rule.min));
    } else if (max && !min && val > rule.max) {
      errors.push(format$1(options.messages[key].max, rule.fullField, rule.max));
    } else if (min && max && (val < rule.min || val > rule.max)) {
      errors.push(format$1(options.messages[key].range, rule.fullField, rule.min, rule.max));
    }
  };
  var ENUM$1 = "enum";
  var enumerable$1 = function enumerable(rule, value, source, errors, options) {
    rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
    if (rule[ENUM$1].indexOf(value) === -1) {
      errors.push(format$1(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
    }
  };
  var pattern$1 = function pattern(rule, value, source, errors, options) {
    if (rule.pattern) {
      if (rule.pattern instanceof RegExp) {
        rule.pattern.lastIndex = 0;
        if (!rule.pattern.test(value)) {
          errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        }
      } else if (typeof rule.pattern === "string") {
        var _pattern = new RegExp(rule.pattern);
        if (!_pattern.test(value)) {
          errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        }
      }
    }
  };
  var rules = {
    required: required$1,
    whitespace,
    type: type$1,
    range,
    "enum": enumerable$1,
    pattern: pattern$1
  };
  var string = function string2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, "string") && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, "string");
      if (!isEmptyValue(value, "string")) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
        rules.pattern(rule, value, source, errors, options);
        if (rule.whitespace === true) {
          rules.whitespace(rule, value, source, errors, options);
        }
      }
    }
    callback(errors);
  };
  var method2 = function method3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var number2 = function number3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (value === "") {
        value = void 0;
      }
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var _boolean = function _boolean2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var regexp2 = function regexp3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value)) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var integer2 = function integer3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var floatFn = function floatFn2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var array2 = function array3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if ((value === void 0 || value === null) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, "array");
      if (value !== void 0 && value !== null) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var object2 = function object3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var ENUM = "enum";
  var enumerable2 = function enumerable3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules[ENUM](rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var pattern2 = function pattern3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, "string") && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value, "string")) {
        rules.pattern(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var date2 = function date3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, "date") && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value, "date")) {
        var dateObject;
        if (value instanceof Date) {
          dateObject = value;
        } else {
          dateObject = new Date(value);
        }
        rules.type(rule, dateObject, source, errors, options);
        if (dateObject) {
          rules.range(rule, dateObject.getTime(), source, errors, options);
        }
      }
    }
    callback(errors);
  };
  var required2 = function required3(rule, value, callback, source, options) {
    var errors = [];
    var type4 = Array.isArray(value) ? "array" : typeof value;
    rules.required(rule, value, source, errors, options, type4);
    callback(errors);
  };
  var type2 = function type3(rule, value, callback, source, options) {
    var ruleType = rule.type;
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, ruleType) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, ruleType);
      if (!isEmptyValue(value, ruleType)) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var any = function any2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
    }
    callback(errors);
  };
  var validators = {
    string,
    method: method2,
    number: number2,
    "boolean": _boolean,
    regexp: regexp2,
    integer: integer2,
    "float": floatFn,
    array: array2,
    object: object2,
    "enum": enumerable2,
    pattern: pattern2,
    date: date2,
    url: type2,
    hex: type2,
    email: type2,
    required: required2,
    any
  };
  function newMessages() {
    return {
      "default": "Validation error on field %s",
      required: "%s is required",
      "enum": "%s must be one of %s",
      whitespace: "%s cannot be empty",
      date: {
        format: "%s date %s is invalid for format %s",
        parse: "%s date could not be parsed, %s is invalid ",
        invalid: "%s date %s is invalid"
      },
      types: {
        string: "%s is not a %s",
        method: "%s is not a %s (function)",
        array: "%s is not an %s",
        object: "%s is not an %s",
        number: "%s is not a %s",
        date: "%s is not a %s",
        "boolean": "%s is not a %s",
        integer: "%s is not an %s",
        "float": "%s is not a %s",
        regexp: "%s is not a valid %s",
        email: "%s is not a valid %s",
        url: "%s is not a valid %s",
        hex: "%s is not a valid %s"
      },
      string: {
        len: "%s must be exactly %s characters",
        min: "%s must be at least %s characters",
        max: "%s cannot be longer than %s characters",
        range: "%s must be between %s and %s characters"
      },
      number: {
        len: "%s must equal %s",
        min: "%s cannot be less than %s",
        max: "%s cannot be greater than %s",
        range: "%s must be between %s and %s"
      },
      array: {
        len: "%s must be exactly %s in length",
        min: "%s cannot be less than %s in length",
        max: "%s cannot be greater than %s in length",
        range: "%s must be between %s and %s in length"
      },
      pattern: {
        mismatch: "%s value %s does not match pattern %s"
      },
      clone: function clone() {
        var cloned = JSON.parse(JSON.stringify(this));
        cloned.clone = this.clone;
        return cloned;
      }
    };
  }
  var messages = newMessages();
  var Schema = /* @__PURE__ */ function() {
    function Schema2(descriptor) {
      this.rules = null;
      this._messages = messages;
      this.define(descriptor);
    }
    var _proto = Schema2.prototype;
    _proto.define = function define(rules2) {
      var _this = this;
      if (!rules2) {
        throw new Error("Cannot configure a schema with no rules");
      }
      if (typeof rules2 !== "object" || Array.isArray(rules2)) {
        throw new Error("Rules must be an object");
      }
      this.rules = {};
      Object.keys(rules2).forEach(function(name) {
        var item = rules2[name];
        _this.rules[name] = Array.isArray(item) ? item : [item];
      });
    };
    _proto.messages = function messages2(_messages) {
      if (_messages) {
        this._messages = deepMerge(newMessages(), _messages);
      }
      return this._messages;
    };
    _proto.validate = function validate(source_, o, oc) {
      var _this2 = this;
      if (o === void 0) {
        o = {};
      }
      if (oc === void 0) {
        oc = function oc2() {
        };
      }
      var source = source_;
      var options = o;
      var callback = oc;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (!this.rules || Object.keys(this.rules).length === 0) {
        if (callback) {
          callback(null, source);
        }
        return Promise.resolve(source);
      }
      function complete(results) {
        var errors = [];
        var fields = {};
        function add(e) {
          if (Array.isArray(e)) {
            var _errors;
            errors = (_errors = errors).concat.apply(_errors, e);
          } else {
            errors.push(e);
          }
        }
        for (var i = 0; i < results.length; i++) {
          add(results[i]);
        }
        if (!errors.length) {
          callback(null, source);
        } else {
          fields = convertFieldsError(errors);
          callback(errors, fields);
        }
      }
      if (options.messages) {
        var messages$1 = this.messages();
        if (messages$1 === messages) {
          messages$1 = newMessages();
        }
        deepMerge(messages$1, options.messages);
        options.messages = messages$1;
      } else {
        options.messages = this.messages();
      }
      var series = {};
      var keys2 = options.keys || Object.keys(this.rules);
      keys2.forEach(function(z) {
        var arr = _this2.rules[z];
        var value = source[z];
        arr.forEach(function(r) {
          var rule = r;
          if (typeof rule.transform === "function") {
            if (source === source_) {
              source = _extends({}, source);
            }
            value = source[z] = rule.transform(value);
          }
          if (typeof rule === "function") {
            rule = {
              validator: rule
            };
          } else {
            rule = _extends({}, rule);
          }
          rule.validator = _this2.getValidationMethod(rule);
          if (!rule.validator) {
            return;
          }
          rule.field = z;
          rule.fullField = rule.fullField || z;
          rule.type = _this2.getType(rule);
          series[z] = series[z] || [];
          series[z].push({
            rule,
            value,
            source,
            field: z
          });
        });
      });
      var errorFields = {};
      return asyncMap(series, options, function(data, doIt) {
        var rule = data.rule;
        var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
        deep = deep && (rule.required || !rule.required && data.value);
        rule.field = data.field;
        function addFullField(key, schema) {
          return _extends({}, schema, {
            fullField: rule.fullField + "." + key,
            fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
          });
        }
        function cb(e) {
          if (e === void 0) {
            e = [];
          }
          var errorList = Array.isArray(e) ? e : [e];
          if (!options.suppressWarning && errorList.length) {
            Schema2.warning("async-validator:", errorList);
          }
          if (errorList.length && rule.message !== void 0) {
            errorList = [].concat(rule.message);
          }
          var filledErrors = errorList.map(complementError(rule, source));
          if (options.first && filledErrors.length) {
            errorFields[rule.field] = 1;
            return doIt(filledErrors);
          }
          if (!deep) {
            doIt(filledErrors);
          } else {
            if (rule.required && !data.value) {
              if (rule.message !== void 0) {
                filledErrors = [].concat(rule.message).map(complementError(rule, source));
              } else if (options.error) {
                filledErrors = [options.error(rule, format$1(options.messages.required, rule.field))];
              }
              return doIt(filledErrors);
            }
            var fieldsSchema = {};
            if (rule.defaultField) {
              Object.keys(data.value).map(function(key) {
                fieldsSchema[key] = rule.defaultField;
              });
            }
            fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
            var paredFieldsSchema = {};
            Object.keys(fieldsSchema).forEach(function(field) {
              var fieldSchema = fieldsSchema[field];
              var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
              paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
            });
            var schema = new Schema2(paredFieldsSchema);
            schema.messages(options.messages);
            if (data.rule.options) {
              data.rule.options.messages = options.messages;
              data.rule.options.error = options.error;
            }
            schema.validate(data.value, data.rule.options || options, function(errs) {
              var finalErrors = [];
              if (filledErrors && filledErrors.length) {
                finalErrors.push.apply(finalErrors, filledErrors);
              }
              if (errs && errs.length) {
                finalErrors.push.apply(finalErrors, errs);
              }
              doIt(finalErrors.length ? finalErrors : null);
            });
          }
        }
        var res;
        if (rule.asyncValidator) {
          res = rule.asyncValidator(rule, data.value, cb, data.source, options);
        } else if (rule.validator) {
          try {
            res = rule.validator(rule, data.value, cb, data.source, options);
          } catch (error2) {
            console.error == null ? void 0 : console.error(error2);
            if (!options.suppressValidatorError) {
              setTimeout(function() {
                throw error2;
              }, 0);
            }
            cb(error2.message);
          }
          if (res === true) {
            cb();
          } else if (res === false) {
            cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
          } else if (res instanceof Array) {
            cb(res);
          } else if (res instanceof Error) {
            cb(res.message);
          }
        }
        if (res && res.then) {
          res.then(function() {
            return cb();
          }, function(e) {
            return cb(e);
          });
        }
      }, function(results) {
        complete(results);
      }, source);
    };
    _proto.getType = function getType(rule) {
      if (rule.type === void 0 && rule.pattern instanceof RegExp) {
        rule.type = "pattern";
      }
      if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
        throw new Error(format$1("Unknown rule type %s", rule.type));
      }
      return rule.type || "string";
    };
    _proto.getValidationMethod = function getValidationMethod(rule) {
      if (typeof rule.validator === "function") {
        return rule.validator;
      }
      var keys2 = Object.keys(rule);
      var messageIndex = keys2.indexOf("message");
      if (messageIndex !== -1) {
        keys2.splice(messageIndex, 1);
      }
      if (keys2.length === 1 && keys2[0] === "required") {
        return validators.required;
      }
      return validators[this.getType(rule)] || void 0;
    };
    return Schema2;
  }();
  Schema.register = function register(type4, validator2) {
    if (typeof validator2 !== "function") {
      throw new Error("Cannot register a validator by type, validator is not a function");
    }
    validators[type4] = validator2;
  };
  Schema.warning = warning;
  Schema.messages = messages;
  Schema.validators = validators;
  function formItemSize(props) {
    const NForm = vue.inject(formInjectionKey, null);
    return {
      mergedSize: vue.computed(() => {
        if (props.size !== void 0)
          return props.size;
        if ((NForm === null || NForm === void 0 ? void 0 : NForm.props.size) !== void 0)
          return NForm.props.size;
        return "medium";
      })
    };
  }
  function formItemMisc(props) {
    const NForm = vue.inject(formInjectionKey, null);
    const mergedLabelPlacementRef = vue.computed(() => {
      const {
        labelPlacement
      } = props;
      if (labelPlacement !== void 0)
        return labelPlacement;
      if (NForm === null || NForm === void 0 ? void 0 : NForm.props.labelPlacement)
        return NForm.props.labelPlacement;
      return "top";
    });
    const isAutoLabelWidthRef = vue.computed(() => {
      return mergedLabelPlacementRef.value === "left" && (props.labelWidth === "auto" || (NForm === null || NForm === void 0 ? void 0 : NForm.props.labelWidth) === "auto");
    });
    const mergedLabelWidthRef = vue.computed(() => {
      if (mergedLabelPlacementRef.value === "top")
        return;
      const {
        labelWidth
      } = props;
      if (labelWidth !== void 0 && labelWidth !== "auto") {
        return formatLength(labelWidth);
      }
      if (isAutoLabelWidthRef.value) {
        const autoComputedWidth = NForm === null || NForm === void 0 ? void 0 : NForm.maxChildLabelWidthRef.value;
        if (autoComputedWidth !== void 0) {
          return formatLength(autoComputedWidth);
        } else {
          return void 0;
        }
      }
      if ((NForm === null || NForm === void 0 ? void 0 : NForm.props.labelWidth) !== void 0) {
        return formatLength(NForm.props.labelWidth);
      }
      return void 0;
    });
    const mergedLabelAlignRef = vue.computed(() => {
      const {
        labelAlign
      } = props;
      if (labelAlign)
        return labelAlign;
      if (NForm === null || NForm === void 0 ? void 0 : NForm.props.labelAlign)
        return NForm.props.labelAlign;
      return void 0;
    });
    const mergedLabelStyleRef = vue.computed(() => {
      var _a;
      return [(_a = props.labelProps) === null || _a === void 0 ? void 0 : _a.style, props.labelStyle, {
        width: mergedLabelWidthRef.value
      }];
    });
    const mergedShowRequireMarkRef = vue.computed(() => {
      const {
        showRequireMark
      } = props;
      if (showRequireMark !== void 0)
        return showRequireMark;
      return NForm === null || NForm === void 0 ? void 0 : NForm.props.showRequireMark;
    });
    const mergedRequireMarkPlacementRef = vue.computed(() => {
      const {
        requireMarkPlacement
      } = props;
      if (requireMarkPlacement !== void 0)
        return requireMarkPlacement;
      return (NForm === null || NForm === void 0 ? void 0 : NForm.props.requireMarkPlacement) || "right";
    });
    const validationErroredRef = vue.ref(false);
    const validationWarnedRef = vue.ref(false);
    const mergedValidationStatusRef = vue.computed(() => {
      const {
        validationStatus
      } = props;
      if (validationStatus !== void 0)
        return validationStatus;
      if (validationErroredRef.value)
        return "error";
      if (validationWarnedRef.value)
        return "warning";
      return void 0;
    });
    const mergedShowFeedbackRef = vue.computed(() => {
      const {
        showFeedback
      } = props;
      if (showFeedback !== void 0)
        return showFeedback;
      if ((NForm === null || NForm === void 0 ? void 0 : NForm.props.showFeedback) !== void 0)
        return NForm.props.showFeedback;
      return true;
    });
    const mergedShowLabelRef = vue.computed(() => {
      const {
        showLabel
      } = props;
      if (showLabel !== void 0)
        return showLabel;
      if ((NForm === null || NForm === void 0 ? void 0 : NForm.props.showLabel) !== void 0)
        return NForm.props.showLabel;
      return true;
    });
    return {
      validationErrored: validationErroredRef,
      validationWarned: validationWarnedRef,
      mergedLabelStyle: mergedLabelStyleRef,
      mergedLabelPlacement: mergedLabelPlacementRef,
      mergedLabelAlign: mergedLabelAlignRef,
      mergedShowRequireMark: mergedShowRequireMarkRef,
      mergedRequireMarkPlacement: mergedRequireMarkPlacementRef,
      mergedValidationStatus: mergedValidationStatusRef,
      mergedShowFeedback: mergedShowFeedbackRef,
      mergedShowLabel: mergedShowLabelRef,
      isAutoLabelWidth: isAutoLabelWidthRef
    };
  }
  function formItemRule(props) {
    const NForm = vue.inject(formInjectionKey, null);
    const compatibleRulePathRef = vue.computed(() => {
      const {
        rulePath
      } = props;
      if (rulePath !== void 0)
        return rulePath;
      const {
        path
      } = props;
      if (path !== void 0)
        return path;
      return void 0;
    });
    const mergedRulesRef = vue.computed(() => {
      const rules2 = [];
      const {
        rule
      } = props;
      if (rule !== void 0) {
        if (Array.isArray(rule))
          rules2.push(...rule);
        else
          rules2.push(rule);
      }
      if (NForm) {
        const {
          rules: formRules
        } = NForm.props;
        const {
          value: rulePath
        } = compatibleRulePathRef;
        if (formRules !== void 0 && rulePath !== void 0) {
          const formRule = get(formRules, rulePath);
          if (formRule !== void 0) {
            if (Array.isArray(formRule)) {
              rules2.push(...formRule);
            } else {
              rules2.push(formRule);
            }
          }
        }
      }
      return rules2;
    });
    const hasRequiredRuleRef = vue.computed(() => {
      return mergedRulesRef.value.some((rule) => rule.required);
    });
    const mergedRequiredRef = vue.computed(() => {
      return hasRequiredRuleRef.value || props.required;
    });
    return {
      mergedRules: mergedRulesRef,
      mergedRequired: mergedRequiredRef
    };
  }
  const {
    cubicBezierEaseInOut
  } = commonVariables$m;
  function fadeDownTransition({
    name = "fade-down",
    fromOffset = "-4px",
    enterDuration = ".3s",
    leaveDuration = ".3s",
    enterCubicBezier = cubicBezierEaseInOut,
    leaveCubicBezier = cubicBezierEaseInOut
  } = {}) {
    return [c$1(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
      opacity: 0,
      transform: `translateY(${fromOffset})`
    }), c$1(`&.${name}-transition-enter-to, &.${name}-transition-leave-from`, {
      opacity: 1,
      transform: "translateY(0)"
    }), c$1(`&.${name}-transition-leave-active`, {
      transition: `opacity ${leaveDuration} ${leaveCubicBezier}, transform ${leaveDuration} ${leaveCubicBezier}`
    }), c$1(`&.${name}-transition-enter-active`, {
      transition: `opacity ${enterDuration} ${enterCubicBezier}, transform ${enterDuration} ${enterCubicBezier}`
    })];
  }
  const style$M = cB("form-item", `
 display: grid;
 line-height: var(--n-line-height);
`, [cB("form-item-label", `
 grid-area: label;
 align-items: center;
 line-height: 1.25;
 text-align: var(--n-label-text-align);
 font-size: var(--n-label-font-size);
 min-height: var(--n-label-height);
 padding: var(--n-label-padding);
 color: var(--n-label-text-color);
 transition: color .3s var(--n-bezier);
 box-sizing: border-box;
 font-weight: var(--n-label-font-weight);
 `, [cE("asterisk", `
 white-space: nowrap;
 user-select: none;
 -webkit-user-select: none;
 color: var(--n-asterisk-color);
 transition: color .3s var(--n-bezier);
 `), cE("asterisk-placeholder", `
 grid-area: mark;
 user-select: none;
 -webkit-user-select: none;
 visibility: hidden; 
 `)]), cB("form-item-blank", `
 grid-area: blank;
 min-height: var(--n-blank-height);
 `), cM("auto-label-width", [cB("form-item-label", "white-space: nowrap;")]), cM("left-labelled", `
 grid-template-areas:
 "label blank"
 "label feedback";
 grid-template-columns: auto minmax(0, 1fr);
 grid-template-rows: auto 1fr;
 align-items: flex-start;
 `, [cB("form-item-label", `
 display: grid;
 grid-template-columns: 1fr auto;
 min-height: var(--n-blank-height);
 height: auto;
 box-sizing: border-box;
 flex-shrink: 0;
 flex-grow: 0;
 `, [cM("reverse-columns-space", `
 grid-template-columns: auto 1fr;
 `), cM("left-mark", `
 grid-template-areas:
 "mark text"
 ". text";
 `), cM("right-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), cM("right-hanging-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), cE("text", `
 grid-area: text; 
 `), cE("asterisk", `
 grid-area: mark; 
 align-self: end;
 `)])]), cM("top-labelled", `
 grid-template-areas:
 "label"
 "blank"
 "feedback";
 grid-template-rows: minmax(var(--n-label-height), auto) 1fr;
 grid-template-columns: minmax(0, 100%);
 `, [cM("no-label", `
 grid-template-areas:
 "blank"
 "feedback";
 grid-template-rows: 1fr;
 `), cB("form-item-label", `
 display: flex;
 align-items: flex-start;
 justify-content: var(--n-label-text-align);
 `)]), cB("form-item-blank", `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 position: relative;
 `), cB("form-item-feedback-wrapper", `
 grid-area: feedback;
 box-sizing: border-box;
 min-height: var(--n-feedback-height);
 font-size: var(--n-feedback-font-size);
 line-height: 1.25;
 transform-origin: top left;
 `, [c$1("&:not(:empty)", `
 padding: var(--n-feedback-padding);
 `), cB("form-item-feedback", {
    transition: "color .3s var(--n-bezier)",
    color: "var(--n-feedback-text-color)"
  }, [cM("warning", {
    color: "var(--n-feedback-text-color-warning)"
  }), cM("error", {
    color: "var(--n-feedback-text-color-error)"
  }), fadeDownTransition({
    fromOffset: "-3px",
    enterDuration: ".3s",
    leaveDuration: ".2s"
  })])])]);
  var __awaiter$6 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  const formItemProps = Object.assign(Object.assign({}, useTheme.props), {
    label: String,
    labelWidth: [Number, String],
    labelStyle: [String, Object],
    labelAlign: String,
    labelPlacement: String,
    path: String,
    first: Boolean,
    rulePath: String,
    required: Boolean,
    showRequireMark: {
      type: Boolean,
      default: void 0
    },
    requireMarkPlacement: String,
    showFeedback: {
      type: Boolean,
      default: void 0
    },
    rule: [Object, Array],
    size: String,
    ignorePathChange: Boolean,
    validationStatus: String,
    feedback: String,
    feedbackClass: String,
    feedbackStyle: [String, Object],
    showLabel: {
      type: Boolean,
      default: void 0
    },
    labelProps: Object
  });
  const formItemPropKeys = keysOf(formItemProps);
  function wrapValidator(validator2, async) {
    return (...args) => {
      try {
        const validateResult = validator2(...args);
        if (!async && (typeof validateResult === "boolean" || validateResult instanceof Error || Array.isArray(validateResult)) || (validateResult === null || validateResult === void 0 ? void 0 : validateResult.then)) {
          return validateResult;
        } else if (validateResult === void 0) {
          return true;
        } else {
          warn$2("form-item/validate", `You return a ${typeof validateResult} typed value in the validator method, which is not recommended. Please use ${async ? "`Promise`" : "`boolean`, `Error` or `Promise`"} typed value instead.`);
          return true;
        }
      } catch (err) {
        warn$2("form-item/validate", "An error is catched in the validation, so the validation won't be done. Your callback in `validate` method of `n-form` or `n-form-item` won't be called in this validation.");
        console.error(err);
        return void 0;
      }
    };
  }
  const NFormItem = vue.defineComponent({
    name: "FormItem",
    props: formItemProps,
    setup(props) {
      useInjectionInstanceCollection(formItemInstsInjectionKey, "formItems", vue.toRef(props, "path"));
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const NForm = vue.inject(formInjectionKey, null);
      const formItemSizeRefs = formItemSize(props);
      const formItemMiscRefs = formItemMisc(props);
      const {
        validationErrored: validationErroredRef,
        validationWarned: validationWarnedRef
      } = formItemMiscRefs;
      const {
        mergedRequired: mergedRequiredRef,
        mergedRules: mergedRulesRef
      } = formItemRule(props);
      const {
        mergedSize: mergedSizeRef
      } = formItemSizeRefs;
      const {
        mergedLabelPlacement: labelPlacementRef,
        mergedLabelAlign: labelTextAlignRef,
        mergedRequireMarkPlacement: mergedRequireMarkPlacementRef
      } = formItemMiscRefs;
      const renderExplainsRef = vue.ref([]);
      const feedbackIdRef = vue.ref(createId());
      const mergedDisabledRef = NForm ? vue.toRef(NForm.props, "disabled") : vue.ref(false);
      const themeRef = useTheme("Form", "-form-item", style$M, formLight$1, props, mergedClsPrefixRef);
      vue.watch(vue.toRef(props, "path"), () => {
        if (props.ignorePathChange)
          return;
        restoreValidation();
      });
      function restoreValidation() {
        renderExplainsRef.value = [];
        validationErroredRef.value = false;
        validationWarnedRef.value = false;
        if (props.feedback) {
          feedbackIdRef.value = createId();
        }
      }
      const internalValidate = (...args_1) => __awaiter$6(this, [...args_1], void 0, function* (trigger2 = null, shouldRuleBeApplied = () => true, options = {
        suppressWarning: true
      }) {
        const {
          path
        } = props;
        if (!options) {
          options = {};
        } else {
          if (!options.first)
            options.first = props.first;
        }
        const {
          value: rules2
        } = mergedRulesRef;
        const value = NForm ? get(NForm.props.model, path || "") : void 0;
        const messageRenderers = {};
        const originalMessageRendersMessage = {};
        const activeRules = (!trigger2 ? rules2 : rules2.filter((rule) => {
          if (Array.isArray(rule.trigger)) {
            return rule.trigger.includes(trigger2);
          } else {
            return rule.trigger === trigger2;
          }
        })).filter(shouldRuleBeApplied).map((rule, i) => {
          const shallowClonedRule = Object.assign({}, rule);
          if (shallowClonedRule.validator) {
            shallowClonedRule.validator = wrapValidator(shallowClonedRule.validator, false);
          }
          if (shallowClonedRule.asyncValidator) {
            shallowClonedRule.asyncValidator = wrapValidator(shallowClonedRule.asyncValidator, true);
          }
          if (shallowClonedRule.renderMessage) {
            const rendererKey = `__renderMessage__${i}`;
            originalMessageRendersMessage[rendererKey] = shallowClonedRule.message;
            shallowClonedRule.message = rendererKey;
            messageRenderers[rendererKey] = shallowClonedRule.renderMessage;
          }
          return shallowClonedRule;
        });
        const activeErrorRules = activeRules.filter((r) => r.level !== "warning");
        const activeWarningRules = activeRules.filter((r) => r.level === "warning");
        const validationResult = {
          valid: true,
          errors: void 0,
          warnings: void 0
        };
        if (!activeRules.length)
          return validationResult;
        const mergedPath = path !== null && path !== void 0 ? path : "__n_no_path__";
        const validator2 = new Schema({
          [mergedPath]: activeErrorRules
        });
        const warningValidator = new Schema({
          [mergedPath]: activeWarningRules
        });
        const {
          validateMessages
        } = (NForm === null || NForm === void 0 ? void 0 : NForm.props) || {};
        if (validateMessages) {
          validator2.messages(validateMessages);
          warningValidator.messages(validateMessages);
        }
        const renderMessages = (errors) => {
          renderExplainsRef.value = errors.map((error2) => {
            const transformedMessage = (error2 === null || error2 === void 0 ? void 0 : error2.message) || "";
            return {
              key: transformedMessage,
              render: () => {
                if (transformedMessage.startsWith("__renderMessage__")) {
                  return messageRenderers[transformedMessage]();
                }
                return transformedMessage;
              }
            };
          });
          errors.forEach((error2) => {
            var _a;
            if ((_a = error2.message) === null || _a === void 0 ? void 0 : _a.startsWith("__renderMessage__")) {
              error2.message = originalMessageRendersMessage[error2.message];
            }
          });
        };
        if (activeErrorRules.length) {
          const errors = yield new Promise((resolve) => {
            void validator2.validate({
              [mergedPath]: value
            }, options, resolve);
          });
          if (errors === null || errors === void 0 ? void 0 : errors.length) {
            validationResult.valid = false;
            validationResult.errors = errors;
            renderMessages(errors);
          }
        }
        if (activeWarningRules.length && !validationResult.errors) {
          const warnings = yield new Promise((resolve) => {
            void warningValidator.validate({
              [mergedPath]: value
            }, options, resolve);
          });
          if (warnings === null || warnings === void 0 ? void 0 : warnings.length) {
            renderMessages(warnings);
            validationResult.warnings = warnings;
          }
        }
        if (!validationResult.errors && !validationResult.warnings) {
          restoreValidation();
        } else {
          validationErroredRef.value = !!validationResult.errors;
          validationWarnedRef.value = !!validationResult.warnings;
        }
        return validationResult;
      });
      function handleContentBlur() {
        void internalValidate("blur");
      }
      function handleContentChange() {
        void internalValidate("change");
      }
      function handleContentFocus() {
        void internalValidate("focus");
      }
      function handleContentInput() {
        void internalValidate("input");
      }
      function validate(options, callback) {
        return __awaiter$6(this, void 0, void 0, function* () {
          let trigger2;
          let validateCallback;
          let shouldRuleBeApplied;
          let asyncValidatorOptions;
          if (typeof options === "string") {
            trigger2 = options;
            validateCallback = callback;
          } else if (options !== null && typeof options === "object") {
            trigger2 = options.trigger;
            validateCallback = options.callback;
            shouldRuleBeApplied = options.shouldRuleBeApplied;
            asyncValidatorOptions = options.options;
          }
          return yield new Promise((resolve, reject) => {
            void internalValidate(trigger2, shouldRuleBeApplied, asyncValidatorOptions).then(({
              valid,
              errors,
              warnings
            }) => {
              if (valid) {
                if (validateCallback) {
                  validateCallback(void 0, {
                    warnings
                  });
                }
                resolve({
                  warnings
                });
              } else {
                if (validateCallback) {
                  validateCallback(errors, {
                    warnings
                  });
                }
                reject(errors);
              }
            });
          });
        });
      }
      vue.provide(formItemInjectionKey, {
        path: vue.toRef(props, "path"),
        disabled: mergedDisabledRef,
        mergedSize: formItemSizeRefs.mergedSize,
        mergedValidationStatus: formItemMiscRefs.mergedValidationStatus,
        restoreValidation,
        handleContentBlur,
        handleContentChange,
        handleContentFocus,
        handleContentInput
      });
      const exposedRef = {
        validate,
        restoreValidation,
        internalValidate
      };
      const labelElementRef = vue.ref(null);
      vue.onMounted(() => {
        if (!formItemMiscRefs.isAutoLabelWidth.value)
          return;
        const labelElement = labelElementRef.value;
        if (labelElement !== null) {
          const memoizedWhitespace = labelElement.style.whiteSpace;
          labelElement.style.whiteSpace = "nowrap";
          labelElement.style.width = "";
          NForm === null || NForm === void 0 ? void 0 : NForm.deriveMaxChildLabelWidth(Number(getComputedStyle(labelElement).width.slice(0, -2)));
          labelElement.style.whiteSpace = memoizedWhitespace;
        }
      });
      const cssVarsRef = vue.computed(() => {
        var _a;
        const {
          value: size2
        } = mergedSizeRef;
        const {
          value: labelPlacement
        } = labelPlacementRef;
        const direction = labelPlacement === "top" ? "vertical" : "horizontal";
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            labelTextColor,
            asteriskColor,
            lineHeight: lineHeight2,
            feedbackTextColor,
            feedbackTextColorWarning,
            feedbackTextColorError,
            feedbackPadding,
            labelFontWeight,
            [createKey("labelHeight", size2)]: labelHeight,
            [createKey("blankHeight", size2)]: blankHeight,
            [createKey("feedbackFontSize", size2)]: feedbackFontSize,
            [createKey("feedbackHeight", size2)]: feedbackHeight,
            [createKey("labelPadding", direction)]: labelPadding,
            [createKey("labelTextAlign", direction)]: labelTextAlign,
            [createKey(createKey("labelFontSize", labelPlacement), size2)]: labelFontSize
          }
        } = themeRef.value;
        let mergedLabelTextAlign = (_a = labelTextAlignRef.value) !== null && _a !== void 0 ? _a : labelTextAlign;
        if (labelPlacement === "top") {
          mergedLabelTextAlign = mergedLabelTextAlign === "right" ? "flex-end" : "flex-start";
        }
        const cssVars = {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-line-height": lineHeight2,
          "--n-blank-height": blankHeight,
          "--n-label-font-size": labelFontSize,
          "--n-label-text-align": mergedLabelTextAlign,
          "--n-label-height": labelHeight,
          "--n-label-padding": labelPadding,
          "--n-label-font-weight": labelFontWeight,
          "--n-asterisk-color": asteriskColor,
          "--n-label-text-color": labelTextColor,
          "--n-feedback-padding": feedbackPadding,
          "--n-feedback-font-size": feedbackFontSize,
          "--n-feedback-height": feedbackHeight,
          "--n-feedback-text-color": feedbackTextColor,
          "--n-feedback-text-color-warning": feedbackTextColorWarning,
          "--n-feedback-text-color-error": feedbackTextColorError
        };
        return cssVars;
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("form-item", vue.computed(() => {
        var _a;
        return `${mergedSizeRef.value[0]}${labelPlacementRef.value[0]}${((_a = labelTextAlignRef.value) === null || _a === void 0 ? void 0 : _a[0]) || ""}`;
      }), cssVarsRef, props) : void 0;
      const reverseColSpaceRef = vue.computed(() => {
        return labelPlacementRef.value === "left" && mergedRequireMarkPlacementRef.value === "left" && labelTextAlignRef.value === "left";
      });
      return Object.assign(Object.assign(Object.assign(Object.assign({
        labelElementRef,
        mergedClsPrefix: mergedClsPrefixRef,
        mergedRequired: mergedRequiredRef,
        feedbackId: feedbackIdRef,
        renderExplains: renderExplainsRef,
        reverseColSpace: reverseColSpaceRef
      }, formItemMiscRefs), formItemSizeRefs), exposedRef), {
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      });
    },
    render() {
      const {
        $slots,
        mergedClsPrefix,
        mergedShowLabel,
        mergedShowRequireMark,
        mergedRequireMarkPlacement,
        onRender
      } = this;
      const renderedShowRequireMark = mergedShowRequireMark !== void 0 ? mergedShowRequireMark : this.mergedRequired;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      const renderLabel = () => {
        const labelText = this.$slots.label ? this.$slots.label() : this.label;
        if (!labelText)
          return null;
        const textNode = vue.h("span", {
          class: `${mergedClsPrefix}-form-item-label__text`
        }, labelText);
        const markNode = renderedShowRequireMark ? vue.h("span", {
          class: `${mergedClsPrefix}-form-item-label__asterisk`
        }, mergedRequireMarkPlacement !== "left" ? " *" : "* ") : mergedRequireMarkPlacement === "right-hanging" && vue.h("span", {
          class: `${mergedClsPrefix}-form-item-label__asterisk-placeholder`
        }, " *");
        const {
          labelProps
        } = this;
        return vue.h("label", Object.assign({}, labelProps, {
          class: [labelProps === null || labelProps === void 0 ? void 0 : labelProps.class, `${mergedClsPrefix}-form-item-label`, `${mergedClsPrefix}-form-item-label--${mergedRequireMarkPlacement}-mark`, this.reverseColSpace && `${mergedClsPrefix}-form-item-label--reverse-columns-space`],
          style: this.mergedLabelStyle,
          ref: "labelElementRef"
        }), mergedRequireMarkPlacement === "left" ? [markNode, textNode] : [textNode, markNode]);
      };
      return vue.h("div", {
        class: [`${mergedClsPrefix}-form-item`, this.themeClass, `${mergedClsPrefix}-form-item--${this.mergedSize}-size`, `${mergedClsPrefix}-form-item--${this.mergedLabelPlacement}-labelled`, this.isAutoLabelWidth && `${mergedClsPrefix}-form-item--auto-label-width`, !mergedShowLabel && `${mergedClsPrefix}-form-item--no-label`],
        style: this.cssVars
      }, mergedShowLabel && renderLabel(), vue.h("div", {
        class: [`${mergedClsPrefix}-form-item-blank`, this.mergedValidationStatus && `${mergedClsPrefix}-form-item-blank--${this.mergedValidationStatus}`]
      }, $slots), this.mergedShowFeedback ? vue.h("div", {
        key: this.feedbackId,
        style: this.feedbackStyle,
        class: [`${mergedClsPrefix}-form-item-feedback-wrapper`, this.feedbackClass]
      }, vue.h(vue.Transition, {
        name: "fade-down-transition",
        mode: "out-in"
      }, {
        default: () => {
          const {
            mergedValidationStatus
          } = this;
          return resolveWrappedSlot($slots.feedback, (children) => {
            var _a;
            const {
              feedback
            } = this;
            const feedbackNodes = children || feedback ? vue.h("div", {
              key: "__feedback__",
              class: `${mergedClsPrefix}-form-item-feedback__line`
            }, children || feedback) : this.renderExplains.length ? (_a = this.renderExplains) === null || _a === void 0 ? void 0 : _a.map(({
              key,
              render: render2
            }) => vue.h("div", {
              key,
              class: `${mergedClsPrefix}-form-item-feedback__line`
            }, render2())) : null;
            return feedbackNodes ? mergedValidationStatus === "warning" ? vue.h("div", {
              key: "controlled-warning",
              class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--warning`
            }, feedbackNodes) : mergedValidationStatus === "error" ? vue.h("div", {
              key: "controlled-error",
              class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--error`
            }, feedbackNodes) : mergedValidationStatus === "success" ? vue.h("div", {
              key: "controlled-success",
              class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--success`
            }, feedbackNodes) : vue.h("div", {
              key: "controlled-default",
              class: `${mergedClsPrefix}-form-item-feedback`
            }, feedbackNodes) : null;
          });
        }
      })) : null);
    }
  });
  const defaultSpan$1 = 1;
  const gridInjectionKey = createInjectionKey("n-grid");
  const defaultSpan = 1;
  const gridItemProps = {
    span: {
      type: [Number, String],
      default: defaultSpan
    },
    offset: {
      type: [Number, String],
      default: 0
    },
    suffix: Boolean,
    // private props
    privateOffset: Number,
    privateSpan: Number,
    privateColStart: Number,
    privateShow: {
      type: Boolean,
      default: true
    }
  };
  const gridItemPropKeys = keysOf(gridItemProps);
  const NGi = vue.defineComponent({
    __GRID_ITEM__: true,
    name: "GridItem",
    alias: ["Gi"],
    props: gridItemProps,
    setup() {
      const {
        isSsrRef,
        xGapRef,
        itemStyleRef,
        overflowRef,
        layoutShiftDisabledRef
      } = vue.inject(gridInjectionKey);
      const self2 = vue.getCurrentInstance();
      return {
        overflow: overflowRef,
        itemStyle: itemStyleRef,
        layoutShiftDisabled: layoutShiftDisabledRef,
        mergedXGap: vue.computed(() => {
          return pxfy(xGapRef.value || 0);
        }),
        deriveStyle: () => {
          void isSsrRef.value;
          const {
            privateSpan = defaultSpan,
            privateShow = true,
            privateColStart = void 0,
            privateOffset = 0
          } = self2.vnode.props;
          const {
            value: xGap
          } = xGapRef;
          const mergedXGap = pxfy(xGap || 0);
          return {
            display: !privateShow ? "none" : "",
            gridColumn: `${privateColStart !== null && privateColStart !== void 0 ? privateColStart : `span ${privateSpan}`} / span ${privateSpan}`,
            marginLeft: privateOffset ? `calc((100% - (${privateSpan} - 1) * ${mergedXGap}) / ${privateSpan} * ${privateOffset} + ${mergedXGap} * ${privateOffset})` : ""
          };
        }
      };
    },
    render() {
      var _a, _b;
      if (this.layoutShiftDisabled) {
        const {
          span,
          offset,
          mergedXGap
        } = this;
        return vue.h("div", {
          style: {
            gridColumn: `span ${span} / span ${span}`,
            marginLeft: offset ? `calc((100% - (${span} - 1) * ${mergedXGap}) / ${span} * ${offset} + ${mergedXGap} * ${offset})` : ""
          }
        }, this.$slots);
      }
      return vue.h("div", {
        style: [this.itemStyle, this.deriveStyle()]
      }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a, {
        overflow: this.overflow
      }));
    }
  });
  const formItemGiProps = Object.assign(Object.assign({}, gridItemProps), formItemProps);
  const FormItemGridItem = vue.defineComponent({
    __GRID_ITEM__: true,
    name: "FormItemGridItem",
    alias: ["FormItemGi"],
    props: formItemGiProps,
    setup() {
      const formItemInstRef = vue.ref(null);
      const validate = (...args) => {
        const {
          value
        } = formItemInstRef;
        if (value) {
          return value.validate(...args);
        }
      };
      const restoreValidation = () => {
        const {
          value
        } = formItemInstRef;
        if (value) {
          value.restoreValidation();
        }
      };
      return {
        formItemInstRef,
        validate,
        restoreValidation
      };
    },
    render() {
      return vue.h(NGi, keep(this.$.vnode.props || {}, gridItemPropKeys), {
        default: () => {
          const itemProps = keep(this.$props, formItemPropKeys);
          return vue.h(NFormItem, Object.assign({
            ref: "formItemInstRef"
          }, itemProps), this.$slots);
        }
      });
    }
  });
  const positionStyles = repeat(24, null).map((_, index) => {
    const prefixIndex = index + 1;
    const percent2 = `calc(100% / 24 * ${prefixIndex})`;
    return [cM(`${prefixIndex}-span`, {
      width: percent2
    }), cM(`${prefixIndex}-offset`, {
      marginLeft: percent2
    }), cM(`${prefixIndex}-push`, {
      left: percent2
    }), cM(`${prefixIndex}-pull`, {
      right: percent2
    })];
  });
  const style$L = c$1([cB("row", {
    width: "100%",
    display: "flex",
    flexWrap: "wrap"
  }), cB("col", {
    verticalAlign: "top",
    boxSizing: "border-box",
    display: "inline-block",
    position: "relative",
    zIndex: "auto"
  }, [cE("box", {
    position: "relative",
    zIndex: "auto",
    width: "100%",
    height: "100%"
  }), positionStyles])]);
  const rowInjectionKey = createInjectionKey("n-row");
  const rowProps = {
    gutter: {
      type: [Array, Number, String],
      default: 0
    },
    alignItems: String,
    justifyContent: String
  };
  const rowPropKeys = keysOf(rowProps);
  const NRow = vue.defineComponent({
    name: "Row",
    props: rowProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        mergedRtlRef
      } = useConfig(props);
      useStyle("-legacy-grid", style$L, mergedClsPrefixRef);
      const rtlEnabledRef = useRtl("Row", mergedRtlRef, mergedClsPrefixRef);
      const verticalGutterRef = useMemo(() => {
        const {
          gutter
        } = props;
        if (Array.isArray(gutter)) {
          return gutter[1] || 0;
        }
        return 0;
      });
      const horizontalGutterRef = useMemo(() => {
        const {
          gutter
        } = props;
        if (Array.isArray(gutter)) {
          return gutter[0];
        }
        return Number(gutter);
      });
      vue.provide(rowInjectionKey, {
        mergedClsPrefixRef,
        gutterRef: vue.toRef(props, "gutter"),
        verticalGutterRef,
        horizontalGutterRef
      });
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        rtlEnabled: rtlEnabledRef,
        styleMargin: useMemo(() => `-${formatLength(verticalGutterRef.value, {
          c: 0.5
        })} -${formatLength(horizontalGutterRef.value, {
          c: 0.5
        })}`),
        styleWidth: useMemo(() => `calc(100% + ${formatLength(horizontalGutterRef.value)})`)
      };
    },
    render() {
      return vue.h("div", {
        class: [`${this.mergedClsPrefix}-row`, this.rtlEnabled && `${this.mergedClsPrefix}-row--rtl`],
        style: {
          margin: this.styleMargin,
          width: this.styleWidth,
          alignItems: this.alignItems,
          justifyContent: this.justifyContent
        }
      }, this.$slots);
    }
  });
  const colProps = {
    span: {
      type: [String, Number],
      default: 1
    },
    push: {
      type: [String, Number],
      default: 0
    },
    pull: {
      type: [String, Number],
      default: 0
    },
    offset: {
      type: [String, Number],
      default: 0
    }
  };
  const colPropKeys = keysOf(colProps);
  const NCol = vue.defineComponent({
    name: "Col",
    props: colProps,
    setup(props) {
      const NRow2 = vue.inject(rowInjectionKey, null);
      if (!NRow2)
        throwError("col", "`n-col` must be placed inside `n-row`.");
      return {
        mergedClsPrefix: NRow2.mergedClsPrefixRef,
        gutter: NRow2.gutterRef,
        stylePadding: vue.computed(() => `${formatLength(NRow2.verticalGutterRef.value, {
          c: 0.5
        })} ${formatLength(NRow2.horizontalGutterRef.value, {
          c: 0.5
        })}`),
        mergedPush: vue.computed(() => Number(props.push) - Number(props.pull))
      };
    },
    render() {
      const {
        $slots,
        span,
        mergedPush,
        offset,
        stylePadding,
        gutter,
        mergedClsPrefix
      } = this;
      return vue.h("div", {
        class: [`${mergedClsPrefix}-col`, {
          [`${mergedClsPrefix}-col--${span}-span`]: true,
          [`${mergedClsPrefix}-col--${mergedPush}-push`]: mergedPush > 0,
          [`${mergedClsPrefix}-col--${-mergedPush}-pull`]: mergedPush < 0,
          [`${mergedClsPrefix}-col--${offset}-offset`]: offset
        }],
        style: {
          padding: stylePadding
        }
      }, gutter ? vue.h("div", null, $slots) : $slots);
    }
  });
  const formItemColProps = Object.assign(Object.assign({}, colProps), formItemProps);
  const formItemColPropKeys = keysOf(formItemColProps);
  const NFormItemCol = vue.defineComponent({
    name: "FormItemCol",
    props: formItemColProps,
    setup() {
      const formItemInstRef = vue.ref(null);
      const validate = (...args) => {
        const {
          value
        } = formItemInstRef;
        if (value) {
          return value.validate(...args);
        }
      };
      const restoreValidation = () => {
        const {
          value
        } = formItemInstRef;
        if (value) {
          value.restoreValidation();
        }
      };
      return {
        formItemInstRef,
        validate,
        restoreValidation
      };
    },
    render() {
      return vue.h(NCol, keep(this.$props, colPropKeys), {
        default: () => {
          const itemProps = keep(this.$props, formItemPropKeys);
          return vue.h(NFormItem, Object.assign({
            ref: "formItemInstRef"
          }, itemProps), this.$slots);
        }
      });
    }
  });
  const formItemRowProps = Object.assign(Object.assign({}, rowProps), formItemColProps);
  const FormItemRow = vue.defineComponent({
    name: "FormItemRow",
    props: formItemRowProps,
    setup() {
      const formItemColInstRef = vue.ref(null);
      const validate = (...args) => {
        const {
          value
        } = formItemColInstRef;
        if (value) {
          return value.validate(...args);
        }
      };
      const restoreValidation = () => {
        const {
          value
        } = formItemColInstRef;
        if (value) {
          value.restoreValidation();
        }
      };
      return {
        formItemColInstRef,
        validate,
        restoreValidation
      };
    },
    render() {
      return vue.h(NRow, keep(this.$props, rowPropKeys), {
        default: () => {
          const colProps2 = keep(this.$props, formItemColPropKeys);
          return vue.h(NFormItemCol, Object.assign(Object.assign({
            ref: "formItemColInstRef"
          }, colProps2), {
            span: 24
          }), this.$slots);
        }
      });
    }
  });
  const commonVars$3 = {
    closeMargin: "16px 12px",
    closeSize: "20px",
    closeIconSize: "16px",
    width: "365px",
    padding: "16px",
    titleFontSize: "16px",
    metaFontSize: "12px",
    descriptionFontSize: "12px"
  };
  function self$B(vars) {
    const {
      textColor2,
      successColor,
      infoColor,
      warningColor,
      errorColor,
      popoverColor,
      closeIconColor,
      closeIconColorHover,
      closeIconColorPressed,
      closeColorHover,
      closeColorPressed,
      textColor1,
      textColor3,
      borderRadius,
      fontWeightStrong,
      boxShadow2,
      lineHeight: lineHeight2,
      fontSize: fontSize2
    } = vars;
    return Object.assign(Object.assign({}, commonVars$3), {
      borderRadius,
      lineHeight: lineHeight2,
      fontSize: fontSize2,
      headerFontWeight: fontWeightStrong,
      iconColor: textColor2,
      iconColorSuccess: successColor,
      iconColorInfo: infoColor,
      iconColorWarning: warningColor,
      iconColorError: errorColor,
      color: popoverColor,
      textColor: textColor2,
      closeIconColor,
      closeIconColorHover,
      closeIconColorPressed,
      closeBorderRadius: borderRadius,
      closeColorHover,
      closeColorPressed,
      headerTextColor: textColor1,
      descriptionTextColor: textColor3,
      actionTextColor: textColor2,
      boxShadow: boxShadow2
    });
  }
  const notificationLight = createTheme({
    name: "Notification",
    common: commonLight,
    peers: {
      Scrollbar: scrollbarLight$1
    },
    self: self$B
  });
  const notificationLight$1 = notificationLight;
  const commonVariables$4 = {
    margin: "0 0 8px 0",
    padding: "10px 20px",
    maxWidth: "720px",
    minWidth: "420px",
    iconMargin: "0 10px 0 0",
    closeMargin: "0 0 0 10px",
    closeSize: "20px",
    closeIconSize: "16px",
    iconSize: "20px",
    fontSize: "14px"
  };
  function self$A(vars) {
    const {
      textColor2,
      closeIconColor,
      closeIconColorHover,
      closeIconColorPressed,
      infoColor,
      successColor,
      errorColor,
      warningColor,
      popoverColor,
      boxShadow2,
      primaryColor,
      lineHeight: lineHeight2,
      borderRadius,
      closeColorHover,
      closeColorPressed
    } = vars;
    return Object.assign(Object.assign({}, commonVariables$4), {
      closeBorderRadius: borderRadius,
      textColor: textColor2,
      textColorInfo: textColor2,
      textColorSuccess: textColor2,
      textColorError: textColor2,
      textColorWarning: textColor2,
      textColorLoading: textColor2,
      color: popoverColor,
      colorInfo: popoverColor,
      colorSuccess: popoverColor,
      colorError: popoverColor,
      colorWarning: popoverColor,
      colorLoading: popoverColor,
      boxShadow: boxShadow2,
      boxShadowInfo: boxShadow2,
      boxShadowSuccess: boxShadow2,
      boxShadowError: boxShadow2,
      boxShadowWarning: boxShadow2,
      boxShadowLoading: boxShadow2,
      iconColor: textColor2,
      iconColorInfo: infoColor,
      iconColorSuccess: successColor,
      iconColorWarning: warningColor,
      iconColorError: errorColor,
      iconColorLoading: primaryColor,
      closeColorHover,
      closeColorPressed,
      closeIconColor,
      closeIconColorHover,
      closeIconColorPressed,
      closeColorHoverInfo: closeColorHover,
      closeColorPressedInfo: closeColorPressed,
      closeIconColorInfo: closeIconColor,
      closeIconColorHoverInfo: closeIconColorHover,
      closeIconColorPressedInfo: closeIconColorPressed,
      closeColorHoverSuccess: closeColorHover,
      closeColorPressedSuccess: closeColorPressed,
      closeIconColorSuccess: closeIconColor,
      closeIconColorHoverSuccess: closeIconColorHover,
      closeIconColorPressedSuccess: closeIconColorPressed,
      closeColorHoverError: closeColorHover,
      closeColorPressedError: closeColorPressed,
      closeIconColorError: closeIconColor,
      closeIconColorHoverError: closeIconColorHover,
      closeIconColorPressedError: closeIconColorPressed,
      closeColorHoverWarning: closeColorHover,
      closeColorPressedWarning: closeColorPressed,
      closeIconColorWarning: closeIconColor,
      closeIconColorHoverWarning: closeIconColorHover,
      closeIconColorPressedWarning: closeIconColorPressed,
      closeColorHoverLoading: closeColorHover,
      closeColorPressedLoading: closeColorPressed,
      closeIconColorLoading: closeIconColor,
      closeIconColorHoverLoading: closeIconColorHover,
      closeIconColorPressedLoading: closeIconColorPressed,
      loadingColor: primaryColor,
      lineHeight: lineHeight2,
      borderRadius
    });
  }
  const messageLight = {
    name: "Message",
    common: commonLight,
    self: self$A
  };
  const messageLight$1 = messageLight;
  function self$z(vars) {
    const {
      primaryColor,
      successColor,
      warningColor,
      errorColor,
      infoColor,
      fontWeightStrong
    } = vars;
    return {
      fontWeight: fontWeightStrong,
      rotate: "252deg",
      colorStartPrimary: changeColor(primaryColor, {
        alpha: 0.6
      }),
      colorEndPrimary: primaryColor,
      colorStartInfo: changeColor(infoColor, {
        alpha: 0.6
      }),
      colorEndInfo: infoColor,
      colorStartWarning: changeColor(warningColor, {
        alpha: 0.6
      }),
      colorEndWarning: warningColor,
      colorStartError: changeColor(errorColor, {
        alpha: 0.6
      }),
      colorEndError: errorColor,
      colorStartSuccess: changeColor(successColor, {
        alpha: 0.6
      }),
      colorEndSuccess: successColor
    };
  }
  const gradientTextLight = {
    name: "GradientText",
    common: commonLight,
    self: self$z
  };
  const gradientTextLight$1 = gradientTextLight;
  function self$y(vars) {
    const {
      textColorDisabled
    } = vars;
    return {
      iconColorDisabled: textColorDisabled
    };
  }
  const inputNumberLight = createTheme({
    name: "InputNumber",
    common: commonLight,
    peers: {
      Button: buttonLight$1,
      Input: inputLight$1
    },
    self: self$y
  });
  const inputNumberLight$1 = inputNumberLight;
  function self$x(vars) {
    const {
      baseColor,
      textColor2,
      bodyColor,
      cardColor,
      dividerColor,
      actionColor,
      scrollbarColor,
      scrollbarColorHover,
      invertedColor
    } = vars;
    return {
      textColor: textColor2,
      textColorInverted: "#FFF",
      color: bodyColor,
      colorEmbedded: actionColor,
      headerColor: cardColor,
      headerColorInverted: invertedColor,
      footerColor: actionColor,
      footerColorInverted: invertedColor,
      headerBorderColor: dividerColor,
      headerBorderColorInverted: invertedColor,
      footerBorderColor: dividerColor,
      footerBorderColorInverted: invertedColor,
      siderBorderColor: dividerColor,
      siderBorderColorInverted: invertedColor,
      siderColor: cardColor,
      siderColorInverted: invertedColor,
      siderToggleButtonBorder: `1px solid ${dividerColor}`,
      siderToggleButtonColor: baseColor,
      siderToggleButtonIconColor: textColor2,
      siderToggleButtonIconColorInverted: textColor2,
      siderToggleBarColor: composite(bodyColor, scrollbarColor),
      siderToggleBarColorHover: composite(bodyColor, scrollbarColorHover),
      // hack for inverted background
      __invertScrollbar: "true"
    };
  }
  const layoutLight = createTheme({
    name: "Layout",
    common: commonLight,
    peers: {
      Scrollbar: scrollbarLight$1
    },
    self: self$x
  });
  const layoutLight$1 = layoutLight;
  function self$w(vars) {
    const {
      textColor2,
      cardColor,
      modalColor,
      popoverColor,
      dividerColor,
      borderRadius,
      fontSize: fontSize2,
      hoverColor
    } = vars;
    return {
      textColor: textColor2,
      color: cardColor,
      colorHover: hoverColor,
      colorModal: modalColor,
      colorHoverModal: composite(modalColor, hoverColor),
      colorPopover: popoverColor,
      colorHoverPopover: composite(popoverColor, hoverColor),
      borderColor: dividerColor,
      borderColorModal: composite(modalColor, dividerColor),
      borderColorPopover: composite(popoverColor, dividerColor),
      borderRadius,
      fontSize: fontSize2
    };
  }
  const listLight = {
    name: "List",
    common: commonLight,
    self: self$w
  };
  const listLight$1 = listLight;
  function self$v(vars) {
    const {
      primaryColor,
      errorColor
    } = vars;
    return {
      colorError: errorColor,
      colorLoading: primaryColor,
      height: "2px"
    };
  }
  const loadingBarLight = {
    name: "LoadingBar",
    common: commonLight,
    self: self$v
  };
  const loadingBarLight$1 = loadingBarLight;
  function self$u(vars) {
    const {
      textColor2,
      modalColor,
      borderColor,
      fontSize: fontSize2,
      primaryColor
    } = vars;
    return {
      loaderFontSize: fontSize2,
      loaderTextColor: textColor2,
      loaderColor: modalColor,
      loaderBorder: `1px solid ${borderColor}`,
      loadingColor: primaryColor
    };
  }
  const logLight = createTheme({
    name: "Log",
    common: commonLight,
    peers: {
      Scrollbar: scrollbarLight$1,
      Code: codeLight$1
    },
    self: self$u
  });
  const logLight$1 = logLight;
  function self$t(vars) {
    const {
      boxShadow2
    } = vars;
    return {
      menuBoxShadow: boxShadow2
    };
  }
  const mentionLight = createTheme({
    name: "Mention",
    common: commonLight,
    peers: {
      InternalSelectMenu: internalSelectMenuLight$1,
      Input: inputLight$1
    },
    self: self$t
  });
  const mentionLight$1 = mentionLight;
  function createPartialInvertedVars(color, activeItemColor, activeTextColor, groupTextColor) {
    return {
      itemColorHoverInverted: "#0000",
      itemColorActiveInverted: activeItemColor,
      itemColorActiveHoverInverted: activeItemColor,
      itemColorActiveCollapsedInverted: activeItemColor,
      itemTextColorInverted: color,
      itemTextColorHoverInverted: activeTextColor,
      itemTextColorChildActiveInverted: activeTextColor,
      itemTextColorChildActiveHoverInverted: activeTextColor,
      itemTextColorActiveInverted: activeTextColor,
      itemTextColorActiveHoverInverted: activeTextColor,
      itemTextColorHorizontalInverted: color,
      itemTextColorHoverHorizontalInverted: activeTextColor,
      itemTextColorChildActiveHorizontalInverted: activeTextColor,
      itemTextColorChildActiveHoverHorizontalInverted: activeTextColor,
      itemTextColorActiveHorizontalInverted: activeTextColor,
      itemTextColorActiveHoverHorizontalInverted: activeTextColor,
      itemIconColorInverted: color,
      itemIconColorHoverInverted: activeTextColor,
      itemIconColorActiveInverted: activeTextColor,
      itemIconColorActiveHoverInverted: activeTextColor,
      itemIconColorChildActiveInverted: activeTextColor,
      itemIconColorChildActiveHoverInverted: activeTextColor,
      itemIconColorCollapsedInverted: color,
      itemIconColorHorizontalInverted: color,
      itemIconColorHoverHorizontalInverted: activeTextColor,
      itemIconColorActiveHorizontalInverted: activeTextColor,
      itemIconColorActiveHoverHorizontalInverted: activeTextColor,
      itemIconColorChildActiveHorizontalInverted: activeTextColor,
      itemIconColorChildActiveHoverHorizontalInverted: activeTextColor,
      arrowColorInverted: color,
      arrowColorHoverInverted: activeTextColor,
      arrowColorActiveInverted: activeTextColor,
      arrowColorActiveHoverInverted: activeTextColor,
      arrowColorChildActiveInverted: activeTextColor,
      arrowColorChildActiveHoverInverted: activeTextColor,
      groupTextColorInverted: groupTextColor
    };
  }
  function self$s(vars) {
    const {
      borderRadius,
      textColor3,
      primaryColor,
      textColor2,
      textColor1,
      fontSize: fontSize2,
      dividerColor,
      hoverColor,
      primaryColorHover
    } = vars;
    return Object.assign({
      borderRadius,
      color: "#0000",
      groupTextColor: textColor3,
      itemColorHover: hoverColor,
      itemColorActive: changeColor(primaryColor, {
        alpha: 0.1
      }),
      itemColorActiveHover: changeColor(primaryColor, {
        alpha: 0.1
      }),
      itemColorActiveCollapsed: changeColor(primaryColor, {
        alpha: 0.1
      }),
      itemTextColor: textColor2,
      itemTextColorHover: textColor2,
      itemTextColorActive: primaryColor,
      itemTextColorActiveHover: primaryColor,
      itemTextColorChildActive: primaryColor,
      itemTextColorChildActiveHover: primaryColor,
      itemTextColorHorizontal: textColor2,
      itemTextColorHoverHorizontal: primaryColorHover,
      itemTextColorActiveHorizontal: primaryColor,
      itemTextColorActiveHoverHorizontal: primaryColor,
      itemTextColorChildActiveHorizontal: primaryColor,
      itemTextColorChildActiveHoverHorizontal: primaryColor,
      itemIconColor: textColor1,
      itemIconColorHover: textColor1,
      itemIconColorActive: primaryColor,
      itemIconColorActiveHover: primaryColor,
      itemIconColorChildActive: primaryColor,
      itemIconColorChildActiveHover: primaryColor,
      itemIconColorCollapsed: textColor1,
      itemIconColorHorizontal: textColor1,
      itemIconColorHoverHorizontal: primaryColorHover,
      itemIconColorActiveHorizontal: primaryColor,
      itemIconColorActiveHoverHorizontal: primaryColor,
      itemIconColorChildActiveHorizontal: primaryColor,
      itemIconColorChildActiveHoverHorizontal: primaryColor,
      itemHeight: "42px",
      arrowColor: textColor2,
      arrowColorHover: textColor2,
      arrowColorActive: primaryColor,
      arrowColorActiveHover: primaryColor,
      arrowColorChildActive: primaryColor,
      arrowColorChildActiveHover: primaryColor,
      colorInverted: "#0000",
      borderColorHorizontal: "#0000",
      fontSize: fontSize2,
      dividerColor
    }, createPartialInvertedVars("#BBB", primaryColor, "#FFF", "#AAA"));
  }
  const menuLight = createTheme({
    name: "Menu",
    common: commonLight,
    peers: {
      Tooltip: tooltipLight$1,
      Dropdown: dropdownLight$1
    },
    self: self$s
  });
  const menuLight$1 = menuLight;
  const common = {
    titleFontSize: "18px",
    backSize: "22px"
  };
  function self$r(vars) {
    const {
      textColor1,
      textColor2,
      textColor3,
      fontSize: fontSize2,
      fontWeightStrong,
      primaryColorHover,
      primaryColorPressed
    } = vars;
    return Object.assign(Object.assign({}, common), {
      titleFontWeight: fontWeightStrong,
      fontSize: fontSize2,
      titleTextColor: textColor1,
      backColor: textColor2,
      backColorHover: primaryColorHover,
      backColorPressed: primaryColorPressed,
      subtitleTextColor: textColor3
    });
  }
  const pageHeaderLight = createTheme({
    name: "PageHeader",
    common: commonLight,
    self: self$r
  });
  const commonVars$2 = {
    iconSize: "22px"
  };
  function self$q(vars) {
    const {
      fontSize: fontSize2,
      warningColor
    } = vars;
    return Object.assign(Object.assign({}, commonVars$2), {
      fontSize: fontSize2,
      iconColor: warningColor
    });
  }
  const popconfirmLight = createTheme({
    name: "Popconfirm",
    common: commonLight,
    peers: {
      Button: buttonLight$1,
      Popover: popoverLight$1
    },
    self: self$q
  });
  const popconfirmLight$1 = popconfirmLight;
  function self$p(vars) {
    const {
      infoColor,
      successColor,
      warningColor,
      errorColor,
      textColor2,
      progressRailColor,
      fontSize: fontSize2,
      fontWeight
    } = vars;
    return {
      fontSize: fontSize2,
      fontSizeCircle: "28px",
      fontWeightCircle: fontWeight,
      railColor: progressRailColor,
      railHeight: "8px",
      iconSizeCircle: "36px",
      iconSizeLine: "18px",
      iconColor: infoColor,
      iconColorInfo: infoColor,
      iconColorSuccess: successColor,
      iconColorWarning: warningColor,
      iconColorError: errorColor,
      textColorCircle: textColor2,
      textColorLineInner: "rgb(255, 255, 255)",
      textColorLineOuter: textColor2,
      fillColor: infoColor,
      fillColorInfo: infoColor,
      fillColorSuccess: successColor,
      fillColorWarning: warningColor,
      fillColorError: errorColor,
      lineBgProcessing: "linear-gradient(90deg, rgba(255, 255, 255, .3) 0%, rgba(255, 255, 255, .5) 100%)"
    };
  }
  const progressLight = {
    name: "Progress",
    common: commonLight,
    self: self$p
  };
  const progressLight$1 = progressLight;
  function self$o(vars) {
    const {
      railColor
    } = vars;
    return {
      itemColor: railColor,
      itemColorActive: "#FFCC33",
      sizeSmall: "16px",
      sizeMedium: "20px",
      sizeLarge: "24px"
    };
  }
  const themeLight$4 = {
    name: "Rate",
    common: commonLight,
    self: self$o
  };
  const rateLight = themeLight$4;
  const commonVariables$3 = {
    titleFontSizeSmall: "26px",
    titleFontSizeMedium: "32px",
    titleFontSizeLarge: "40px",
    titleFontSizeHuge: "48px",
    fontSizeSmall: "14px",
    fontSizeMedium: "14px",
    fontSizeLarge: "15px",
    fontSizeHuge: "16px",
    iconSizeSmall: "64px",
    iconSizeMedium: "80px",
    iconSizeLarge: "100px",
    iconSizeHuge: "125px",
    iconColor418: void 0,
    iconColor404: void 0,
    iconColor403: void 0,
    iconColor500: void 0
  };
  function self$n(vars) {
    const {
      textColor2,
      textColor1,
      errorColor,
      successColor,
      infoColor,
      warningColor,
      lineHeight: lineHeight2,
      fontWeightStrong
    } = vars;
    return Object.assign(Object.assign({}, commonVariables$3), {
      lineHeight: lineHeight2,
      titleFontWeight: fontWeightStrong,
      titleTextColor: textColor1,
      textColor: textColor2,
      iconColorError: errorColor,
      iconColorSuccess: successColor,
      iconColorInfo: infoColor,
      iconColorWarning: warningColor
    });
  }
  const resultLight = {
    name: "Result",
    common: commonLight,
    self: self$n
  };
  const resultLight$1 = resultLight;
  const sizeVariables$3 = {
    railHeight: "4px",
    railWidthVertical: "4px",
    handleSize: "18px",
    dotHeight: "8px",
    dotWidth: "8px",
    dotBorderRadius: "4px"
  };
  function self$m(vars) {
    const indicatorColor = "rgba(0, 0, 0, .85)";
    const boxShadow = "0 2px 8px 0 rgba(0, 0, 0, 0.12)";
    const {
      railColor,
      primaryColor,
      baseColor,
      cardColor,
      modalColor,
      popoverColor,
      borderRadius,
      fontSize: fontSize2,
      opacityDisabled
    } = vars;
    return Object.assign(Object.assign({}, sizeVariables$3), {
      fontSize: fontSize2,
      markFontSize: fontSize2,
      railColor,
      railColorHover: railColor,
      fillColor: primaryColor,
      fillColorHover: primaryColor,
      opacityDisabled,
      handleColor: "#FFF",
      dotColor: cardColor,
      dotColorModal: modalColor,
      dotColorPopover: popoverColor,
      handleBoxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)",
      handleBoxShadowHover: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)",
      handleBoxShadowActive: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)",
      handleBoxShadowFocus: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)",
      indicatorColor,
      indicatorBoxShadow: boxShadow,
      indicatorTextColor: baseColor,
      indicatorBorderRadius: borderRadius,
      dotBorder: `2px solid ${railColor}`,
      dotBorderActive: `2px solid ${primaryColor}`,
      dotBoxShadow: ""
    });
  }
  const sliderLight = {
    name: "Slider",
    common: commonLight,
    self: self$m
  };
  const sliderLight$1 = sliderLight;
  function self$l(vars) {
    const {
      opacityDisabled,
      heightTiny,
      heightSmall,
      heightMedium,
      heightLarge,
      heightHuge,
      primaryColor,
      fontSize: fontSize2
    } = vars;
    return {
      fontSize: fontSize2,
      textColor: primaryColor,
      sizeTiny: heightTiny,
      sizeSmall: heightSmall,
      sizeMedium: heightMedium,
      sizeLarge: heightLarge,
      sizeHuge: heightHuge,
      color: primaryColor,
      opacitySpinning: opacityDisabled
    };
  }
  const spinLight = {
    name: "Spin",
    common: commonLight,
    self: self$l
  };
  const spinLight$1 = spinLight;
  function self$k(vars) {
    const {
      textColor2,
      textColor3,
      fontSize: fontSize2,
      fontWeight
    } = vars;
    return {
      labelFontSize: fontSize2,
      labelFontWeight: fontWeight,
      valueFontWeight: fontWeight,
      valueFontSize: "24px",
      labelTextColor: textColor3,
      valuePrefixTextColor: textColor2,
      valueSuffixTextColor: textColor2,
      valueTextColor: textColor2
    };
  }
  const statisticLight = {
    name: "Statistic",
    common: commonLight,
    self: self$k
  };
  const statisticLight$1 = statisticLight;
  const commonVariables$2 = {
    stepHeaderFontSizeSmall: "14px",
    stepHeaderFontSizeMedium: "16px",
    indicatorIndexFontSizeSmall: "14px",
    indicatorIndexFontSizeMedium: "16px",
    indicatorSizeSmall: "22px",
    indicatorSizeMedium: "28px",
    indicatorIconSizeSmall: "14px",
    indicatorIconSizeMedium: "18px"
  };
  function self$j(vars) {
    const {
      fontWeightStrong,
      baseColor,
      textColorDisabled,
      primaryColor,
      errorColor,
      textColor1,
      textColor2
    } = vars;
    return Object.assign(Object.assign({}, commonVariables$2), {
      stepHeaderFontWeight: fontWeightStrong,
      indicatorTextColorProcess: baseColor,
      indicatorTextColorWait: textColorDisabled,
      indicatorTextColorFinish: primaryColor,
      indicatorTextColorError: errorColor,
      indicatorBorderColorProcess: primaryColor,
      indicatorBorderColorWait: textColorDisabled,
      indicatorBorderColorFinish: primaryColor,
      indicatorBorderColorError: errorColor,
      indicatorColorProcess: primaryColor,
      indicatorColorWait: "#0000",
      indicatorColorFinish: "#0000",
      indicatorColorError: "#0000",
      splitorColorProcess: textColorDisabled,
      splitorColorWait: textColorDisabled,
      splitorColorFinish: primaryColor,
      splitorColorError: textColorDisabled,
      headerTextColorProcess: textColor1,
      headerTextColorWait: textColorDisabled,
      headerTextColorFinish: textColorDisabled,
      headerTextColorError: errorColor,
      descriptionTextColorProcess: textColor2,
      descriptionTextColorWait: textColorDisabled,
      descriptionTextColorFinish: textColorDisabled,
      descriptionTextColorError: errorColor
    });
  }
  const stepsLight = {
    name: "Steps",
    common: commonLight,
    self: self$j
  };
  const stepsLight$1 = stepsLight;
  const commonVars$1 = {
    buttonHeightSmall: "14px",
    buttonHeightMedium: "18px",
    buttonHeightLarge: "22px",
    buttonWidthSmall: "14px",
    buttonWidthMedium: "18px",
    buttonWidthLarge: "22px",
    buttonWidthPressedSmall: "20px",
    buttonWidthPressedMedium: "24px",
    buttonWidthPressedLarge: "28px",
    railHeightSmall: "18px",
    railHeightMedium: "22px",
    railHeightLarge: "26px",
    railWidthSmall: "32px",
    railWidthMedium: "40px",
    railWidthLarge: "48px"
  };
  function self$i(vars) {
    const {
      primaryColor,
      opacityDisabled,
      borderRadius,
      textColor3
    } = vars;
    const railOverlayColor = "rgba(0, 0, 0, .14)";
    return Object.assign(Object.assign({}, commonVars$1), {
      iconColor: textColor3,
      textColor: "white",
      loadingColor: primaryColor,
      opacityDisabled,
      railColor: railOverlayColor,
      railColorActive: primaryColor,
      buttonBoxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)",
      buttonColor: "#FFF",
      railBorderRadiusSmall: borderRadius,
      railBorderRadiusMedium: borderRadius,
      railBorderRadiusLarge: borderRadius,
      buttonBorderRadiusSmall: borderRadius,
      buttonBorderRadiusMedium: borderRadius,
      buttonBorderRadiusLarge: borderRadius,
      boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, {
        alpha: 0.2
      })}`
    });
  }
  const switchLight = {
    name: "Switch",
    common: commonLight,
    self: self$i
  };
  const switchLight$1 = switchLight;
  const sizeVariables$2 = {
    thPaddingSmall: "6px",
    thPaddingMedium: "12px",
    thPaddingLarge: "12px",
    tdPaddingSmall: "6px",
    tdPaddingMedium: "12px",
    tdPaddingLarge: "12px"
  };
  function self$h(vars) {
    const {
      dividerColor,
      cardColor,
      modalColor,
      popoverColor,
      tableHeaderColor,
      tableColorStriped,
      textColor1,
      textColor2,
      borderRadius,
      fontWeightStrong,
      lineHeight: lineHeight2,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge
    } = vars;
    return Object.assign(Object.assign({}, sizeVariables$2), {
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      lineHeight: lineHeight2,
      borderRadius,
      borderColor: composite(cardColor, dividerColor),
      borderColorModal: composite(modalColor, dividerColor),
      borderColorPopover: composite(popoverColor, dividerColor),
      tdColor: cardColor,
      tdColorModal: modalColor,
      tdColorPopover: popoverColor,
      tdColorStriped: composite(cardColor, tableColorStriped),
      tdColorStripedModal: composite(modalColor, tableColorStriped),
      tdColorStripedPopover: composite(popoverColor, tableColorStriped),
      thColor: composite(cardColor, tableHeaderColor),
      thColorModal: composite(modalColor, tableHeaderColor),
      thColorPopover: composite(popoverColor, tableHeaderColor),
      thTextColor: textColor1,
      tdTextColor: textColor2,
      thFontWeight: fontWeightStrong
    });
  }
  const tableLight = {
    name: "Table",
    common: commonLight,
    self: self$h
  };
  const tableLight$1 = tableLight;
  const sizeVariables$1 = {
    tabFontSizeSmall: "14px",
    tabFontSizeMedium: "14px",
    tabFontSizeLarge: "16px",
    tabGapSmallLine: "36px",
    tabGapMediumLine: "36px",
    tabGapLargeLine: "36px",
    tabGapSmallLineVertical: "8px",
    tabGapMediumLineVertical: "8px",
    tabGapLargeLineVertical: "8px",
    tabPaddingSmallLine: "6px 0",
    tabPaddingMediumLine: "10px 0",
    tabPaddingLargeLine: "14px 0",
    tabPaddingVerticalSmallLine: "6px 12px",
    tabPaddingVerticalMediumLine: "8px 16px",
    tabPaddingVerticalLargeLine: "10px 20px",
    tabGapSmallBar: "36px",
    tabGapMediumBar: "36px",
    tabGapLargeBar: "36px",
    tabGapSmallBarVertical: "8px",
    tabGapMediumBarVertical: "8px",
    tabGapLargeBarVertical: "8px",
    tabPaddingSmallBar: "4px 0",
    tabPaddingMediumBar: "6px 0",
    tabPaddingLargeBar: "10px 0",
    tabPaddingVerticalSmallBar: "6px 12px",
    tabPaddingVerticalMediumBar: "8px 16px",
    tabPaddingVerticalLargeBar: "10px 20px",
    tabGapSmallCard: "4px",
    tabGapMediumCard: "4px",
    tabGapLargeCard: "4px",
    tabGapSmallCardVertical: "4px",
    tabGapMediumCardVertical: "4px",
    tabGapLargeCardVertical: "4px",
    tabPaddingSmallCard: "8px 16px",
    tabPaddingMediumCard: "10px 20px",
    tabPaddingLargeCard: "12px 24px",
    tabPaddingSmallSegment: "4px 0",
    tabPaddingMediumSegment: "6px 0",
    tabPaddingLargeSegment: "8px 0",
    tabPaddingVerticalLargeSegment: "0 8px",
    tabPaddingVerticalSmallCard: "8px 12px",
    tabPaddingVerticalMediumCard: "10px 16px",
    tabPaddingVerticalLargeCard: "12px 20px",
    tabPaddingVerticalSmallSegment: "0 4px",
    tabPaddingVerticalMediumSegment: "0 6px",
    tabGapSmallSegment: "0",
    tabGapMediumSegment: "0",
    tabGapLargeSegment: "0",
    tabGapSmallSegmentVertical: "0",
    tabGapMediumSegmentVertical: "0",
    tabGapLargeSegmentVertical: "0",
    panePaddingSmall: "8px 0 0 0",
    panePaddingMedium: "12px 0 0 0",
    panePaddingLarge: "16px 0 0 0",
    closeSize: "18px",
    closeIconSize: "14px"
  };
  function self$g(vars) {
    const {
      textColor2,
      primaryColor,
      textColorDisabled,
      closeIconColor,
      closeIconColorHover,
      closeIconColorPressed,
      closeColorHover,
      closeColorPressed,
      tabColor,
      baseColor,
      dividerColor,
      fontWeight,
      textColor1,
      borderRadius,
      fontSize: fontSize2,
      fontWeightStrong
    } = vars;
    return Object.assign(Object.assign({}, sizeVariables$1), {
      colorSegment: tabColor,
      tabFontSizeCard: fontSize2,
      tabTextColorLine: textColor1,
      tabTextColorActiveLine: primaryColor,
      tabTextColorHoverLine: primaryColor,
      tabTextColorDisabledLine: textColorDisabled,
      tabTextColorSegment: textColor1,
      tabTextColorActiveSegment: textColor2,
      tabTextColorHoverSegment: textColor2,
      tabTextColorDisabledSegment: textColorDisabled,
      tabTextColorBar: textColor1,
      tabTextColorActiveBar: primaryColor,
      tabTextColorHoverBar: primaryColor,
      tabTextColorDisabledBar: textColorDisabled,
      tabTextColorCard: textColor1,
      tabTextColorHoverCard: textColor1,
      tabTextColorActiveCard: primaryColor,
      tabTextColorDisabledCard: textColorDisabled,
      barColor: primaryColor,
      closeIconColor,
      closeIconColorHover,
      closeIconColorPressed,
      closeColorHover,
      closeColorPressed,
      closeBorderRadius: borderRadius,
      tabColor,
      tabColorSegment: baseColor,
      tabBorderColor: dividerColor,
      tabFontWeightActive: fontWeight,
      tabFontWeight: fontWeight,
      tabBorderRadius: borderRadius,
      paneTextColor: textColor2,
      fontWeightStrong
    });
  }
  const tabsLight = {
    name: "Tabs",
    common: commonLight,
    self: self$g
  };
  const tabsLight$1 = tabsLight;
  function self$f(vars) {
    const {
      textColor1,
      textColor2,
      fontWeightStrong,
      fontSize: fontSize2
    } = vars;
    return {
      fontSize: fontSize2,
      titleTextColor: textColor1,
      textColor: textColor2,
      titleFontWeight: fontWeightStrong
    };
  }
  const thingLight = {
    name: "Thing",
    common: commonLight,
    self: self$f
  };
  const thingLight$1 = thingLight;
  const sizeVariables = {
    titleMarginMedium: "0 0 6px 0",
    titleMarginLarge: "-2px 0 6px 0",
    titleFontSizeMedium: "14px",
    titleFontSizeLarge: "16px",
    iconSizeMedium: "14px",
    iconSizeLarge: "14px"
  };
  function self$e(vars) {
    const {
      textColor3,
      infoColor,
      errorColor,
      successColor,
      warningColor,
      textColor1,
      textColor2,
      railColor,
      fontWeightStrong,
      fontSize: fontSize2
    } = vars;
    return Object.assign(Object.assign({}, sizeVariables), {
      contentFontSize: fontSize2,
      titleFontWeight: fontWeightStrong,
      circleBorder: `2px solid ${textColor3}`,
      circleBorderInfo: `2px solid ${infoColor}`,
      circleBorderError: `2px solid ${errorColor}`,
      circleBorderSuccess: `2px solid ${successColor}`,
      circleBorderWarning: `2px solid ${warningColor}`,
      iconColor: textColor3,
      iconColorInfo: infoColor,
      iconColorError: errorColor,
      iconColorSuccess: successColor,
      iconColorWarning: warningColor,
      titleTextColor: textColor1,
      contentTextColor: textColor2,
      metaTextColor: textColor3,
      lineColor: railColor
    });
  }
  const timelineLight = {
    name: "Timeline",
    common: commonLight,
    self: self$e
  };
  const timelineLight$1 = timelineLight;
  const commonVariables$1 = {
    extraFontSizeSmall: "12px",
    extraFontSizeMedium: "12px",
    extraFontSizeLarge: "14px",
    titleFontSizeSmall: "14px",
    titleFontSizeMedium: "16px",
    titleFontSizeLarge: "16px",
    closeSize: "20px",
    closeIconSize: "16px",
    headerHeightSmall: "44px",
    headerHeightMedium: "44px",
    headerHeightLarge: "50px"
  };
  function self$d(vars) {
    const {
      fontWeight,
      fontSizeLarge,
      fontSizeMedium,
      fontSizeSmall,
      heightLarge,
      heightMedium,
      borderRadius,
      cardColor,
      tableHeaderColor,
      textColor1,
      textColorDisabled,
      textColor2,
      textColor3,
      borderColor,
      hoverColor,
      closeColorHover,
      closeColorPressed,
      closeIconColor,
      closeIconColorHover,
      closeIconColorPressed
    } = vars;
    return Object.assign(Object.assign({}, commonVariables$1), {
      itemHeightSmall: heightMedium,
      itemHeightMedium: heightMedium,
      itemHeightLarge: heightLarge,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      borderRadius,
      dividerColor: borderColor,
      borderColor,
      listColor: cardColor,
      headerColor: composite(cardColor, tableHeaderColor),
      titleTextColor: textColor1,
      titleTextColorDisabled: textColorDisabled,
      extraTextColor: textColor3,
      extraTextColorDisabled: textColorDisabled,
      itemTextColor: textColor2,
      itemTextColorDisabled: textColorDisabled,
      itemColorPending: hoverColor,
      titleFontWeight: fontWeight,
      closeColorHover,
      closeColorPressed,
      closeIconColor,
      closeIconColorHover,
      closeIconColorPressed
    });
  }
  const transferLight$1 = createTheme({
    name: "Transfer",
    common: commonLight,
    peers: {
      Checkbox: checkboxLight$1,
      Scrollbar: scrollbarLight$1,
      Input: inputLight$1,
      Empty: emptyLight$1,
      Button: buttonLight$1
    },
    self: self$d
  });
  const transferLight$2 = transferLight$1;
  function self$c(vars) {
    const {
      borderRadiusSmall,
      dividerColor,
      hoverColor,
      pressedColor,
      primaryColor,
      textColor3,
      textColor2,
      textColorDisabled,
      fontSize: fontSize2
    } = vars;
    return {
      fontSize: fontSize2,
      lineHeight: "1.5",
      nodeHeight: "30px",
      nodeWrapperPadding: "3px 0",
      nodeBorderRadius: borderRadiusSmall,
      nodeColorHover: hoverColor,
      nodeColorPressed: pressedColor,
      nodeColorActive: changeColor(primaryColor, {
        alpha: 0.1
      }),
      arrowColor: textColor3,
      nodeTextColor: textColor2,
      nodeTextColorDisabled: textColorDisabled,
      loadingColor: primaryColor,
      dropMarkColor: primaryColor,
      lineColor: dividerColor
    };
  }
  const treeLight = createTheme({
    name: "Tree",
    common: commonLight,
    peers: {
      Checkbox: checkboxLight$1,
      Scrollbar: scrollbarLight$1,
      Empty: emptyLight$1
    },
    self: self$c
  });
  const treeLight$1 = treeLight;
  function self$b(vars) {
    const {
      popoverColor,
      boxShadow2,
      borderRadius,
      heightMedium,
      dividerColor,
      textColor2
    } = vars;
    return {
      menuPadding: "4px",
      menuColor: popoverColor,
      menuBoxShadow: boxShadow2,
      menuBorderRadius: borderRadius,
      menuHeight: `calc(${heightMedium} * 7.6)`,
      actionDividerColor: dividerColor,
      actionTextColor: textColor2,
      actionPadding: "8px 12px",
      headerDividerColor: dividerColor,
      headerTextColor: textColor2,
      headerPadding: "8px 12px"
    };
  }
  const treeSelectLight = createTheme({
    name: "TreeSelect",
    common: commonLight,
    peers: {
      Tree: treeLight$1,
      Empty: emptyLight$1,
      InternalSelection: internalSelectionLight$1
    },
    self: self$b
  });
  const treeSelectLight$1 = treeSelectLight;
  const commonVars = {
    headerFontSize1: "30px",
    headerFontSize2: "22px",
    headerFontSize3: "18px",
    headerFontSize4: "16px",
    headerFontSize5: "16px",
    headerFontSize6: "16px",
    headerMargin1: "28px 0 20px 0",
    headerMargin2: "28px 0 20px 0",
    headerMargin3: "28px 0 20px 0",
    headerMargin4: "28px 0 18px 0",
    headerMargin5: "28px 0 18px 0",
    headerMargin6: "28px 0 18px 0",
    headerPrefixWidth1: "16px",
    headerPrefixWidth2: "16px",
    headerPrefixWidth3: "12px",
    headerPrefixWidth4: "12px",
    headerPrefixWidth5: "12px",
    headerPrefixWidth6: "12px",
    headerBarWidth1: "4px",
    headerBarWidth2: "4px",
    headerBarWidth3: "3px",
    headerBarWidth4: "3px",
    headerBarWidth5: "3px",
    headerBarWidth6: "3px",
    pMargin: "16px 0 16px 0",
    liMargin: ".25em 0 0 0",
    olPadding: "0 0 0 2em",
    ulPadding: "0 0 0 2em"
  };
  function self$a(vars) {
    const {
      primaryColor,
      textColor2,
      borderColor,
      lineHeight: lineHeight2,
      fontSize: fontSize2,
      borderRadiusSmall,
      dividerColor,
      fontWeightStrong,
      textColor1,
      textColor3,
      infoColor,
      warningColor,
      errorColor,
      successColor,
      codeColor
    } = vars;
    return Object.assign(Object.assign({}, commonVars), {
      aTextColor: primaryColor,
      blockquoteTextColor: textColor2,
      blockquotePrefixColor: borderColor,
      blockquoteLineHeight: lineHeight2,
      blockquoteFontSize: fontSize2,
      codeBorderRadius: borderRadiusSmall,
      liTextColor: textColor2,
      liLineHeight: lineHeight2,
      liFontSize: fontSize2,
      hrColor: dividerColor,
      headerFontWeight: fontWeightStrong,
      headerTextColor: textColor1,
      pTextColor: textColor2,
      pTextColor1Depth: textColor1,
      pTextColor2Depth: textColor2,
      pTextColor3Depth: textColor3,
      pLineHeight: lineHeight2,
      pFontSize: fontSize2,
      headerBarColor: primaryColor,
      headerBarColorPrimary: primaryColor,
      headerBarColorInfo: infoColor,
      headerBarColorError: errorColor,
      headerBarColorWarning: warningColor,
      headerBarColorSuccess: successColor,
      textColor: textColor2,
      textColor1Depth: textColor1,
      textColor2Depth: textColor2,
      textColor3Depth: textColor3,
      textColorPrimary: primaryColor,
      textColorInfo: infoColor,
      textColorSuccess: successColor,
      textColorWarning: warningColor,
      textColorError: errorColor,
      codeTextColor: textColor2,
      codeColor,
      codeBorder: "1px solid #0000"
    });
  }
  const typographyLight = {
    name: "Typography",
    common: commonLight,
    self: self$a
  };
  const typographyLight$1 = typographyLight;
  function self$9(vars) {
    const {
      iconColor,
      primaryColor,
      errorColor,
      textColor2,
      successColor,
      opacityDisabled,
      actionColor,
      borderColor,
      hoverColor,
      lineHeight: lineHeight2,
      borderRadius,
      fontSize: fontSize2
    } = vars;
    return {
      fontSize: fontSize2,
      lineHeight: lineHeight2,
      borderRadius,
      draggerColor: actionColor,
      draggerBorder: `1px dashed ${borderColor}`,
      draggerBorderHover: `1px dashed ${primaryColor}`,
      itemColorHover: hoverColor,
      itemColorHoverError: changeColor(errorColor, {
        alpha: 0.06
      }),
      itemTextColor: textColor2,
      itemTextColorError: errorColor,
      itemTextColorSuccess: successColor,
      itemIconColor: iconColor,
      itemDisabledOpacity: opacityDisabled,
      itemBorderImageCardError: `1px solid ${errorColor}`,
      itemBorderImageCard: `1px solid ${borderColor}`
    };
  }
  const uploadLight = createTheme({
    name: "Upload",
    common: commonLight,
    peers: {
      Button: buttonLight$1,
      Progress: progressLight$1
    },
    self: self$9
  });
  const uploadLight$1 = uploadLight;
  const watermarkLight = createTheme({
    name: "Watermark",
    common: commonLight,
    self(vars) {
      const {
        fontFamily: fontFamily2
      } = vars;
      return {
        fontFamily: fontFamily2
      };
    }
  });
  const watermarkLight$1 = watermarkLight;
  function self$8(vars) {
    const {
      popoverColor,
      dividerColor,
      borderRadius
    } = vars;
    return {
      color: popoverColor,
      buttonBorderColor: dividerColor,
      borderRadiusSquare: borderRadius,
      boxShadow: "0 2px 8px 0px rgba(0, 0, 0, .12)"
    };
  }
  const themeLight$3 = {
    name: "FloatButtonGroup",
    common: commonLight,
    self: self$8
  };
  const floatButtonGroupLight = themeLight$3;
  const style$K = cB("float-button-group", [cB("float-button", `
 position: relative;
 `), cM("square-shape", `
 background-color: var(--n-color);
 cursor: pointer;
 display: flex;
 width: fit-content;
 align-items: center;
 justify-content: center;
 border-radius: var(--n-border-radius-square);
 flex-direction: column;
 box-shadow: var(--n-box-shadow);
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [cB("float-button", `
 background-color: unset;
 border-radius: 0;
 box-shadow: none;
 box-sizing: content-box;
 `, [c$1("&:not(:last-child)", `
 border-bottom: 1px solid var(--n-button-border-color); 
 `), c$1("&:first-child", `
 border-top-left-radius: 4px;
 border-top-right-radius: 4px;
 `), c$1("&:last-child", `
 border-bottom-left-radius: 4px;
 border-bottom-right-radius: 4px;
 `), cE("fill", "inset: 4px; border-radius: var(--n-border-radius-square);")])]), cM("circle-shape", [c$1(">:not(:last-child)", `
 margin-bottom: 16px;
 `)])]);
  const floatButtonGroupProps = Object.assign(Object.assign({}, useTheme.props), {
    left: [Number, String],
    right: [Number, String],
    top: [Number, String],
    bottom: [Number, String],
    shape: {
      type: String,
      default: "circle"
    },
    position: {
      type: String,
      default: "fixed"
    }
  });
  const floatButtonGroupInjectionKey = createInjectionKey("n-float-button-group");
  const FloatButtonGroup = vue.defineComponent({
    name: "FloatButtonGroup",
    props: floatButtonGroupProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("FloatButtonGroup", "-float-button-group", style$K, floatButtonGroupLight, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          self: {
            color,
            boxShadow,
            buttonBorderColor,
            borderRadiusSquare
          },
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-box-shadow": boxShadow,
          "--n-color": color,
          "--n-button-border-color": buttonBorderColor,
          "--n-border-radius-square": borderRadiusSquare,
          position: props.position,
          left: formatLength(props.left) || "",
          right: formatLength(props.right) || "",
          top: formatLength(props.top) || "",
          bottom: formatLength(props.bottom) || ""
        };
      });
      vue.provide(floatButtonGroupInjectionKey, {
        shapeRef: vue.toRef(props, "shape")
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("float-button", void 0, cssVarsRef, props) : void 0;
      return {
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        mergedClsPrefix: mergedClsPrefixRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      const {
        mergedClsPrefix,
        cssVars,
        shape
      } = this;
      return vue.h("div", {
        class: [`${mergedClsPrefix}-float-button-group`, `${mergedClsPrefix}-float-button-group--${shape}-shape`],
        style: cssVars,
        role: "group"
      }, this.$slots);
    }
  });
  function self$7(vars) {
    const {
      popoverColor,
      textColor2,
      buttonColor2Hover,
      buttonColor2Pressed,
      primaryColor,
      primaryColorHover,
      primaryColorPressed,
      borderRadius
    } = vars;
    return {
      color: popoverColor,
      colorHover: buttonColor2Hover,
      colorPressed: buttonColor2Pressed,
      colorPrimary: primaryColor,
      colorPrimaryHover: primaryColorHover,
      colorPrimaryPressed: primaryColorPressed,
      textColor: textColor2,
      boxShadow: "0 2px 8px 0px rgba(0, 0, 0, .16)",
      boxShadowHover: "0 2px 12px 0px rgba(0, 0, 0, .24)",
      boxShadowPressed: "0 2px 12px 0px rgba(0, 0, 0, .24)",
      textColorPrimary: "#fff",
      borderRadiusSquare: borderRadius
    };
  }
  const themeLight$2 = {
    name: "FloatButton",
    common: commonLight,
    self: self$7
  };
  const floatButtonLight = themeLight$2;
  const style$J = cB("float-button", `
 user-select: none;
 cursor: pointer;
 color: var(--n-text-color);
 background-color: var(--n-color);
 font-size: 18px;
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 box-shadow: var(--n-box-shadow);
 display: flex;
 align-items: stretch;
 box-sizing: border-box;
`, [cM("circle-shape", `
 border-radius: 4096px;
 `), cM("square-shape", `
 border-radius: var(--n-border-radius-square);
 `), cE("fill", `
 position: absolute;
 inset: 0;
 transition: background-color .3s var(--n-bezier);
 border-radius: inherit;
 `), cE("body", `
 position: relative;
 flex-grow: 1;
 display: flex;
 align-items: center;
 justify-content: center;
 transition: transform .3s var(--n-bezier), opacity .3s var(--n-bezier);
 border-radius: inherit;
 flex-direction: column;
 box-sizing: border-box;
 padding: 2px 4px;
 gap: 2px;
 transform: scale(1);
 `, [cE("description", `
 font-size: 12px;
 text-align: center;
 line-height: 14px;
 `)]), c$1("&:hover", "box-shadow: var(--n-box-shadow-hover);", [c$1(">", [cE("fill", `
 background-color: var(--n-color-hover);
 `)])]), c$1("&:active", "box-shadow: var(--n-box-shadow-pressed);", [c$1(">", [cE("fill", `
 background-color: var(--n-color-pressed);
 `)])]), cM("show-menu", [c$1(">", [cE("menu", `
 pointer-events: all;
 bottom: 100%;
 opacity: 1;
 `), cE("close", `
 transform: scale(1);
 opacity: 1;
 `), cE("body", `
 transform: scale(0.75);
 opacity: 0;
 `)])]), cE("close", `
 opacity: 0;
 transform: scale(0.75);
 position: absolute;
 inset: 0;
 display: flex;
 align-items: center;
 justify-content: center;
 transition: transform .3s var(--n-bezier), opacity .3s var(--n-bezier);
 `), cE("menu", `
 position: absolute;
 bottom: calc(100% - 8px);
 display: flex;
 flex-direction: column;
 opacity: 0;
 pointer-events: none;
 transition:
 opacity .3s var(--n-bezier),
 bottom .3s var(--n-bezier); 
 `, [c$1("> *", `
 margin-bottom: 16px;
 `), cB("float-button", `
 position: relative !important;
 `)])]);
  const floatButtonProps = Object.assign(Object.assign({}, useTheme.props), {
    width: {
      type: [Number, String],
      default: 40
    },
    height: {
      type: [Number, String],
      default: 40
    },
    left: [Number, String],
    right: [Number, String],
    top: [Number, String],
    bottom: [Number, String],
    shape: {
      type: String,
      default: "circle"
    },
    position: {
      type: String,
      default: "fixed"
    },
    type: {
      type: String,
      default: "default"
    },
    menuTrigger: String,
    showMenu: {
      type: Boolean,
      default: void 0
    },
    onUpdateShowMenu: {
      type: [Function, Array],
      default: void 0
    },
    "onUpdate:showMenu": {
      type: [Function, Array],
      default: void 0
    }
  });
  const FloatButton = vue.defineComponent({
    name: "FloatButton",
    props: floatButtonProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const selfElRef = vue.ref(null);
      const themeRef = useTheme("FloatButton", "-float-button", style$J, floatButtonLight, props, mergedClsPrefixRef);
      const floatButtonGroupInjection = vue.inject(floatButtonGroupInjectionKey, null);
      const uncontrolledShowMenuRef = vue.ref(false);
      const controlledShoeMenuRef = vue.toRef(props, "showMenu");
      const mergedShowMenuRef = useMergedState(controlledShoeMenuRef, uncontrolledShowMenuRef);
      function doUpdateShowMenu(value) {
        const {
          onUpdateShowMenu,
          "onUpdate:showMenu": _onUpdateShowMenu
        } = props;
        uncontrolledShowMenuRef.value = value;
        if (onUpdateShowMenu) {
          call(onUpdateShowMenu, value);
        }
        if (_onUpdateShowMenu) {
          call(_onUpdateShowMenu, value);
        }
      }
      const cssVarsRef = vue.computed(() => {
        const {
          self: {
            color,
            textColor,
            boxShadow,
            boxShadowHover,
            boxShadowPressed,
            colorHover,
            colorPrimary,
            colorPrimaryHover,
            textColorPrimary,
            borderRadiusSquare,
            colorPressed,
            colorPrimaryPressed
          },
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          }
        } = themeRef.value;
        const {
          type
        } = props;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-box-shadow": boxShadow,
          "--n-box-shadow-hover": boxShadowHover,
          "--n-box-shadow-pressed": boxShadowPressed,
          "--n-color": type === "primary" ? colorPrimary : color,
          "--n-text-color": type === "primary" ? textColorPrimary : textColor,
          "--n-color-hover": type === "primary" ? colorPrimaryHover : colorHover,
          "--n-color-pressed": type === "primary" ? colorPrimaryPressed : colorPressed,
          "--n-border-radius-square": borderRadiusSquare
        };
      });
      const inlineStyle = vue.computed(() => {
        const {
          width,
          height
        } = props;
        return Object.assign({
          position: floatButtonGroupInjection ? void 0 : props.position,
          width: formatLength(width),
          minHeight: formatLength(height)
        }, floatButtonGroupInjection ? null : {
          left: formatLength(props.left),
          right: formatLength(props.right),
          top: formatLength(props.top),
          bottom: formatLength(props.bottom)
        });
      });
      const mergedShapeRef = vue.computed(() => {
        return floatButtonGroupInjection ? floatButtonGroupInjection.shapeRef.value : props.shape;
      });
      const Mouseenter = () => {
        if (props.menuTrigger === "hover") {
          doUpdateShowMenu(true);
        }
      };
      const handleMouseleave = () => {
        if (props.menuTrigger === "hover" && mergedShowMenuRef.value) {
          doUpdateShowMenu(false);
        }
      };
      const handleClick2 = () => {
        if (props.menuTrigger === "click") {
          doUpdateShowMenu(!mergedShowMenuRef.value);
        }
      };
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("float-button", vue.computed(() => props.type[0]), cssVarsRef, props) : void 0;
      vue.onMounted(() => {
        const selfEl = selfElRef.value;
        if (selfEl) {
          on("mousemoveoutside", selfEl, handleMouseleave);
        }
      });
      vue.onBeforeUnmount(() => {
        const selfEl = selfElRef.value;
        if (selfEl) {
          off("mousemoveoutside", selfEl, handleMouseleave);
        }
      });
      return {
        inlineStyle,
        selfElRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        mergedClsPrefix: mergedClsPrefixRef,
        mergedShape: mergedShapeRef,
        mergedShowMenu: mergedShowMenuRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
        Mouseenter,
        handleMouseleave,
        handleClick: handleClick2
      };
    },
    render() {
      var _a;
      const {
        mergedClsPrefix,
        cssVars,
        mergedShape,
        type,
        menuTrigger,
        mergedShowMenu,
        themeClass,
        $slots,
        inlineStyle,
        onRender
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h("div", {
        ref: "selfElRef",
        class: [`${mergedClsPrefix}-float-button`, `${mergedClsPrefix}-float-button--${mergedShape}-shape`, `${mergedClsPrefix}-float-button--${type}-type`, mergedShowMenu && `${mergedClsPrefix}-float-button--show-menu`, themeClass],
        style: [cssVars, inlineStyle],
        onMouseenter: this.Mouseenter,
        onMouseleave: this.handleMouseleave,
        onClick: this.handleClick,
        role: "button"
      }, vue.h("div", {
        class: `${mergedClsPrefix}-float-button__fill`,
        "aria-hidden": true
      }), vue.h("div", {
        class: `${mergedClsPrefix}-float-button__body`
      }, (_a = $slots.default) === null || _a === void 0 ? void 0 : _a.call($slots), resolveWrappedSlot($slots.description, (children) => {
        if (children) {
          return vue.h("div", {
            class: `${mergedClsPrefix}-float-button__description`
          }, children);
        }
        return null;
      })), menuTrigger ? vue.h("div", {
        class: `${mergedClsPrefix}-float-button__close`
      }, vue.h(NBaseIcon, {
        clsPrefix: mergedClsPrefix
      }, {
        default: () => vue.h(ErrorIcon$1, null)
      })) : null, menuTrigger ? vue.h("div", {
        onClick: (e) => {
          e.stopPropagation();
        },
        "data-float-button-menu": true,
        class: `${mergedClsPrefix}-float-button__menu`
      }, resolveSlot($slots.menu, () => [])) : null);
    }
  });
  const GlobalStyle = vue.defineComponent({
    name: "GlobalStyle",
    setup() {
      if (typeof document === "undefined")
        return;
      const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
      const {
        body
      } = document;
      const {
        style: style2
      } = body;
      let styleApplied = false;
      let firstApply = true;
      vue.onBeforeMount(() => {
        vue.watchEffect(() => {
          var _a, _b;
          const {
            textColor2,
            fontSize: fontSize2,
            fontFamily: fontFamily2,
            bodyColor,
            cubicBezierEaseInOut: cubicBezierEaseInOut2,
            lineHeight: lineHeight2
          } = NConfigProvider2 ? merge$1({}, ((_a = NConfigProvider2.mergedThemeRef.value) === null || _a === void 0 ? void 0 : _a.common) || commonLight, (_b = NConfigProvider2.mergedThemeOverridesRef.value) === null || _b === void 0 ? void 0 : _b.common) : commonLight;
          if (styleApplied || !body.hasAttribute("n-styled")) {
            style2.setProperty("-webkit-text-size-adjust", "100%");
            style2.setProperty("-webkit-tap-highlight-color", "transparent");
            style2.padding = "0";
            style2.margin = "0";
            style2.backgroundColor = bodyColor;
            style2.color = textColor2;
            style2.fontSize = fontSize2;
            style2.fontFamily = fontFamily2;
            style2.lineHeight = lineHeight2;
            const transition = `color .3s ${cubicBezierEaseInOut2}, background-color .3s ${cubicBezierEaseInOut2}`;
            if (firstApply) {
              setTimeout(() => {
                style2.transition = transition;
              }, 0);
            } else {
              style2.transition = transition;
            }
            body.setAttribute("n-styled", "");
            styleApplied = true;
            firstApply = false;
          } else {
            warn$2("global-style", "More than one n-global-style exist in the document.body. Only the first mounted one will work.");
          }
        });
      });
      vue.onUnmounted(() => {
        if (styleApplied) {
          body.removeAttribute("n-styled");
        }
      });
    },
    render() {
      return null;
    }
  });
  const style$I = cB("gradient-text", `
 display: inline-block;
 font-weight: var(--n-font-weight);
 -webkit-background-clip: text;
 background-clip: text;
 color: #0000;
 white-space: nowrap;
 background-image: linear-gradient(var(--n-rotate), var(--n-color-start) 0%, var(--n-color-end) 100%);
 transition:
 --n-color-start .3s var(--n-bezier),
 --n-color-end .3s var(--n-bezier);
`);
  const gradientTextProps = Object.assign(Object.assign({}, useTheme.props), {
    size: [String, Number],
    fontSize: [String, Number],
    type: {
      type: String,
      default: "primary"
    },
    color: [Object, String],
    gradient: [Object, String]
  });
  const GradientText = vue.defineComponent({
    name: "GradientText",
    props: gradientTextProps,
    setup(props) {
      useHoudini();
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const compatibleTypeRef = vue.computed(() => {
        const {
          type
        } = props;
        if (type === "danger")
          return "error";
        return type;
      });
      const styleFontSizeRef = vue.computed(() => {
        let fontSize2 = props.size || props.fontSize;
        if (fontSize2)
          fontSize2 = formatLength(fontSize2);
        return fontSize2 || void 0;
      });
      const styleBgImageRef = vue.computed(() => {
        const gradient = props.color || props.gradient;
        if (typeof gradient === "string") {
          return gradient;
        } else if (gradient) {
          const deg = gradient.deg || 0;
          const from = gradient.from;
          const to = gradient.to;
          return `linear-gradient(${deg}deg, ${from} 0%, ${to} 100%)`;
        }
        return void 0;
      });
      const themeRef = useTheme("GradientText", "-gradient-text", style$I, gradientTextLight$1, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          value: type
        } = compatibleTypeRef;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            rotate,
            [createKey("colorStart", type)]: colorStart,
            [createKey("colorEnd", type)]: colorEnd,
            fontWeight
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-rotate": rotate,
          "--n-color-start": colorStart,
          "--n-color-end": colorEnd,
          "--n-font-weight": fontWeight
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("gradient-text", vue.computed(() => compatibleTypeRef.value[0]), cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        compatibleType: compatibleTypeRef,
        styleFontSize: styleFontSizeRef,
        styleBgImage: styleBgImageRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      const {
        mergedClsPrefix,
        onRender
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h("span", {
        class: [`${mergedClsPrefix}-gradient-text`, `${mergedClsPrefix}-gradient-text--${this.compatibleType}-type`, this.themeClass],
        style: [{
          fontSize: this.styleFontSize,
          backgroundImage: this.styleBgImage
        }, this.cssVars]
      }, this.$slots);
    }
  });
  const defaultBreakpoints = {
    xs: 0,
    // mobile
    s: 640,
    // tablet
    m: 1024,
    // laptop s
    l: 1280,
    // laptop
    xl: 1536,
    // laptop l
    xxl: 1920
    // normal desktop display
  };
  const defaultCols = 24;
  const SSR_ATTR_NAME = "__ssr__";
  const gridProps = {
    layoutShiftDisabled: Boolean,
    responsive: {
      type: [String, Boolean],
      default: "self"
    },
    cols: {
      type: [Number, String],
      default: defaultCols
    },
    itemResponsive: Boolean,
    collapsed: Boolean,
    // may create grid rows < collapsedRows since a item may take all the row
    collapsedRows: {
      type: Number,
      default: 1
    },
    itemStyle: [Object, String],
    xGap: {
      type: [Number, String],
      default: 0
    },
    yGap: {
      type: [Number, String],
      default: 0
    }
  };
  const NGrid = vue.defineComponent({
    name: "Grid",
    inheritAttrs: false,
    props: gridProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        mergedBreakpointsRef
      } = useConfig(props);
      const numRegex = /^\d+$/;
      const widthRef = vue.ref(void 0);
      const breakpointsRef = useBreakpoints((mergedBreakpointsRef === null || mergedBreakpointsRef === void 0 ? void 0 : mergedBreakpointsRef.value) || defaultBreakpoints);
      const isResponsiveRef = useMemo(() => {
        if (props.itemResponsive)
          return true;
        if (!numRegex.test(props.cols.toString()))
          return true;
        if (!numRegex.test(props.xGap.toString()))
          return true;
        if (!numRegex.test(props.yGap.toString()))
          return true;
        return false;
      });
      const responsiveQueryRef = vue.computed(() => {
        if (!isResponsiveRef.value)
          return void 0;
        return props.responsive === "self" ? widthRef.value : breakpointsRef.value;
      });
      const responsiveColsRef = useMemo(() => {
        var _a;
        return (_a = Number(parseResponsivePropValue(props.cols.toString(), responsiveQueryRef.value))) !== null && _a !== void 0 ? _a : defaultCols;
      });
      const responsiveXGapRef = useMemo(() => parseResponsivePropValue(props.xGap.toString(), responsiveQueryRef.value));
      const responsiveYGapRef = useMemo(() => parseResponsivePropValue(props.yGap.toString(), responsiveQueryRef.value));
      const handleResize = (entry) => {
        widthRef.value = entry.contentRect.width;
      };
      const handleResizeRaf = (entry) => {
        beforeNextFrameOnce(handleResize, entry);
      };
      const overflowRef = vue.ref(false);
      const handleResizeRef = vue.computed(() => {
        if (props.responsive === "self") {
          return handleResizeRaf;
        }
        return void 0;
      });
      const isSsrRef = vue.ref(false);
      const contentElRef = vue.ref();
      vue.onMounted(() => {
        const {
          value: contentEl
        } = contentElRef;
        if (contentEl) {
          if (contentEl.hasAttribute(SSR_ATTR_NAME)) {
            contentEl.removeAttribute(SSR_ATTR_NAME);
            isSsrRef.value = true;
          }
        }
      });
      vue.provide(gridInjectionKey, {
        layoutShiftDisabledRef: vue.toRef(props, "layoutShiftDisabled"),
        isSsrRef,
        itemStyleRef: vue.toRef(props, "itemStyle"),
        xGapRef: responsiveXGapRef,
        overflowRef
      });
      return {
        isSsr: !isBrowser$2,
        contentEl: contentElRef,
        mergedClsPrefix: mergedClsPrefixRef,
        style: vue.computed(() => {
          if (props.layoutShiftDisabled) {
            return {
              width: "100%",
              display: "grid",
              gridTemplateColumns: `repeat(${props.cols}, minmax(0, 1fr))`,
              columnGap: pxfy(props.xGap),
              rowGap: pxfy(props.yGap)
            };
          }
          return {
            width: "100%",
            display: "grid",
            gridTemplateColumns: `repeat(${responsiveColsRef.value}, minmax(0, 1fr))`,
            columnGap: pxfy(responsiveXGapRef.value),
            rowGap: pxfy(responsiveYGapRef.value)
          };
        }),
        isResponsive: isResponsiveRef,
        responsiveQuery: responsiveQueryRef,
        responsiveCols: responsiveColsRef,
        handleResize: handleResizeRef,
        overflow: overflowRef
      };
    },
    render() {
      if (this.layoutShiftDisabled) {
        return vue.h("div", vue.mergeProps({
          ref: "contentEl",
          class: `${this.mergedClsPrefix}-grid`,
          style: this.style
        }, this.$attrs), this.$slots);
      }
      const renderContent = () => {
        var _a, _b, _c, _d, _e, _f, _g;
        this.overflow = false;
        const rawChildren = flatten$3(getSlot$1(this));
        const childrenAndRawSpan = [];
        const {
          collapsed,
          collapsedRows,
          responsiveCols,
          responsiveQuery
        } = this;
        rawChildren.forEach((child) => {
          var _a2, _b2, _c2, _d2, _e2;
          if (((_a2 = child === null || child === void 0 ? void 0 : child.type) === null || _a2 === void 0 ? void 0 : _a2.__GRID_ITEM__) !== true)
            return;
          if (isNodeVShowFalse(child)) {
            const clonedNode = vue.cloneVNode(child);
            if (clonedNode.props) {
              clonedNode.props.privateShow = false;
            } else {
              clonedNode.props = {
                privateShow: false
              };
            }
            childrenAndRawSpan.push({
              child: clonedNode,
              rawChildSpan: 0
            });
            return;
          }
          child.dirs = ((_b2 = child.dirs) === null || _b2 === void 0 ? void 0 : _b2.filter(({
            dir
          }) => dir !== vue.vShow)) || null;
          if (((_c2 = child.dirs) === null || _c2 === void 0 ? void 0 : _c2.length) === 0) {
            child.dirs = null;
          }
          const clonedChild = vue.cloneVNode(child);
          const rawChildSpan = Number((_e2 = parseResponsivePropValue((_d2 = clonedChild.props) === null || _d2 === void 0 ? void 0 : _d2.span, responsiveQuery)) !== null && _e2 !== void 0 ? _e2 : defaultSpan$1);
          if (rawChildSpan === 0)
            return;
          childrenAndRawSpan.push({
            child: clonedChild,
            rawChildSpan
          });
        });
        let suffixSpan = 0;
        const maybeSuffixNode = (_a = childrenAndRawSpan[childrenAndRawSpan.length - 1]) === null || _a === void 0 ? void 0 : _a.child;
        if (maybeSuffixNode === null || maybeSuffixNode === void 0 ? void 0 : maybeSuffixNode.props) {
          const suffixPropValue = (_b = maybeSuffixNode.props) === null || _b === void 0 ? void 0 : _b.suffix;
          if (suffixPropValue !== void 0 && suffixPropValue !== false) {
            suffixSpan = Number((_d = parseResponsivePropValue((_c = maybeSuffixNode.props) === null || _c === void 0 ? void 0 : _c.span, responsiveQuery)) !== null && _d !== void 0 ? _d : defaultSpan$1);
            maybeSuffixNode.props.privateSpan = suffixSpan;
            maybeSuffixNode.props.privateColStart = responsiveCols + 1 - suffixSpan;
            maybeSuffixNode.props.privateShow = (_e = maybeSuffixNode.props.privateShow) !== null && _e !== void 0 ? _e : true;
          }
        }
        let spanCounter = 0;
        let done = false;
        for (const {
          child,
          rawChildSpan
        } of childrenAndRawSpan) {
          if (done) {
            this.overflow = true;
          }
          if (!done) {
            const childOffset = Number((_g = parseResponsivePropValue((_f = child.props) === null || _f === void 0 ? void 0 : _f.offset, responsiveQuery)) !== null && _g !== void 0 ? _g : 0);
            const childSpan = Math.min(rawChildSpan + childOffset, responsiveCols);
            if (!child.props) {
              child.props = {
                privateSpan: childSpan,
                privateOffset: childOffset
              };
            } else {
              child.props.privateSpan = childSpan;
              child.props.privateOffset = childOffset;
            }
            if (collapsed) {
              const remainder = spanCounter % responsiveCols;
              if (childSpan + remainder > responsiveCols) {
                spanCounter += responsiveCols - remainder;
              }
              if (childSpan + spanCounter + suffixSpan > collapsedRows * responsiveCols) {
                done = true;
              } else {
                spanCounter += childSpan;
              }
            }
          }
          if (done) {
            if (child.props) {
              if (child.props.privateShow !== true) {
                child.props.privateShow = false;
              }
            } else {
              child.props = {
                privateShow: false
              };
            }
          }
        }
        return vue.h("div", vue.mergeProps({
          ref: "contentEl",
          class: `${this.mergedClsPrefix}-grid`,
          style: this.style,
          [SSR_ATTR_NAME]: this.isSsr || void 0
        }, this.$attrs), childrenAndRawSpan.map(({
          child
        }) => child));
      };
      return this.isResponsive && this.responsive === "self" ? vue.h(VResizeObserver, {
        onResize: this.handleResize
      }, {
        default: renderContent
      }) : renderContent();
    }
  });
  function splitAndMarkByRegex(str, regex) {
    const result = [];
    let lastIndex = 0;
    let match2;
    while ((match2 = regex.exec(str)) !== null) {
      if (match2.index > lastIndex) {
        result.push({
          text: str.slice(lastIndex, match2.index),
          isMatch: false
        });
      }
      result.push({
        text: match2[0],
        isMatch: true
      });
      lastIndex = regex.lastIndex;
      if (!regex.global) {
        break;
      }
    }
    if (lastIndex < str.length) {
      result.push({
        text: str.slice(lastIndex),
        isMatch: false
      });
    }
    return result;
  }
  const highlightProps = {
    highlightTag: {
      type: String,
      default: "mark"
    },
    caseSensitive: Boolean,
    autoEscape: {
      type: Boolean,
      default: true
    },
    text: String,
    patterns: {
      type: Array,
      default: () => []
    },
    highlightClass: String,
    highlightStyle: [Object, String]
  };
  const Highlight = vue.defineComponent({
    name: "Highlight",
    props: highlightProps,
    setup(props) {
      const {
        mergedClsPrefixRef
      } = useConfig();
      const escapeRegExp = (text2) => text2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      const highlightedNodeRef = vue.computed(() => {
        const mergedClsPrefix = mergedClsPrefixRef.value;
        let children = [];
        const {
          patterns: patterns2,
          text: text2
        } = props;
        if (patterns2.length === 0 || !text2) {
          children = [text2];
        } else {
          const {
            highlightTag,
            caseSensitive,
            autoEscape,
            highlightClass,
            highlightStyle
          } = props;
          const pattern = patterns2.map((word) => autoEscape ? escapeRegExp(word) : word).join("|");
          const regex = new RegExp(`(${pattern})`, caseSensitive ? "g" : "gi");
          const splitItems = splitAndMarkByRegex(text2, regex);
          children = splitItems.map(({
            text: text3,
            isMatch
          }) => {
            if (isMatch) {
              return vue.h(highlightTag, {
                class: [`${mergedClsPrefix}-highlight__mark`, highlightClass],
                style: highlightStyle
              }, text3);
            }
            return text3;
          });
        }
        return vue.h("span", {
          class: `${mergedClsPrefix}-highlight`
        }, children);
      });
      return {
        highlightedNode: highlightedNodeRef,
        mergedClsPrefix: mergedClsPrefixRef
      };
    },
    render() {
      return this.highlightedNode;
    }
  });
  function self$6(vars) {
    const {
      primaryColor,
      baseColor
    } = vars;
    return {
      color: primaryColor,
      iconColor: baseColor
    };
  }
  const iconWrapperLight = {
    name: "IconWrapper",
    common: commonLight,
    self: self$6
  };
  const iconWrapperLight$1 = iconWrapperLight;
  const style$H = cB("icon-wrapper", `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 background-color: var(--n-color);
 display: inline-flex;
 align-items: center;
 justify-content: center;
 color: var(--n-icon-color);
`);
  const iconWrapperProps = Object.assign(Object.assign({}, useTheme.props), {
    size: {
      type: Number,
      default: 24
    },
    borderRadius: {
      type: Number,
      default: 6
    },
    color: String,
    iconColor: String
  });
  const NIconWrapper = vue.defineComponent({
    name: "IconWrapper",
    props: iconWrapperProps,
    setup(props, {
      slots
    }) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("IconWrapper", "-icon-wrapper", style$H, iconWrapperLight$1, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            color,
            iconColor
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-color": color,
          "--n-icon-color": iconColor
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("icon-wrapper", void 0, cssVarsRef, props) : void 0;
      return () => {
        const size2 = formatLength(props.size);
        themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender();
        return vue.h("div", {
          class: [`${mergedClsPrefixRef.value}-icon-wrapper`, themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value],
          style: [cssVarsRef === null || cssVarsRef === void 0 ? void 0 : cssVarsRef.value, {
            height: size2,
            width: size2,
            borderRadius: formatLength(props.borderRadius),
            backgroundColor: props.color,
            color: props.iconColor
          }]
        }, slots);
      };
    }
  });
  const imagePreviewSharedProps = Object.assign(Object.assign({}, useTheme.props), {
    onPreviewPrev: Function,
    onPreviewNext: Function,
    showToolbar: {
      type: Boolean,
      default: true
    },
    showToolbarTooltip: Boolean,
    renderToolbar: Function
  });
  const imageContextKey = createInjectionKey("n-image");
  function self$5() {
    return {
      toolbarIconColor: "rgba(255, 255, 255, .9)",
      toolbarColor: "rgba(0, 0, 0, .35)",
      toolbarBoxShadow: "none",
      toolbarBorderRadius: "24px"
    };
  }
  const imageLight = createTheme({
    name: "Image",
    common: commonLight,
    peers: {
      Tooltip: tooltipLight$1
    },
    self: self$5
  });
  const prevIcon = vue.h("svg", {
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, vue.h("path", {
    d: "M6 5C5.75454 5 5.55039 5.17688 5.50806 5.41012L5.5 5.5V14.5C5.5 14.7761 5.72386 15 6 15C6.24546 15 6.44961 14.8231 6.49194 14.5899L6.5 14.5V5.5C6.5 5.22386 6.27614 5 6 5ZM13.8536 5.14645C13.68 4.97288 13.4106 4.9536 13.2157 5.08859L13.1464 5.14645L8.64645 9.64645C8.47288 9.82001 8.4536 10.0894 8.58859 10.2843L8.64645 10.3536L13.1464 14.8536C13.3417 15.0488 13.6583 15.0488 13.8536 14.8536C14.0271 14.68 14.0464 14.4106 13.9114 14.2157L13.8536 14.1464L9.70711 10L13.8536 5.85355C14.0488 5.65829 14.0488 5.34171 13.8536 5.14645Z",
    fill: "currentColor"
  }));
  const nextIcon = vue.h("svg", {
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, vue.h("path", {
    d: "M13.5 5C13.7455 5 13.9496 5.17688 13.9919 5.41012L14 5.5V14.5C14 14.7761 13.7761 15 13.5 15C13.2545 15 13.0504 14.8231 13.0081 14.5899L13 14.5V5.5C13 5.22386 13.2239 5 13.5 5ZM5.64645 5.14645C5.82001 4.97288 6.08944 4.9536 6.28431 5.08859L6.35355 5.14645L10.8536 9.64645C11.0271 9.82001 11.0464 10.0894 10.9114 10.2843L10.8536 10.3536L6.35355 14.8536C6.15829 15.0488 5.84171 15.0488 5.64645 14.8536C5.47288 14.68 5.4536 14.4106 5.58859 14.2157L5.64645 14.1464L9.79289 10L5.64645 5.85355C5.45118 5.65829 5.45118 5.34171 5.64645 5.14645Z",
    fill: "currentColor"
  }));
  const closeIcon = vue.h("svg", {
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, vue.h("path", {
    d: "M4.089 4.216l.057-.07a.5.5 0 0 1 .638-.057l.07.057L10 9.293l5.146-5.147a.5.5 0 0 1 .638-.057l.07.057a.5.5 0 0 1 .057.638l-.057.07L10.707 10l5.147 5.146a.5.5 0 0 1 .057.638l-.057.07a.5.5 0 0 1-.638.057l-.07-.057L10 10.707l-5.146 5.147a.5.5 0 0 1-.638.057l-.07-.057a.5.5 0 0 1-.057-.638l.057-.07L9.293 10L4.146 4.854a.5.5 0 0 1-.057-.638l.057-.07l-.057.07z",
    fill: "currentColor"
  }));
  const style$G = c$1([c$1("body >", [cB("image-container", "position: fixed;")]), cB("image-preview-container", `
 position: fixed;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 `), cB("image-preview-overlay", `
 z-index: -1;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 background: rgba(0, 0, 0, .3);
 `, [fadeInTransition()]), cB("image-preview-toolbar", `
 z-index: 1;
 position: absolute;
 left: 50%;
 transform: translateX(-50%);
 border-radius: var(--n-toolbar-border-radius);
 height: 48px;
 bottom: 40px;
 padding: 0 12px;
 background: var(--n-toolbar-color);
 box-shadow: var(--n-toolbar-box-shadow);
 color: var(--n-toolbar-icon-color);
 transition: color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 `, [cB("base-icon", `
 padding: 0 8px;
 font-size: 28px;
 cursor: pointer;
 `), fadeInTransition()]), cB("image-preview-wrapper", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 pointer-events: none;
 `, [fadeInScaleUpTransition()]), cB("image-preview", `
 user-select: none;
 -webkit-user-select: none;
 pointer-events: all;
 margin: auto;
 max-height: calc(100vh - 32px);
 max-width: calc(100vw - 32px);
 transition: transform .3s var(--n-bezier);
 `), cB("image", `
 display: inline-flex;
 max-height: 100%;
 max-width: 100%;
 `, [cNotM("preview-disabled", `
 cursor: pointer;
 `), c$1("img", `
 border-radius: inherit;
 `)])]);
  const BLEEDING = 32;
  const NImagePreview = vue.defineComponent({
    name: "ImagePreview",
    props: Object.assign(Object.assign({}, imagePreviewSharedProps), {
      onNext: Function,
      onPrev: Function,
      clsPrefix: {
        type: String,
        required: true
      }
    }),
    setup(props) {
      const themeRef = useTheme("Image", "-image", style$G, imageLight, props, vue.toRef(props, "clsPrefix"));
      let thumbnailEl = null;
      const previewRef = vue.ref(null);
      const previewWrapperRef = vue.ref(null);
      const previewSrcRef = vue.ref(void 0);
      const showRef = vue.ref(false);
      const displayedRef = vue.ref(false);
      const {
        localeRef
      } = useLocale("Image");
      function syncTransformOrigin() {
        const {
          value: previewWrapper
        } = previewWrapperRef;
        if (!thumbnailEl || !previewWrapper)
          return;
        const {
          style: style2
        } = previewWrapper;
        const tbox = thumbnailEl.getBoundingClientRect();
        const tx = tbox.left + tbox.width / 2;
        const ty = tbox.top + tbox.height / 2;
        style2.transformOrigin = `${tx}px ${ty}px`;
      }
      function handleKeydown(e) {
        var _a, _b;
        switch (e.key) {
          case " ":
            e.preventDefault();
            break;
          case "ArrowLeft":
            (_a = props.onPrev) === null || _a === void 0 ? void 0 : _a.call(props);
            break;
          case "ArrowRight":
            (_b = props.onNext) === null || _b === void 0 ? void 0 : _b.call(props);
            break;
          case "Escape":
            toggleShow();
            break;
        }
      }
      vue.watch(showRef, (value) => {
        if (value) {
          on("keydown", document, handleKeydown);
        } else {
          off("keydown", document, handleKeydown);
        }
      });
      vue.onBeforeUnmount(() => {
        off("keydown", document, handleKeydown);
      });
      let startX = 0;
      let startY = 0;
      let offsetX = 0;
      let offsetY = 0;
      let startOffsetX = 0;
      let startOffsetY = 0;
      let mouseDownClientX = 0;
      let mouseDownClientY = 0;
      let dragging = false;
      function handleMouseMove(e) {
        const {
          clientX,
          clientY
        } = e;
        offsetX = clientX - startX;
        offsetY = clientY - startY;
        beforeNextFrameOnce(derivePreviewStyle);
      }
      function getMoveStrategy(opts) {
        const {
          mouseUpClientX,
          mouseUpClientY,
          mouseDownClientX: mouseDownClientX2,
          mouseDownClientY: mouseDownClientY2
        } = opts;
        const deltaHorizontal = mouseDownClientX2 - mouseUpClientX;
        const deltaVertical = mouseDownClientY2 - mouseUpClientY;
        const moveVerticalDirection = `vertical${deltaVertical > 0 ? "Top" : "Bottom"}`;
        const moveHorizontalDirection = `horizontal${deltaHorizontal > 0 ? "Left" : "Right"}`;
        return {
          moveVerticalDirection,
          moveHorizontalDirection,
          deltaHorizontal,
          deltaVertical
        };
      }
      function getDerivedOffset(moveStrategy) {
        const {
          value: preview
        } = previewRef;
        if (!preview)
          return {
            offsetX: 0,
            offsetY: 0
          };
        const pbox = preview.getBoundingClientRect();
        const {
          moveVerticalDirection,
          moveHorizontalDirection,
          deltaHorizontal,
          deltaVertical
        } = moveStrategy || {};
        let nextOffsetX = 0;
        let nextOffsetY = 0;
        if (pbox.width <= window.innerWidth) {
          nextOffsetX = 0;
        } else if (pbox.left > 0) {
          nextOffsetX = (pbox.width - window.innerWidth) / 2;
        } else if (pbox.right < window.innerWidth) {
          nextOffsetX = -(pbox.width - window.innerWidth) / 2;
        } else if (moveHorizontalDirection === "horizontalRight") {
          nextOffsetX = Math.min((pbox.width - window.innerWidth) / 2, startOffsetX - (deltaHorizontal !== null && deltaHorizontal !== void 0 ? deltaHorizontal : 0));
        } else {
          nextOffsetX = Math.max(-((pbox.width - window.innerWidth) / 2), startOffsetX - (deltaHorizontal !== null && deltaHorizontal !== void 0 ? deltaHorizontal : 0));
        }
        if (pbox.height <= window.innerHeight) {
          nextOffsetY = 0;
        } else if (pbox.top > 0) {
          nextOffsetY = (pbox.height - window.innerHeight) / 2;
        } else if (pbox.bottom < window.innerHeight) {
          nextOffsetY = -(pbox.height - window.innerHeight) / 2;
        } else if (moveVerticalDirection === "verticalBottom") {
          nextOffsetY = Math.min((pbox.height - window.innerHeight) / 2, startOffsetY - (deltaVertical !== null && deltaVertical !== void 0 ? deltaVertical : 0));
        } else {
          nextOffsetY = Math.max(-((pbox.height - window.innerHeight) / 2), startOffsetY - (deltaVertical !== null && deltaVertical !== void 0 ? deltaVertical : 0));
        }
        return {
          offsetX: nextOffsetX,
          offsetY: nextOffsetY
        };
      }
      function handleMouseUp(e) {
        off("mousemove", document, handleMouseMove);
        off("mouseup", document, handleMouseUp);
        const {
          clientX: mouseUpClientX,
          clientY: mouseUpClientY
        } = e;
        dragging = false;
        const moveStrategy = getMoveStrategy({
          mouseUpClientX,
          mouseUpClientY,
          mouseDownClientX,
          mouseDownClientY
        });
        const offset = getDerivedOffset(moveStrategy);
        offsetX = offset.offsetX;
        offsetY = offset.offsetY;
        derivePreviewStyle();
      }
      const imageContext = vue.inject(imageContextKey, null);
      function handlePreviewMousedown(e) {
        var _a, _b;
        (_b = (_a = imageContext === null || imageContext === void 0 ? void 0 : imageContext.previewedImgPropsRef.value) === null || _a === void 0 ? void 0 : _a.onMousedown) === null || _b === void 0 ? void 0 : _b.call(_a, e);
        if (e.button !== 0)
          return;
        const {
          clientX,
          clientY
        } = e;
        dragging = true;
        startX = clientX - offsetX;
        startY = clientY - offsetY;
        startOffsetX = offsetX;
        startOffsetY = offsetY;
        mouseDownClientX = clientX;
        mouseDownClientY = clientY;
        derivePreviewStyle();
        on("mousemove", document, handleMouseMove);
        on("mouseup", document, handleMouseUp);
      }
      const scaleRadix = 1.5;
      let scaleExp = 0;
      let scale = 1;
      let rotate = 0;
      function handlePreviewDblclick(e) {
        var _a, _b;
        (_b = (_a = imageContext === null || imageContext === void 0 ? void 0 : imageContext.previewedImgPropsRef.value) === null || _a === void 0 ? void 0 : _a.onDblclick) === null || _b === void 0 ? void 0 : _b.call(_a, e);
        const originalImageSizeScale = getOrignalImageSizeScale();
        scale = scale === originalImageSizeScale ? 1 : originalImageSizeScale;
        derivePreviewStyle();
      }
      function resetScale() {
        scale = 1;
        scaleExp = 0;
      }
      function handleSwitchPrev() {
        var _a;
        resetScale();
        rotate = 0;
        (_a = props.onPrev) === null || _a === void 0 ? void 0 : _a.call(props);
      }
      function handleSwitchNext() {
        var _a;
        resetScale();
        rotate = 0;
        (_a = props.onNext) === null || _a === void 0 ? void 0 : _a.call(props);
      }
      function rotateCounterclockwise() {
        rotate -= 90;
        derivePreviewStyle();
      }
      function rotateClockwise() {
        rotate += 90;
        derivePreviewStyle();
      }
      function getMaxScale() {
        const {
          value: preview
        } = previewRef;
        if (!preview)
          return 1;
        const {
          innerWidth,
          innerHeight
        } = window;
        const heightMaxScale = Math.max(1, preview.naturalHeight / (innerHeight - BLEEDING));
        const widthMaxScale = Math.max(1, preview.naturalWidth / (innerWidth - BLEEDING));
        return Math.max(3, heightMaxScale * 2, widthMaxScale * 2);
      }
      function getOrignalImageSizeScale() {
        const {
          value: preview
        } = previewRef;
        if (!preview)
          return 1;
        const {
          innerWidth,
          innerHeight
        } = window;
        const heightScale = preview.naturalHeight / (innerHeight - BLEEDING);
        const widthScale = preview.naturalWidth / (innerWidth - BLEEDING);
        if (heightScale < 1 && widthScale < 1) {
          return 1;
        }
        return Math.max(heightScale, widthScale);
      }
      function zoomIn() {
        const maxScale = getMaxScale();
        if (scale < maxScale) {
          scaleExp += 1;
          scale = Math.min(maxScale, Math.pow(scaleRadix, scaleExp));
          derivePreviewStyle();
        }
      }
      function zoomOut() {
        if (scale > 0.5) {
          const originalScale = scale;
          scaleExp -= 1;
          scale = Math.max(0.5, Math.pow(scaleRadix, scaleExp));
          const diff = originalScale - scale;
          derivePreviewStyle(false);
          const offset = getDerivedOffset();
          scale += diff;
          derivePreviewStyle(false);
          scale -= diff;
          offsetX = offset.offsetX;
          offsetY = offset.offsetY;
          derivePreviewStyle();
        }
      }
      function handleDownloadClick() {
        const src = previewSrcRef.value;
        if (src) {
          download(src, void 0);
        }
      }
      function derivePreviewStyle(transition = true) {
        var _a;
        const {
          value: preview
        } = previewRef;
        if (!preview)
          return;
        const {
          style: style2
        } = preview;
        const controlledStyle = vue.normalizeStyle((_a = imageContext === null || imageContext === void 0 ? void 0 : imageContext.previewedImgPropsRef.value) === null || _a === void 0 ? void 0 : _a.style);
        let controlledStyleString = "";
        if (typeof controlledStyle === "string") {
          controlledStyleString = `${controlledStyle};`;
        } else {
          for (const key in controlledStyle) {
            controlledStyleString += `${kebabCase(key)}: ${controlledStyle[key]};`;
          }
        }
        const transformStyle = `transform-origin: center; transform: translateX(${offsetX}px) translateY(${offsetY}px) rotate(${rotate}deg) scale(${scale});`;
        if (dragging) {
          style2.cssText = `${controlledStyleString}cursor: grabbing; transition: none;${transformStyle}`;
        } else {
          style2.cssText = `${controlledStyleString}cursor: grab;${transformStyle}${transition ? "" : "transition: none;"}`;
        }
        if (!transition) {
          void preview.offsetHeight;
        }
      }
      function toggleShow() {
        showRef.value = !showRef.value;
        displayedRef.value = true;
      }
      function resizeToOrignalImageSize() {
        scale = getOrignalImageSizeScale();
        scaleExp = Math.ceil(Math.log(scale) / Math.log(scaleRadix));
        offsetX = 0;
        offsetY = 0;
        derivePreviewStyle();
      }
      const exposedMethods = {
        setPreviewSrc: (src) => {
          previewSrcRef.value = src;
        },
        setThumbnailEl: (el) => {
          thumbnailEl = el;
        },
        toggleShow
      };
      function withTooltip(node, tooltipKey) {
        if (props.showToolbarTooltip) {
          const {
            value: theme
          } = themeRef;
          return vue.h(NTooltip, {
            to: false,
            theme: theme.peers.Tooltip,
            themeOverrides: theme.peerOverrides.Tooltip,
            keepAliveOnHover: false
          }, {
            default: () => {
              return localeRef.value[tooltipKey];
            },
            trigger: () => node
          });
        } else {
          return node;
        }
      }
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            toolbarIconColor,
            toolbarBorderRadius,
            toolbarBoxShadow,
            toolbarColor
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-toolbar-icon-color": toolbarIconColor,
          "--n-toolbar-color": toolbarColor,
          "--n-toolbar-border-radius": toolbarBorderRadius,
          "--n-toolbar-box-shadow": toolbarBoxShadow
        };
      });
      const {
        inlineThemeDisabled
      } = useConfig();
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("image-preview", void 0, cssVarsRef, props) : void 0;
      return Object.assign({
        previewRef,
        previewWrapperRef,
        previewSrc: previewSrcRef,
        show: showRef,
        appear: isMounted(),
        displayed: displayedRef,
        previewedImgProps: imageContext === null || imageContext === void 0 ? void 0 : imageContext.previewedImgPropsRef,
        handleWheel(e) {
          e.preventDefault();
        },
        handlePreviewMousedown,
        handlePreviewDblclick,
        syncTransformOrigin,
        handleAfterLeave: () => {
          resetScale();
          rotate = 0;
          displayedRef.value = false;
        },
        handleDragStart: (e) => {
          var _a, _b;
          (_b = (_a = imageContext === null || imageContext === void 0 ? void 0 : imageContext.previewedImgPropsRef.value) === null || _a === void 0 ? void 0 : _a.onDragstart) === null || _b === void 0 ? void 0 : _b.call(_a, e);
          e.preventDefault();
        },
        zoomIn,
        zoomOut,
        handleDownloadClick,
        rotateCounterclockwise,
        rotateClockwise,
        handleSwitchPrev,
        handleSwitchNext,
        withTooltip,
        resizeToOrignalImageSize,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      }, exposedMethods);
    },
    render() {
      var _a, _b;
      const {
        clsPrefix,
        renderToolbar,
        withTooltip
      } = this;
      const prevNode = withTooltip(vue.h(NBaseIcon, {
        clsPrefix,
        onClick: this.handleSwitchPrev
      }, {
        default: () => prevIcon
      }), "tipPrevious");
      const nextNode = withTooltip(vue.h(NBaseIcon, {
        clsPrefix,
        onClick: this.handleSwitchNext
      }, {
        default: () => nextIcon
      }), "tipNext");
      const rotateCounterclockwiseNode = withTooltip(vue.h(NBaseIcon, {
        clsPrefix,
        onClick: this.rotateCounterclockwise
      }, {
        default: () => vue.h(RotateCounterclockwiseIcon, null)
      }), "tipCounterclockwise");
      const rotateClockwiseNode = withTooltip(vue.h(NBaseIcon, {
        clsPrefix,
        onClick: this.rotateClockwise
      }, {
        default: () => vue.h(RotateClockwiseIcon, null)
      }), "tipClockwise");
      const originalSizeNode = withTooltip(vue.h(NBaseIcon, {
        clsPrefix,
        onClick: this.resizeToOrignalImageSize
      }, {
        default: () => {
          return vue.h(ResizeSmallIcon, null);
        }
      }), "tipOriginalSize");
      const zoomOutNode = withTooltip(vue.h(NBaseIcon, {
        clsPrefix,
        onClick: this.zoomOut
      }, {
        default: () => vue.h(ZoomOutIcon, null)
      }), "tipZoomOut");
      const downloadNode = withTooltip(vue.h(NBaseIcon, {
        clsPrefix,
        onClick: this.handleDownloadClick
      }, {
        default: () => vue.h(DownloadIcon, null)
      }), "tipDownload");
      const closeNode = withTooltip(vue.h(NBaseIcon, {
        clsPrefix,
        onClick: this.toggleShow
      }, {
        default: () => closeIcon
      }), "tipClose");
      const zoomInNode = withTooltip(vue.h(NBaseIcon, {
        clsPrefix,
        onClick: this.zoomIn
      }, {
        default: () => vue.h(ZoomInIcon, null)
      }), "tipZoomIn");
      return vue.h(vue.Fragment, null, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a), vue.h(LazyTeleport, {
        show: this.show
      }, {
        default: () => {
          var _a2;
          if (!(this.show || this.displayed)) {
            return null;
          }
          (_a2 = this.onRender) === null || _a2 === void 0 ? void 0 : _a2.call(this);
          return vue.withDirectives(vue.h("div", {
            class: [`${clsPrefix}-image-preview-container`, this.themeClass],
            style: this.cssVars,
            onWheel: this.handleWheel
          }, vue.h(vue.Transition, {
            name: "fade-in-transition",
            appear: this.appear
          }, {
            default: () => this.show ? vue.h("div", {
              class: `${clsPrefix}-image-preview-overlay`,
              onClick: this.toggleShow
            }) : null
          }), this.showToolbar ? vue.h(vue.Transition, {
            name: "fade-in-transition",
            appear: this.appear
          }, {
            default: () => {
              if (!this.show)
                return null;
              return vue.h("div", {
                class: `${clsPrefix}-image-preview-toolbar`
              }, renderToolbar ? renderToolbar({
                nodes: {
                  prev: prevNode,
                  next: nextNode,
                  rotateCounterclockwise: rotateCounterclockwiseNode,
                  rotateClockwise: rotateClockwiseNode,
                  resizeToOriginalSize: originalSizeNode,
                  zoomOut: zoomOutNode,
                  zoomIn: zoomInNode,
                  download: downloadNode,
                  close: closeNode
                }
              }) : vue.h(vue.Fragment, null, this.onPrev ? vue.h(vue.Fragment, null, prevNode, nextNode) : null, rotateCounterclockwiseNode, rotateClockwiseNode, originalSizeNode, zoomOutNode, zoomInNode, downloadNode, closeNode));
            }
          }) : null, vue.h(vue.Transition, {
            name: "fade-in-scale-up-transition",
            onAfterLeave: this.handleAfterLeave,
            appear: this.appear,
            // BUG:
            // onEnter will be called twice, I don't know why
            // Maybe it is a bug of vue
            onEnter: this.syncTransformOrigin,
            onBeforeLeave: this.syncTransformOrigin
          }, {
            default: () => {
              const {
                previewedImgProps = {}
              } = this;
              return vue.withDirectives(vue.h("div", {
                class: `${clsPrefix}-image-preview-wrapper`,
                ref: "previewWrapperRef"
              }, vue.h("img", Object.assign({}, previewedImgProps, {
                draggable: false,
                onMousedown: this.handlePreviewMousedown,
                onDblclick: this.handlePreviewDblclick,
                class: [`${clsPrefix}-image-preview`, previewedImgProps.class],
                key: this.previewSrc,
                src: this.previewSrc,
                ref: "previewRef",
                onDragstart: this.handleDragStart
              }))), [[vue.vShow, this.show]]);
            }
          })), [[zindexable$1, {
            enabled: this.show
          }]]);
        }
      }));
    }
  });
  const imageGroupInjectionKey = createInjectionKey("n-image-group");
  const imageGroupProps = imagePreviewSharedProps;
  const NImageGroup = vue.defineComponent({
    name: "ImageGroup",
    props: imageGroupProps,
    setup(props) {
      let currentSrc;
      const {
        mergedClsPrefixRef
      } = useConfig(props);
      const groupId = `c${createId()}`;
      const vm = vue.getCurrentInstance();
      const previewInstRef = vue.ref(null);
      const setPreviewSrc = (src) => {
        var _a;
        currentSrc = src;
        (_a = previewInstRef.value) === null || _a === void 0 ? void 0 : _a.setPreviewSrc(src);
      };
      function go(step) {
        var _a, _b;
        if (!(vm === null || vm === void 0 ? void 0 : vm.proxy))
          return;
        const container = vm.proxy.$el.parentElement;
        const imgs = container.querySelectorAll(`[data-group-id=${groupId}]:not([data-error=true])`);
        if (!imgs.length)
          return;
        const index = Array.from(imgs).findIndex((img) => img.dataset.previewSrc === currentSrc);
        if (~index) {
          setPreviewSrc(imgs[(index + step + imgs.length) % imgs.length].dataset.previewSrc);
        } else {
          setPreviewSrc(imgs[0].dataset.previewSrc);
        }
        if (step === 1) {
          (_a = props.onPreviewNext) === null || _a === void 0 ? void 0 : _a.call(props);
        } else {
          (_b = props.onPreviewPrev) === null || _b === void 0 ? void 0 : _b.call(props);
        }
      }
      vue.provide(imageGroupInjectionKey, {
        mergedClsPrefixRef,
        setPreviewSrc,
        setThumbnailEl: (el) => {
          var _a;
          (_a = previewInstRef.value) === null || _a === void 0 ? void 0 : _a.setThumbnailEl(el);
        },
        toggleShow: () => {
          var _a;
          (_a = previewInstRef.value) === null || _a === void 0 ? void 0 : _a.toggleShow();
        },
        groupId,
        renderToolbarRef: vue.toRef(props, "renderToolbar")
      });
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        previewInstRef,
        next: () => {
          go(1);
        },
        prev: () => {
          go(-1);
        }
      };
    },
    render() {
      return vue.h(NImagePreview, {
        theme: this.theme,
        themeOverrides: this.themeOverrides,
        clsPrefix: this.mergedClsPrefix,
        ref: "previewInstRef",
        onPrev: this.prev,
        onNext: this.next,
        showToolbar: this.showToolbar,
        showToolbarTooltip: this.showToolbarTooltip,
        renderToolbar: this.renderToolbar
      }, this.$slots);
    }
  });
  const imageProps = Object.assign({
    alt: String,
    height: [String, Number],
    imgProps: Object,
    previewedImgProps: Object,
    lazy: Boolean,
    intersectionObserverOptions: Object,
    objectFit: {
      type: String,
      default: "fill"
    },
    previewSrc: String,
    fallbackSrc: String,
    width: [String, Number],
    src: String,
    previewDisabled: Boolean,
    loadDescription: String,
    onError: Function,
    onLoad: Function
  }, imagePreviewSharedProps);
  const NImage = vue.defineComponent({
    name: "Image",
    props: imageProps,
    inheritAttrs: false,
    setup(props) {
      const imageRef = vue.ref(null);
      const showErrorRef = vue.ref(false);
      const previewInstRef = vue.ref(null);
      const imageGroupHandle = vue.inject(imageGroupInjectionKey, null);
      const {
        mergedClsPrefixRef
      } = imageGroupHandle || useConfig(props);
      const exposedMethods = {
        click: () => {
          if (props.previewDisabled || showErrorRef.value)
            return;
          const mergedPreviewSrc = props.previewSrc || props.src;
          if (imageGroupHandle) {
            imageGroupHandle.setPreviewSrc(mergedPreviewSrc);
            imageGroupHandle.setThumbnailEl(imageRef.value);
            imageGroupHandle.toggleShow();
            return;
          }
          const {
            value: previewInst
          } = previewInstRef;
          if (!previewInst)
            return;
          previewInst.setPreviewSrc(mergedPreviewSrc);
          previewInst.setThumbnailEl(imageRef.value);
          previewInst.toggleShow();
        }
      };
      const shouldStartLoadingRef = vue.ref(!props.lazy);
      vue.onMounted(() => {
        var _a;
        (_a = imageRef.value) === null || _a === void 0 ? void 0 : _a.setAttribute("data-group-id", (imageGroupHandle === null || imageGroupHandle === void 0 ? void 0 : imageGroupHandle.groupId) || "");
      });
      vue.onMounted(() => {
        if (props.lazy && props.intersectionObserverOptions) {
          let unobserve;
          const stopWatchHandle = vue.watchEffect(() => {
            unobserve === null || unobserve === void 0 ? void 0 : unobserve();
            unobserve = void 0;
            unobserve = observeIntersection(imageRef.value, props.intersectionObserverOptions, shouldStartLoadingRef);
          });
          vue.onBeforeUnmount(() => {
            stopWatchHandle();
            unobserve === null || unobserve === void 0 ? void 0 : unobserve();
          });
        }
      });
      vue.watchEffect(() => {
        var _a;
        void (props.src || ((_a = props.imgProps) === null || _a === void 0 ? void 0 : _a.src));
        showErrorRef.value = false;
      });
      const loadedRef = vue.ref(false);
      vue.provide(imageContextKey, {
        previewedImgPropsRef: vue.toRef(props, "previewedImgProps")
      });
      return Object.assign({
        mergedClsPrefix: mergedClsPrefixRef,
        groupId: imageGroupHandle === null || imageGroupHandle === void 0 ? void 0 : imageGroupHandle.groupId,
        previewInstRef,
        imageRef,
        showError: showErrorRef,
        shouldStartLoading: shouldStartLoadingRef,
        loaded: loadedRef,
        mergedOnClick: (e) => {
          var _a, _b;
          exposedMethods.click();
          (_b = (_a = props.imgProps) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e);
        },
        mergedOnError: (e) => {
          if (!shouldStartLoadingRef.value)
            return;
          showErrorRef.value = true;
          const {
            onError,
            imgProps: {
              onError: imgPropsOnError
            } = {}
          } = props;
          onError === null || onError === void 0 ? void 0 : onError(e);
          imgPropsOnError === null || imgPropsOnError === void 0 ? void 0 : imgPropsOnError(e);
        },
        mergedOnLoad: (e) => {
          const {
            onLoad,
            imgProps: {
              onLoad: imgPropsOnLoad
            } = {}
          } = props;
          onLoad === null || onLoad === void 0 ? void 0 : onLoad(e);
          imgPropsOnLoad === null || imgPropsOnLoad === void 0 ? void 0 : imgPropsOnLoad(e);
          loadedRef.value = true;
        }
      }, exposedMethods);
    },
    render() {
      var _a, _b;
      const {
        mergedClsPrefix,
        imgProps = {},
        loaded,
        $attrs,
        lazy
      } = this;
      const placeholderNode = (_b = (_a = this.$slots).placeholder) === null || _b === void 0 ? void 0 : _b.call(_a);
      const loadSrc = this.src || imgProps.src;
      const imgNode = vue.h("img", Object.assign(Object.assign({}, imgProps), {
        ref: "imageRef",
        width: this.width || imgProps.width,
        height: this.height || imgProps.height,
        src: this.showError ? this.fallbackSrc : lazy && this.intersectionObserverOptions ? this.shouldStartLoading ? loadSrc : void 0 : loadSrc,
        alt: this.alt || imgProps.alt,
        "aria-label": this.alt || imgProps.alt,
        onClick: this.mergedOnClick,
        onError: this.mergedOnError,
        onLoad: this.mergedOnLoad,
        // If interseciton observer options is set, do not use native lazy
        loading: isImageSupportNativeLazy && lazy && !this.intersectionObserverOptions ? "lazy" : "eager",
        style: [imgProps.style || "", placeholderNode && !loaded ? {
          height: "0",
          width: "0",
          visibility: "hidden"
        } : "", {
          objectFit: this.objectFit
        }],
        "data-error": this.showError,
        "data-preview-src": this.previewSrc || this.src
      }));
      return vue.h("div", Object.assign({}, $attrs, {
        role: "none",
        class: [$attrs.class, `${mergedClsPrefix}-image`, (this.previewDisabled || this.showError) && `${mergedClsPrefix}-image--preview-disabled`]
      }), this.groupId ? imgNode : vue.h(NImagePreview, {
        theme: this.theme,
        themeOverrides: this.themeOverrides,
        clsPrefix: mergedClsPrefix,
        ref: "previewInstRef",
        showToolbar: this.showToolbar,
        showToolbarTooltip: this.showToolbarTooltip,
        renderToolbar: this.renderToolbar
      }, {
        default: () => imgNode,
        toolbar: () => {
          var _a2, _b2;
          return (_b2 = (_a2 = this.$slots).toolbar) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
        }
      }), !loaded && placeholderNode);
    }
  });
  function parse(value) {
    if (value === void 0 || value === null || typeof value === "string" && value.trim() === "") {
      return null;
    }
    return Number(value);
  }
  function isWipValue(value) {
    return value.includes(".") && (/^(-)?\d+.*(\.|0)$/.test(value) || /^\.\d+$/.test(value));
  }
  function validator(value) {
    if (value === void 0 || value === null)
      return true;
    if (Number.isNaN(value))
      return false;
    return true;
  }
  function format(value, precision) {
    if (typeof value !== "number")
      return "";
    return precision === void 0 ? String(value) : value.toFixed(precision);
  }
  function parseNumber(number) {
    if (number === null)
      return null;
    if (typeof number === "number") {
      return number;
    } else {
      const parsedNumber = Number(number);
      if (Number.isNaN(parsedNumber)) {
        return null;
      } else {
        return parsedNumber;
      }
    }
  }
  const style$F = c$1([cB("input-number-suffix", `
 display: inline-block;
 margin-right: 10px;
 `), cB("input-number-prefix", `
 display: inline-block;
 margin-left: 10px;
 `)]);
  const HOLDING_CHANGE_THRESHOLD = 800;
  const HOLDING_CHANGE_INTERVAL = 100;
  const inputNumberProps = Object.assign(Object.assign({}, useTheme.props), {
    autofocus: Boolean,
    loading: {
      type: Boolean,
      default: void 0
    },
    placeholder: String,
    defaultValue: {
      type: Number,
      default: null
    },
    value: Number,
    step: {
      type: [Number, String],
      default: 1
    },
    min: [Number, String],
    max: [Number, String],
    size: String,
    disabled: {
      type: Boolean,
      default: void 0
    },
    validator: Function,
    bordered: {
      type: Boolean,
      default: void 0
    },
    showButton: {
      type: Boolean,
      default: true
    },
    buttonPlacement: {
      type: String,
      default: "right"
    },
    inputProps: Object,
    readonly: Boolean,
    clearable: Boolean,
    keyboard: {
      type: Object,
      default: {}
    },
    updateValueOnInput: {
      type: Boolean,
      default: true
    },
    round: {
      type: Boolean,
      default: void 0
    },
    parse: Function,
    format: Function,
    precision: Number,
    status: String,
    "onUpdate:value": [Function, Array],
    onUpdateValue: [Function, Array],
    onFocus: [Function, Array],
    onBlur: [Function, Array],
    onClear: [Function, Array],
    // deprecated
    onChange: [Function, Array]
  });
  const InputNumber = vue.defineComponent({
    name: "InputNumber",
    props: inputNumberProps,
    setup(props) {
      {
        vue.watchEffect(() => {
          if (props.onChange !== void 0) {
            warnOnce("input-number", "`on-change` is deprecated, please use `on-update:value` instead");
          }
        });
      }
      const {
        mergedBorderedRef,
        mergedClsPrefixRef,
        mergedRtlRef
      } = useConfig(props);
      const themeRef = useTheme("InputNumber", "-input-number", style$F, inputNumberLight$1, props, mergedClsPrefixRef);
      const {
        localeRef
      } = useLocale("InputNumber");
      const formItem = useFormItem(props);
      const {
        mergedSizeRef,
        mergedDisabledRef,
        mergedStatusRef
      } = formItem;
      const inputInstRef = vue.ref(null);
      const minusButtonInstRef = vue.ref(null);
      const addButtonInstRef = vue.ref(null);
      const uncontrolledValueRef = vue.ref(props.defaultValue);
      const controlledValueRef = vue.toRef(props, "value");
      const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
      const displayedValueRef = vue.ref("");
      const getPrecision = (value) => {
        const fraction = String(value).split(".")[1];
        return fraction ? fraction.length : 0;
      };
      const getMaxPrecision = (currentValue) => {
        const precisions = [props.min, props.max, props.step, currentValue].map((value) => {
          if (value === void 0)
            return 0;
          return getPrecision(value);
        });
        return Math.max(...precisions);
      };
      const mergedPlaceholderRef = useMemo(() => {
        const {
          placeholder
        } = props;
        if (placeholder !== void 0)
          return placeholder;
        return localeRef.value.placeholder;
      });
      const mergedStepRef = useMemo(() => {
        const parsedNumber = parseNumber(props.step);
        if (parsedNumber !== null) {
          return parsedNumber === 0 ? 1 : Math.abs(parsedNumber);
        }
        return 1;
      });
      const mergedMinRef = useMemo(() => {
        const parsedNumber = parseNumber(props.min);
        if (parsedNumber !== null)
          return parsedNumber;
        else
          return null;
      });
      const mergedMaxRef = useMemo(() => {
        const parsedNumber = parseNumber(props.max);
        if (parsedNumber !== null)
          return parsedNumber;
        else
          return null;
      });
      const deriveDisplayedValueFromValue = () => {
        const {
          value: mergedValue
        } = mergedValueRef;
        if (validator(mergedValue)) {
          const {
            format: formatProp,
            precision
          } = props;
          if (formatProp) {
            displayedValueRef.value = formatProp(mergedValue);
          } else {
            if (mergedValue === null || precision === void 0 || getPrecision(mergedValue) > precision) {
              displayedValueRef.value = format(mergedValue, void 0);
            } else {
              displayedValueRef.value = format(mergedValue, precision);
            }
          }
        } else {
          displayedValueRef.value = String(mergedValue);
        }
      };
      deriveDisplayedValueFromValue();
      const doUpdateValue = (value) => {
        const {
          value: mergedValue
        } = mergedValueRef;
        if (value === mergedValue) {
          deriveDisplayedValueFromValue();
          return;
        }
        const {
          "onUpdate:value": _onUpdateValue,
          onUpdateValue,
          onChange
        } = props;
        const {
          nTriggerFormInput,
          nTriggerFormChange
        } = formItem;
        if (onChange)
          call(onChange, value);
        if (onUpdateValue)
          call(onUpdateValue, value);
        if (_onUpdateValue)
          call(_onUpdateValue, value);
        uncontrolledValueRef.value = value;
        nTriggerFormInput();
        nTriggerFormChange();
      };
      const deriveValueFromDisplayedValue = ({
        offset,
        doUpdateIfValid,
        fixPrecision,
        isInputing
      }) => {
        const {
          value: displayedValue
        } = displayedValueRef;
        if (isInputing && isWipValue(displayedValue)) {
          return false;
        }
        const parsedValue = (props.parse || parse)(displayedValue);
        if (parsedValue === null) {
          if (doUpdateIfValid)
            doUpdateValue(null);
          return null;
        }
        if (validator(parsedValue)) {
          const currentPrecision = getPrecision(parsedValue);
          const {
            precision
          } = props;
          if (precision !== void 0 && precision < currentPrecision && !fixPrecision) {
            return false;
          }
          let nextValue = Number.parseFloat((parsedValue + offset).toFixed(precision !== null && precision !== void 0 ? precision : getMaxPrecision(parsedValue)));
          if (validator(nextValue)) {
            const {
              value: mergedMax
            } = mergedMaxRef;
            const {
              value: mergedMin
            } = mergedMinRef;
            if (mergedMax !== null && nextValue > mergedMax) {
              if (!doUpdateIfValid || isInputing)
                return false;
              nextValue = mergedMax;
            }
            if (mergedMin !== null && nextValue < mergedMin) {
              if (!doUpdateIfValid || isInputing)
                return false;
              nextValue = mergedMin;
            }
            if (props.validator && !props.validator(nextValue))
              return false;
            if (doUpdateIfValid)
              doUpdateValue(nextValue);
            return nextValue;
          }
        }
        return false;
      };
      const displayedValueInvalidRef = useMemo(() => {
        const derivedValue = deriveValueFromDisplayedValue({
          offset: 0,
          doUpdateIfValid: false,
          isInputing: false,
          fixPrecision: false
        });
        return derivedValue === false;
      });
      const minusableRef = useMemo(() => {
        const {
          value: mergedValue
        } = mergedValueRef;
        if (props.validator && mergedValue === null) {
          return false;
        }
        const {
          value: mergedStep
        } = mergedStepRef;
        const derivedNextValue = deriveValueFromDisplayedValue({
          offset: -mergedStep,
          doUpdateIfValid: false,
          isInputing: false,
          fixPrecision: false
        });
        return derivedNextValue !== false;
      });
      const addableRef = useMemo(() => {
        const {
          value: mergedValue
        } = mergedValueRef;
        if (props.validator && mergedValue === null) {
          return false;
        }
        const {
          value: mergedStep
        } = mergedStepRef;
        const derivedNextValue = deriveValueFromDisplayedValue({
          offset: +mergedStep,
          doUpdateIfValid: false,
          isInputing: false,
          fixPrecision: false
        });
        return derivedNextValue !== false;
      });
      function doFocus(e) {
        const {
          onFocus
        } = props;
        const {
          nTriggerFormFocus
        } = formItem;
        if (onFocus)
          call(onFocus, e);
        nTriggerFormFocus();
      }
      function doBlur(e) {
        var _a, _b;
        if (e.target === ((_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.wrapperElRef)) {
          return;
        }
        const value = deriveValueFromDisplayedValue({
          offset: 0,
          doUpdateIfValid: true,
          isInputing: false,
          fixPrecision: true
        });
        if (value !== false) {
          const inputElRef = (_b = inputInstRef.value) === null || _b === void 0 ? void 0 : _b.inputElRef;
          if (inputElRef) {
            inputElRef.value = String(value || "");
          }
          if (mergedValueRef.value === value) {
            deriveDisplayedValueFromValue();
          }
        } else {
          deriveDisplayedValueFromValue();
        }
        const {
          onBlur
        } = props;
        const {
          nTriggerFormBlur
        } = formItem;
        if (onBlur)
          call(onBlur, e);
        nTriggerFormBlur();
        void vue.nextTick(() => {
          deriveDisplayedValueFromValue();
        });
      }
      function doClear(e) {
        const {
          onClear
        } = props;
        if (onClear)
          call(onClear, e);
      }
      function doAdd() {
        const {
          value: addable
        } = addableRef;
        if (!addable) {
          clearAddHoldTimeout();
          return;
        }
        const {
          value: mergedValue
        } = mergedValueRef;
        if (mergedValue === null) {
          if (!props.validator) {
            doUpdateValue(createValidValue());
          }
        } else {
          const {
            value: mergedStep
          } = mergedStepRef;
          deriveValueFromDisplayedValue({
            offset: mergedStep,
            doUpdateIfValid: true,
            isInputing: false,
            fixPrecision: true
          });
        }
      }
      function doMinus() {
        const {
          value: minusable
        } = minusableRef;
        if (!minusable) {
          clearMinusHoldTimeout();
          return;
        }
        const {
          value: mergedValue
        } = mergedValueRef;
        if (mergedValue === null) {
          if (!props.validator) {
            doUpdateValue(createValidValue());
          }
        } else {
          const {
            value: mergedStep
          } = mergedStepRef;
          deriveValueFromDisplayedValue({
            offset: -mergedStep,
            doUpdateIfValid: true,
            isInputing: false,
            fixPrecision: true
          });
        }
      }
      const handleFocus = doFocus;
      const handleBlur = doBlur;
      function createValidValue() {
        if (props.validator)
          return null;
        const {
          value: mergedMin
        } = mergedMinRef;
        const {
          value: mergedMax
        } = mergedMaxRef;
        if (mergedMin !== null) {
          return Math.max(0, mergedMin);
        } else if (mergedMax !== null) {
          return Math.min(0, mergedMax);
        } else {
          return 0;
        }
      }
      function handleClear(e) {
        doClear(e);
        doUpdateValue(null);
      }
      function handleMouseDown(e) {
        var _a, _b, _c;
        if ((_a = addButtonInstRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(e.target)) {
          e.preventDefault();
        }
        if ((_b = minusButtonInstRef.value) === null || _b === void 0 ? void 0 : _b.$el.contains(e.target)) {
          e.preventDefault();
        }
        (_c = inputInstRef.value) === null || _c === void 0 ? void 0 : _c.activate();
      }
      let minusHoldStateIntervalId = null;
      let addHoldStateIntervalId = null;
      let firstMinusMousedownId = null;
      function clearMinusHoldTimeout() {
        if (firstMinusMousedownId) {
          window.clearTimeout(firstMinusMousedownId);
          firstMinusMousedownId = null;
        }
        if (minusHoldStateIntervalId) {
          window.clearInterval(minusHoldStateIntervalId);
          minusHoldStateIntervalId = null;
        }
      }
      let firstAddMousedownId = null;
      function clearAddHoldTimeout() {
        if (firstAddMousedownId) {
          window.clearTimeout(firstAddMousedownId);
          firstAddMousedownId = null;
        }
        if (addHoldStateIntervalId) {
          window.clearInterval(addHoldStateIntervalId);
          addHoldStateIntervalId = null;
        }
      }
      function handleMinusMousedown() {
        clearMinusHoldTimeout();
        firstMinusMousedownId = window.setTimeout(() => {
          minusHoldStateIntervalId = window.setInterval(() => {
            doMinus();
          }, HOLDING_CHANGE_INTERVAL);
        }, HOLDING_CHANGE_THRESHOLD);
        on("mouseup", document, clearMinusHoldTimeout, {
          once: true
        });
      }
      function handleAddMousedown() {
        clearAddHoldTimeout();
        firstAddMousedownId = window.setTimeout(() => {
          addHoldStateIntervalId = window.setInterval(() => {
            doAdd();
          }, HOLDING_CHANGE_INTERVAL);
        }, HOLDING_CHANGE_THRESHOLD);
        on("mouseup", document, clearAddHoldTimeout, {
          once: true
        });
      }
      const handleAddClick = () => {
        if (addHoldStateIntervalId)
          return;
        doAdd();
      };
      const handleMinusClick = () => {
        if (minusHoldStateIntervalId)
          return;
        doMinus();
      };
      function handleKeyDown(e) {
        var _a, _b;
        if (e.key === "Enter") {
          if (e.target === ((_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.wrapperElRef)) {
            return;
          }
          const value = deriveValueFromDisplayedValue({
            offset: 0,
            doUpdateIfValid: true,
            isInputing: false,
            fixPrecision: true
          });
          if (value !== false) {
            (_b = inputInstRef.value) === null || _b === void 0 ? void 0 : _b.deactivate();
          }
        } else if (e.key === "ArrowUp") {
          if (!addableRef.value)
            return;
          if (props.keyboard.ArrowUp === false)
            return;
          e.preventDefault();
          const value = deriveValueFromDisplayedValue({
            offset: 0,
            doUpdateIfValid: true,
            isInputing: false,
            fixPrecision: true
          });
          if (value !== false) {
            doAdd();
          }
        } else if (e.key === "ArrowDown") {
          if (!minusableRef.value)
            return;
          if (props.keyboard.ArrowDown === false)
            return;
          e.preventDefault();
          const value = deriveValueFromDisplayedValue({
            offset: 0,
            doUpdateIfValid: true,
            isInputing: false,
            fixPrecision: true
          });
          if (value !== false) {
            doMinus();
          }
        }
      }
      function handleUpdateDisplayedValue(value) {
        displayedValueRef.value = value;
        if (props.updateValueOnInput && !props.format && !props.parse && props.precision === void 0) {
          deriveValueFromDisplayedValue({
            offset: 0,
            doUpdateIfValid: true,
            isInputing: true,
            fixPrecision: false
          });
        }
      }
      vue.watch(mergedValueRef, () => {
        deriveDisplayedValueFromValue();
      });
      const exposedMethods = {
        focus: () => {
          var _a;
          return (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
        },
        blur: () => {
          var _a;
          return (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.blur();
        },
        select: () => {
          var _a;
          return (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.select();
        }
      };
      const rtlEnabledRef = useRtl("InputNumber", mergedRtlRef, mergedClsPrefixRef);
      return Object.assign(Object.assign({}, exposedMethods), {
        rtlEnabled: rtlEnabledRef,
        inputInstRef,
        minusButtonInstRef,
        addButtonInstRef,
        mergedClsPrefix: mergedClsPrefixRef,
        mergedBordered: mergedBorderedRef,
        uncontrolledValue: uncontrolledValueRef,
        mergedValue: mergedValueRef,
        mergedPlaceholder: mergedPlaceholderRef,
        displayedValueInvalid: displayedValueInvalidRef,
        mergedSize: mergedSizeRef,
        mergedDisabled: mergedDisabledRef,
        displayedValue: displayedValueRef,
        addable: addableRef,
        minusable: minusableRef,
        mergedStatus: mergedStatusRef,
        handleFocus,
        handleBlur,
        handleClear,
        handleMouseDown,
        handleAddClick,
        handleMinusClick,
        handleAddMousedown,
        handleMinusMousedown,
        handleKeyDown,
        handleUpdateDisplayedValue,
        // theme
        mergedTheme: themeRef,
        inputThemeOverrides: {
          paddingSmall: "0 8px 0 10px",
          paddingMedium: "0 8px 0 12px",
          paddingLarge: "0 8px 0 14px"
        },
        buttonThemeOverrides: vue.computed(() => {
          const {
            self: {
              iconColorDisabled
            }
          } = themeRef.value;
          const [r, g, b, a2] = rgba(iconColorDisabled);
          return {
            textColorTextDisabled: `rgb(${r}, ${g}, ${b})`,
            opacityDisabled: `${a2}`
          };
        })
      });
    },
    render() {
      const {
        mergedClsPrefix,
        $slots
      } = this;
      const renderMinusButton = () => {
        return vue.h(XButton, {
          text: true,
          disabled: !this.minusable || this.mergedDisabled || this.readonly,
          focusable: false,
          theme: this.mergedTheme.peers.Button,
          themeOverrides: this.mergedTheme.peerOverrides.Button,
          builtinThemeOverrides: this.buttonThemeOverrides,
          onClick: this.handleMinusClick,
          onMousedown: this.handleMinusMousedown,
          ref: "minusButtonInstRef"
        }, {
          icon: () => resolveSlot($slots["minus-icon"], () => [vue.h(NBaseIcon, {
            clsPrefix: mergedClsPrefix
          }, {
            default: () => vue.h(RemoveIcon, null)
          })])
        });
      };
      const renderAddButton = () => {
        return vue.h(XButton, {
          text: true,
          disabled: !this.addable || this.mergedDisabled || this.readonly,
          focusable: false,
          theme: this.mergedTheme.peers.Button,
          themeOverrides: this.mergedTheme.peerOverrides.Button,
          builtinThemeOverrides: this.buttonThemeOverrides,
          onClick: this.handleAddClick,
          onMousedown: this.handleAddMousedown,
          ref: "addButtonInstRef"
        }, {
          icon: () => resolveSlot($slots["add-icon"], () => [vue.h(NBaseIcon, {
            clsPrefix: mergedClsPrefix
          }, {
            default: () => vue.h(AddIcon, null)
          })])
        });
      };
      return vue.h("div", {
        class: [`${mergedClsPrefix}-input-number`, this.rtlEnabled && `${mergedClsPrefix}-input-number--rtl`]
      }, vue.h(NInput, {
        ref: "inputInstRef",
        autofocus: this.autofocus,
        status: this.mergedStatus,
        bordered: this.mergedBordered,
        loading: this.loading,
        value: this.displayedValue,
        onUpdateValue: this.handleUpdateDisplayedValue,
        theme: this.mergedTheme.peers.Input,
        themeOverrides: this.mergedTheme.peerOverrides.Input,
        builtinThemeOverrides: this.inputThemeOverrides,
        size: this.mergedSize,
        placeholder: this.mergedPlaceholder,
        disabled: this.mergedDisabled,
        readonly: this.readonly,
        round: this.round,
        textDecoration: this.displayedValueInvalid ? "line-through" : void 0,
        onFocus: this.handleFocus,
        onBlur: this.handleBlur,
        onKeydown: this.handleKeyDown,
        onMousedown: this.handleMouseDown,
        onClear: this.handleClear,
        clearable: this.clearable,
        inputProps: this.inputProps,
        internalLoadingBeforeSuffix: true
      }, {
        prefix: () => {
          var _a;
          return this.showButton && this.buttonPlacement === "both" ? [renderMinusButton(), resolveWrappedSlot($slots.prefix, (children) => {
            if (children) {
              return vue.h("span", {
                class: `${mergedClsPrefix}-input-number-prefix`
              }, children);
            }
            return null;
          })] : (_a = $slots.prefix) === null || _a === void 0 ? void 0 : _a.call($slots);
        },
        suffix: () => {
          var _a;
          return this.showButton ? [resolveWrappedSlot($slots.suffix, (children) => {
            if (children) {
              return vue.h("span", {
                class: `${mergedClsPrefix}-input-number-suffix`
              }, children);
            }
            return null;
          }), this.buttonPlacement === "right" ? renderMinusButton() : null, renderAddButton()] : (_a = $slots.suffix) === null || _a === void 0 ? void 0 : _a.call($slots);
        }
      }));
    }
  });
  const layoutSiderInjectionKey = createInjectionKey("n-layout-sider");
  const positionProp = {
    type: String,
    default: "static"
  };
  const style$E = cB("layout", `
 color: var(--n-text-color);
 background-color: var(--n-color);
 box-sizing: border-box;
 position: relative;
 z-index: auto;
 flex: auto;
 overflow: hidden;
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
`, [cB("layout-scroll-container", `
 overflow-x: hidden;
 box-sizing: border-box;
 height: 100%;
 `), cM("absolute-positioned", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]);
  const layoutProps = {
    embedded: Boolean,
    position: positionProp,
    nativeScrollbar: {
      type: Boolean,
      default: true
    },
    scrollbarProps: Object,
    onScroll: Function,
    contentClass: String,
    contentStyle: {
      type: [String, Object],
      default: ""
    },
    hasSider: Boolean,
    siderPlacement: {
      type: String,
      default: "left"
    }
  };
  const layoutInjectionKey = createInjectionKey("n-layout");
  function createLayoutComponent(isContent) {
    return vue.defineComponent({
      name: isContent ? "LayoutContent" : "Layout",
      props: Object.assign(Object.assign({}, useTheme.props), layoutProps),
      setup(props) {
        const scrollableElRef = vue.ref(null);
        const scrollbarInstRef = vue.ref(null);
        const {
          mergedClsPrefixRef,
          inlineThemeDisabled
        } = useConfig(props);
        const themeRef = useTheme("Layout", "-layout", style$E, layoutLight$1, props, mergedClsPrefixRef);
        function scrollTo(options, y) {
          if (props.nativeScrollbar) {
            const {
              value: scrollableEl
            } = scrollableElRef;
            if (scrollableEl) {
              if (y === void 0) {
                scrollableEl.scrollTo(options);
              } else {
                scrollableEl.scrollTo(options, y);
              }
            }
          } else {
            const {
              value: scrollbarInst
            } = scrollbarInstRef;
            if (scrollbarInst) {
              scrollbarInst.scrollTo(options, y);
            }
          }
        }
        vue.provide(layoutInjectionKey, props);
        let scrollX = 0;
        let scrollY = 0;
        const handleNativeElScroll = (e) => {
          var _a;
          const target = e.target;
          scrollX = target.scrollLeft;
          scrollY = target.scrollTop;
          (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);
        };
        useReactivated(() => {
          if (props.nativeScrollbar) {
            const el = scrollableElRef.value;
            if (el) {
              el.scrollTop = scrollY;
              el.scrollLeft = scrollX;
            }
          }
        });
        const hasSiderStyle = {
          display: "flex",
          flexWrap: "nowrap",
          width: "100%",
          flexDirection: "row"
        };
        const exposedMethods = {
          scrollTo
        };
        const cssVarsRef = vue.computed(() => {
          const {
            common: {
              cubicBezierEaseInOut: cubicBezierEaseInOut2
            },
            self: self2
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-color": props.embedded ? self2.colorEmbedded : self2.color,
            "--n-text-color": self2.textColor
          };
        });
        const themeClassHandle = inlineThemeDisabled ? useThemeClass("layout", vue.computed(() => {
          return props.embedded ? "e" : "";
        }), cssVarsRef, props) : void 0;
        return Object.assign({
          mergedClsPrefix: mergedClsPrefixRef,
          scrollableElRef,
          scrollbarInstRef,
          hasSiderStyle,
          mergedTheme: themeRef,
          handleNativeElScroll,
          cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
          themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
          onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
        }, exposedMethods);
      },
      render() {
        var _a;
        const {
          mergedClsPrefix,
          hasSider
        } = this;
        (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
        const hasSiderStyle = hasSider ? this.hasSiderStyle : void 0;
        const layoutClass = [this.themeClass, isContent && `${mergedClsPrefix}-layout-content`, `${mergedClsPrefix}-layout`, `${mergedClsPrefix}-layout--${this.position}-positioned`];
        return vue.h("div", {
          class: layoutClass,
          style: this.cssVars
        }, this.nativeScrollbar ? vue.h("div", {
          ref: "scrollableElRef",
          class: [`${mergedClsPrefix}-layout-scroll-container`, this.contentClass],
          style: [this.contentStyle, hasSiderStyle],
          onScroll: this.handleNativeElScroll
        }, this.$slots) : vue.h(NScrollbar, Object.assign({}, this.scrollbarProps, {
          onScroll: this.onScroll,
          ref: "scrollbarInstRef",
          theme: this.mergedTheme.peers.Scrollbar,
          themeOverrides: this.mergedTheme.peerOverrides.Scrollbar,
          contentClass: this.contentClass,
          contentStyle: [this.contentStyle, hasSiderStyle]
        }), this.$slots));
      }
    });
  }
  const Layout = createLayoutComponent(false);
  const LayoutContent = createLayoutComponent(true);
  const style$D = cB("layout-header", `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 box-sizing: border-box;
 width: 100%;
 background-color: var(--n-color);
 color: var(--n-text-color);
`, [cM("absolute-positioned", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 `), cM("bordered", `
 border-bottom: solid 1px var(--n-border-color);
 `)]);
  const headerProps$1 = {
    position: positionProp,
    inverted: Boolean,
    bordered: {
      type: Boolean,
      default: false
    }
  };
  const LayoutHeader = vue.defineComponent({
    name: "LayoutHeader",
    props: Object.assign(Object.assign({}, useTheme.props), headerProps$1),
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Layout", "-layout-header", style$D, layoutLight$1, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: self2
        } = themeRef.value;
        const vars = {
          "--n-bezier": cubicBezierEaseInOut2
        };
        if (props.inverted) {
          vars["--n-color"] = self2.headerColorInverted;
          vars["--n-text-color"] = self2.textColorInverted;
          vars["--n-border-color"] = self2.headerBorderColorInverted;
        } else {
          vars["--n-color"] = self2.headerColor;
          vars["--n-text-color"] = self2.textColor;
          vars["--n-border-color"] = self2.headerBorderColor;
        }
        return vars;
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("layout-header", vue.computed(() => props.inverted ? "a" : "b"), cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a;
      const {
        mergedClsPrefix
      } = this;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      return vue.h("div", {
        class: [`${mergedClsPrefix}-layout-header`, this.themeClass, this.position && `${mergedClsPrefix}-layout-header--${this.position}-positioned`, this.bordered && `${mergedClsPrefix}-layout-header--bordered`],
        style: this.cssVars
      }, this.$slots);
    }
  });
  const style$C = cB("layout-footer", `
 transition:
 box-shadow .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 color: var(--n-text-color);
 background-color: var(--n-color);
 box-sizing: border-box;
`, [cM("absolute-positioned", `
 position: absolute;
 left: 0;
 right: 0;
 bottom: 0;
 `), cM("bordered", `
 border-top: solid 1px var(--n-border-color);
 `)]);
  const layoutFooterProps = Object.assign(Object.assign({}, useTheme.props), {
    inverted: Boolean,
    position: positionProp,
    bordered: Boolean
  });
  const LayoutFooter = vue.defineComponent({
    name: "LayoutFooter",
    props: layoutFooterProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Layout", "-layout-footer", style$C, layoutLight$1, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: self2
        } = themeRef.value;
        const vars = {
          "--n-bezier": cubicBezierEaseInOut2
        };
        if (props.inverted) {
          vars["--n-color"] = self2.footerColorInverted;
          vars["--n-text-color"] = self2.textColorInverted;
          vars["--n-border-color"] = self2.footerBorderColorInverted;
        } else {
          vars["--n-color"] = self2.footerColor;
          vars["--n-text-color"] = self2.textColor;
          vars["--n-border-color"] = self2.footerBorderColor;
        }
        return vars;
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("layout-footer", vue.computed(() => props.inverted ? "a" : "b"), cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a;
      const {
        mergedClsPrefix
      } = this;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      return vue.h("div", {
        class: [`${mergedClsPrefix}-layout-footer`, this.themeClass, this.position && `${mergedClsPrefix}-layout-footer--${this.position}-positioned`, this.bordered && `${mergedClsPrefix}-layout-footer--bordered`],
        style: this.cssVars
      }, this.$slots);
    }
  });
  const style$B = cB("layout-sider", `
 flex-shrink: 0;
 box-sizing: border-box;
 position: relative;
 z-index: 1;
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 min-width .3s var(--n-bezier),
 max-width .3s var(--n-bezier),
 transform .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 background-color: var(--n-color);
 display: flex;
 justify-content: flex-end;
`, [cM("bordered", [cE("border", `
 content: "";
 position: absolute;
 top: 0;
 bottom: 0;
 width: 1px;
 background-color: var(--n-border-color);
 transition: background-color .3s var(--n-bezier);
 `)]), cE("left-placement", [cM("bordered", [cE("border", `
 right: 0;
 `)])]), cM("right-placement", `
 justify-content: flex-start;
 `, [cM("bordered", [cE("border", `
 left: 0;
 `)]), cM("collapsed", [cB("layout-toggle-button", [cB("base-icon", `
 transform: rotate(180deg);
 `)]), cB("layout-toggle-bar", [c$1("&:hover", [cE("top", {
    transform: "rotate(-12deg) scale(1.15) translateY(-2px)"
  }), cE("bottom", {
    transform: "rotate(12deg) scale(1.15) translateY(2px)"
  })])])]), cB("layout-toggle-button", `
 left: 0;
 transform: translateX(-50%) translateY(-50%);
 `, [cB("base-icon", `
 transform: rotate(0);
 `)]), cB("layout-toggle-bar", `
 left: -28px;
 transform: rotate(180deg);
 `, [c$1("&:hover", [cE("top", {
    transform: "rotate(12deg) scale(1.15) translateY(-2px)"
  }), cE("bottom", {
    transform: "rotate(-12deg) scale(1.15) translateY(2px)"
  })])])]), cM("collapsed", [cB("layout-toggle-bar", [c$1("&:hover", [cE("top", {
    transform: "rotate(-12deg) scale(1.15) translateY(-2px)"
  }), cE("bottom", {
    transform: "rotate(12deg) scale(1.15) translateY(2px)"
  })])]), cB("layout-toggle-button", [cB("base-icon", `
 transform: rotate(0);
 `)])]), cB("layout-toggle-button", `
 transition:
 color .3s var(--n-bezier),
 right .3s var(--n-bezier),
 left .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 cursor: pointer;
 width: 24px;
 height: 24px;
 position: absolute;
 top: 50%;
 right: 0;
 border-radius: 50%;
 display: flex;
 align-items: center;
 justify-content: center;
 font-size: 18px;
 color: var(--n-toggle-button-icon-color);
 border: var(--n-toggle-button-border);
 background-color: var(--n-toggle-button-color);
 box-shadow: 0 2px 4px 0px rgba(0, 0, 0, .06);
 transform: translateX(50%) translateY(-50%);
 z-index: 1;
 `, [cB("base-icon", `
 transition: transform .3s var(--n-bezier);
 transform: rotate(180deg);
 `)]), cB("layout-toggle-bar", `
 cursor: pointer;
 height: 72px;
 width: 32px;
 position: absolute;
 top: calc(50% - 36px);
 right: -28px;
 `, [cE("top, bottom", `
 position: absolute;
 width: 4px;
 border-radius: 2px;
 height: 38px;
 left: 14px;
 transition: 
 background-color .3s var(--n-bezier),
 transform .3s var(--n-bezier);
 `), cE("bottom", `
 position: absolute;
 top: 34px;
 `), c$1("&:hover", [cE("top", {
    transform: "rotate(12deg) scale(1.15) translateY(-2px)"
  }), cE("bottom", {
    transform: "rotate(-12deg) scale(1.15) translateY(2px)"
  })]), cE("top, bottom", {
    backgroundColor: "var(--n-toggle-bar-color)"
  }), c$1("&:hover", [cE("top, bottom", {
    backgroundColor: "var(--n-toggle-bar-color-hover)"
  })])]), cE("border", `
 position: absolute;
 top: 0;
 right: 0;
 bottom: 0;
 width: 1px;
 transition: background-color .3s var(--n-bezier);
 `), cB("layout-sider-scroll-container", `
 flex-grow: 1;
 flex-shrink: 0;
 box-sizing: border-box;
 height: 100%;
 opacity: 0;
 transition: opacity .3s var(--n-bezier);
 max-width: 100%;
 `), cM("show-content", [cB("layout-sider-scroll-container", {
    opacity: 1
  })]), cM("absolute-positioned", `
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 `)]);
  const ToggleButton = vue.defineComponent({
    name: "LayoutToggleButton",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      onClick: Function
    },
    render() {
      const {
        clsPrefix
      } = this;
      return vue.h("div", {
        class: `${clsPrefix}-layout-toggle-button`,
        onClick: this.onClick
      }, vue.h(NBaseIcon, {
        clsPrefix
      }, {
        default: () => vue.h(ChevronRightIcon, null)
      }));
    }
  });
  const ToggleBar = vue.defineComponent({
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      onClick: Function
    },
    render() {
      const {
        clsPrefix
      } = this;
      return vue.h("div", {
        onClick: this.onClick,
        class: `${clsPrefix}-layout-toggle-bar`
      }, vue.h("div", {
        class: `${clsPrefix}-layout-toggle-bar__top`
      }), vue.h("div", {
        class: `${clsPrefix}-layout-toggle-bar__bottom`
      }));
    }
  });
  const layoutSiderProps = {
    position: positionProp,
    bordered: Boolean,
    collapsedWidth: {
      type: Number,
      default: 48
    },
    width: {
      type: [Number, String],
      default: 272
    },
    contentClass: String,
    contentStyle: {
      type: [String, Object],
      default: ""
    },
    collapseMode: {
      type: String,
      default: "transform"
    },
    collapsed: {
      type: Boolean,
      default: void 0
    },
    defaultCollapsed: Boolean,
    showCollapsedContent: {
      type: Boolean,
      default: true
    },
    showTrigger: {
      type: [Boolean, String],
      default: false
    },
    nativeScrollbar: {
      type: Boolean,
      default: true
    },
    inverted: Boolean,
    scrollbarProps: Object,
    triggerClass: String,
    triggerStyle: [String, Object],
    collapsedTriggerClass: String,
    collapsedTriggerStyle: [String, Object],
    "onUpdate:collapsed": [Function, Array],
    onUpdateCollapsed: [Function, Array],
    onAfterEnter: Function,
    onAfterLeave: Function,
    // deprecated
    onExpand: [Function, Array],
    onCollapse: [Function, Array],
    onScroll: Function
  };
  const LayoutSider = vue.defineComponent({
    name: "LayoutSider",
    props: Object.assign(Object.assign({}, useTheme.props), layoutSiderProps),
    setup(props) {
      const layoutProps2 = vue.inject(layoutInjectionKey);
      {
        if (!layoutProps2) {
          warn$2("layout-sider", "Layout sider is not allowed to be put outside layout.");
        } else {
          if (!layoutProps2.hasSider) {
            warn$2("layout-sider", "You are putting `n-layout-sider` in a `n-layout` but haven't set `has-sider` on the `n-layout`.");
          }
        }
      }
      const scrollableElRef = vue.ref(null);
      const scrollbarInstRef = vue.ref(null);
      const uncontrolledCollapsedRef = vue.ref(props.defaultCollapsed);
      const mergedCollapsedRef = useMergedState(vue.toRef(props, "collapsed"), uncontrolledCollapsedRef);
      const styleMaxWidthRef = vue.computed(() => {
        return formatLength(mergedCollapsedRef.value ? props.collapsedWidth : props.width);
      });
      const scrollContainerStyleRef = vue.computed(() => {
        if (props.collapseMode !== "transform")
          return {};
        return {
          minWidth: formatLength(props.width)
        };
      });
      const siderPlacementRef = vue.computed(() => {
        return layoutProps2 ? layoutProps2.siderPlacement : "left";
      });
      function scrollTo(options, y) {
        if (props.nativeScrollbar) {
          const {
            value: scrollableEl
          } = scrollableElRef;
          if (scrollableEl) {
            if (y === void 0) {
              scrollableEl.scrollTo(options);
            } else {
              scrollableEl.scrollTo(options, y);
            }
          }
        } else {
          const {
            value: scrollbarInst
          } = scrollbarInstRef;
          if (scrollbarInst) {
            scrollbarInst.scrollTo(options, y);
          }
        }
      }
      function handleTriggerClick() {
        const {
          "onUpdate:collapsed": _onUpdateCollapsed,
          onUpdateCollapsed,
          // deprecated
          onExpand,
          onCollapse
        } = props;
        const {
          value: collapsed
        } = mergedCollapsedRef;
        if (onUpdateCollapsed) {
          call(onUpdateCollapsed, !collapsed);
        }
        if (_onUpdateCollapsed) {
          call(_onUpdateCollapsed, !collapsed);
        }
        uncontrolledCollapsedRef.value = !collapsed;
        if (collapsed) {
          if (onExpand)
            call(onExpand);
        } else {
          if (onCollapse)
            call(onCollapse);
        }
      }
      let scrollX = 0;
      let scrollY = 0;
      const handleNativeElScroll = (e) => {
        var _a;
        const target = e.target;
        scrollX = target.scrollLeft;
        scrollY = target.scrollTop;
        (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);
      };
      useReactivated(() => {
        if (props.nativeScrollbar) {
          const el = scrollableElRef.value;
          if (el) {
            el.scrollTop = scrollY;
            el.scrollLeft = scrollX;
          }
        }
      });
      vue.provide(layoutSiderInjectionKey, {
        collapsedRef: mergedCollapsedRef,
        collapseModeRef: vue.toRef(props, "collapseMode")
      });
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Layout", "-layout-sider", style$B, layoutLight$1, props, mergedClsPrefixRef);
      function handleTransitionend(e) {
        var _a, _b;
        if (e.propertyName === "max-width") {
          if (mergedCollapsedRef.value) {
            (_a = props.onAfterLeave) === null || _a === void 0 ? void 0 : _a.call(props);
          } else {
            (_b = props.onAfterEnter) === null || _b === void 0 ? void 0 : _b.call(props);
          }
        }
      }
      const exposedMethods = {
        scrollTo
      };
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: self2
        } = themeRef.value;
        const {
          siderToggleButtonColor,
          siderToggleButtonBorder,
          siderToggleBarColor,
          siderToggleBarColorHover
        } = self2;
        const vars = {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-toggle-button-color": siderToggleButtonColor,
          "--n-toggle-button-border": siderToggleButtonBorder,
          "--n-toggle-bar-color": siderToggleBarColor,
          "--n-toggle-bar-color-hover": siderToggleBarColorHover
        };
        if (props.inverted) {
          vars["--n-color"] = self2.siderColorInverted;
          vars["--n-text-color"] = self2.textColorInverted;
          vars["--n-border-color"] = self2.siderBorderColorInverted;
          vars["--n-toggle-button-icon-color"] = self2.siderToggleButtonIconColorInverted;
          vars.__invertScrollbar = self2.__invertScrollbar;
        } else {
          vars["--n-color"] = self2.siderColor;
          vars["--n-text-color"] = self2.textColor;
          vars["--n-border-color"] = self2.siderBorderColor;
          vars["--n-toggle-button-icon-color"] = self2.siderToggleButtonIconColor;
        }
        return vars;
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("layout-sider", vue.computed(() => props.inverted ? "a" : "b"), cssVarsRef, props) : void 0;
      return Object.assign({
        scrollableElRef,
        scrollbarInstRef,
        mergedClsPrefix: mergedClsPrefixRef,
        mergedTheme: themeRef,
        styleMaxWidth: styleMaxWidthRef,
        mergedCollapsed: mergedCollapsedRef,
        scrollContainerStyle: scrollContainerStyleRef,
        siderPlacement: siderPlacementRef,
        handleNativeElScroll,
        handleTransitionend,
        handleTriggerClick,
        inlineThemeDisabled,
        cssVars: cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      }, exposedMethods);
    },
    render() {
      var _a;
      const {
        mergedClsPrefix,
        mergedCollapsed,
        showTrigger
      } = this;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      return vue.h("aside", {
        class: [`${mergedClsPrefix}-layout-sider`, this.themeClass, `${mergedClsPrefix}-layout-sider--${this.position}-positioned`, `${mergedClsPrefix}-layout-sider--${this.siderPlacement}-placement`, this.bordered && `${mergedClsPrefix}-layout-sider--bordered`, mergedCollapsed && `${mergedClsPrefix}-layout-sider--collapsed`, (!mergedCollapsed || this.showCollapsedContent) && `${mergedClsPrefix}-layout-sider--show-content`],
        onTransitionend: this.handleTransitionend,
        style: [this.inlineThemeDisabled ? void 0 : this.cssVars, {
          maxWidth: this.styleMaxWidth,
          width: formatLength(this.width)
        }]
      }, !this.nativeScrollbar ? vue.h(NScrollbar, Object.assign({}, this.scrollbarProps, {
        onScroll: this.onScroll,
        ref: "scrollbarInstRef",
        style: this.scrollContainerStyle,
        contentStyle: this.contentStyle,
        contentClass: this.contentClass,
        theme: this.mergedTheme.peers.Scrollbar,
        themeOverrides: this.mergedTheme.peerOverrides.Scrollbar,
        // here is a hack, since in light theme the scrollbar color is dark,
        // we need to invert it in light color...
        builtinThemeOverrides: this.inverted && this.cssVars.__invertScrollbar === "true" ? {
          colorHover: "rgba(255, 255, 255, .4)",
          color: "rgba(255, 255, 255, .3)"
        } : void 0
      }), this.$slots) : vue.h("div", {
        class: [`${mergedClsPrefix}-layout-sider-scroll-container`, this.contentClass],
        onScroll: this.handleNativeElScroll,
        style: [this.scrollContainerStyle, {
          overflow: "auto"
        }, this.contentStyle],
        ref: "scrollableElRef"
      }, this.$slots), showTrigger ? showTrigger === "bar" ? vue.h(ToggleBar, {
        clsPrefix: mergedClsPrefix,
        class: mergedCollapsed ? this.collapsedTriggerClass : this.triggerClass,
        style: mergedCollapsed ? this.collapsedTriggerStyle : this.triggerStyle,
        onClick: this.handleTriggerClick
      }) : vue.h(ToggleButton, {
        clsPrefix: mergedClsPrefix,
        class: mergedCollapsed ? this.collapsedTriggerClass : this.triggerClass,
        style: mergedCollapsed ? this.collapsedTriggerStyle : this.triggerStyle,
        onClick: this.handleTriggerClick
      }) : null, this.bordered ? vue.h("div", {
        class: `${mergedClsPrefix}-layout-sider__border`
      }) : null);
    }
  });
  const commonVariables = {
    extraFontSize: "12px",
    width: "440px"
  };
  function self$4(vars) {
    const {
      fontWeight,
      iconColorDisabled,
      iconColor,
      fontSizeLarge,
      fontSizeMedium,
      fontSizeSmall,
      heightLarge,
      heightMedium,
      heightSmall,
      borderRadius,
      cardColor,
      tableHeaderColor,
      textColor1,
      textColorDisabled,
      textColor2,
      borderColor,
      hoverColor
    } = vars;
    return Object.assign(Object.assign({}, commonVariables), {
      itemHeightSmall: heightSmall,
      itemHeightMedium: heightMedium,
      itemHeightLarge: heightLarge,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      borderRadius,
      borderColor,
      listColor: cardColor,
      headerColor: composite(cardColor, tableHeaderColor),
      titleTextColor: textColor1,
      titleTextColorDisabled: textColorDisabled,
      extraTextColor: textColor2,
      filterDividerColor: borderColor,
      itemTextColor: textColor2,
      itemTextColorDisabled: textColorDisabled,
      itemColorPending: hoverColor,
      titleFontWeight: fontWeight,
      iconColor,
      iconColorDisabled
    });
  }
  const transferLight = createTheme({
    name: "Transfer",
    common: commonLight,
    peers: {
      Checkbox: checkboxLight$1,
      Scrollbar: scrollbarLight$1,
      Input: inputLight$1,
      Empty: emptyLight$1,
      Button: buttonLight$1
    },
    self: self$4
  });
  const legacyTransferLight = transferLight;
  const transferInjectionKey$1 = createInjectionKey("n-transfer");
  const NTransferHeader$1 = vue.defineComponent({
    name: "TransferHeader",
    props: {
      source: {
        type: Boolean,
        default: false
      },
      onChange: {
        type: Function,
        required: true
      },
      title: String
    },
    setup(props) {
      const {
        srcOptsRef,
        tgtOptsRef,
        srcCheckedStatusRef,
        tgtCheckedStatusRef,
        srcCheckedValuesRef,
        tgtCheckedValuesRef,
        mergedThemeRef,
        disabledRef,
        mergedClsPrefixRef
      } = vue.inject(transferInjectionKey$1);
      const checkboxPropsRef = vue.computed(() => {
        const {
          source
        } = props;
        if (source) {
          return srcCheckedStatusRef.value;
        } else {
          return tgtCheckedStatusRef.value;
        }
      });
      return () => {
        const {
          source
        } = props;
        const {
          value: checkboxProps2
        } = checkboxPropsRef;
        const {
          value: mergedTheme
        } = mergedThemeRef;
        const {
          value: mergedClsPrefix
        } = mergedClsPrefixRef;
        return vue.h("div", {
          class: `${mergedClsPrefix}-legacy-transfer-list-header`
        }, vue.h("div", {
          class: `${mergedClsPrefix}-legacy-transfer-list-header__checkbox`
        }, vue.h(NCheckbox, {
          theme: mergedTheme.peers.Checkbox,
          themeOverrides: mergedTheme.peerOverrides.Checkbox,
          checked: checkboxProps2.checked,
          indeterminate: checkboxProps2.indeterminate,
          disabled: checkboxProps2.disabled || disabledRef.value,
          onUpdateChecked: props.onChange
        })), vue.h("div", {
          class: `${mergedClsPrefix}-legacy-transfer-list-header__header`
        }, props.title), vue.h("div", {
          class: `${mergedClsPrefix}-legacy-transfer-list-header__extra`
        }, source ? srcCheckedValuesRef.value.length : tgtCheckedValuesRef.value.length, "/", source ? srcOptsRef.value.length : tgtOptsRef.value.length));
      };
    }
  });
  const NTransferListItem$1 = vue.defineComponent({
    name: "NTransferListItem",
    props: {
      source: {
        type: Boolean,
        default: false
      },
      label: {
        type: String,
        required: true
      },
      value: {
        type: [String, Number],
        required: true
      },
      disabled: {
        type: Boolean,
        default: false
      }
    },
    setup(props) {
      const {
        source
      } = props;
      const {
        mergedClsPrefixRef,
        mergedThemeRef,
        srcCheckedValuesRef,
        tgtCheckedValuesRef,
        handleSrcCheckboxClick,
        handleTgtCheckboxClick
      } = vue.inject(transferInjectionKey$1);
      const checkedRef = source ? useMemo(() => srcCheckedValuesRef.value.includes(props.value)) : useMemo(() => tgtCheckedValuesRef.value.includes(props.value));
      const handleClick2 = source ? () => {
        if (!props.disabled) {
          handleSrcCheckboxClick(!checkedRef.value, props.value);
        }
      } : () => {
        if (!props.disabled) {
          handleTgtCheckboxClick(!checkedRef.value, props.value);
        }
      };
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        mergedTheme: mergedThemeRef,
        checked: checkedRef,
        handleClick: handleClick2
      };
    },
    render() {
      const {
        disabled,
        mergedTheme,
        mergedClsPrefix,
        label,
        checked,
        source
      } = this;
      return vue.h("div", {
        class: [`${mergedClsPrefix}-legacy-transfer-list-item`, disabled && `${mergedClsPrefix}-legacy-transfer-list-item--disabled`, source ? `${mergedClsPrefix}-legacy-transfer-list-item--source` : `${mergedClsPrefix}-legacy-transfer-list-item--target`],
        onClick: this.handleClick
      }, vue.h("div", {
        class: `${mergedClsPrefix}-legacy-transfer-list-item__checkbox`
      }, vue.h(NCheckbox, {
        theme: mergedTheme.peers.Checkbox,
        themeOverrides: mergedTheme.peerOverrides.Checkbox,
        disabled,
        checked
      })), vue.h("div", {
        class: `${mergedClsPrefix}-legacy-transfer-list-item__label`,
        title: getTitleAttribute(label)
      }, label));
    }
  });
  const NTransferList$1 = vue.defineComponent({
    name: "TransferList",
    props: {
      virtualScroll: {
        type: Boolean,
        required: true
      },
      itemSize: {
        type: Number,
        required: true
      },
      options: {
        type: Array,
        required: true
      },
      disabled: {
        type: Boolean,
        required: true
      },
      isMounted: {
        type: Boolean,
        required: true
      },
      isInputing: {
        type: Boolean,
        required: true
      },
      source: {
        type: Boolean,
        default: false
      }
    },
    setup() {
      const {
        mergedThemeRef,
        mergedClsPrefixRef
      } = vue.inject(transferInjectionKey$1);
      const scrollerInstRef = vue.ref(null);
      const vlInstRef = vue.ref(null);
      function syncVLScroller() {
        var _a;
        (_a = scrollerInstRef.value) === null || _a === void 0 ? void 0 : _a.sync();
      }
      function scrollContainer() {
        const {
          value
        } = vlInstRef;
        if (!value)
          return null;
        const {
          listElRef
        } = value;
        return listElRef;
      }
      function scrollContent() {
        const {
          value
        } = vlInstRef;
        if (!value)
          return null;
        const {
          itemsElRef
        } = value;
        return itemsElRef;
      }
      return {
        mergedTheme: mergedThemeRef,
        mergedClsPrefix: mergedClsPrefixRef,
        scrollerInstRef,
        vlInstRef,
        syncVLScroller,
        scrollContainer,
        scrollContent
      };
    },
    render() {
      const {
        mergedTheme,
        mergedClsPrefix,
        virtualScroll,
        syncVLScroller
      } = this;
      return vue.h(vue.Fragment, null, vue.h(NScrollbar, {
        ref: "scrollerInstRef",
        theme: mergedTheme.peers.Scrollbar,
        themeOverrides: mergedTheme.peerOverrides.Scrollbar,
        container: virtualScroll ? this.scrollContainer : void 0,
        content: virtualScroll ? this.scrollContent : void 0
      }, {
        default: () => virtualScroll ? vue.h(VVirtualList, {
          ref: "vlInstRef",
          style: {
            height: "100%"
          },
          class: `${mergedClsPrefix}-legacy-transfer-list-content`,
          items: this.options,
          itemSize: this.itemSize,
          showScrollbar: false,
          onResize: syncVLScroller,
          onScroll: syncVLScroller,
          keyField: "value"
        }, {
          default: ({
            item
          }) => {
            const {
              source,
              disabled
            } = this;
            return vue.h(NTransferListItem$1, {
              source,
              key: item.value,
              value: item.value,
              disabled: item.disabled || disabled,
              label: item.label
            });
          }
        }) : vue.h("div", {
          class: `${mergedClsPrefix}-legacy-transfer-list-content`
        }, vue.h(vue.TransitionGroup, {
          name: "item",
          appear: this.isMounted,
          css: !this.isInputing
        }, {
          default: () => {
            const {
              source,
              disabled
            } = this;
            return this.options.map((option) => vue.h(NTransferListItem$1, {
              source,
              key: option.value,
              value: option.value,
              disabled: option.disabled || disabled,
              label: option.label
            }));
          }
        }))
      }), vue.h(vue.Transition, {
        name: "fade-in-transition",
        appear: this.isMounted,
        css: !this.isInputing
      }, {
        default: () => this.options.length ? null : vue.h(NEmpty, {
          theme: mergedTheme.peers.Empty,
          themeOverrides: mergedTheme.peerOverrides.Empty
        })
      }));
    }
  });
  const NTransferFilter$1 = vue.defineComponent({
    name: "TransferFilter",
    props: {
      value: String,
      placeholder: String,
      disabled: Boolean,
      onFocus: {
        type: Function,
        required: true
      },
      onBlur: {
        type: Function,
        required: true
      },
      onUpdateValue: {
        type: Function,
        required: true
      }
    },
    setup() {
      const {
        mergedThemeRef,
        mergedClsPrefixRef
      } = vue.inject(transferInjectionKey$1);
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        mergedTheme: mergedThemeRef
      };
    },
    render() {
      const {
        mergedTheme,
        mergedClsPrefix
      } = this;
      return vue.h("div", {
        class: `${mergedClsPrefix}-legacy-transfer-filter`
      }, vue.h(NInput, {
        value: this.value,
        onUpdateValue: this.onUpdateValue,
        disabled: this.disabled,
        theme: mergedTheme.peers.Input,
        themeOverrides: mergedTheme.peerOverrides.Input,
        clearable: true,
        size: "small",
        placeholder: this.placeholder,
        onFocus: this.onFocus,
        onBlur: this.onBlur
      }, {
        "clear-icon-placeholder": () => vue.h(NBaseIcon, {
          clsPrefix: mergedClsPrefix,
          class: `${mergedClsPrefix}-legacy-transfer-icon`
        }, {
          default: () => vue.h(SearchIcon, null)
        })
      }));
    }
  });
  function useTransferData$1(props, mergedDisabledRef) {
    const uncontrolledValueRef = vue.ref(props.defaultValue);
    const controlledValueRef = vue.toRef(props, "value");
    const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
    const optMapRef = vue.computed(() => {
      const map2 = /* @__PURE__ */ new Map();
      (props.options || []).forEach((opt) => map2.set(opt.value, opt));
      return map2;
    });
    const tgtValueSetRef = vue.computed(() => new Set(mergedValueRef.value || []));
    const srcOptsRef = vue.computed(() => props.options.filter((option) => !tgtValueSetRef.value.has(option.value)));
    const tgtOptsRef = vue.computed(() => {
      const optMap = optMapRef.value;
      return (mergedValueRef.value || []).map((v) => optMap.get(v));
    });
    const srcPatternRef = vue.ref("");
    const tgtPatternRef = vue.ref("");
    const filteredSrcOptsRef = vue.computed(() => {
      if (!props.filterable)
        return srcOptsRef.value;
      const {
        filter
      } = props;
      return srcOptsRef.value.filter((opt) => filter(srcPatternRef.value, opt, "source"));
    });
    const filteredTgtOptsRef = vue.computed(() => {
      if (!props.filterable)
        return tgtOptsRef.value;
      const {
        filter
      } = props;
      return tgtOptsRef.value.filter((opt) => filter(tgtPatternRef.value, opt, "target"));
    });
    const avlSrcValueSetRef = vue.computed(() => new Set(filteredSrcOptsRef.value.filter((opt) => !opt.disabled).map((opt) => opt.value)));
    const avlTgtValueSetRef = vue.computed(() => new Set(filteredTgtOptsRef.value.filter((opt) => !opt.disabled).map((opt) => opt.value)));
    const srcCheckedValuesRef = vue.ref([]);
    const tgtCheckedValuesRef = vue.ref([]);
    const srcCheckedStatusRef = vue.computed(() => {
      const srcCheckedLength = srcCheckedValuesRef.value.filter((v) => avlSrcValueSetRef.value.has(v)).length;
      const avlValueCount = avlSrcValueSetRef.value.size;
      if (avlValueCount === 0) {
        return {
          checked: false,
          indeterminate: false,
          disabled: true
        };
      } else if (srcCheckedLength === 0) {
        return {
          checked: false,
          indeterminate: false
        };
      } else if (srcCheckedLength === avlValueCount) {
        return {
          checked: true,
          indeterminate: false
        };
      } else {
        return {
          checked: false,
          indeterminate: true
        };
      }
    });
    const tgtCheckedStatusRef = vue.computed(() => {
      const tgtCheckedLength = tgtCheckedValuesRef.value.filter((v) => avlTgtValueSetRef.value.has(v)).length;
      const avlValueCount = avlTgtValueSetRef.value.size;
      if (avlValueCount === 0) {
        return {
          checked: false,
          indeterminate: false,
          disabled: true
        };
      } else if (tgtCheckedLength === 0) {
        return {
          checked: false,
          indeterminate: false
        };
      } else if (tgtCheckedLength === avlValueCount) {
        return {
          checked: true,
          indeterminate: false
        };
      } else {
        return {
          checked: false,
          indeterminate: true
        };
      }
    });
    const fromButtonDisabledRef = useMemo(() => {
      if (mergedDisabledRef.value)
        return true;
      return tgtCheckedValuesRef.value.length === 0;
    });
    const toButtonDisabledRef = useMemo(() => {
      if (mergedDisabledRef.value)
        return true;
      return srcCheckedValuesRef.value.length === 0;
    });
    const isInputingRef = vue.ref(false);
    function handleInputFocus() {
      isInputingRef.value = true;
    }
    function handleInputBlur() {
      isInputingRef.value = false;
    }
    function handleSrcFilterUpdateValue(value) {
      srcPatternRef.value = value !== null && value !== void 0 ? value : "";
    }
    function handleTgtFilterUpdateValue(value) {
      tgtPatternRef.value = value !== null && value !== void 0 ? value : "";
    }
    return {
      uncontrolledValue: uncontrolledValueRef,
      mergedValue: mergedValueRef,
      avlSrcValueSet: avlSrcValueSetRef,
      avlTgtValueSet: avlTgtValueSetRef,
      tgtOpts: tgtOptsRef,
      srcOpts: srcOptsRef,
      filteredSrcOpts: filteredSrcOptsRef,
      filteredTgtOpts: filteredTgtOptsRef,
      srcCheckedValues: srcCheckedValuesRef,
      tgtCheckedValues: tgtCheckedValuesRef,
      srcCheckedStatus: srcCheckedStatusRef,
      tgtCheckedStatus: tgtCheckedStatusRef,
      srcPattern: srcPatternRef,
      tgtPattern: tgtPatternRef,
      isInputing: isInputingRef,
      fromButtonDisabled: fromButtonDisabledRef,
      toButtonDisabled: toButtonDisabledRef,
      handleInputFocus,
      handleInputBlur,
      handleTgtFilterUpdateValue,
      handleSrcFilterUpdateValue
    };
  }
  const animation = c$1([c$1("@keyframes legacy-transfer-slide-in-from-left", `
 0% {
 transform: translateX(-150%);
 }
 100% {
 transform: translateX(0);
 }
 `), c$1("@keyframes legacy-transfer-slide-out-to-right", `
 0% {
 transform: translateX(0);
 }
 100% {
 transform: translateX(150%);
 }
 `), c$1("@keyframes legacy-transfer-slide-in-from-right", `
 0% {
 transform: translateX(150%);
 }
 100% {
 transform: translateX(0);
 }
 `), c$1("@keyframes legacy-transfer-slide-out-to-left", `
 0% {
 transform: translateX(0);
 }
 100% {
 transform: translateX(-150%);
 }
 `), c$1("@keyframes legacy-transfer-height-collapse", `
 0% {
 max-height: var(--n-item-height);
 }
 100% {
 max-height: 0;
 }
 `), c$1("@keyframes legacy-transfer-height-expand", `
 0% {
 max-height: 0;
 }
 100% {
 max-height: var(--n-item-height);
 }
 `)]);
  const style$A = c$1([cB("legacy-transfer", `
 display: flex;
 width: var(--n-width);
 font-size: var(--n-font-size);
 height: 240px;
 display: flex;
 flex-wrap: nowrap;
 `, [cB("legacy-transfer-icon", `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 `), cM("disabled", [cB("legacy-transfer-icon", {
    color: "var(--n-icon-color-disabled)"
  })]), cB("legacy-transfer-list", `
 height: inherit;
 display: flex;
 flex-direction: column;
 background-clip: padding-box;
 width: calc(50% - 36px);
 position: relative;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 background-color: var(--n-list-color);
 `, [cE("border", `
 border: 1px solid var(--n-border-color);
 transition: border-color .3s var(--n-bezier);
 pointer-events: none;
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `), cB("legacy-transfer-list-header", `
 height: calc(var(--n-item-height) + 4px);
 box-sizing: border-box;
 display: flex;
 align-items: center;
 background-clip: padding-box;
 border-radius: inherit;
 border-bottom-left-radius: 0;
 border-bottom-right-radius: 0;
 background-color: var(--n-header-color);
 transition:
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [cE("checkbox", `
 display: flex;
 align-items: center;
 position: relative;
 padding: 0 9px 0 14px;
 `), cE("header", `
 flex: 1;
 line-height: 1;
 font-weight: var(--n-header-font-weight);
 transition: color .3s var(--n-bezier);
 color: var(--n-header-text-color);
 `, [cM("disabled", {
    color: "var(--n-header-text-color-disabled)"
  })]), cE("extra", `
 transition: color .3s var(--n-bezier);
 font-size: var(--n-extra-font-size);
 justify-self: flex-end;
 margin-right: 14px;
 white-space: nowrap;
 color: var(--n-header-extra-text-color);
 `)]), cB("legacy-transfer-list-body", `
 flex-basis: 0;
 flex-grow: 1;
 box-sizing: border-box;
 position: relative;
 display: flex;
 flex-direction: column;
 border-radius: inherit;
 border-top-left-radius: 0;
 border-top-right-radius: 0;
 `, [cB("legacy-transfer-filter", `
 padding: 0 8px 8px 8px;
 box-sizing: border-box;
 background-color: var(--n-header-color);
 transition:
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-filter-divider-color);
 `), cB("legacy-transfer-list-flex-container", `
 flex: 1;
 position: relative;
 `, [cB("scrollbar", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 height: unset;
 `, [cB("scrollbar-content", {
    width: "100%"
  })]), cB("empty", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateY(-50%) translateX(-50%);
 `, [fadeInTransition()]), cB("legacy-transfer-list-content", `
 padding: 0;
 margin: 0;
 position: relative;
 `, [cM("transition-disabled", [cB("legacy-transfer-list-item", {
    animation: "none !important"
  })]), cB("legacy-transfer-list-item", `
 height: var(--n-item-height);
 max-height: var(--n-item-height);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 position: relative;
 cursor: pointer;
 display: flex;
 align-items: center;
 color: var(--n-item-text-color);
 `, [cNotM("disabled", [c$1("&:hover", {
    backgroundColor: "var(--n-item-color-pending)"
  })]), cE("extra", `
 text-overflow: ellipsis;
 overflow: hidden;
 white-space: nowrap;
 padding-right: 4px;
 `), cE("checkbox", `
 display: flex;
 align-items: center;
 position: relative;
 padding: 0 9px 0 14px;
 `), cM("disabled", `
 cursor: not-allowed
 background-color: #0000;
 color: var(--n-item-text-color-disabled);
 `), cM("source", {
    animationFillMode: "forwards"
  }, [c$1("&.item-enter-active", `
 transform: translateX(150%);
 animation-duration: .25s, .25s;
 animation-timing-function: var(--n-bezier), var(--n-bezier-ease-out);
 animation-delay: 0s, .25s;
 animation-name: legacy-transfer-height-expand, legacy-transfer-slide-in-from-right;
 `), c$1("&.item-leave-active", `
 transform: translateX(-150%);
 animation-duration: .25s, .25s;
 animation-timing-function: var(--n-bezier), var(--n-bezier-ease-in);
 animation-delay: .25s, 0s;
 animation-name: legacy-transfer-height-collapse, legacy-transfer-slide-out-to-right;
 `)]), cM("target", {
    animationFillMode: "forwards"
  }, [c$1("&.item-enter-active", `
 transform: translateX(-150%);
 animation-duration: .25s, .25s;
 animation-timing-function: var(--n-bezier), var(--n-bezier-ease-out);
 animation-delay: 0s, .25s;
 animation-name: legacy-transfer-height-expand, legacy-transfer-slide-in-from-left;
 `), c$1("&.item-leave-active", `
 transform: translateX(150%);
 animation-duration: .25s, .25s;
 animation-timing-function: var(--n-bezier), var(--n-bezier-ease-in);
 animation-delay: .25s, 0s;
 animation-name: legacy-transfer-height-collapse, legacy-transfer-slide-out-to-left;
 `)])])])])])]), cB("legacy-transfer-gap", {
    width: "72px",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "column"
  }), cB("button", [c$1("&:first-child", {
    marginBottom: "12px"
  })])]), animation]);
  const transferProps$1 = Object.assign(Object.assign({}, useTheme.props), {
    value: Array,
    defaultValue: {
      type: Array,
      default: null
    },
    options: {
      type: Array,
      default: () => []
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    virtualScroll: Boolean,
    sourceTitle: String,
    targetTitle: String,
    filterable: Boolean,
    sourceFilterPlaceholder: String,
    targetFilterPlaceholder: String,
    filter: {
      type: Function,
      default: (pattern, option) => {
        if (!pattern)
          return true;
        return ~`${option.label}`.toLowerCase().indexOf(`${pattern}`.toLowerCase());
      }
    },
    size: String,
    "onUpdate:value": [Function, Array],
    onUpdateValue: [Function, Array],
    onChange: [Function, Array]
  });
  const Transfer$1 = vue.defineComponent({
    name: "LegacyTransfer",
    props: transferProps$1,
    setup(props) {
      {
        vue.watchEffect(() => {
          if (props.onChange !== void 0) {
            warnOnce("legacy-transfer", "`on-change` is deprecated, please use `on-update:value` instead.");
          }
        });
      }
      const {
        mergedClsPrefixRef
      } = useConfig(props);
      const themeRef = useTheme("LegacyTransfer", "-legacy-transfer", style$A, legacyTransferLight, props, mergedClsPrefixRef);
      const formItem = useFormItem(props);
      const {
        mergedSizeRef,
        mergedDisabledRef
      } = formItem;
      const itemSizeRef = vue.computed(() => {
        const {
          value: size2
        } = mergedSizeRef;
        const {
          self: {
            [createKey("itemHeight", size2)]: itemSize
          }
        } = themeRef.value;
        return depx(itemSize);
      });
      const {
        uncontrolledValue: uncontrolledValueRef,
        mergedValue: mergedValueRef,
        avlSrcValueSet: avlSrcValueSetRef,
        avlTgtValueSet: avlTgtValueSetRef,
        tgtOpts: tgtOptsRef,
        srcOpts: srcOptsRef,
        filteredSrcOpts: filteredSrcOptsRef,
        filteredTgtOpts: filteredTgtOptsRef,
        srcCheckedValues: srcCheckedValuesRef,
        tgtCheckedValues: tgtCheckedValuesRef,
        srcCheckedStatus: srcCheckedStatusRef,
        tgtCheckedStatus: tgtCheckedStatusRef,
        srcPattern: srcPatternRef,
        tgtPattern: tgtPatternRef,
        isInputing: isInputingRef,
        fromButtonDisabled: fromButtonDisabledRef,
        toButtonDisabled: toButtonDisabledRef,
        handleInputFocus,
        handleInputBlur,
        handleTgtFilterUpdateValue,
        handleSrcFilterUpdateValue
      } = useTransferData$1(props, mergedDisabledRef);
      function doUpdateValue(value) {
        const {
          onUpdateValue,
          "onUpdate:value": _onUpdateValue,
          onChange
        } = props;
        const {
          nTriggerFormInput,
          nTriggerFormChange
        } = formItem;
        if (onUpdateValue)
          call(onUpdateValue, value);
        if (_onUpdateValue)
          call(_onUpdateValue, value);
        if (onChange)
          call(onChange, value);
        uncontrolledValueRef.value = value;
        nTriggerFormInput();
        nTriggerFormChange();
      }
      function handleSrcHeaderCheck() {
        const {
          value: {
            checked,
            indeterminate
          }
        } = srcCheckedStatusRef;
        if (indeterminate || checked) {
          srcCheckedValuesRef.value = [];
        } else {
          srcCheckedValuesRef.value = Array.from(avlSrcValueSetRef.value);
        }
      }
      function handleTgtHeaderCheck() {
        const {
          value: {
            checked,
            indeterminate
          }
        } = tgtCheckedStatusRef;
        if (indeterminate || checked) {
          tgtCheckedValuesRef.value = [];
        } else {
          tgtCheckedValuesRef.value = Array.from(avlTgtValueSetRef.value);
        }
      }
      function handleTgtCheckboxClick(checked, optionValue) {
        if (checked) {
          tgtCheckedValuesRef.value.push(optionValue);
        } else {
          const index = tgtCheckedValuesRef.value.findIndex((v) => v === optionValue);
          if (~index) {
            tgtCheckedValuesRef.value.splice(index, 1);
          }
        }
      }
      function handleSrcCheckboxClick(checked, optionValue) {
        if (checked) {
          srcCheckedValuesRef.value.push(optionValue);
        } else {
          const index = srcCheckedValuesRef.value.findIndex((v) => v === optionValue);
          if (~index) {
            srcCheckedValuesRef.value.splice(index, 1);
          }
        }
      }
      function handleToTgtClick() {
        doUpdateValue(srcCheckedValuesRef.value.concat(mergedValueRef.value || []));
        srcCheckedValuesRef.value = [];
      }
      function handleToSrcClick() {
        const tgtCheckedValueSet = new Set(tgtCheckedValuesRef.value);
        doUpdateValue((mergedValueRef.value || []).filter((v) => !tgtCheckedValueSet.has(v)));
        tgtCheckedValuesRef.value = [];
      }
      vue.provide(transferInjectionKey$1, {
        mergedClsPrefixRef,
        mergedSizeRef,
        disabledRef: mergedDisabledRef,
        mergedThemeRef: themeRef,
        srcCheckedValuesRef,
        tgtCheckedValuesRef,
        srcOptsRef,
        tgtOptsRef,
        srcCheckedStatusRef,
        tgtCheckedStatusRef,
        handleSrcCheckboxClick,
        handleTgtCheckboxClick
      });
      const {
        localeRef
      } = useLocale("LegacyTransfer");
      return {
        locale: localeRef,
        mergedClsPrefix: mergedClsPrefixRef,
        mergedDisabled: mergedDisabledRef,
        itemSize: itemSizeRef,
        isMounted: isMounted(),
        isInputing: isInputingRef,
        mergedTheme: themeRef,
        filteredSrcOpts: filteredSrcOptsRef,
        filteredTgtOpts: filteredTgtOptsRef,
        srcPattern: srcPatternRef,
        tgtPattern: tgtPatternRef,
        toButtonDisabled: toButtonDisabledRef,
        fromButtonDisabled: fromButtonDisabledRef,
        handleSrcHeaderCheck,
        handleTgtHeaderCheck,
        handleToSrcClick,
        handleToTgtClick,
        handleInputFocus,
        handleInputBlur,
        handleTgtFilterUpdateValue,
        handleSrcFilterUpdateValue,
        cssVars: vue.computed(() => {
          const {
            value: size2
          } = mergedSizeRef;
          const {
            common: {
              cubicBezierEaseInOut: cubicBezierEaseInOut2,
              cubicBezierEaseIn: cubicBezierEaseIn2,
              cubicBezierEaseOut: cubicBezierEaseOut2
            },
            self: {
              width,
              borderRadius,
              borderColor,
              listColor,
              headerColor,
              titleTextColor,
              titleTextColorDisabled,
              extraTextColor,
              filterDividerColor,
              itemTextColor,
              itemColorPending,
              itemTextColorDisabled,
              extraFontSize,
              titleFontWeight,
              iconColor,
              iconColorDisabled,
              [createKey("fontSize", size2)]: fontSize2,
              [createKey("itemHeight", size2)]: itemHeight
            }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-bezier-ease-in": cubicBezierEaseIn2,
            "--n-bezier-ease-out": cubicBezierEaseOut2,
            "--n-border-color": borderColor,
            "--n-border-radius": borderRadius,
            "--n-extra-font-size": extraFontSize,
            "--n-filter-divider-color": filterDividerColor,
            "--n-font-size": fontSize2,
            "--n-header-color": headerColor,
            "--n-header-extra-text-color": extraTextColor,
            "--n-header-font-weight": titleFontWeight,
            "--n-header-text-color": titleTextColor,
            "--n-header-text-color-disabled": titleTextColorDisabled,
            "--n-item-color-pending": itemColorPending,
            "--n-item-height": itemHeight,
            "--n-item-text-color": itemTextColor,
            "--n-item-text-color-disabled": itemTextColorDisabled,
            "--n-list-color": listColor,
            "--n-width": width,
            "--n-icon-color": iconColor,
            "--n-icon-color-disabled": iconColorDisabled
          };
        })
      };
    },
    render() {
      const {
        mergedClsPrefix
      } = this;
      return vue.h("div", {
        class: [`${mergedClsPrefix}-legacy-transfer`, this.mergedDisabled && `${mergedClsPrefix}-legacy-transfer--disabled`, this.filterable && `${mergedClsPrefix}-legacy-transfer--filterable`],
        style: this.cssVars
      }, vue.h("div", {
        class: `${mergedClsPrefix}-legacy-transfer-list`
      }, vue.h(NTransferHeader$1, {
        source: true,
        onChange: this.handleSrcHeaderCheck,
        title: this.sourceTitle || this.locale.sourceTitle
      }), vue.h("div", {
        class: `${mergedClsPrefix}-legacy-transfer-list-body`
      }, this.filterable ? vue.h(NTransferFilter$1, {
        onUpdateValue: this.handleSrcFilterUpdateValue,
        value: this.srcPattern,
        disabled: this.mergedDisabled,
        placeholder: this.sourceFilterPlaceholder,
        onFocus: this.handleInputFocus,
        onBlur: this.handleInputBlur
      }) : null, vue.h("div", {
        class: `${mergedClsPrefix}-legacy-transfer-list-flex-container`
      }, vue.h(NTransferList$1, {
        source: true,
        options: this.filteredSrcOpts,
        disabled: this.mergedDisabled,
        virtualScroll: this.virtualScroll,
        isMounted: this.isMounted,
        isInputing: this.isInputing,
        itemSize: this.itemSize
      }))), vue.h("div", {
        class: `${mergedClsPrefix}-legacy-transfer-list__border`
      })), vue.h("div", {
        class: `${mergedClsPrefix}-legacy-transfer-gap`
      }, vue.h(NButton, {
        disabled: this.toButtonDisabled || this.mergedDisabled,
        theme: this.mergedTheme.peers.Button,
        themeOverrides: this.mergedTheme.peerOverrides.Button,
        onClick: this.handleToTgtClick
      }, {
        icon: () => vue.h(NBaseIcon, {
          clsPrefix: mergedClsPrefix
        }, {
          default: () => vue.h(ChevronRightIcon, null)
        })
      }), vue.h(NButton, {
        disabled: this.fromButtonDisabled || this.mergedDisabled,
        theme: this.mergedTheme.peers.Button,
        themeOverrides: this.mergedTheme.peerOverrides.Button,
        onClick: this.handleToSrcClick
      }, {
        icon: () => vue.h(NBaseIcon, {
          clsPrefix: mergedClsPrefix
        }, {
          default: () => vue.h(ChevronLeftIcon, null)
        })
      })), vue.h("div", {
        class: `${mergedClsPrefix}-legacy-transfer-list`
      }, vue.h(NTransferHeader$1, {
        onChange: this.handleTgtHeaderCheck,
        title: this.targetTitle || this.locale.targetTitle
      }), vue.h("div", {
        class: `${mergedClsPrefix}-legacy-transfer-list-body`
      }, this.filterable ? vue.h(NTransferFilter$1, {
        onUpdateValue: this.handleTgtFilterUpdateValue,
        value: this.tgtPattern,
        disabled: this.mergedDisabled,
        placeholder: this.targetFilterPlaceholder,
        onFocus: this.handleInputFocus,
        onBlur: this.handleInputBlur
      }) : null, vue.h("div", {
        class: `${mergedClsPrefix}-legacy-transfer-list-flex-container`
      }, vue.h(NTransferList$1, {
        options: this.filteredTgtOpts,
        disabled: this.mergedDisabled,
        virtualScroll: this.virtualScroll,
        isMounted: this.isMounted,
        isInputing: this.isInputing,
        itemSize: this.itemSize
      }))), vue.h("div", {
        class: `${mergedClsPrefix}-legacy-transfer-list__border`
      })));
    }
  });
  const style$z = c$1([cB("list", `
 --n-merged-border-color: var(--n-border-color);
 --n-merged-color: var(--n-color);
 --n-merged-color-hover: var(--n-color-hover);
 margin: 0;
 font-size: var(--n-font-size);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 padding: 0;
 list-style-type: none;
 color: var(--n-text-color);
 background-color: var(--n-merged-color);
 `, [cM("show-divider", [cB("list-item", [c$1("&:not(:last-child)", [cE("divider", `
 background-color: var(--n-merged-border-color);
 `)])])]), cM("clickable", [cB("list-item", `
 cursor: pointer;
 `)]), cM("bordered", `
 border: 1px solid var(--n-merged-border-color);
 border-radius: var(--n-border-radius);
 `), cM("hoverable", [cB("list-item", `
 border-radius: var(--n-border-radius);
 `, [c$1("&:hover", `
 background-color: var(--n-merged-color-hover);
 `, [cE("divider", `
 background-color: transparent;
 `)])])]), cM("bordered, hoverable", [cB("list-item", `
 padding: 12px 20px;
 `), cE("header, footer", `
 padding: 12px 20px;
 `)]), cE("header, footer", `
 padding: 12px 0;
 box-sizing: border-box;
 transition: border-color .3s var(--n-bezier);
 `, [c$1("&:not(:last-child)", `
 border-bottom: 1px solid var(--n-merged-border-color);
 `)]), cB("list-item", `
 position: relative;
 padding: 12px 0; 
 box-sizing: border-box;
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cE("prefix", `
 margin-right: 20px;
 flex: 0;
 `), cE("suffix", `
 margin-left: 20px;
 flex: 0;
 `), cE("main", `
 flex: 1;
 `), cE("divider", `
 height: 1px;
 position: absolute;
 bottom: 0;
 left: 0;
 right: 0;
 background-color: transparent;
 transition: background-color .3s var(--n-bezier);
 pointer-events: none;
 `)])]), insideModal(cB("list", `
 --n-merged-color-hover: var(--n-color-hover-modal);
 --n-merged-color: var(--n-color-modal);
 --n-merged-border-color: var(--n-border-color-modal);
 `)), insidePopover(cB("list", `
 --n-merged-color-hover: var(--n-color-hover-popover);
 --n-merged-color: var(--n-color-popover);
 --n-merged-border-color: var(--n-border-color-popover);
 `))]);
  const listProps = Object.assign(Object.assign({}, useTheme.props), {
    size: {
      type: String,
      default: "medium"
    },
    bordered: Boolean,
    clickable: Boolean,
    hoverable: Boolean,
    showDivider: {
      type: Boolean,
      default: true
    }
  });
  const listInjectionKey = createInjectionKey("n-list");
  const List = vue.defineComponent({
    name: "List",
    props: listProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled,
        mergedRtlRef
      } = useConfig(props);
      const rtlEnabledRef = useRtl("List", mergedRtlRef, mergedClsPrefixRef);
      const themeRef = useTheme("List", "-list", style$z, listLight$1, props, mergedClsPrefixRef);
      vue.provide(listInjectionKey, {
        showDividerRef: vue.toRef(props, "showDivider"),
        mergedClsPrefixRef
      });
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            fontSize: fontSize2,
            textColor,
            color,
            colorModal,
            colorPopover,
            borderColor,
            borderColorModal,
            borderColorPopover,
            borderRadius,
            colorHover,
            colorHoverModal,
            colorHoverPopover
          }
        } = themeRef.value;
        return {
          "--n-font-size": fontSize2,
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-text-color": textColor,
          "--n-color": color,
          "--n-border-radius": borderRadius,
          "--n-border-color": borderColor,
          "--n-border-color-modal": borderColorModal,
          "--n-border-color-popover": borderColorPopover,
          "--n-color-modal": colorModal,
          "--n-color-popover": colorPopover,
          "--n-color-hover": colorHover,
          "--n-color-hover-modal": colorHoverModal,
          "--n-color-hover-popover": colorHoverPopover
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("list", void 0, cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        rtlEnabled: rtlEnabledRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a;
      const {
        $slots,
        mergedClsPrefix,
        onRender
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h("ul", {
        class: [`${mergedClsPrefix}-list`, this.rtlEnabled && `${mergedClsPrefix}-list--rtl`, this.bordered && `${mergedClsPrefix}-list--bordered`, this.showDivider && `${mergedClsPrefix}-list--show-divider`, this.hoverable && `${mergedClsPrefix}-list--hoverable`, this.clickable && `${mergedClsPrefix}-list--clickable`, this.themeClass],
        style: this.cssVars
      }, $slots.header ? vue.h("div", {
        class: `${mergedClsPrefix}-list__header`
      }, $slots.header()) : null, (_a = $slots.default) === null || _a === void 0 ? void 0 : _a.call($slots), $slots.footer ? vue.h("div", {
        class: `${mergedClsPrefix}-list__footer`
      }, $slots.footer()) : null);
    }
  });
  const ListItem = vue.defineComponent({
    name: "ListItem",
    setup() {
      const listInjection = vue.inject(listInjectionKey, null);
      if (!listInjection) {
        throwError("list-item", "`n-list-item` must be placed in `n-list`.");
      }
      return {
        showDivider: listInjection.showDividerRef,
        mergedClsPrefix: listInjection.mergedClsPrefixRef
      };
    },
    render() {
      const {
        $slots,
        mergedClsPrefix
      } = this;
      return vue.h("li", {
        class: `${mergedClsPrefix}-list-item`
      }, $slots.prefix ? vue.h("div", {
        class: `${mergedClsPrefix}-list-item__prefix`
      }, $slots.prefix()) : null, $slots.default ? vue.h("div", {
        class: `${mergedClsPrefix}-list-item__main`
      }, $slots) : null, $slots.suffix ? vue.h("div", {
        class: `${mergedClsPrefix}-list-item__suffix`
      }, $slots.suffix()) : null, this.showDivider && vue.h("div", {
        class: `${mergedClsPrefix}-list-item__divider`
      }));
    }
  });
  const loadingBarProviderInjectionKey = createInjectionKey("n-loading-bar");
  const loadingBarApiInjectionKey = createInjectionKey("n-loading-bar-api");
  const style$y = cB("loading-bar-container", `
 z-index: 5999;
 position: fixed;
 top: 0;
 left: 0;
 right: 0;
 height: 2px;
`, [fadeInTransition({
    enterDuration: "0.3s",
    leaveDuration: "0.8s"
  }), cB("loading-bar", `
 width: 100%;
 transition:
 max-width 4s linear,
 background .2s linear;
 height: var(--n-height);
 `, [cM("starting", `
 background: var(--n-color-loading);
 `), cM("finishing", `
 background: var(--n-color-loading);
 transition:
 max-width .2s linear,
 background .2s linear;
 `), cM("error", `
 background: var(--n-color-error);
 transition:
 max-width .2s linear,
 background .2s linear;
 `)])]);
  var __awaiter$5 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function createClassName(status, clsPrefix) {
    return `${clsPrefix}-loading-bar ${clsPrefix}-loading-bar--${status}`;
  }
  const NLoadingBar = vue.defineComponent({
    name: "LoadingBar",
    props: {
      containerClass: String,
      containerStyle: [String, Object]
    },
    setup() {
      const {
        inlineThemeDisabled
      } = useConfig();
      const {
        props: providerProps,
        mergedClsPrefixRef
      } = vue.inject(loadingBarProviderInjectionKey);
      const loadingBarRef = vue.ref(null);
      const enteringRef = vue.ref(false);
      const startedRef = vue.ref(false);
      const loadingRef = vue.ref(false);
      const transitionDisabledRef = vue.ref(false);
      let finishing = false;
      const erroringRef = vue.ref(false);
      const mergedLoadingBarStyle = vue.computed(() => {
        const {
          loadingBarStyle
        } = providerProps;
        if (!loadingBarStyle)
          return "";
        return loadingBarStyle[erroringRef.value ? "error" : "loading"];
      });
      function init2() {
        return __awaiter$5(this, void 0, void 0, function* () {
          enteringRef.value = false;
          loadingRef.value = false;
          finishing = false;
          erroringRef.value = false;
          transitionDisabledRef.value = true;
          yield vue.nextTick();
          transitionDisabledRef.value = false;
        });
      }
      function start() {
        return __awaiter$5(this, arguments, void 0, function* (fromProgress = 0, toProgress = 80, status = "starting") {
          startedRef.value = true;
          yield init2();
          if (finishing)
            return;
          loadingRef.value = true;
          yield vue.nextTick();
          const el = loadingBarRef.value;
          if (!el)
            return;
          el.style.maxWidth = `${fromProgress}%`;
          el.style.transition = "none";
          void el.offsetWidth;
          el.className = createClassName(status, mergedClsPrefixRef.value);
          el.style.transition = "";
          el.style.maxWidth = `${toProgress}%`;
        });
      }
      function finish() {
        return __awaiter$5(this, void 0, void 0, function* () {
          if (finishing || erroringRef.value)
            return;
          if (startedRef.value) {
            yield vue.nextTick();
          }
          finishing = true;
          const el = loadingBarRef.value;
          if (!el)
            return;
          el.className = createClassName("finishing", mergedClsPrefixRef.value);
          el.style.maxWidth = "100%";
          void el.offsetWidth;
          loadingRef.value = false;
        });
      }
      function error2() {
        if (finishing || erroringRef.value)
          return;
        if (!loadingRef.value) {
          void start(100, 100, "error").then(() => {
            erroringRef.value = true;
            const el = loadingBarRef.value;
            if (!el)
              return;
            el.className = createClassName("error", mergedClsPrefixRef.value);
            void el.offsetWidth;
            loadingRef.value = false;
          });
        } else {
          erroringRef.value = true;
          const el = loadingBarRef.value;
          if (!el)
            return;
          el.className = createClassName("error", mergedClsPrefixRef.value);
          el.style.maxWidth = "100%";
          void el.offsetWidth;
          loadingRef.value = false;
        }
      }
      function handleEnter() {
        enteringRef.value = true;
      }
      function handleAfterEnter() {
        enteringRef.value = false;
      }
      function handleAfterLeave() {
        return __awaiter$5(this, void 0, void 0, function* () {
          yield init2();
        });
      }
      const themeRef = useTheme("LoadingBar", "-loading-bar", style$y, loadingBarLight$1, providerProps, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          self: {
            height,
            colorError,
            colorLoading
          }
        } = themeRef.value;
        return {
          "--n-height": height,
          "--n-color-loading": colorLoading,
          "--n-color-error": colorError
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("loading-bar", void 0, cssVarsRef, providerProps) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        loadingBarRef,
        started: startedRef,
        loading: loadingRef,
        entering: enteringRef,
        transitionDisabled: transitionDisabledRef,
        start,
        error: error2,
        finish,
        handleEnter,
        handleAfterEnter,
        handleAfterLeave,
        mergedLoadingBarStyle,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      if (!this.started)
        return null;
      const {
        mergedClsPrefix
      } = this;
      return vue.h(vue.Transition, {
        name: "fade-in-transition",
        appear: true,
        onEnter: this.handleEnter,
        onAfterEnter: this.handleAfterEnter,
        onAfterLeave: this.handleAfterLeave,
        css: !this.transitionDisabled
      }, {
        default: () => {
          var _a;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.withDirectives(vue.h("div", {
            class: [`${mergedClsPrefix}-loading-bar-container`, this.themeClass, this.containerClass],
            style: this.containerStyle
          }, vue.h("div", {
            ref: "loadingBarRef",
            class: [`${mergedClsPrefix}-loading-bar`],
            style: [this.cssVars, this.mergedLoadingBarStyle]
          })), [[vue.vShow, this.loading || !this.loading && this.entering]]);
        }
      });
    }
  });
  const loadingBarProviderProps = Object.assign(Object.assign({}, useTheme.props), {
    to: {
      type: [String, Object, Boolean],
      default: void 0
    },
    containerClass: String,
    containerStyle: [String, Object],
    loadingBarStyle: {
      type: Object
    }
  });
  const NLoadingBarProvider = vue.defineComponent({
    name: "LoadingBarProvider",
    props: loadingBarProviderProps,
    setup(props) {
      const isMountedRef = isMounted();
      const loadingBarRef = vue.ref(null);
      const methods = {
        start() {
          var _a;
          if (isMountedRef.value) {
            (_a = loadingBarRef.value) === null || _a === void 0 ? void 0 : _a.start();
          } else {
            void vue.nextTick(() => {
              var _a2;
              (_a2 = loadingBarRef.value) === null || _a2 === void 0 ? void 0 : _a2.start();
            });
          }
        },
        error() {
          var _a;
          if (isMountedRef.value) {
            (_a = loadingBarRef.value) === null || _a === void 0 ? void 0 : _a.error();
          } else {
            void vue.nextTick(() => {
              var _a2;
              (_a2 = loadingBarRef.value) === null || _a2 === void 0 ? void 0 : _a2.error();
            });
          }
        },
        finish() {
          var _a;
          if (isMountedRef.value) {
            (_a = loadingBarRef.value) === null || _a === void 0 ? void 0 : _a.finish();
          } else {
            void vue.nextTick(() => {
              var _a2;
              (_a2 = loadingBarRef.value) === null || _a2 === void 0 ? void 0 : _a2.finish();
            });
          }
        }
      };
      const {
        mergedClsPrefixRef
      } = useConfig(props);
      vue.provide(loadingBarApiInjectionKey, methods);
      vue.provide(loadingBarProviderInjectionKey, {
        props,
        mergedClsPrefixRef
      });
      return Object.assign(methods, {
        loadingBarRef
      });
    },
    render() {
      var _a, _b;
      return vue.h(vue.Fragment, null, vue.h(vue.Teleport, {
        disabled: this.to === false,
        to: this.to || "body"
      }, vue.h(NLoadingBar, {
        ref: "loadingBarRef",
        containerStyle: this.containerStyle,
        containerClass: this.containerClass
      })), (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a));
    }
  });
  function useLoadingBar() {
    const loadingBar = vue.inject(loadingBarApiInjectionKey, null);
    if (loadingBar === null) {
      throwError("use-loading-bar", "No outer <n-loading-bar-provider /> founded.");
    }
    return loadingBar;
  }
  const NLogLoader = vue.defineComponent({
    name: "LogLoader",
    props: {
      clsPrefix: {
        type: String,
        required: true
      }
    },
    setup() {
      return {
        locale: useLocale("Log").localeRef
      };
    },
    render() {
      const {
        clsPrefix
      } = this;
      return vue.h("div", {
        class: `${clsPrefix}-log-loader`
      }, vue.h(NBaseLoading, {
        clsPrefix,
        strokeWidth: 24,
        scale: 0.85
      }), vue.h("span", {
        class: `${clsPrefix}-log-loader__content`
      }, this.locale.loading));
    }
  });
  const logInjectionKey = createInjectionKey("n-log");
  const NLogLine = vue.defineComponent({
    props: {
      line: {
        type: String,
        default: ""
      }
    },
    setup(props) {
      const {
        trimRef,
        highlightRef,
        languageRef,
        mergedHljsRef
      } = vue.inject(logInjectionKey);
      const selfRef = vue.ref(null);
      const maybeTrimmedLinesRef = vue.computed(() => {
        return trimRef.value ? props.line.trim() : props.line;
      });
      function setInnerHTML() {
        if (selfRef.value) {
          selfRef.value.innerHTML = generateCodeHTML(languageRef.value, maybeTrimmedLinesRef.value);
        }
      }
      function generateCodeHTML(language, code) {
        const {
          value: hljs
        } = mergedHljsRef;
        if (hljs) {
          if (language && hljs.getLanguage(language)) {
            return hljs.highlight(code, {
              language
            }).value;
          }
        }
        return code;
      }
      vue.onMounted(() => {
        if (highlightRef.value) {
          setInnerHTML();
        }
      });
      vue.watch(vue.toRef(props, "line"), () => {
        if (highlightRef.value) {
          setInnerHTML();
        }
      });
      return {
        highlight: highlightRef,
        selfRef,
        maybeTrimmedLines: maybeTrimmedLinesRef
      };
    },
    render() {
      const {
        highlight,
        maybeTrimmedLines
      } = this;
      return vue.h("pre", {
        ref: "selfRef"
      }, highlight ? null : maybeTrimmedLines);
    }
  });
  const style$x = cB("log", `
 position: relative;
 box-sizing: border-box;
 transition: border-color .3s var(--n-bezier);
`, [c$1("pre", `
 white-space: pre-wrap;
 word-break: break-word;
 margin: 0;
 `), cB("log-loader", `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 box-sizing: border-box;
 position: absolute;
 right: 16px;
 top: 8px;
 height: 34px;
 border-radius: 17px;
 line-height: 34px;
 white-space: nowrap;
 overflow: hidden;
 border: var(--n-loader-border);
 color: var(--n-loader-text-color);
 background-color: var(--n-loader-color);
 font-size: var(--n-loader-font-size);
 `, [fadeInScaleUpTransition(), cE("content", `
 display: inline-block;
 vertical-align: bottom;
 line-height: 34px;
 padding-left: 40px;
 padding-right: 20px;
 white-space: nowrap;
 `), cB("base-loading", `
 color: var(--n-loading-color);
 position: absolute;
 left: 12px;
 top: calc(50% - 10px);
 font-size: 20px;
 width: 20px;
 height: 20px;
 display: inline-block;
 `)])]);
  const logProps = Object.assign(Object.assign({}, useTheme.props), {
    loading: Boolean,
    trim: Boolean,
    log: String,
    fontSize: {
      type: Number,
      default: 14
    },
    lines: {
      type: Array,
      default: () => []
    },
    lineHeight: {
      type: Number,
      default: 1.25
    },
    language: String,
    rows: {
      type: Number,
      default: 15
    },
    offsetTop: {
      type: Number,
      default: 0
    },
    offsetBottom: {
      type: Number,
      default: 0
    },
    hljs: Object,
    onReachTop: Function,
    onReachBottom: Function,
    onRequireMore: Function
  });
  const Log = vue.defineComponent({
    name: "Log",
    props: logProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const silentRef = vue.ref(false);
      const highlightRef = vue.computed(() => {
        return props.language !== void 0;
      });
      const styleHeightRef = vue.computed(() => {
        return `calc(${Math.round(props.rows * props.lineHeight * props.fontSize)}px)`;
      });
      const mergedLinesRef = vue.computed(() => {
        const {
          log
        } = props;
        if (log) {
          return log.split("\n");
        }
        return props.lines;
      });
      const scrollbarRef = vue.ref(null);
      const themeRef = useTheme("Log", "-log", style$x, logLight$1, props, mergedClsPrefixRef);
      function handleScroll(e) {
        const container = e.target;
        const content = container.firstElementChild;
        if (silentRef.value) {
          void vue.nextTick(() => {
            silentRef.value = false;
          });
          return;
        }
        const containerHeight = container.offsetHeight;
        const containerScrollTop = container.scrollTop;
        const contentHeight = content.offsetHeight;
        const scrollTop = containerScrollTop;
        const scrollBottom = contentHeight - containerScrollTop - containerHeight;
        if (scrollTop <= props.offsetTop) {
          const {
            onReachTop,
            onRequireMore
          } = props;
          if (onRequireMore)
            onRequireMore("top");
          if (onReachTop)
            onReachTop();
        }
        if (scrollBottom <= props.offsetBottom) {
          const {
            onReachBottom,
            onRequireMore
          } = props;
          if (onRequireMore)
            onRequireMore("bottom");
          if (onReachBottom)
            onReachBottom();
        }
      }
      const handleWheel = throttle(_handleWheel, 300);
      function _handleWheel(e) {
        if (silentRef.value) {
          void vue.nextTick(() => {
            silentRef.value = false;
          });
          return;
        }
        if (scrollbarRef.value) {
          const {
            containerRef,
            contentRef
          } = scrollbarRef.value;
          if (containerRef && contentRef) {
            const containerHeight = containerRef.offsetHeight;
            const containerScrollTop = containerRef.scrollTop;
            const contentHeight = contentRef.offsetHeight;
            const scrollTop = containerScrollTop;
            const scrollBottom = contentHeight - containerScrollTop - containerHeight;
            const deltaY = e.deltaY;
            if (scrollTop === 0 && deltaY < 0) {
              const {
                onRequireMore
              } = props;
              if (onRequireMore)
                onRequireMore("top");
            }
            if (scrollBottom <= 0 && deltaY > 0) {
              const {
                onRequireMore
              } = props;
              if (onRequireMore)
                onRequireMore("bottom");
            }
          }
        }
      }
      function scrollTo(options) {
        const {
          value: scrollbarInst
        } = scrollbarRef;
        if (!scrollbarInst)
          return;
        const {
          silent,
          top,
          position
        } = options;
        if (silent) {
          silentRef.value = true;
        }
        if (top !== void 0) {
          scrollbarInst.scrollTo({
            left: 0,
            top
          });
        } else if (position === "bottom" || position === "top") {
          scrollbarInst.scrollTo({
            position
          });
        }
      }
      function scrollToTop(silent = false) {
        warn$2("log", "`scrollToTop` is deprecated, please use `scrollTo({ position: 'top'})` instead.");
        scrollTo({
          position: "top",
          silent
        });
      }
      function scrollToBottom(silent = false) {
        warn$2("log", "`scrollToTop` is deprecated, please use `scrollTo({ position: 'bottom'})` instead.");
        scrollTo({
          position: "bottom",
          silent
        });
      }
      vue.provide(logInjectionKey, {
        languageRef: vue.toRef(props, "language"),
        mergedHljsRef: useHljs(props, highlightRef),
        trimRef: vue.toRef(props, "trim"),
        highlightRef
      });
      const exportedMethods = {
        scrollTo
      };
      const cssVarsRef = vue.computed(() => {
        const {
          self: {
            loaderFontSize,
            loaderTextColor,
            loaderColor,
            loaderBorder,
            loadingColor
          },
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-loader-font-size": loaderFontSize,
          "--n-loader-border": loaderBorder,
          "--n-loader-color": loaderColor,
          "--n-loader-text-color": loaderTextColor,
          "--n-loading-color": loadingColor
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("log", void 0, cssVarsRef, props) : void 0;
      return Object.assign(Object.assign({}, exportedMethods), {
        mergedClsPrefix: mergedClsPrefixRef,
        scrollbarRef,
        mergedTheme: themeRef,
        styleHeight: styleHeightRef,
        mergedLines: mergedLinesRef,
        scrollToTop,
        scrollToBottom,
        handleWheel,
        handleScroll,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      });
    },
    render() {
      const {
        mergedClsPrefix,
        mergedTheme,
        onRender
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h("div", {
        class: [`${mergedClsPrefix}-log`, this.themeClass],
        style: [{
          lineHeight: this.lineHeight,
          height: this.styleHeight
        }, this.cssVars],
        onWheelPassive: this.handleWheel
      }, [vue.h(NScrollbar, {
        ref: "scrollbarRef",
        theme: mergedTheme.peers.Scrollbar,
        themeOverrides: mergedTheme.peerOverrides.Scrollbar,
        onScroll: this.handleScroll
      }, {
        default: () => vue.h(NCode, {
          internalNoHighlight: true,
          internalFontSize: this.fontSize,
          theme: mergedTheme.peers.Code,
          themeOverrides: mergedTheme.peerOverrides.Code
        }, {
          default: () => this.mergedLines.map((line, index) => {
            return vue.h(NLogLine, {
              key: index,
              line
            });
          })
        })
      }), vue.h(vue.Transition, {
        name: "fade-in-scale-up-transition"
      }, {
        default: () => this.loading ? vue.h(NLogLoader, {
          clsPrefix: mergedClsPrefix
        }) : null
      })]);
    }
  });
  var __awaiter$4 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  const infiniteScrollProps = {
    distance: {
      type: Number,
      default: 0
    },
    onLoad: Function,
    scrollbarProps: Object
  };
  const InfiniteScroll = vue.defineComponent({
    name: "InfiniteScroll",
    props: infiniteScrollProps,
    setup(props) {
      const scrollbarInstRef = vue.ref(null);
      let loading = false;
      const handleCheckBottom = () => __awaiter$4(this, void 0, void 0, function* () {
        var _a;
        const {
          value: scrollbarInst
        } = scrollbarInstRef;
        if (scrollbarInst) {
          const {
            containerRef
          } = scrollbarInst;
          const scrollHeight = containerRef === null || containerRef === void 0 ? void 0 : containerRef.scrollHeight;
          const clientHeight = containerRef === null || containerRef === void 0 ? void 0 : containerRef.clientHeight;
          const scrollTop = containerRef === null || containerRef === void 0 ? void 0 : containerRef.scrollTop;
          if (containerRef && scrollHeight !== void 0 && clientHeight !== void 0 && scrollTop !== void 0) {
            if (scrollTop + clientHeight >= scrollHeight - props.distance) {
              loading = true;
              try {
                yield (_a = props.onLoad) === null || _a === void 0 ? void 0 : _a.call(props);
              } catch (_b) {
              }
              loading = false;
            }
          }
        }
      });
      const handleScroll = () => {
        if (loading)
          return;
        void handleCheckBottom();
      };
      const handleWheel = (e) => {
        if (e.deltaY <= 0)
          return;
        if (loading)
          return;
        void handleCheckBottom();
      };
      return {
        scrollbarInstRef,
        handleScroll,
        handleWheel
      };
    },
    render() {
      return vue.h(XScrollbar, Object.assign({}, this.scrollbarProps, {
        ref: "scrollbarInstRef",
        onWheel: this.handleWheel,
        onScroll: this.handleScroll
      }), {
        default: () => {
          return resolveSlot(this.$slots.default, () => []);
        }
      });
    }
  });
  const menuInjectionKey = createInjectionKey("n-menu");
  const submenuInjectionKey = createInjectionKey("n-submenu");
  const menuItemGroupInjectionKey = createInjectionKey("n-menu-item-group");
  const ICON_MARGIN_RIGHT = 8;
  function useMenuChild(props) {
    const NMenu = vue.inject(menuInjectionKey);
    const {
      props: menuProps2,
      mergedCollapsedRef
    } = NMenu;
    const NSubmenu2 = vue.inject(submenuInjectionKey, null);
    const NMenuOptionGroup2 = vue.inject(menuItemGroupInjectionKey, null);
    const horizontalRef = vue.computed(() => {
      return menuProps2.mode === "horizontal";
    });
    const dropdownPlacementRef = vue.computed(() => {
      if (horizontalRef.value) {
        return menuProps2.dropdownPlacement;
      }
      if ("tmNodes" in props)
        return "right-start";
      return "right";
    });
    const maxIconSizeRef = vue.computed(() => {
      var _a;
      return Math.max((_a = menuProps2.collapsedIconSize) !== null && _a !== void 0 ? _a : menuProps2.iconSize, menuProps2.iconSize);
    });
    const activeIconSizeRef = vue.computed(() => {
      var _a;
      if (!horizontalRef.value && props.root && mergedCollapsedRef.value) {
        return (_a = menuProps2.collapsedIconSize) !== null && _a !== void 0 ? _a : menuProps2.iconSize;
      } else {
        return menuProps2.iconSize;
      }
    });
    const paddingLeftRef = vue.computed(() => {
      if (horizontalRef.value)
        return void 0;
      const {
        collapsedWidth,
        indent,
        rootIndent
      } = menuProps2;
      const {
        root: root2,
        isGroup: isGroup2
      } = props;
      const mergedRootIndent = rootIndent === void 0 ? indent : rootIndent;
      if (root2) {
        if (mergedCollapsedRef.value) {
          return collapsedWidth / 2 - maxIconSizeRef.value / 2;
        }
        return mergedRootIndent;
      }
      if (NMenuOptionGroup2 && typeof NMenuOptionGroup2.paddingLeftRef.value === "number") {
        return indent / 2 + NMenuOptionGroup2.paddingLeftRef.value;
      }
      if (NSubmenu2 && typeof NSubmenu2.paddingLeftRef.value === "number") {
        return (isGroup2 ? indent / 2 : indent) + NSubmenu2.paddingLeftRef.value;
      }
      return 0;
    });
    const iconMarginRightRef = vue.computed(() => {
      const {
        collapsedWidth,
        indent,
        rootIndent
      } = menuProps2;
      const {
        value: maxIconSize
      } = maxIconSizeRef;
      const {
        root: root2
      } = props;
      if (horizontalRef.value)
        return ICON_MARGIN_RIGHT;
      if (!root2)
        return ICON_MARGIN_RIGHT;
      if (!mergedCollapsedRef.value)
        return ICON_MARGIN_RIGHT;
      const mergedRootIndent = rootIndent === void 0 ? indent : rootIndent;
      return mergedRootIndent + maxIconSize + ICON_MARGIN_RIGHT - (collapsedWidth + maxIconSize) / 2;
    });
    return {
      dropdownPlacement: dropdownPlacementRef,
      activeIconSize: activeIconSizeRef,
      maxIconSize: maxIconSizeRef,
      paddingLeft: paddingLeftRef,
      iconMarginRight: iconMarginRightRef,
      NMenu,
      NSubmenu: NSubmenu2
    };
  }
  const useMenuChildProps = {
    internalKey: {
      type: [String, Number],
      required: true
    },
    root: Boolean,
    isGroup: Boolean,
    level: {
      type: Number,
      required: true
    },
    title: [String, Function],
    extra: [String, Function]
  };
  const menuItemGroupProps = Object.assign(Object.assign({}, useMenuChildProps), {
    tmNode: {
      type: Object,
      required: true
    },
    tmNodes: {
      type: Array,
      required: true
    }
  });
  const NMenuOptionGroup = vue.defineComponent({
    name: "MenuOptionGroup",
    props: menuItemGroupProps,
    setup(props) {
      vue.provide(submenuInjectionKey, null);
      const MenuChild = useMenuChild(props);
      vue.provide(menuItemGroupInjectionKey, {
        paddingLeftRef: MenuChild.paddingLeft
      });
      const {
        mergedClsPrefixRef,
        props: menuProps2
      } = vue.inject(menuInjectionKey);
      return function() {
        const {
          value: mergedClsPrefix
        } = mergedClsPrefixRef;
        const paddingLeft = MenuChild.paddingLeft.value;
        const {
          nodeProps
        } = menuProps2;
        const attrs = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(props.tmNode.rawNode);
        return vue.h("div", {
          class: `${mergedClsPrefix}-menu-item-group`,
          role: "group"
        }, vue.h("div", Object.assign({}, attrs, {
          class: [`${mergedClsPrefix}-menu-item-group-title`, attrs === null || attrs === void 0 ? void 0 : attrs.class],
          style: [(attrs === null || attrs === void 0 ? void 0 : attrs.style) || "", paddingLeft !== void 0 ? `padding-left: ${paddingLeft}px;` : ""]
        }), render$1(props.title), props.extra ? vue.h(vue.Fragment, null, " ", render$1(props.extra)) : null), vue.h("div", null, props.tmNodes.map((tmNode) => itemRenderer(tmNode, menuProps2))));
      };
    }
  });
  const NMenuOptionContent = vue.defineComponent({
    name: "MenuOptionContent",
    props: {
      collapsed: Boolean,
      disabled: Boolean,
      title: [String, Function],
      icon: Function,
      extra: [String, Function],
      showArrow: Boolean,
      childActive: Boolean,
      hover: Boolean,
      paddingLeft: Number,
      selected: Boolean,
      maxIconSize: {
        type: Number,
        required: true
      },
      activeIconSize: {
        type: Number,
        required: true
      },
      iconMarginRight: {
        type: Number,
        required: true
      },
      clsPrefix: {
        type: String,
        required: true
      },
      onClick: Function,
      tmNode: {
        type: Object,
        required: true
      },
      isEllipsisPlaceholder: Boolean
    },
    setup(props) {
      const {
        props: menuProps2
      } = vue.inject(menuInjectionKey);
      return {
        menuProps: menuProps2,
        style: vue.computed(() => {
          const {
            paddingLeft
          } = props;
          return {
            paddingLeft: paddingLeft && `${paddingLeft}px`
          };
        }),
        iconStyle: vue.computed(() => {
          const {
            maxIconSize,
            activeIconSize,
            iconMarginRight
          } = props;
          return {
            width: `${maxIconSize}px`,
            height: `${maxIconSize}px`,
            fontSize: `${activeIconSize}px`,
            marginRight: `${iconMarginRight}px`
          };
        })
      };
    },
    render() {
      const {
        clsPrefix,
        tmNode,
        menuProps: {
          renderIcon,
          renderLabel,
          renderExtra,
          expandIcon
        }
      } = this;
      const icon = renderIcon ? renderIcon(tmNode.rawNode) : render$1(this.icon);
      return vue.h("div", {
        onClick: (e) => {
          var _a;
          (_a = this.onClick) === null || _a === void 0 ? void 0 : _a.call(this, e);
        },
        role: "none",
        class: [`${clsPrefix}-menu-item-content`, {
          [`${clsPrefix}-menu-item-content--selected`]: this.selected,
          [`${clsPrefix}-menu-item-content--collapsed`]: this.collapsed,
          [`${clsPrefix}-menu-item-content--child-active`]: this.childActive,
          [`${clsPrefix}-menu-item-content--disabled`]: this.disabled,
          [`${clsPrefix}-menu-item-content--hover`]: this.hover
        }],
        style: this.style
      }, icon && vue.h("div", {
        class: `${clsPrefix}-menu-item-content__icon`,
        style: this.iconStyle,
        role: "none"
      }, [icon]), vue.h("div", {
        class: `${clsPrefix}-menu-item-content-header`,
        role: "none"
      }, this.isEllipsisPlaceholder ? this.title : renderLabel ? renderLabel(tmNode.rawNode) : render$1(this.title), this.extra || renderExtra ? vue.h("span", {
        class: `${clsPrefix}-menu-item-content-header__extra`
      }, " ", renderExtra ? renderExtra(tmNode.rawNode) : render$1(this.extra)) : null), this.showArrow ? vue.h(NBaseIcon, {
        ariaHidden: true,
        class: `${clsPrefix}-menu-item-content__arrow`,
        clsPrefix
      }, {
        default: () => expandIcon ? expandIcon(tmNode.rawNode) : vue.h(ChevronDownFilledIcon, null)
      }) : null);
    }
  });
  const submenuProps = Object.assign(Object.assign({}, useMenuChildProps), {
    rawNodes: {
      type: Array,
      default: () => []
    },
    tmNodes: {
      type: Array,
      default: () => []
    },
    tmNode: {
      type: Object,
      required: true
    },
    disabled: Boolean,
    icon: Function,
    onClick: Function,
    domId: String,
    virtualChildActive: {
      type: Boolean,
      default: void 0
    },
    isEllipsisPlaceholder: Boolean
  });
  const NSubmenu = vue.defineComponent({
    name: "Submenu",
    props: submenuProps,
    setup(props) {
      const MenuChild = useMenuChild(props);
      const {
        NMenu,
        NSubmenu: NSubmenu2
      } = MenuChild;
      const {
        props: menuProps2,
        mergedCollapsedRef,
        mergedThemeRef
      } = NMenu;
      const mergedDisabledRef = vue.computed(() => {
        const {
          disabled
        } = props;
        if (NSubmenu2 === null || NSubmenu2 === void 0 ? void 0 : NSubmenu2.mergedDisabledRef.value)
          return true;
        if (menuProps2.disabled)
          return true;
        return disabled;
      });
      const dropdownShowRef = vue.ref(false);
      vue.provide(submenuInjectionKey, {
        paddingLeftRef: MenuChild.paddingLeft,
        mergedDisabledRef
      });
      vue.provide(menuItemGroupInjectionKey, null);
      function doClick() {
        const {
          onClick
        } = props;
        if (onClick)
          onClick();
      }
      function handleClick2() {
        if (!mergedDisabledRef.value) {
          if (!mergedCollapsedRef.value) {
            NMenu.toggleExpand(props.internalKey);
          }
          doClick();
        }
      }
      function handlePopoverShowChange(value) {
        dropdownShowRef.value = value;
      }
      return {
        menuProps: menuProps2,
        mergedTheme: mergedThemeRef,
        doSelect: NMenu.doSelect,
        inverted: NMenu.invertedRef,
        isHorizontal: NMenu.isHorizontalRef,
        mergedClsPrefix: NMenu.mergedClsPrefixRef,
        maxIconSize: MenuChild.maxIconSize,
        activeIconSize: MenuChild.activeIconSize,
        iconMarginRight: MenuChild.iconMarginRight,
        dropdownPlacement: MenuChild.dropdownPlacement,
        dropdownShow: dropdownShowRef,
        paddingLeft: MenuChild.paddingLeft,
        mergedDisabled: mergedDisabledRef,
        mergedValue: NMenu.mergedValueRef,
        childActive: useMemo(() => {
          var _a;
          return (_a = props.virtualChildActive) !== null && _a !== void 0 ? _a : NMenu.activePathRef.value.includes(props.internalKey);
        }),
        collapsed: vue.computed(() => {
          if (menuProps2.mode === "horizontal")
            return false;
          if (mergedCollapsedRef.value) {
            return true;
          }
          return !NMenu.mergedExpandedKeysRef.value.includes(props.internalKey);
        }),
        dropdownEnabled: vue.computed(() => {
          return !mergedDisabledRef.value && (menuProps2.mode === "horizontal" || mergedCollapsedRef.value);
        }),
        handlePopoverShowChange,
        handleClick: handleClick2
      };
    },
    render() {
      var _a;
      const {
        mergedClsPrefix,
        menuProps: {
          renderIcon,
          renderLabel
        }
      } = this;
      const createSubmenuItem = () => {
        const {
          isHorizontal,
          paddingLeft,
          collapsed,
          mergedDisabled,
          maxIconSize,
          activeIconSize,
          title,
          childActive,
          icon,
          handleClick: handleClick2,
          menuProps: {
            nodeProps
          },
          dropdownShow,
          iconMarginRight,
          tmNode,
          mergedClsPrefix: mergedClsPrefix2,
          isEllipsisPlaceholder,
          extra
        } = this;
        const attrs = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(tmNode.rawNode);
        return vue.h("div", Object.assign({}, attrs, {
          class: [`${mergedClsPrefix2}-menu-item`, attrs === null || attrs === void 0 ? void 0 : attrs.class],
          role: "menuitem"
        }), vue.h(NMenuOptionContent, {
          tmNode,
          paddingLeft,
          collapsed,
          disabled: mergedDisabled,
          iconMarginRight,
          maxIconSize,
          activeIconSize,
          title,
          extra,
          showArrow: !isHorizontal,
          childActive,
          clsPrefix: mergedClsPrefix2,
          icon,
          hover: dropdownShow,
          onClick: handleClick2,
          isEllipsisPlaceholder
        }));
      };
      const createSubmenuChildren = () => {
        return vue.h(NFadeInExpandTransition, null, {
          default: () => {
            const {
              tmNodes,
              collapsed
            } = this;
            return !collapsed ? vue.h("div", {
              class: `${mergedClsPrefix}-submenu-children`,
              role: "menu"
            }, tmNodes.map((item) => itemRenderer(item, this.menuProps))) : null;
          }
        });
      };
      return this.root ? vue.h(NDropdown, Object.assign({
        size: "large",
        trigger: "hover"
      }, (_a = this.menuProps) === null || _a === void 0 ? void 0 : _a.dropdownProps, {
        themeOverrides: this.mergedTheme.peerOverrides.Dropdown,
        theme: this.mergedTheme.peers.Dropdown,
        builtinThemeOverrides: {
          fontSizeLarge: "14px",
          optionIconSizeLarge: "18px"
        },
        value: this.mergedValue,
        disabled: !this.dropdownEnabled,
        placement: this.dropdownPlacement,
        keyField: this.menuProps.keyField,
        labelField: this.menuProps.labelField,
        childrenField: this.menuProps.childrenField,
        onUpdateShow: this.handlePopoverShowChange,
        options: this.rawNodes,
        onSelect: this.doSelect,
        inverted: this.inverted,
        renderIcon,
        renderLabel
      }), {
        default: () => vue.h("div", {
          class: `${mergedClsPrefix}-submenu`,
          role: "menu",
          "aria-expanded": !this.collapsed,
          id: this.domId
        }, createSubmenuItem(), this.isHorizontal ? null : createSubmenuChildren())
      }) : vue.h("div", {
        class: `${mergedClsPrefix}-submenu`,
        role: "menu",
        "aria-expanded": !this.collapsed,
        id: this.domId
      }, createSubmenuItem(), createSubmenuChildren());
    }
  });
  const menuItemProps = Object.assign(Object.assign({}, useMenuChildProps), {
    tmNode: {
      type: Object,
      required: true
    },
    disabled: Boolean,
    icon: Function,
    onClick: Function
  });
  const NMenuOption = vue.defineComponent({
    name: "MenuOption",
    props: menuItemProps,
    setup(props) {
      const MenuChild = useMenuChild(props);
      const {
        NSubmenu: NSubmenu2,
        NMenu
      } = MenuChild;
      const {
        props: menuProps2,
        mergedClsPrefixRef,
        mergedCollapsedRef
      } = NMenu;
      const submenuDisabledRef = NSubmenu2 ? NSubmenu2.mergedDisabledRef : {
        value: false
      };
      const mergedDisabledRef = vue.computed(() => {
        return submenuDisabledRef.value || props.disabled;
      });
      function doClick(e) {
        const {
          onClick
        } = props;
        if (onClick)
          onClick(e);
      }
      function handleClick2(e) {
        if (!mergedDisabledRef.value) {
          NMenu.doSelect(props.internalKey, props.tmNode.rawNode);
          doClick(e);
        }
      }
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        dropdownPlacement: MenuChild.dropdownPlacement,
        paddingLeft: MenuChild.paddingLeft,
        iconMarginRight: MenuChild.iconMarginRight,
        maxIconSize: MenuChild.maxIconSize,
        activeIconSize: MenuChild.activeIconSize,
        mergedTheme: NMenu.mergedThemeRef,
        menuProps: menuProps2,
        dropdownEnabled: useMemo(() => {
          return props.root && mergedCollapsedRef.value && menuProps2.mode !== "horizontal" && !mergedDisabledRef.value;
        }),
        selected: useMemo(() => {
          if (NMenu.mergedValueRef.value === props.internalKey)
            return true;
          return false;
        }),
        mergedDisabled: mergedDisabledRef,
        handleClick: handleClick2
      };
    },
    render() {
      const {
        mergedClsPrefix,
        mergedTheme,
        tmNode,
        menuProps: {
          renderLabel,
          nodeProps
        }
      } = this;
      const attrs = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(tmNode.rawNode);
      return vue.h("div", Object.assign({}, attrs, {
        role: "menuitem",
        class: [`${mergedClsPrefix}-menu-item`, attrs === null || attrs === void 0 ? void 0 : attrs.class]
      }), vue.h(NTooltip, {
        theme: mergedTheme.peers.Tooltip,
        themeOverrides: mergedTheme.peerOverrides.Tooltip,
        trigger: "hover",
        placement: this.dropdownPlacement,
        disabled: !this.dropdownEnabled || this.title === void 0,
        internalExtraClass: ["menu-tooltip"]
      }, {
        default: () => renderLabel ? renderLabel(tmNode.rawNode) : render$1(this.title),
        trigger: () => vue.h(NMenuOptionContent, {
          tmNode,
          clsPrefix: mergedClsPrefix,
          paddingLeft: this.paddingLeft,
          iconMarginRight: this.iconMarginRight,
          maxIconSize: this.maxIconSize,
          activeIconSize: this.activeIconSize,
          selected: this.selected,
          title: this.title,
          extra: this.extra,
          disabled: this.mergedDisabled,
          icon: this.icon,
          onClick: this.handleClick
        })
      }));
    }
  });
  const NMenuDivider = vue.defineComponent({
    name: "MenuDivider",
    setup() {
      const NMenu = vue.inject(menuInjectionKey);
      const {
        mergedClsPrefixRef,
        isHorizontalRef
      } = NMenu;
      return () => isHorizontalRef.value ? null : vue.h("div", {
        class: `${mergedClsPrefixRef.value}-menu-divider`
      });
    }
  });
  const groupPropKeys = keysOf(menuItemGroupProps);
  const itemPropKeys = keysOf(menuItemProps);
  const submenuPropKeys = keysOf(submenuProps);
  function isIgnoredNode(rawNode) {
    return rawNode.type === "divider" || rawNode.type === "render";
  }
  function isDividerNode(rawNode) {
    return rawNode.type === "divider";
  }
  function itemRenderer(tmNode, menuProps2) {
    const {
      rawNode
    } = tmNode;
    const {
      show
    } = rawNode;
    if (show === false) {
      return null;
    }
    if (isIgnoredNode(rawNode)) {
      if (isDividerNode(rawNode)) {
        return vue.h(NMenuDivider, Object.assign({
          key: tmNode.key
        }, rawNode.props));
      }
      return null;
    }
    const {
      labelField
    } = menuProps2;
    const {
      key,
      level,
      isGroup: isGroup2
    } = tmNode;
    const props = Object.assign(Object.assign({}, rawNode), {
      title: rawNode.title || rawNode[labelField],
      extra: rawNode.titleExtra || rawNode.extra,
      key,
      internalKey: key,
      // since key can't be used as a prop
      level,
      root: level === 0,
      isGroup: isGroup2
    });
    if (tmNode.children) {
      if (tmNode.isGroup) {
        return vue.h(NMenuOptionGroup, keep(props, groupPropKeys, {
          tmNode,
          tmNodes: tmNode.children,
          key
        }));
      }
      return vue.h(NSubmenu, keep(props, submenuPropKeys, {
        key,
        rawNodes: rawNode[menuProps2.childrenField],
        tmNodes: tmNode.children,
        tmNode
      }));
    } else {
      return vue.h(NMenuOption, keep(props, itemPropKeys, {
        key,
        tmNode
      }));
    }
  }
  function useCheckDeprecated(props) {
    vue.watchEffect(() => {
      if (props.items) {
        warnOnce("menu", "`items` is deprecated, please use `options` instead.");
      }
      if (props.onOpenNamesChange) {
        warnOnce("menu", "`on-open-names-change` is deprecated, please use `on-update:expanded-keys` instead.");
      }
      if (props.onSelect) {
        warnOnce("menu", "`on-select` is deprecated, please use `on-update:value` instead.");
      }
      if (props.onExpandedNamesChange) {
        warnOnce("menu", "`on-expanded-names-change` is deprecated, please use `on-update:expanded-keys` instead.");
      }
      if (props.expandedNames) {
        warnOnce("menu", "`expanded-names` is deprecated, please use `expanded-keys` instead.");
      }
      if (props.defaultExpandedNames) {
        warnOnce("menu", "`default-expanded-names` is deprecated, please use `default-expanded-keys` instead.");
      }
    });
  }
  const hoverStyleChildren = [c$1("&::before", "background-color: var(--n-item-color-hover);"), cE("arrow", `
 color: var(--n-arrow-color-hover);
 `), cE("icon", `
 color: var(--n-item-icon-color-hover);
 `), cB("menu-item-content-header", `
 color: var(--n-item-text-color-hover);
 `, [c$1("a", `
 color: var(--n-item-text-color-hover);
 `), cE("extra", `
 color: var(--n-item-text-color-hover);
 `)])];
  const horizontalHoverStyleChildren = [cE("icon", `
 color: var(--n-item-icon-color-hover-horizontal);
 `), cB("menu-item-content-header", `
 color: var(--n-item-text-color-hover-horizontal);
 `, [c$1("a", `
 color: var(--n-item-text-color-hover-horizontal);
 `), cE("extra", `
 color: var(--n-item-text-color-hover-horizontal);
 `)])];
  const style$w = c$1([cB("menu", `
 background-color: var(--n-color);
 color: var(--n-item-text-color);
 overflow: hidden;
 transition: background-color .3s var(--n-bezier);
 box-sizing: border-box;
 font-size: var(--n-font-size);
 padding-bottom: 6px;
 `, [cM("horizontal", `
 max-width: 100%;
 width: 100%;
 display: flex;
 overflow: hidden;
 padding-bottom: 0;
 `, [cB("submenu", "margin: 0;"), cB("menu-item", "margin: 0;"), cB("menu-item-content", `
 padding: 0 20px;
 border-bottom: 2px solid #0000;
 `, [c$1("&::before", "display: none;"), cM("selected", "border-bottom: 2px solid var(--n-border-color-horizontal)")]), cB("menu-item-content", [cM("selected", [cE("icon", "color: var(--n-item-icon-color-active-horizontal);"), cB("menu-item-content-header", `
 color: var(--n-item-text-color-active-horizontal);
 `, [c$1("a", "color: var(--n-item-text-color-active-horizontal);"), cE("extra", "color: var(--n-item-text-color-active-horizontal);")])]), cM("child-active", `
 border-bottom: 2px solid var(--n-border-color-horizontal);
 `, [cB("menu-item-content-header", `
 color: var(--n-item-text-color-child-active-horizontal);
 `, [c$1("a", `
 color: var(--n-item-text-color-child-active-horizontal);
 `), cE("extra", `
 color: var(--n-item-text-color-child-active-horizontal);
 `)]), cE("icon", `
 color: var(--n-item-icon-color-child-active-horizontal);
 `)]), cNotM("disabled", [cNotM("selected, child-active", [c$1("&:focus-within", horizontalHoverStyleChildren)]), cM("selected", [hoverStyle(null, [cE("icon", "color: var(--n-item-icon-color-active-hover-horizontal);"), cB("menu-item-content-header", `
 color: var(--n-item-text-color-active-hover-horizontal);
 `, [c$1("a", "color: var(--n-item-text-color-active-hover-horizontal);"), cE("extra", "color: var(--n-item-text-color-active-hover-horizontal);")])])]), cM("child-active", [hoverStyle(null, [cE("icon", "color: var(--n-item-icon-color-child-active-hover-horizontal);"), cB("menu-item-content-header", `
 color: var(--n-item-text-color-child-active-hover-horizontal);
 `, [c$1("a", "color: var(--n-item-text-color-child-active-hover-horizontal);"), cE("extra", "color: var(--n-item-text-color-child-active-hover-horizontal);")])])]), hoverStyle("border-bottom: 2px solid var(--n-border-color-horizontal);", horizontalHoverStyleChildren)]), cB("menu-item-content-header", [c$1("a", "color: var(--n-item-text-color-horizontal);")])])]), cNotM("responsive", [cB("menu-item-content-header", `
 overflow: hidden;
 text-overflow: ellipsis;
 `)]), cM("collapsed", [cB("menu-item-content", [cM("selected", [c$1("&::before", `
 background-color: var(--n-item-color-active-collapsed) !important;
 `)]), cB("menu-item-content-header", "opacity: 0;"), cE("arrow", "opacity: 0;"), cE("icon", "color: var(--n-item-icon-color-collapsed);")])]), cB("menu-item", `
 height: var(--n-item-height);
 margin-top: 6px;
 position: relative;
 `), cB("menu-item-content", `
 box-sizing: border-box;
 line-height: 1.75;
 height: 100%;
 display: grid;
 grid-template-areas: "icon content arrow";
 grid-template-columns: auto 1fr auto;
 align-items: center;
 cursor: pointer;
 position: relative;
 padding-right: 18px;
 transition:
 background-color .3s var(--n-bezier),
 padding-left .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [c$1("> *", "z-index: 1;"), c$1("&::before", `
 z-index: auto;
 content: "";
 background-color: #0000;
 position: absolute;
 left: 8px;
 right: 8px;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border-radius: var(--n-border-radius);
 transition: background-color .3s var(--n-bezier);
 `), cM("disabled", `
 opacity: .45;
 cursor: not-allowed;
 `), cM("collapsed", [cE("arrow", "transform: rotate(0);")]), cM("selected", [c$1("&::before", "background-color: var(--n-item-color-active);"), cE("arrow", "color: var(--n-arrow-color-active);"), cE("icon", "color: var(--n-item-icon-color-active);"), cB("menu-item-content-header", `
 color: var(--n-item-text-color-active);
 `, [c$1("a", "color: var(--n-item-text-color-active);"), cE("extra", "color: var(--n-item-text-color-active);")])]), cM("child-active", [cB("menu-item-content-header", `
 color: var(--n-item-text-color-child-active);
 `, [c$1("a", `
 color: var(--n-item-text-color-child-active);
 `), cE("extra", `
 color: var(--n-item-text-color-child-active);
 `)]), cE("arrow", `
 color: var(--n-arrow-color-child-active);
 `), cE("icon", `
 color: var(--n-item-icon-color-child-active);
 `)]), cNotM("disabled", [cNotM("selected, child-active", [c$1("&:focus-within", hoverStyleChildren)]), cM("selected", [hoverStyle(null, [cE("arrow", "color: var(--n-arrow-color-active-hover);"), cE("icon", "color: var(--n-item-icon-color-active-hover);"), cB("menu-item-content-header", `
 color: var(--n-item-text-color-active-hover);
 `, [c$1("a", "color: var(--n-item-text-color-active-hover);"), cE("extra", "color: var(--n-item-text-color-active-hover);")])])]), cM("child-active", [hoverStyle(null, [cE("arrow", "color: var(--n-arrow-color-child-active-hover);"), cE("icon", "color: var(--n-item-icon-color-child-active-hover);"), cB("menu-item-content-header", `
 color: var(--n-item-text-color-child-active-hover);
 `, [c$1("a", "color: var(--n-item-text-color-child-active-hover);"), cE("extra", "color: var(--n-item-text-color-child-active-hover);")])])]), cM("selected", [hoverStyle(null, [c$1("&::before", "background-color: var(--n-item-color-active-hover);")])]), hoverStyle(null, hoverStyleChildren)]), cE("icon", `
 grid-area: icon;
 color: var(--n-item-icon-color);
 transition:
 color .3s var(--n-bezier),
 font-size .3s var(--n-bezier),
 margin-right .3s var(--n-bezier);
 box-sizing: content-box;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 `), cE("arrow", `
 grid-area: arrow;
 font-size: 16px;
 color: var(--n-arrow-color);
 transform: rotate(180deg);
 opacity: 1;
 transition:
 color .3s var(--n-bezier),
 transform 0.2s var(--n-bezier),
 opacity 0.2s var(--n-bezier);
 `), cB("menu-item-content-header", `
 grid-area: content;
 transition:
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 opacity: 1;
 white-space: nowrap;
 color: var(--n-item-text-color);
 `, [c$1("a", `
 outline: none;
 text-decoration: none;
 transition: color .3s var(--n-bezier);
 color: var(--n-item-text-color);
 `, [c$1("&::before", `
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]), cE("extra", `
 font-size: .93em;
 color: var(--n-group-text-color);
 transition: color .3s var(--n-bezier);
 `)])]), cB("submenu", `
 cursor: pointer;
 position: relative;
 margin-top: 6px;
 `, [cB("menu-item-content", `
 height: var(--n-item-height);
 `), cB("submenu-children", `
 overflow: hidden;
 padding: 0;
 `, [fadeInHeightExpandTransition({
    duration: ".2s"
  })])]), cB("menu-item-group", [cB("menu-item-group-title", `
 margin-top: 6px;
 color: var(--n-group-text-color);
 cursor: default;
 font-size: .93em;
 height: 36px;
 display: flex;
 align-items: center;
 transition:
 padding-left .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)])]), cB("menu-tooltip", [c$1("a", `
 color: inherit;
 text-decoration: none;
 `)]), cB("menu-divider", `
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-divider-color);
 height: 1px;
 margin: 6px 18px;
 `)]);
  function hoverStyle(props, children) {
    return [cM("hover", props, children), c$1("&:hover", props, children)];
  }
  const menuProps = Object.assign(Object.assign({}, useTheme.props), {
    options: {
      type: Array,
      default: () => []
    },
    collapsed: {
      type: Boolean,
      default: void 0
    },
    collapsedWidth: {
      type: Number,
      default: 48
    },
    iconSize: {
      type: Number,
      default: 20
    },
    collapsedIconSize: {
      type: Number,
      default: 24
    },
    rootIndent: Number,
    indent: {
      type: Number,
      default: 32
    },
    labelField: {
      type: String,
      default: "label"
    },
    keyField: {
      type: String,
      default: "key"
    },
    childrenField: {
      type: String,
      default: "children"
    },
    disabledField: {
      type: String,
      default: "disabled"
    },
    defaultExpandAll: Boolean,
    defaultExpandedKeys: Array,
    expandedKeys: Array,
    value: [String, Number],
    defaultValue: {
      type: [String, Number],
      default: null
    },
    mode: {
      type: String,
      default: "vertical"
    },
    watchProps: {
      type: Array,
      default: void 0
    },
    disabled: Boolean,
    show: {
      type: Boolean,
      default: true
    },
    inverted: Boolean,
    "onUpdate:expandedKeys": [Function, Array],
    onUpdateExpandedKeys: [Function, Array],
    onUpdateValue: [Function, Array],
    "onUpdate:value": [Function, Array],
    expandIcon: Function,
    renderIcon: Function,
    renderLabel: Function,
    renderExtra: Function,
    dropdownProps: Object,
    accordion: Boolean,
    nodeProps: Function,
    dropdownPlacement: {
      type: String,
      default: "bottom"
    },
    responsive: Boolean,
    // deprecated
    items: Array,
    onOpenNamesChange: [Function, Array],
    onSelect: [Function, Array],
    onExpandedNamesChange: [Function, Array],
    expandedNames: Array,
    defaultExpandedNames: Array
  });
  const Menu = vue.defineComponent({
    name: "Menu",
    inheritAttrs: false,
    props: menuProps,
    setup(props) {
      {
        useCheckDeprecated(props);
      }
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Menu", "-menu", style$w, menuLight$1, props, mergedClsPrefixRef);
      const layoutSider = vue.inject(layoutSiderInjectionKey, null);
      const mergedCollapsedRef = vue.computed(() => {
        var _a;
        const {
          collapsed
        } = props;
        if (collapsed !== void 0)
          return collapsed;
        if (layoutSider) {
          const {
            collapseModeRef,
            collapsedRef
          } = layoutSider;
          if (collapseModeRef.value === "width") {
            return (_a = collapsedRef.value) !== null && _a !== void 0 ? _a : false;
          }
        }
        return false;
      });
      const treeMateRef = vue.computed(() => {
        const {
          keyField,
          childrenField,
          disabledField
        } = props;
        return createTreeMate(props.items || props.options, {
          getIgnored(node) {
            return isIgnoredNode(node);
          },
          getChildren(node) {
            return node[childrenField];
          },
          getDisabled(node) {
            return node[disabledField];
          },
          getKey(node) {
            var _a;
            return (_a = node[keyField]) !== null && _a !== void 0 ? _a : node.name;
          }
        });
      });
      const treeKeysLevelOneRef = vue.computed(() => new Set(treeMateRef.value.treeNodes.map((e) => e.key)));
      const {
        watchProps
      } = props;
      const uncontrolledValueRef = vue.ref(null);
      if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes("defaultValue")) {
        vue.watchEffect(() => {
          uncontrolledValueRef.value = props.defaultValue;
        });
      } else {
        uncontrolledValueRef.value = props.defaultValue;
      }
      const controlledValueRef = vue.toRef(props, "value");
      const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
      const uncontrolledExpandedKeysRef = vue.ref([]);
      const initUncontrolledExpandedKeys = () => {
        uncontrolledExpandedKeysRef.value = props.defaultExpandAll ? treeMateRef.value.getNonLeafKeys() : props.defaultExpandedNames || props.defaultExpandedKeys || treeMateRef.value.getPath(mergedValueRef.value, {
          includeSelf: false
        }).keyPath;
      };
      if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes("defaultExpandedKeys")) {
        vue.watchEffect(initUncontrolledExpandedKeys);
      } else {
        initUncontrolledExpandedKeys();
      }
      const controlledExpandedKeysRef = useCompitable(props, ["expandedNames", "expandedKeys"]);
      const mergedExpandedKeysRef = useMergedState(controlledExpandedKeysRef, uncontrolledExpandedKeysRef);
      const tmNodesRef = vue.computed(() => treeMateRef.value.treeNodes);
      const activePathRef = vue.computed(() => {
        return treeMateRef.value.getPath(mergedValueRef.value).keyPath;
      });
      vue.provide(menuInjectionKey, {
        props,
        mergedCollapsedRef,
        mergedThemeRef: themeRef,
        mergedValueRef,
        mergedExpandedKeysRef,
        activePathRef,
        mergedClsPrefixRef,
        isHorizontalRef: vue.computed(() => props.mode === "horizontal"),
        invertedRef: vue.toRef(props, "inverted"),
        doSelect,
        toggleExpand
      });
      function doSelect(value, item) {
        const {
          "onUpdate:value": _onUpdateValue,
          onUpdateValue,
          onSelect
        } = props;
        if (onUpdateValue) {
          call(onUpdateValue, value, item);
        }
        if (_onUpdateValue) {
          call(_onUpdateValue, value, item);
        }
        if (onSelect) {
          call(onSelect, value, item);
        }
        uncontrolledValueRef.value = value;
      }
      function doUpdateExpandedKeys(value) {
        const {
          "onUpdate:expandedKeys": _onUpdateExpandedKeys,
          onUpdateExpandedKeys,
          onExpandedNamesChange,
          onOpenNamesChange
        } = props;
        if (_onUpdateExpandedKeys) {
          call(_onUpdateExpandedKeys, value);
        }
        if (onUpdateExpandedKeys) {
          call(onUpdateExpandedKeys, value);
        }
        if (onExpandedNamesChange) {
          call(onExpandedNamesChange, value);
        }
        if (onOpenNamesChange) {
          call(onOpenNamesChange, value);
        }
        uncontrolledExpandedKeysRef.value = value;
      }
      function toggleExpand(key) {
        const currentExpandedKeys = Array.from(mergedExpandedKeysRef.value);
        const index = currentExpandedKeys.findIndex((expanededKey) => expanededKey === key);
        if (~index) {
          currentExpandedKeys.splice(index, 1);
        } else {
          if (props.accordion) {
            if (treeKeysLevelOneRef.value.has(key)) {
              const closeKeyIndex = currentExpandedKeys.findIndex((e) => treeKeysLevelOneRef.value.has(e));
              if (closeKeyIndex > -1) {
                currentExpandedKeys.splice(closeKeyIndex, 1);
              }
            }
          }
          currentExpandedKeys.push(key);
        }
        doUpdateExpandedKeys(currentExpandedKeys);
      }
      const showOption = (key) => {
        const selectedKeyPath = treeMateRef.value.getPath(key !== null && key !== void 0 ? key : mergedValueRef.value, {
          includeSelf: false
        }).keyPath;
        if (!selectedKeyPath.length)
          return;
        const currentExpandedKeys = Array.from(mergedExpandedKeysRef.value);
        const nextExpandedKeys = /* @__PURE__ */ new Set([...currentExpandedKeys, ...selectedKeyPath]);
        if (props.accordion) {
          treeKeysLevelOneRef.value.forEach((firstLevelKey) => {
            if (nextExpandedKeys.has(firstLevelKey) && !selectedKeyPath.includes(firstLevelKey)) {
              nextExpandedKeys.delete(firstLevelKey);
            }
          });
        }
        doUpdateExpandedKeys(Array.from(nextExpandedKeys));
      };
      const cssVarsRef = vue.computed(() => {
        const {
          inverted
        } = props;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: self2
        } = themeRef.value;
        const {
          borderRadius,
          borderColorHorizontal,
          fontSize: fontSize2,
          itemHeight,
          dividerColor
        } = self2;
        const vars = {
          "--n-divider-color": dividerColor,
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-font-size": fontSize2,
          "--n-border-color-horizontal": borderColorHorizontal,
          "--n-border-radius": borderRadius,
          "--n-item-height": itemHeight
        };
        if (inverted) {
          vars["--n-group-text-color"] = self2.groupTextColorInverted;
          vars["--n-color"] = self2.colorInverted;
          vars["--n-item-text-color"] = self2.itemTextColorInverted;
          vars["--n-item-text-color-hover"] = self2.itemTextColorHoverInverted;
          vars["--n-item-text-color-active"] = self2.itemTextColorActiveInverted;
          vars["--n-item-text-color-child-active"] = self2.itemTextColorChildActiveInverted;
          vars["--n-item-text-color-child-active-hover"] = self2.itemTextColorChildActiveInverted;
          vars["--n-item-text-color-active-hover"] = self2.itemTextColorActiveHoverInverted;
          vars["--n-item-icon-color"] = self2.itemIconColorInverted;
          vars["--n-item-icon-color-hover"] = self2.itemIconColorHoverInverted;
          vars["--n-item-icon-color-active"] = self2.itemIconColorActiveInverted;
          vars["--n-item-icon-color-active-hover"] = self2.itemIconColorActiveHoverInverted;
          vars["--n-item-icon-color-child-active"] = self2.itemIconColorChildActiveInverted;
          vars["--n-item-icon-color-child-active-hover"] = self2.itemIconColorChildActiveHoverInverted;
          vars["--n-item-icon-color-collapsed"] = self2.itemIconColorCollapsedInverted;
          vars["--n-item-text-color-horizontal"] = self2.itemTextColorHorizontalInverted;
          vars["--n-item-text-color-hover-horizontal"] = self2.itemTextColorHoverHorizontalInverted;
          vars["--n-item-text-color-active-horizontal"] = self2.itemTextColorActiveHorizontalInverted;
          vars["--n-item-text-color-child-active-horizontal"] = self2.itemTextColorChildActiveHorizontalInverted;
          vars["--n-item-text-color-child-active-hover-horizontal"] = self2.itemTextColorChildActiveHoverHorizontalInverted;
          vars["--n-item-text-color-active-hover-horizontal"] = self2.itemTextColorActiveHoverHorizontalInverted;
          vars["--n-item-icon-color-horizontal"] = self2.itemIconColorHorizontalInverted;
          vars["--n-item-icon-color-hover-horizontal"] = self2.itemIconColorHoverHorizontalInverted;
          vars["--n-item-icon-color-active-horizontal"] = self2.itemIconColorActiveHorizontalInverted;
          vars["--n-item-icon-color-active-hover-horizontal"] = self2.itemIconColorActiveHoverHorizontalInverted;
          vars["--n-item-icon-color-child-active-horizontal"] = self2.itemIconColorChildActiveHorizontalInverted;
          vars["--n-item-icon-color-child-active-hover-horizontal"] = self2.itemIconColorChildActiveHoverHorizontalInverted;
          vars["--n-arrow-color"] = self2.arrowColorInverted;
          vars["--n-arrow-color-hover"] = self2.arrowColorHoverInverted;
          vars["--n-arrow-color-active"] = self2.arrowColorActiveInverted;
          vars["--n-arrow-color-active-hover"] = self2.arrowColorActiveHoverInverted;
          vars["--n-arrow-color-child-active"] = self2.arrowColorChildActiveInverted;
          vars["--n-arrow-color-child-active-hover"] = self2.arrowColorChildActiveHoverInverted;
          vars["--n-item-color-hover"] = self2.itemColorHoverInverted;
          vars["--n-item-color-active"] = self2.itemColorActiveInverted;
          vars["--n-item-color-active-hover"] = self2.itemColorActiveHoverInverted;
          vars["--n-item-color-active-collapsed"] = self2.itemColorActiveCollapsedInverted;
        } else {
          vars["--n-group-text-color"] = self2.groupTextColor;
          vars["--n-color"] = self2.color;
          vars["--n-item-text-color"] = self2.itemTextColor;
          vars["--n-item-text-color-hover"] = self2.itemTextColorHover;
          vars["--n-item-text-color-active"] = self2.itemTextColorActive;
          vars["--n-item-text-color-child-active"] = self2.itemTextColorChildActive;
          vars["--n-item-text-color-child-active-hover"] = self2.itemTextColorChildActiveHover;
          vars["--n-item-text-color-active-hover"] = self2.itemTextColorActiveHover;
          vars["--n-item-icon-color"] = self2.itemIconColor;
          vars["--n-item-icon-color-hover"] = self2.itemIconColorHover;
          vars["--n-item-icon-color-active"] = self2.itemIconColorActive;
          vars["--n-item-icon-color-active-hover"] = self2.itemIconColorActiveHover;
          vars["--n-item-icon-color-child-active"] = self2.itemIconColorChildActive;
          vars["--n-item-icon-color-child-active-hover"] = self2.itemIconColorChildActiveHover;
          vars["--n-item-icon-color-collapsed"] = self2.itemIconColorCollapsed;
          vars["--n-item-text-color-horizontal"] = self2.itemTextColorHorizontal;
          vars["--n-item-text-color-hover-horizontal"] = self2.itemTextColorHoverHorizontal;
          vars["--n-item-text-color-active-horizontal"] = self2.itemTextColorActiveHorizontal;
          vars["--n-item-text-color-child-active-horizontal"] = self2.itemTextColorChildActiveHorizontal;
          vars["--n-item-text-color-child-active-hover-horizontal"] = self2.itemTextColorChildActiveHoverHorizontal;
          vars["--n-item-text-color-active-hover-horizontal"] = self2.itemTextColorActiveHoverHorizontal;
          vars["--n-item-icon-color-horizontal"] = self2.itemIconColorHorizontal;
          vars["--n-item-icon-color-hover-horizontal"] = self2.itemIconColorHoverHorizontal;
          vars["--n-item-icon-color-active-horizontal"] = self2.itemIconColorActiveHorizontal;
          vars["--n-item-icon-color-active-hover-horizontal"] = self2.itemIconColorActiveHoverHorizontal;
          vars["--n-item-icon-color-child-active-horizontal"] = self2.itemIconColorChildActiveHorizontal;
          vars["--n-item-icon-color-child-active-hover-horizontal"] = self2.itemIconColorChildActiveHoverHorizontal;
          vars["--n-arrow-color"] = self2.arrowColor;
          vars["--n-arrow-color-hover"] = self2.arrowColorHover;
          vars["--n-arrow-color-active"] = self2.arrowColorActive;
          vars["--n-arrow-color-active-hover"] = self2.arrowColorActiveHover;
          vars["--n-arrow-color-child-active"] = self2.arrowColorChildActive;
          vars["--n-arrow-color-child-active-hover"] = self2.arrowColorChildActiveHover;
          vars["--n-item-color-hover"] = self2.itemColorHover;
          vars["--n-item-color-active"] = self2.itemColorActive;
          vars["--n-item-color-active-hover"] = self2.itemColorActiveHover;
          vars["--n-item-color-active-collapsed"] = self2.itemColorActiveCollapsed;
        }
        return vars;
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("menu", vue.computed(() => props.inverted ? "a" : "b"), cssVarsRef, props) : void 0;
      const ellipsisNodeId = createId();
      const overflowRef = vue.ref(null);
      const counterRef = vue.ref(null);
      let isFirstResize = true;
      const onResize = () => {
        var _a;
        if (isFirstResize) {
          isFirstResize = false;
        } else {
          (_a = overflowRef.value) === null || _a === void 0 ? void 0 : _a.sync({
            showAllItemsBeforeCalculate: true
          });
        }
      };
      function getCounter() {
        return document.getElementById(ellipsisNodeId);
      }
      const ellipsisFromIndexRef = vue.ref(-1);
      function onUpdateCount(count) {
        ellipsisFromIndexRef.value = props.options.length - count;
      }
      function onUpdateOverflow(overflow) {
        if (!overflow) {
          ellipsisFromIndexRef.value = -1;
        }
      }
      const ellipsisOptionRef = vue.computed(() => {
        const ellipsisFromIndex = ellipsisFromIndexRef.value;
        const option = {
          children: ellipsisFromIndex === -1 ? [] : props.options.slice(ellipsisFromIndex)
        };
        return option;
      });
      const ellipsisTreeMateRef = vue.computed(() => {
        const {
          childrenField,
          disabledField,
          keyField
        } = props;
        return createTreeMate([ellipsisOptionRef.value], {
          getIgnored(node) {
            return isIgnoredNode(node);
          },
          getChildren(node) {
            return node[childrenField];
          },
          getDisabled(node) {
            return node[disabledField];
          },
          getKey(node) {
            var _a;
            return (_a = node[keyField]) !== null && _a !== void 0 ? _a : node.name;
          }
        });
      });
      const emptyTmNodeRef = vue.computed(() => {
        return createTreeMate([{}]).treeNodes[0];
      });
      function renderCounter() {
        var _a;
        if (ellipsisFromIndexRef.value === -1) {
          return vue.h(NSubmenu, {
            root: true,
            level: 0,
            key: "__ellpisisGroupPlaceholder__",
            internalKey: "__ellpisisGroupPlaceholder__",
            title: "···",
            tmNode: emptyTmNodeRef.value,
            domId: ellipsisNodeId,
            isEllipsisPlaceholder: true
          });
        }
        const tmNode = ellipsisTreeMateRef.value.treeNodes[0];
        const activePath = activePathRef.value;
        const childActive = !!((_a = tmNode.children) === null || _a === void 0 ? void 0 : _a.some((tmNode2) => {
          return activePath.includes(tmNode2.key);
        }));
        return vue.h(NSubmenu, {
          level: 0,
          root: true,
          key: "__ellpisisGroup__",
          internalKey: "__ellpisisGroup__",
          title: "···",
          virtualChildActive: childActive,
          tmNode,
          domId: ellipsisNodeId,
          rawNodes: tmNode.rawNode.children || [],
          tmNodes: tmNode.children || [],
          isEllipsisPlaceholder: true
        });
      }
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        controlledExpandedKeys: controlledExpandedKeysRef,
        uncontrolledExpanededKeys: uncontrolledExpandedKeysRef,
        mergedExpandedKeys: mergedExpandedKeysRef,
        uncontrolledValue: uncontrolledValueRef,
        mergedValue: mergedValueRef,
        activePath: activePathRef,
        tmNodes: tmNodesRef,
        mergedTheme: themeRef,
        mergedCollapsed: mergedCollapsedRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        overflowRef,
        counterRef,
        updateCounter: () => {
        },
        onResize,
        onUpdateOverflow,
        onUpdateCount,
        renderCounter,
        getCounter,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
        showOption,
        deriveResponsiveState: onResize
      };
    },
    render() {
      const {
        mergedClsPrefix,
        mode,
        themeClass,
        onRender
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      const renderMenuItemNodes = () => this.tmNodes.map((tmNode) => itemRenderer(tmNode, this.$props));
      const horizontal = mode === "horizontal";
      const finalResponsive = horizontal && this.responsive;
      const renderMainNode = () => vue.h("div", vue.mergeProps(this.$attrs, {
        role: mode === "horizontal" ? "menubar" : "menu",
        class: [`${mergedClsPrefix}-menu`, themeClass, `${mergedClsPrefix}-menu--${mode}`, finalResponsive && `${mergedClsPrefix}-menu--responsive`, this.mergedCollapsed && `${mergedClsPrefix}-menu--collapsed`],
        style: this.cssVars
      }), finalResponsive ? vue.h(VOverflow, {
        ref: "overflowRef",
        onUpdateOverflow: this.onUpdateOverflow,
        getCounter: this.getCounter,
        onUpdateCount: this.onUpdateCount,
        updateCounter: this.updateCounter,
        style: {
          width: "100%",
          display: "flex",
          overflow: "hidden"
        }
      }, {
        default: renderMenuItemNodes,
        counter: this.renderCounter
      }) : renderMenuItemNodes());
      return finalResponsive ? vue.h(VResizeObserver, {
        onResize: this.onResize
      }, {
        default: renderMainNode
      }) : renderMainNode();
    }
  });
  function getRelativePosition(element, options = {
    debug: false,
    useSelectionEnd: false,
    checkWidthOverflow: true
  }) {
    const selectionStart = element.selectionStart !== null ? element.selectionStart : 0;
    const selectionEnd = element.selectionEnd !== null ? element.selectionEnd : 0;
    const position = options.useSelectionEnd ? selectionEnd : selectionStart;
    const properties = [
      "direction",
      // RTL support
      "boxSizing",
      "width",
      // on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does
      "height",
      "overflowX",
      "overflowY",
      // copy the scrollbar for IE
      "borderTopWidth",
      "borderRightWidth",
      "borderBottomWidth",
      "borderLeftWidth",
      "borderStyle",
      "paddingTop",
      "paddingRight",
      "paddingBottom",
      "paddingLeft",
      // https://developer.mozilla.org/en-US/docs/Web/CSS/font
      "fontStyle",
      "fontVariant",
      "fontWeight",
      "fontStretch",
      "fontSize",
      "fontSizeAdjust",
      "lineHeight",
      "fontFamily",
      "textAlign",
      "textTransform",
      "textIndent",
      "textDecoration",
      // might not make a difference, but better be safe
      "letterSpacing",
      "wordSpacing",
      "tabSize",
      "MozTabSize"
    ];
    const isFirefox = navigator.userAgent.toLowerCase().includes("firefox");
    if (!isBrowser$2) {
      throw new Error("textarea-caret-position#getCaretPosition should only be called in a browser");
    }
    const debug = options === null || options === void 0 ? void 0 : options.debug;
    if (debug) {
      const el = document.querySelector("#input-textarea-caret-position-mirror-div");
      if (el === null || el === void 0 ? void 0 : el.parentNode)
        el.parentNode.removeChild(el);
    }
    const div = document.createElement("div");
    div.id = "input-textarea-caret-position-mirror-div";
    document.body.appendChild(div);
    const style2 = div.style;
    const computed = window.getComputedStyle ? window.getComputedStyle(element) : element.currentStyle;
    const isInput = element.nodeName === "INPUT";
    style2.whiteSpace = isInput ? "nowrap" : "pre-wrap";
    if (!isInput)
      style2.wordWrap = "break-word";
    style2.position = "absolute";
    if (!debug)
      style2.visibility = "hidden";
    properties.forEach((prop) => {
      if (isInput && prop === "lineHeight") {
        if (computed.boxSizing === "border-box") {
          const height = Number.parseInt(computed.height);
          const outerHeight = Number.parseInt(computed.paddingTop) + Number.parseInt(computed.paddingBottom) + Number.parseInt(computed.borderTopWidth) + Number.parseInt(computed.borderBottomWidth);
          const targetHeight = outerHeight + Number.parseInt(computed.lineHeight);
          if (height > targetHeight) {
            style2.lineHeight = `${height - outerHeight}px`;
          } else if (height === targetHeight) {
            style2.lineHeight = computed.lineHeight;
          } else {
            style2.lineHeight = "0";
          }
        } else {
          style2.lineHeight = computed.height;
        }
      } else {
        style2[prop] = computed[prop];
      }
    });
    if (isFirefox) {
      if (element.scrollHeight > Number.parseInt(computed.height)) {
        style2.overflowY = "scroll";
      }
    } else {
      style2.overflow = "hidden";
    }
    div.textContent = element.value.substring(0, position);
    if (isInput && div.textContent) {
      div.textContent = div.textContent.replace(/\s/g, " ");
    }
    const span = document.createElement("span");
    span.textContent = element.value.substring(position) || ".";
    span.style.position = "relative";
    span.style.left = `${-element.scrollLeft}px`;
    span.style.top = `${-element.scrollTop}px`;
    div.appendChild(span);
    const relativePosition = {
      top: span.offsetTop + Number.parseInt(computed.borderTopWidth),
      left: span.offsetLeft + Number.parseInt(computed.borderLeftWidth),
      absolute: false,
      // We don't use line-height since it may be too large for position. Eg. 34px
      // for input
      height: Number.parseInt(computed.fontSize) * 1.5
    };
    if (debug) {
      span.style.backgroundColor = "#aaa";
    } else {
      document.body.removeChild(div);
    }
    if (relativePosition.left >= element.clientWidth && options.checkWidthOverflow) {
      relativePosition.left = element.clientWidth;
    }
    return relativePosition;
  }
  const style$v = c$1([cB("mention", "width: 100%; z-index: auto; position: relative;"), cB("mention-menu", `
 box-shadow: var(--n-menu-box-shadow);
 `, [fadeInScaleUpTransition({
    originalTransition: "background-color .3s var(--n-bezier), box-shadow .3s var(--n-bezier)"
  })])]);
  const mentionProps = Object.assign(Object.assign({}, useTheme.props), {
    to: useAdjustedTo.propTo,
    autosize: [Boolean, Object],
    options: {
      type: Array,
      default: []
    },
    filter: {
      type: Function,
      default: (pattern, option) => {
        if (!pattern)
          return true;
        if (typeof option.label === "string") {
          return option.label.startsWith(pattern);
        }
        if (typeof option.value === "string") {
          return option.value.startsWith(pattern);
        }
        return false;
      }
    },
    type: {
      type: String,
      default: "text"
    },
    separator: {
      type: String,
      validator: (separator) => {
        if (separator.length !== 1) {
          warn$2("mention", "`separator`'s length must be 1.");
          return false;
        }
        return true;
      },
      default: " "
    },
    bordered: {
      type: Boolean,
      default: void 0
    },
    disabled: Boolean,
    value: String,
    defaultValue: {
      type: String,
      default: ""
    },
    loading: Boolean,
    prefix: {
      type: [String, Array],
      default: "@"
    },
    placeholder: {
      type: String,
      default: ""
    },
    placement: {
      type: String,
      default: "bottom-start"
    },
    size: String,
    renderLabel: Function,
    status: String,
    "onUpdate:show": [Array, Function],
    onUpdateShow: [Array, Function],
    "onUpdate:value": [Array, Function],
    onUpdateValue: [Array, Function],
    onSearch: Function,
    onSelect: Function,
    onFocus: Function,
    onBlur: Function,
    // private
    internalDebug: Boolean
  });
  const Mention = vue.defineComponent({
    name: "Mention",
    props: mentionProps,
    setup(props) {
      const {
        namespaceRef,
        mergedClsPrefixRef,
        mergedBorderedRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Mention", "-mention", style$v, mentionLight$1, props, mergedClsPrefixRef);
      const formItem = useFormItem(props);
      const inputInstRef = vue.ref(null);
      const cursorRef = vue.ref(null);
      const followerRef = vue.ref(null);
      const wrapperElRef = vue.ref(null);
      const partialPatternRef = vue.ref("");
      let cachedPrefix = null;
      let cachedPartialPatternStart = null;
      let cachedPartialPatternEnd = null;
      const filteredOptionsRef = vue.computed(() => {
        const {
          value: pattern
        } = partialPatternRef;
        return props.options.filter((option) => props.filter(pattern, option));
      });
      const treeMateRef = vue.computed(() => {
        return createTreeMate(filteredOptionsRef.value, {
          getKey: (v) => {
            return v.value;
          }
        });
      });
      const selectMenuInstRef = vue.ref(null);
      const showMenuRef = vue.ref(false);
      const uncontrolledValueRef = vue.ref(props.defaultValue);
      const controlledValueRef = vue.toRef(props, "value");
      const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
      const cssVarsRef = vue.computed(() => {
        const {
          self: {
            menuBoxShadow
          }
        } = themeRef.value;
        return {
          "--n-menu-box-shadow": menuBoxShadow
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("mention", void 0, cssVarsRef, props) : void 0;
      function doUpdateShowMenu(show) {
        if (props.disabled)
          return;
        const {
          onUpdateShow,
          "onUpdate:show": _onUpdateShow
        } = props;
        if (onUpdateShow)
          call(onUpdateShow, show);
        if (_onUpdateShow)
          call(_onUpdateShow, show);
        if (!show) {
          cachedPrefix = null;
          cachedPartialPatternStart = null;
          cachedPartialPatternEnd = null;
        }
        showMenuRef.value = show;
      }
      function doUpdateValue(value) {
        const {
          onUpdateValue,
          "onUpdate:value": _onUpdateValue
        } = props;
        const {
          nTriggerFormChange,
          nTriggerFormInput
        } = formItem;
        if (_onUpdateValue) {
          call(_onUpdateValue, value);
        }
        if (onUpdateValue) {
          call(onUpdateValue, value);
        }
        nTriggerFormInput();
        nTriggerFormChange();
        uncontrolledValueRef.value = value;
      }
      function getInputEl() {
        return props.type === "text" ? inputInstRef.value.inputElRef : inputInstRef.value.textareaElRef;
      }
      function deriveShowMenu() {
        var _a;
        const inputEl = getInputEl();
        if (document.activeElement !== inputEl) {
          doUpdateShowMenu(false);
          return;
        }
        const {
          selectionEnd
        } = inputEl;
        if (selectionEnd === null) {
          doUpdateShowMenu(false);
          return;
        }
        const inputValue = inputEl.value;
        const {
          separator
        } = props;
        const {
          prefix: prefix2
        } = props;
        const prefixArray = typeof prefix2 === "string" ? [prefix2] : prefix2;
        for (let i = selectionEnd - 1; i >= 0; --i) {
          const char = inputValue[i];
          if (char === separator || char === "\n" || char === "\r") {
            doUpdateShowMenu(false);
            return;
          }
          if (prefixArray.includes(char)) {
            const partialPattern = inputValue.slice(i + 1, selectionEnd);
            doUpdateShowMenu(true);
            (_a = props.onSearch) === null || _a === void 0 ? void 0 : _a.call(props, partialPattern, char);
            partialPatternRef.value = partialPattern;
            cachedPrefix = char;
            cachedPartialPatternStart = i + 1;
            cachedPartialPatternEnd = selectionEnd;
            return;
          }
        }
        doUpdateShowMenu(false);
      }
      function syncCursor() {
        const {
          value: cursorAnchor
        } = cursorRef;
        if (!cursorAnchor)
          return;
        const inputEl = getInputEl();
        const cursorPos = getRelativePosition(inputEl);
        const inputRect = inputEl.getBoundingClientRect();
        const wrapperRect = wrapperElRef.value.getBoundingClientRect();
        cursorAnchor.style.left = `${cursorPos.left + inputRect.left - wrapperRect.left}px`;
        cursorAnchor.style.top = `${cursorPos.top + inputRect.top - wrapperRect.top}px`;
        cursorAnchor.style.height = `${cursorPos.height}px`;
      }
      function syncPosition() {
        var _a;
        if (!showMenuRef.value)
          return;
        (_a = followerRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
      }
      function handleInputUpdateValue(value) {
        doUpdateValue(value);
        syncAfterCursorMove();
      }
      function syncAfterCursorMove() {
        setTimeout(() => {
          syncCursor();
          deriveShowMenu();
          void vue.nextTick().then(syncPosition);
        }, 0);
      }
      function handleInputKeyDown(e) {
        var _a, _b;
        if (e.key === "ArrowLeft" || e.key === "ArrowRight") {
          if ((_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.isCompositing)
            return;
          syncAfterCursorMove();
        } else if (e.key === "ArrowUp" || e.key === "ArrowDown" || e.key === "Enter") {
          if ((_b = inputInstRef.value) === null || _b === void 0 ? void 0 : _b.isCompositing)
            return;
          const {
            value: selectMenuInst
          } = selectMenuInstRef;
          if (showMenuRef.value) {
            if (selectMenuInst) {
              e.preventDefault();
              if (e.key === "ArrowUp") {
                selectMenuInst.prev();
              } else if (e.key === "ArrowDown") {
                selectMenuInst.next();
              } else {
                const pendingOptionTmNode = selectMenuInst.getPendingTmNode();
                if (pendingOptionTmNode) {
                  handleSelect(pendingOptionTmNode);
                } else {
                  doUpdateShowMenu(false);
                }
              }
            }
          } else {
            syncAfterCursorMove();
          }
        }
      }
      function handleInputFocus(e) {
        const {
          onFocus
        } = props;
        onFocus === null || onFocus === void 0 ? void 0 : onFocus(e);
        const {
          nTriggerFormFocus
        } = formItem;
        nTriggerFormFocus();
        syncAfterCursorMove();
      }
      function focus() {
        var _a;
        (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
      }
      function blur() {
        var _a;
        (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.blur();
      }
      function handleInputBlur(e) {
        const {
          onBlur
        } = props;
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
        const {
          nTriggerFormBlur
        } = formItem;
        nTriggerFormBlur();
        doUpdateShowMenu(false);
      }
      function handleSelect(tmNode) {
        var _a;
        if (cachedPrefix === null || cachedPartialPatternStart === null || cachedPartialPatternEnd === null) {
          {
            warn$2("mention", "Cache works unexpectly, this is probably a bug. Please create an issue.");
          }
          return;
        }
        const {
          rawNode: {
            value = ""
          }
        } = tmNode;
        const inputEl = getInputEl();
        const inputValue = inputEl.value;
        const {
          separator
        } = props;
        const nextEndPart = inputValue.slice(cachedPartialPatternEnd);
        const alreadySeparated = nextEndPart.startsWith(separator);
        const nextMiddlePart = `${value}${alreadySeparated ? "" : separator}`;
        doUpdateValue(inputValue.slice(0, cachedPartialPatternStart) + nextMiddlePart + nextEndPart);
        (_a = props.onSelect) === null || _a === void 0 ? void 0 : _a.call(props, tmNode.rawNode, cachedPrefix);
        const nextSelectionEnd = cachedPartialPatternStart + nextMiddlePart.length + (alreadySeparated ? 1 : 0);
        void vue.nextTick().then(() => {
          inputEl.selectionStart = nextSelectionEnd;
          inputEl.selectionEnd = nextSelectionEnd;
          deriveShowMenu();
        });
      }
      function handleInputMouseDown() {
        if (!props.disabled) {
          syncAfterCursorMove();
        }
      }
      return {
        namespace: namespaceRef,
        mergedClsPrefix: mergedClsPrefixRef,
        mergedBordered: mergedBorderedRef,
        mergedSize: formItem.mergedSizeRef,
        mergedStatus: formItem.mergedStatusRef,
        mergedTheme: themeRef,
        treeMate: treeMateRef,
        selectMenuInstRef,
        inputInstRef,
        cursorRef,
        followerRef,
        wrapperElRef,
        showMenu: showMenuRef,
        adjustedTo: useAdjustedTo(props),
        isMounted: isMounted(),
        mergedValue: mergedValueRef,
        handleInputFocus,
        handleInputBlur,
        handleInputUpdateValue,
        handleInputKeyDown,
        handleSelect,
        handleInputMouseDown,
        focus,
        blur,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      const {
        mergedTheme,
        mergedClsPrefix,
        $slots
      } = this;
      return vue.h("div", {
        class: `${mergedClsPrefix}-mention`,
        ref: "wrapperElRef"
      }, vue.h(NInput, {
        status: this.mergedStatus,
        themeOverrides: mergedTheme.peerOverrides.Input,
        theme: mergedTheme.peers.Input,
        size: this.mergedSize,
        autosize: this.autosize,
        type: this.type,
        ref: "inputInstRef",
        placeholder: this.placeholder,
        onMousedown: this.handleInputMouseDown,
        onUpdateValue: this.handleInputUpdateValue,
        onKeydown: this.handleInputKeyDown,
        onFocus: this.handleInputFocus,
        onBlur: this.handleInputBlur,
        bordered: this.mergedBordered,
        disabled: this.disabled,
        value: this.mergedValue
      }), vue.h(VBinder, null, {
        default: () => [vue.h(VTarget, null, {
          default: () => {
            const style2 = {
              position: "absolute",
              width: 0
            };
            if (this.internalDebug) {
              style2.width = "1px";
              style2.background = "red";
            }
            return vue.h("div", {
              style: style2,
              ref: "cursorRef"
            });
          }
        }), vue.h(VFollower, {
          ref: "followerRef",
          placement: this.placement,
          show: this.showMenu,
          containerClass: this.namespace,
          to: this.adjustedTo,
          teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey
        }, {
          default: () => vue.h(vue.Transition, {
            name: "fade-in-scale-up-transition",
            appear: this.isMounted
          }, {
            default: () => {
              const {
                mergedTheme: mergedTheme2,
                onRender
              } = this;
              onRender === null || onRender === void 0 ? void 0 : onRender();
              return this.showMenu ? vue.h(NInternalSelectMenu, {
                clsPrefix: mergedClsPrefix,
                theme: mergedTheme2.peers.InternalSelectMenu,
                themeOverrides: mergedTheme2.peerOverrides.InternalSelectMenu,
                autoPending: true,
                ref: "selectMenuInstRef",
                class: [`${mergedClsPrefix}-mention-menu`, this.themeClass],
                loading: this.loading,
                treeMate: this.treeMate,
                virtualScroll: false,
                style: this.cssVars,
                onToggle: this.handleSelect,
                renderLabel: this.renderLabel
              }, $slots) : null;
            }
          })
        })]
      }));
    }
  });
  const messageProps = {
    icon: Function,
    type: {
      type: String,
      default: "info"
    },
    content: [String, Number, Function],
    showIcon: {
      type: Boolean,
      default: true
    },
    closable: Boolean,
    keepAliveOnHover: Boolean,
    onClose: Function,
    onMouseenter: Function,
    onMouseleave: Function
  };
  const messageApiInjectionKey = createInjectionKey("n-message-api");
  const messageProviderInjectionKey = createInjectionKey("n-message-provider");
  const style$u = c$1([cB("message-wrapper", `
 margin: var(--n-margin);
 z-index: 0;
 transform-origin: top center;
 display: flex;
 `, [fadeInHeightExpandTransition({
    overflow: "visible",
    originalTransition: "transform .3s var(--n-bezier)",
    enterToProps: {
      transform: "scale(1)"
    },
    leaveToProps: {
      transform: "scale(0.85)"
    }
  })]), cB("message", `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 transform .3s var(--n-bezier),
 margin-bottom .3s var(--n-bezier);
 padding: var(--n-padding);
 border-radius: var(--n-border-radius);
 flex-wrap: nowrap;
 overflow: hidden;
 max-width: var(--n-max-width);
 color: var(--n-text-color);
 background-color: var(--n-color);
 box-shadow: var(--n-box-shadow);
 `, [cE("content", `
 display: inline-block;
 line-height: var(--n-line-height);
 font-size: var(--n-font-size);
 `), cE("icon", `
 position: relative;
 margin: var(--n-icon-margin);
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 font-size: var(--n-icon-size);
 flex-shrink: 0;
 `, [["default", "info", "success", "warning", "error", "loading"].map((type) => cM(`${type}-type`, [c$1("> *", `
 color: var(--n-icon-color-${type});
 transition: color .3s var(--n-bezier);
 `)])), c$1("> *", `
 position: absolute;
 left: 0;
 top: 0;
 right: 0;
 bottom: 0;
 `, [iconSwitchTransition()])]), cE("close", `
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 flex-shrink: 0;
 `, [c$1("&:hover", `
 color: var(--n-close-icon-color-hover);
 `), c$1("&:active", `
 color: var(--n-close-icon-color-pressed);
 `)])]), cB("message-container", `
 z-index: 6000;
 position: fixed;
 height: 0;
 overflow: visible;
 display: flex;
 flex-direction: column;
 align-items: center;
 `, [cM("top", `
 top: 12px;
 left: 0;
 right: 0;
 `), cM("top-left", `
 top: 12px;
 left: 12px;
 right: 0;
 align-items: flex-start;
 `), cM("top-right", `
 top: 12px;
 left: 0;
 right: 12px;
 align-items: flex-end;
 `), cM("bottom", `
 bottom: 4px;
 left: 0;
 right: 0;
 justify-content: flex-end;
 `), cM("bottom-left", `
 bottom: 4px;
 left: 12px;
 right: 0;
 justify-content: flex-end;
 align-items: flex-start;
 `), cM("bottom-right", `
 bottom: 4px;
 left: 0;
 right: 12px;
 justify-content: flex-end;
 align-items: flex-end;
 `)])]);
  const iconRenderMap$2 = {
    info: () => vue.h(InfoIcon, null),
    success: () => vue.h(SuccessIcon, null),
    warning: () => vue.h(WarningIcon, null),
    error: () => vue.h(ErrorIcon, null),
    default: () => null
  };
  const NMessage = vue.defineComponent({
    name: "Message",
    props: Object.assign(Object.assign({}, messageProps), {
      render: Function
    }),
    setup(props) {
      const {
        inlineThemeDisabled,
        mergedRtlRef
      } = useConfig(props);
      const {
        props: messageProviderProps2,
        mergedClsPrefixRef
      } = vue.inject(messageProviderInjectionKey);
      const rtlEnabledRef = useRtl("Message", mergedRtlRef, mergedClsPrefixRef);
      const themeRef = useTheme("Message", "-message", style$u, messageLight$1, messageProviderProps2, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          type
        } = props;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            padding,
            margin,
            maxWidth,
            iconMargin,
            closeMargin,
            closeSize,
            iconSize,
            fontSize: fontSize2,
            lineHeight: lineHeight2,
            borderRadius,
            iconColorInfo,
            iconColorSuccess,
            iconColorWarning,
            iconColorError,
            iconColorLoading,
            closeIconSize,
            closeBorderRadius,
            [createKey("textColor", type)]: textColor,
            [createKey("boxShadow", type)]: boxShadow,
            [createKey("color", type)]: color,
            [createKey("closeColorHover", type)]: closeColorHover,
            [createKey("closeColorPressed", type)]: closeColorPressed,
            [createKey("closeIconColor", type)]: closeIconColor,
            [createKey("closeIconColorPressed", type)]: closeIconColorPressed,
            [createKey("closeIconColorHover", type)]: closeIconColorHover
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-margin": margin,
          "--n-padding": padding,
          "--n-max-width": maxWidth,
          "--n-font-size": fontSize2,
          "--n-icon-margin": iconMargin,
          "--n-icon-size": iconSize,
          "--n-close-icon-size": closeIconSize,
          "--n-close-border-radius": closeBorderRadius,
          "--n-close-size": closeSize,
          "--n-close-margin": closeMargin,
          "--n-text-color": textColor,
          "--n-color": color,
          "--n-box-shadow": boxShadow,
          "--n-icon-color-info": iconColorInfo,
          "--n-icon-color-success": iconColorSuccess,
          "--n-icon-color-warning": iconColorWarning,
          "--n-icon-color-error": iconColorError,
          "--n-icon-color-loading": iconColorLoading,
          "--n-close-color-hover": closeColorHover,
          "--n-close-color-pressed": closeColorPressed,
          "--n-close-icon-color": closeIconColor,
          "--n-close-icon-color-pressed": closeIconColorPressed,
          "--n-close-icon-color-hover": closeIconColorHover,
          "--n-line-height": lineHeight2,
          "--n-border-radius": borderRadius
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("message", vue.computed(() => props.type[0]), cssVarsRef, {}) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        rtlEnabled: rtlEnabledRef,
        messageProviderProps: messageProviderProps2,
        handleClose() {
          var _a;
          (_a = props.onClose) === null || _a === void 0 ? void 0 : _a.call(props);
        },
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
        placement: messageProviderProps2.placement
      };
    },
    render() {
      const {
        render: renderMessage,
        type,
        closable,
        content,
        mergedClsPrefix,
        cssVars,
        themeClass,
        onRender,
        icon,
        handleClose,
        showIcon
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      let iconNode;
      return vue.h("div", {
        class: [`${mergedClsPrefix}-message-wrapper`, themeClass],
        onMouseenter: this.onMouseenter,
        onMouseleave: this.onMouseleave,
        style: [{
          alignItems: this.placement.startsWith("top") ? "flex-start" : "flex-end"
        }, cssVars]
      }, renderMessage ? renderMessage(this.$props) : vue.h("div", {
        class: [`${mergedClsPrefix}-message ${mergedClsPrefix}-message--${type}-type`, this.rtlEnabled && `${mergedClsPrefix}-message--rtl`]
      }, (iconNode = createIconVNode(icon, type, mergedClsPrefix)) && showIcon ? vue.h("div", {
        class: `${mergedClsPrefix}-message__icon ${mergedClsPrefix}-message__icon--${type}-type`
      }, vue.h(NIconSwitchTransition, null, {
        default: () => iconNode
      })) : null, vue.h("div", {
        class: `${mergedClsPrefix}-message__content`
      }, render$1(content)), closable ? vue.h(NBaseClose, {
        clsPrefix: mergedClsPrefix,
        class: `${mergedClsPrefix}-message__close`,
        onClick: handleClose,
        absolute: true
      }) : null));
    }
  });
  function createIconVNode(icon, type, clsPrefix) {
    if (typeof icon === "function") {
      return icon();
    } else {
      const innerIcon = type === "loading" ? vue.h(NBaseLoading, {
        clsPrefix,
        strokeWidth: 24,
        scale: 0.85
      }) : iconRenderMap$2[type]();
      if (!innerIcon)
        return null;
      return vue.h(NBaseIcon, {
        clsPrefix,
        key: type
      }, {
        default: () => innerIcon
      });
    }
  }
  const MessageEnvironment = vue.defineComponent({
    name: "MessageEnvironment",
    props: Object.assign(Object.assign({}, messageProps), {
      duration: {
        type: Number,
        default: 3e3
      },
      onAfterLeave: Function,
      onLeave: Function,
      internalKey: {
        type: String,
        required: true
      },
      // private
      onInternalAfterLeave: Function,
      // deprecated
      onHide: Function,
      onAfterHide: Function
    }),
    setup(props) {
      let timerId = null;
      const showRef = vue.ref(true);
      vue.onMounted(() => {
        setHideTimeout();
      });
      function setHideTimeout() {
        const {
          duration: duration2
        } = props;
        if (duration2) {
          timerId = window.setTimeout(hide, duration2);
        }
      }
      function handleMouseenter(e) {
        if (e.currentTarget !== e.target)
          return;
        if (timerId !== null) {
          window.clearTimeout(timerId);
          timerId = null;
        }
      }
      function handleMouseleave(e) {
        if (e.currentTarget !== e.target)
          return;
        setHideTimeout();
      }
      function hide() {
        const {
          onHide
        } = props;
        showRef.value = false;
        if (timerId) {
          window.clearTimeout(timerId);
          timerId = null;
        }
        if (onHide)
          onHide();
      }
      function handleClose() {
        const {
          onClose
        } = props;
        if (onClose)
          onClose();
        hide();
      }
      function handleAfterLeave() {
        const {
          onAfterLeave,
          onInternalAfterLeave,
          onAfterHide,
          internalKey
        } = props;
        if (onAfterLeave)
          onAfterLeave();
        if (onInternalAfterLeave)
          onInternalAfterLeave(internalKey);
        if (onAfterHide)
          onAfterHide();
      }
      function deactivate() {
        hide();
      }
      return {
        show: showRef,
        hide,
        handleClose,
        handleAfterLeave,
        handleMouseleave,
        handleMouseenter,
        deactivate
      };
    },
    render() {
      return vue.h(NFadeInExpandTransition, {
        appear: true,
        onAfterLeave: this.handleAfterLeave,
        onLeave: this.onLeave
      }, {
        default: () => [this.show ? vue.h(NMessage, {
          content: this.content,
          type: this.type,
          icon: this.icon,
          showIcon: this.showIcon,
          closable: this.closable,
          onClose: this.handleClose,
          onMouseenter: this.keepAliveOnHover ? this.handleMouseenter : void 0,
          onMouseleave: this.keepAliveOnHover ? this.handleMouseleave : void 0
        }) : null]
      });
    }
  });
  const messageProviderProps = Object.assign(Object.assign({}, useTheme.props), {
    to: [String, Object],
    duration: {
      type: Number,
      default: 3e3
    },
    keepAliveOnHover: Boolean,
    max: Number,
    placement: {
      type: String,
      default: "top"
    },
    closable: Boolean,
    containerClass: String,
    containerStyle: [String, Object]
  });
  const NMessageProvider = vue.defineComponent({
    name: "MessageProvider",
    props: messageProviderProps,
    setup(props) {
      const {
        mergedClsPrefixRef
      } = useConfig(props);
      const messageListRef = vue.ref([]);
      const messageRefs = vue.ref({});
      const api = {
        create(content, options) {
          return create2(content, Object.assign({
            type: "default"
          }, options));
        },
        info(content, options) {
          return create2(content, Object.assign(Object.assign({}, options), {
            type: "info"
          }));
        },
        success(content, options) {
          return create2(content, Object.assign(Object.assign({}, options), {
            type: "success"
          }));
        },
        warning(content, options) {
          return create2(content, Object.assign(Object.assign({}, options), {
            type: "warning"
          }));
        },
        error(content, options) {
          return create2(content, Object.assign(Object.assign({}, options), {
            type: "error"
          }));
        },
        loading(content, options) {
          return create2(content, Object.assign(Object.assign({}, options), {
            type: "loading"
          }));
        },
        destroyAll
      };
      vue.provide(messageProviderInjectionKey, {
        props,
        mergedClsPrefixRef
      });
      vue.provide(messageApiInjectionKey, api);
      function create2(content, options) {
        const key = createId();
        const messageReactive = vue.reactive(Object.assign(Object.assign({}, options), {
          content,
          key,
          destroy: () => {
            var _a;
            (_a = messageRefs.value[key]) === null || _a === void 0 ? void 0 : _a.hide();
          }
        }));
        const {
          max
        } = props;
        if (max && messageListRef.value.length >= max) {
          messageListRef.value.shift();
        }
        messageListRef.value.push(messageReactive);
        return messageReactive;
      }
      function handleAfterLeave(key) {
        messageListRef.value.splice(messageListRef.value.findIndex((message2) => message2.key === key), 1);
        delete messageRefs.value[key];
      }
      function destroyAll() {
        Object.values(messageRefs.value).forEach((messageInstRef) => {
          messageInstRef.hide();
        });
      }
      return Object.assign({
        mergedClsPrefix: mergedClsPrefixRef,
        messageRefs,
        messageList: messageListRef,
        handleAfterLeave
      }, api);
    },
    render() {
      var _a, _b, _c;
      return vue.h(vue.Fragment, null, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a), this.messageList.length ? vue.h(vue.Teleport, {
        to: (_c = this.to) !== null && _c !== void 0 ? _c : "body"
      }, vue.h("div", {
        class: [`${this.mergedClsPrefix}-message-container`, `${this.mergedClsPrefix}-message-container--${this.placement}`, this.containerClass],
        key: "message-container",
        style: this.containerStyle
      }, this.messageList.map((message2) => {
        return vue.h(MessageEnvironment, Object.assign({
          ref: (inst) => {
            if (inst) {
              this.messageRefs[message2.key] = inst;
            }
          },
          internalKey: message2.key,
          onInternalAfterLeave: this.handleAfterLeave
        }, omit(message2, ["destroy"], void 0), {
          duration: message2.duration === void 0 ? this.duration : message2.duration,
          keepAliveOnHover: message2.keepAliveOnHover === void 0 ? this.keepAliveOnHover : message2.keepAliveOnHover,
          closable: message2.closable === void 0 ? this.closable : message2.closable
        }));
      }))) : null);
    }
  });
  function useMessage() {
    const api = vue.inject(messageApiInjectionKey, null);
    if (api === null) {
      throwError("use-message", "No outer <n-message-provider /> founded. See prerequisite in https://www.naiveui.com/en-US/os-theme/components/message for more details. If you want to use `useMessage` outside setup, please check https://www.naiveui.com/zh-CN/os-theme/components/message#Q-&-A.");
    }
    return api;
  }
  const NModalEnvironment = vue.defineComponent({
    name: "ModalEnvironment",
    props: Object.assign(Object.assign({}, modalProps), {
      internalKey: {
        type: String,
        required: true
      },
      // private
      onInternalAfterLeave: {
        type: Function,
        required: true
      }
    }),
    setup(props) {
      const showRef = vue.ref(true);
      function handleAfterLeave() {
        const {
          onInternalAfterLeave,
          internalKey,
          onAfterLeave
        } = props;
        if (onInternalAfterLeave)
          onInternalAfterLeave(internalKey);
        if (onAfterLeave)
          onAfterLeave();
      }
      function handlePositiveClick() {
        const {
          onPositiveClick
        } = props;
        if (onPositiveClick) {
          void Promise.resolve(onPositiveClick()).then((result) => {
            if (result === false)
              return;
            hide();
          });
        } else {
          hide();
        }
      }
      function handleNegativeClick() {
        const {
          onNegativeClick
        } = props;
        if (onNegativeClick) {
          void Promise.resolve(onNegativeClick()).then((result) => {
            if (result === false)
              return;
            hide();
          });
        } else {
          hide();
        }
      }
      function handleCloseClick() {
        const {
          onClose
        } = props;
        if (onClose) {
          void Promise.resolve(onClose()).then((result) => {
            if (result === false)
              return;
            hide();
          });
        } else {
          hide();
        }
      }
      function handleMaskClick(e) {
        const {
          onMaskClick,
          maskClosable
        } = props;
        if (onMaskClick) {
          onMaskClick(e);
          if (maskClosable) {
            hide();
          }
        }
      }
      function handleEsc() {
        const {
          onEsc
        } = props;
        if (onEsc) {
          onEsc();
        }
      }
      function hide() {
        showRef.value = false;
      }
      function handleUpdateShow(value) {
        showRef.value = value;
      }
      return {
        show: showRef,
        hide,
        handleUpdateShow,
        handleAfterLeave,
        handleCloseClick,
        handleNegativeClick,
        handlePositiveClick,
        handleMaskClick,
        handleEsc
      };
    },
    render() {
      const {
        handleUpdateShow,
        handleAfterLeave,
        handleMaskClick,
        handleEsc,
        show
      } = this;
      return vue.h(NModal, Object.assign({}, this.$props, {
        show,
        onUpdateShow: handleUpdateShow,
        onMaskClick: handleMaskClick,
        onEsc: handleEsc,
        onAfterLeave: handleAfterLeave,
        internalAppear: true,
        internalModal: true
      }));
    }
  });
  const modalProviderInjectionKey = createInjectionKey("n-modal-provider");
  const modalApiInjectionKey = createInjectionKey("n-modal-api");
  const modalReactiveListInjectionKey = createInjectionKey("n-modal-reactive-list");
  const modalProviderProps = {
    to: [String, Object]
  };
  const NModalProvider = vue.defineComponent({
    name: "ModalProvider",
    props: modalProviderProps,
    setup() {
      const clickedRef = useClicked(64);
      const clickedPositionRef = useClickPosition();
      const modalListRef = vue.ref([]);
      const modalInstRefs = {};
      function create2(options = {}) {
        const key = createId();
        const modalReactive = vue.reactive(Object.assign(Object.assign({}, options), {
          key,
          destroy: () => {
            var _a;
            (_a = modalInstRefs[`n-modal-${key}`]) === null || _a === void 0 ? void 0 : _a.hide();
          }
        }));
        modalListRef.value.push(modalReactive);
        return modalReactive;
      }
      function handleAfterLeave(key) {
        const {
          value: modalList
        } = modalListRef;
        modalList.splice(modalList.findIndex((modal) => modal.key === key), 1);
      }
      function destroyAll() {
        Object.values(modalInstRefs).forEach((modalInstRef) => {
          modalInstRef === null || modalInstRef === void 0 ? void 0 : modalInstRef.hide();
        });
      }
      const api = {
        create: create2,
        destroyAll
      };
      vue.provide(modalApiInjectionKey, api);
      vue.provide(modalProviderInjectionKey, {
        clickedRef: useClicked(64),
        clickedPositionRef: useClickPosition()
      });
      vue.provide(modalReactiveListInjectionKey, modalListRef);
      vue.provide(modalProviderInjectionKey, {
        clickedRef,
        clickedPositionRef
      });
      return Object.assign(Object.assign({}, api), {
        modalList: modalListRef,
        modalInstRefs,
        handleAfterLeave
      });
    },
    render() {
      var _a, _b;
      return vue.h(vue.Fragment, null, [this.modalList.map((modal) => {
        var _a2;
        return vue.h(NModalEnvironment, omit(modal, ["destroy"], {
          to: (_a2 = modal.to) !== null && _a2 !== void 0 ? _a2 : this.to,
          ref: (inst) => {
            if (inst === null) {
              delete this.modalInstRefs[`n-modal-${modal.key}`];
            } else {
              this.modalInstRefs[`n-modal-${modal.key}`] = inst;
            }
          },
          internalKey: modal.key,
          onInternalAfterLeave: this.handleAfterLeave
        }));
      }), (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a)]);
    }
  });
  function useModal() {
    const modal = vue.inject(modalApiInjectionKey, null);
    if (modal === null) {
      throwError("use-modal", "No outer <n-modal-provider /> founded.");
    }
    return modal;
  }
  function useModalReactiveList() {
    const modalReactiveList = vue.inject(modalReactiveListInjectionKey, null);
    if (modalReactiveList === null) {
      throwError("use-modal-reactive-list", "No outer <n-modal-provider /> founded.");
    }
    return modalReactiveList;
  }
  const notificationProviderInjectionKey = createInjectionKey("n-notification-provider");
  const NotificationContainer = vue.defineComponent({
    name: "NotificationContainer",
    props: {
      scrollable: {
        type: Boolean,
        required: true
      },
      placement: {
        type: String,
        required: true
      }
    },
    setup() {
      const {
        mergedThemeRef,
        mergedClsPrefixRef,
        wipTransitionCountRef
      } = vue.inject(notificationProviderInjectionKey);
      const selfRef = vue.ref(null);
      vue.watchEffect(() => {
        var _a, _b;
        if (wipTransitionCountRef.value > 0) {
          (_a = selfRef === null || selfRef === void 0 ? void 0 : selfRef.value) === null || _a === void 0 ? void 0 : _a.classList.add("transitioning");
        } else {
          (_b = selfRef === null || selfRef === void 0 ? void 0 : selfRef.value) === null || _b === void 0 ? void 0 : _b.classList.remove("transitioning");
        }
      });
      return {
        selfRef,
        mergedTheme: mergedThemeRef,
        mergedClsPrefix: mergedClsPrefixRef,
        transitioning: wipTransitionCountRef
      };
    },
    render() {
      const {
        $slots,
        scrollable,
        mergedClsPrefix,
        mergedTheme,
        placement
      } = this;
      return vue.h("div", {
        ref: "selfRef",
        class: [`${mergedClsPrefix}-notification-container`, scrollable && `${mergedClsPrefix}-notification-container--scrollable`, `${mergedClsPrefix}-notification-container--${placement}`]
      }, scrollable ? vue.h(NScrollbar, {
        theme: mergedTheme.peers.Scrollbar,
        themeOverrides: mergedTheme.peerOverrides.Scrollbar,
        contentStyle: {
          overflow: "hidden"
        }
      }, $slots) : $slots);
    }
  });
  const iconRenderMap$1 = {
    info: () => vue.h(InfoIcon, null),
    success: () => vue.h(SuccessIcon, null),
    warning: () => vue.h(WarningIcon, null),
    error: () => vue.h(ErrorIcon, null),
    default: () => null
  };
  const notificationProps = {
    closable: {
      type: Boolean,
      default: true
    },
    type: {
      type: String,
      default: "default"
    },
    avatar: Function,
    title: [String, Function],
    description: [String, Function],
    content: [String, Function],
    meta: [String, Function],
    action: [String, Function],
    onClose: {
      type: Function,
      required: true
    },
    keepAliveOnHover: Boolean,
    onMouseenter: Function,
    onMouseleave: Function
  };
  const notificationPropKeys = keysOf(notificationProps);
  const Notification = vue.defineComponent({
    name: "Notification",
    props: notificationProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        mergedThemeRef,
        props: providerProps
      } = vue.inject(notificationProviderInjectionKey);
      const {
        inlineThemeDisabled,
        mergedRtlRef
      } = useConfig();
      const rtlEnabledRef = useRtl("Notification", mergedRtlRef, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          type
        } = props;
        const {
          self: {
            color,
            textColor,
            closeIconColor,
            closeIconColorHover,
            closeIconColorPressed,
            headerTextColor,
            descriptionTextColor,
            actionTextColor,
            borderRadius,
            headerFontWeight,
            boxShadow,
            lineHeight: lineHeight2,
            fontSize: fontSize2,
            closeMargin,
            closeSize,
            width,
            padding,
            closeIconSize,
            closeBorderRadius,
            closeColorHover,
            closeColorPressed,
            titleFontSize,
            metaFontSize,
            descriptionFontSize,
            [createKey("iconColor", type)]: iconColor
          },
          common: {
            cubicBezierEaseOut: cubicBezierEaseOut2,
            cubicBezierEaseIn: cubicBezierEaseIn2,
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          }
        } = mergedThemeRef.value;
        const {
          left,
          right,
          top,
          bottom
        } = getMargin(padding);
        return {
          "--n-color": color,
          "--n-font-size": fontSize2,
          "--n-text-color": textColor,
          "--n-description-text-color": descriptionTextColor,
          "--n-action-text-color": actionTextColor,
          "--n-title-text-color": headerTextColor,
          "--n-title-font-weight": headerFontWeight,
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-bezier-ease-out": cubicBezierEaseOut2,
          "--n-bezier-ease-in": cubicBezierEaseIn2,
          "--n-border-radius": borderRadius,
          "--n-box-shadow": boxShadow,
          "--n-close-border-radius": closeBorderRadius,
          "--n-close-color-hover": closeColorHover,
          "--n-close-color-pressed": closeColorPressed,
          "--n-close-icon-color": closeIconColor,
          "--n-close-icon-color-hover": closeIconColorHover,
          "--n-close-icon-color-pressed": closeIconColorPressed,
          "--n-line-height": lineHeight2,
          "--n-icon-color": iconColor,
          "--n-close-margin": closeMargin,
          "--n-close-size": closeSize,
          "--n-close-icon-size": closeIconSize,
          "--n-width": width,
          "--n-padding-left": left,
          "--n-padding-right": right,
          "--n-padding-top": top,
          "--n-padding-bottom": bottom,
          "--n-title-font-size": titleFontSize,
          "--n-meta-font-size": metaFontSize,
          "--n-description-font-size": descriptionFontSize
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("notification", vue.computed(() => props.type[0]), cssVarsRef, providerProps) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        showAvatar: vue.computed(() => {
          return props.avatar || props.type !== "default";
        }),
        handleCloseClick() {
          props.onClose();
        },
        rtlEnabled: rtlEnabledRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a;
      const {
        mergedClsPrefix
      } = this;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      return vue.h("div", {
        class: [`${mergedClsPrefix}-notification-wrapper`, this.themeClass],
        onMouseenter: this.onMouseenter,
        onMouseleave: this.onMouseleave,
        style: this.cssVars
      }, vue.h("div", {
        class: [`${mergedClsPrefix}-notification`, this.rtlEnabled && `${mergedClsPrefix}-notification--rtl`, this.themeClass, {
          [`${mergedClsPrefix}-notification--closable`]: this.closable,
          [`${mergedClsPrefix}-notification--show-avatar`]: this.showAvatar
        }],
        style: this.cssVars
      }, this.showAvatar ? vue.h("div", {
        class: `${mergedClsPrefix}-notification__avatar`
      }, this.avatar ? render$1(this.avatar) : this.type !== "default" ? vue.h(NBaseIcon, {
        clsPrefix: mergedClsPrefix
      }, {
        default: () => iconRenderMap$1[this.type]()
      }) : null) : null, this.closable ? vue.h(NBaseClose, {
        clsPrefix: mergedClsPrefix,
        class: `${mergedClsPrefix}-notification__close`,
        onClick: this.handleCloseClick
      }) : null, vue.h("div", {
        ref: "bodyRef",
        class: `${mergedClsPrefix}-notification-main`
      }, this.title ? vue.h("div", {
        class: `${mergedClsPrefix}-notification-main__header`
      }, render$1(this.title)) : null, this.description ? vue.h("div", {
        class: `${mergedClsPrefix}-notification-main__description`
      }, render$1(this.description)) : null, this.content ? vue.h("pre", {
        class: `${mergedClsPrefix}-notification-main__content`
      }, render$1(this.content)) : null, this.meta || this.action ? vue.h("div", {
        class: `${mergedClsPrefix}-notification-main-footer`
      }, this.meta ? vue.h("div", {
        class: `${mergedClsPrefix}-notification-main-footer__meta`
      }, render$1(this.meta)) : null, this.action ? vue.h("div", {
        class: `${mergedClsPrefix}-notification-main-footer__action`
      }, render$1(this.action)) : null) : null)));
    }
  });
  const notificationEnvOptions = Object.assign(Object.assign({}, notificationProps), {
    duration: Number,
    onClose: Function,
    onLeave: Function,
    onAfterEnter: Function,
    onAfterLeave: Function,
    /** @deprecated */
    onHide: Function,
    /** @deprecated */
    onAfterShow: Function,
    /** @deprecated */
    onAfterHide: Function
  });
  const NotificationEnvironment = vue.defineComponent({
    name: "NotificationEnvironment",
    props: Object.assign(Object.assign({}, notificationEnvOptions), {
      // private
      internalKey: {
        type: String,
        required: true
      },
      onInternalAfterLeave: {
        type: Function,
        required: true
      }
    }),
    setup(props) {
      const {
        wipTransitionCountRef
      } = vue.inject(notificationProviderInjectionKey);
      const showRef = vue.ref(true);
      let timerId = null;
      function hide() {
        showRef.value = false;
        if (timerId) {
          window.clearTimeout(timerId);
        }
      }
      function handleBeforeEnter(el) {
        wipTransitionCountRef.value++;
        void vue.nextTick(() => {
          el.style.height = `${el.offsetHeight}px`;
          el.style.maxHeight = "0";
          el.style.transition = "none";
          void el.offsetHeight;
          el.style.transition = "";
          el.style.maxHeight = el.style.height;
        });
      }
      function handleAfterEnter(el) {
        wipTransitionCountRef.value--;
        el.style.height = "";
        el.style.maxHeight = "";
        const {
          onAfterEnter,
          onAfterShow
        } = props;
        if (onAfterEnter)
          onAfterEnter();
        if (onAfterShow)
          onAfterShow();
      }
      function handleBeforeLeave(el) {
        wipTransitionCountRef.value++;
        el.style.maxHeight = `${el.offsetHeight}px`;
        el.style.height = `${el.offsetHeight}px`;
        void el.offsetHeight;
      }
      function handleLeave(el) {
        const {
          onHide
        } = props;
        if (onHide)
          onHide();
        el.style.maxHeight = "0";
        void el.offsetHeight;
      }
      function handleAfterLeave() {
        wipTransitionCountRef.value--;
        const {
          onAfterLeave,
          onInternalAfterLeave,
          onAfterHide,
          internalKey
        } = props;
        if (onAfterLeave)
          onAfterLeave();
        onInternalAfterLeave(internalKey);
        if (onAfterHide)
          onAfterHide();
      }
      function setHideTimeout() {
        const {
          duration: duration2
        } = props;
        if (duration2) {
          timerId = window.setTimeout(hide, duration2);
        }
      }
      function handleMouseenter(e) {
        if (e.currentTarget !== e.target)
          return;
        if (timerId !== null) {
          window.clearTimeout(timerId);
          timerId = null;
        }
      }
      function handleMouseleave(e) {
        if (e.currentTarget !== e.target)
          return;
        setHideTimeout();
      }
      function handleClose() {
        const {
          onClose
        } = props;
        if (onClose) {
          void Promise.resolve(onClose()).then((feedback) => {
            if (feedback === false)
              return;
            hide();
          });
        } else {
          hide();
        }
      }
      vue.onMounted(() => {
        if (props.duration) {
          timerId = window.setTimeout(hide, props.duration);
        }
      });
      return {
        show: showRef,
        hide,
        handleClose,
        handleAfterLeave,
        handleLeave,
        handleBeforeLeave,
        handleAfterEnter,
        handleBeforeEnter,
        handleMouseenter,
        handleMouseleave
      };
    },
    render() {
      return vue.h(vue.Transition, {
        name: "notification-transition",
        appear: true,
        // convert to any since Element is not compatible with HTMLElement
        onBeforeEnter: this.handleBeforeEnter,
        onAfterEnter: this.handleAfterEnter,
        onBeforeLeave: this.handleBeforeLeave,
        onLeave: this.handleLeave,
        onAfterLeave: this.handleAfterLeave
      }, {
        default: () => {
          return this.show ? vue.h(Notification, Object.assign({}, keep(this.$props, notificationPropKeys), {
            onClose: this.handleClose,
            onMouseenter: this.duration && this.keepAliveOnHover ? this.handleMouseenter : void 0,
            onMouseleave: this.duration && this.keepAliveOnHover ? this.handleMouseleave : void 0
          })) : null;
        }
      });
    }
  });
  const style$t = c$1([cB("notification-container", `
 z-index: 4000;
 position: fixed;
 overflow: visible;
 display: flex;
 flex-direction: column;
 align-items: flex-end;
 `, [c$1(">", [cB("scrollbar", `
 width: initial;
 overflow: visible;
 height: -moz-fit-content !important;
 height: fit-content !important;
 max-height: 100vh !important;
 `, [c$1(">", [cB("scrollbar-container", `
 height: -moz-fit-content !important;
 height: fit-content !important;
 max-height: 100vh !important;
 `, [cB("scrollbar-content", `
 padding-top: 12px;
 padding-bottom: 33px;
 `)])])])]), cM("top, top-right, top-left", `
 top: 12px;
 `, [c$1("&.transitioning >", [cB("scrollbar", [c$1(">", [cB("scrollbar-container", `
 min-height: 100vh !important;
 `)])])])]), cM("bottom, bottom-right, bottom-left", `
 bottom: 12px;
 `, [c$1(">", [cB("scrollbar", [c$1(">", [cB("scrollbar-container", [cB("scrollbar-content", `
 padding-bottom: 12px;
 `)])])])]), cB("notification-wrapper", `
 display: flex;
 align-items: flex-end;
 margin-bottom: 0;
 margin-top: 12px;
 `)]), cM("top, bottom", `
 left: 50%;
 transform: translateX(-50%);
 `, [cB("notification-wrapper", [c$1("&.notification-transition-enter-from, &.notification-transition-leave-to", `
 transform: scale(0.85);
 `), c$1("&.notification-transition-leave-from, &.notification-transition-enter-to", `
 transform: scale(1);
 `)])]), cM("top", [cB("notification-wrapper", `
 transform-origin: top center;
 `)]), cM("bottom", [cB("notification-wrapper", `
 transform-origin: bottom center;
 `)]), cM("top-right, bottom-right", [cB("notification", `
 margin-left: 28px;
 margin-right: 16px;
 `)]), cM("top-left, bottom-left", [cB("notification", `
 margin-left: 16px;
 margin-right: 28px;
 `)]), cM("top-right", `
 right: 0;
 `, [placementTransformStyle("top-right")]), cM("top-left", `
 left: 0;
 `, [placementTransformStyle("top-left")]), cM("bottom-right", `
 right: 0;
 `, [placementTransformStyle("bottom-right")]), cM("bottom-left", `
 left: 0;
 `, [placementTransformStyle("bottom-left")]), cM("scrollable", [cM("top-right", `
 top: 0;
 `), cM("top-left", `
 top: 0;
 `), cM("bottom-right", `
 bottom: 0;
 `), cM("bottom-left", `
 bottom: 0;
 `)]), cB("notification-wrapper", `
 margin-bottom: 12px;
 `, [c$1("&.notification-transition-enter-from, &.notification-transition-leave-to", `
 opacity: 0;
 margin-top: 0 !important;
 margin-bottom: 0 !important;
 `), c$1("&.notification-transition-leave-from, &.notification-transition-enter-to", `
 opacity: 1;
 `), c$1("&.notification-transition-leave-active", `
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 transform .3s var(--n-bezier-ease-in),
 max-height .3s var(--n-bezier),
 margin-top .3s linear,
 margin-bottom .3s linear,
 box-shadow .3s var(--n-bezier);
 `), c$1("&.notification-transition-enter-active", `
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 transform .3s var(--n-bezier-ease-out),
 max-height .3s var(--n-bezier),
 margin-top .3s linear,
 margin-bottom .3s linear,
 box-shadow .3s var(--n-bezier);
 `)]), cB("notification", `
 background-color: var(--n-color);
 color: var(--n-text-color);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 font-family: inherit;
 font-size: var(--n-font-size);
 font-weight: 400;
 position: relative;
 display: flex;
 overflow: hidden;
 flex-shrink: 0;
 padding-left: var(--n-padding-left);
 padding-right: var(--n-padding-right);
 width: var(--n-width);
 max-width: calc(100vw - 16px - 16px);
 border-radius: var(--n-border-radius);
 box-shadow: var(--n-box-shadow);
 box-sizing: border-box;
 opacity: 1;
 `, [cE("avatar", [cB("icon", `
 color: var(--n-icon-color);
 `), cB("base-icon", `
 color: var(--n-icon-color);
 `)]), cM("show-avatar", [cB("notification-main", `
 margin-left: 40px;
 width: calc(100% - 40px); 
 `)]), cM("closable", [cB("notification-main", [c$1("> *:first-child", `
 padding-right: 20px;
 `)]), cE("close", `
 position: absolute;
 top: 0;
 right: 0;
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), cE("avatar", `
 position: absolute;
 top: var(--n-padding-top);
 left: var(--n-padding-left);
 width: 28px;
 height: 28px;
 font-size: 28px;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [cB("icon", "transition: color .3s var(--n-bezier);")]), cB("notification-main", `
 padding-top: var(--n-padding-top);
 padding-bottom: var(--n-padding-bottom);
 box-sizing: border-box;
 display: flex;
 flex-direction: column;
 margin-left: 8px;
 width: calc(100% - 8px);
 `, [cB("notification-main-footer", `
 display: flex;
 align-items: center;
 justify-content: space-between;
 margin-top: 12px;
 `, [cE("meta", `
 font-size: var(--n-meta-font-size);
 transition: color .3s var(--n-bezier-ease-out);
 color: var(--n-description-text-color);
 `), cE("action", `
 cursor: pointer;
 transition: color .3s var(--n-bezier-ease-out);
 color: var(--n-action-text-color);
 `)]), cE("header", `
 font-weight: var(--n-title-font-weight);
 font-size: var(--n-title-font-size);
 transition: color .3s var(--n-bezier-ease-out);
 color: var(--n-title-text-color);
 `), cE("description", `
 margin-top: 8px;
 font-size: var(--n-description-font-size);
 white-space: pre-wrap;
 word-wrap: break-word;
 transition: color .3s var(--n-bezier-ease-out);
 color: var(--n-description-text-color);
 `), cE("content", `
 line-height: var(--n-line-height);
 margin: 12px 0 0 0;
 font-family: inherit;
 white-space: pre-wrap;
 word-wrap: break-word;
 transition: color .3s var(--n-bezier-ease-out);
 color: var(--n-text-color);
 `, [c$1("&:first-child", "margin: 0;")])])])])]);
  function placementTransformStyle(placement) {
    const direction = placement.split("-")[1];
    const transformXEnter = direction === "left" ? "calc(-100%)" : "calc(100%)";
    const transformXLeave = "0";
    return cB("notification-wrapper", [c$1("&.notification-transition-enter-from, &.notification-transition-leave-to", `
 transform: translate(${transformXEnter}, 0);
 `), c$1("&.notification-transition-leave-from, &.notification-transition-enter-to", `
 transform: translate(${transformXLeave}, 0);
 `)]);
  }
  const notificationApiInjectionKey = createInjectionKey("n-notification-api");
  const notificationProviderProps = Object.assign(Object.assign({}, useTheme.props), {
    containerClass: String,
    containerStyle: [String, Object],
    to: [String, Object],
    scrollable: {
      type: Boolean,
      default: true
    },
    max: Number,
    placement: {
      type: String,
      default: "top-right"
    },
    keepAliveOnHover: Boolean
  });
  const NNotificationProvider = vue.defineComponent({
    name: "NotificationProvider",
    props: notificationProviderProps,
    setup(props) {
      const {
        mergedClsPrefixRef
      } = useConfig(props);
      const notificationListRef = vue.ref([]);
      const notificationRefs = {};
      const leavingKeySet = /* @__PURE__ */ new Set();
      function create2(options) {
        const key = createId();
        const destroy = () => {
          leavingKeySet.add(key);
          if (notificationRefs[key]) {
            notificationRefs[key].hide();
          }
        };
        const notificationReactive = vue.reactive(Object.assign(Object.assign({}, options), {
          key,
          destroy,
          hide: destroy,
          deactivate: destroy
        }));
        const {
          max
        } = props;
        if (max && notificationListRef.value.length - leavingKeySet.size >= max) {
          let someoneMountedRemoved = false;
          let index = 0;
          for (const notification of notificationListRef.value) {
            if (!leavingKeySet.has(notification.key)) {
              if (notificationRefs[notification.key]) {
                notification.destroy();
                someoneMountedRemoved = true;
              }
              break;
            }
            index++;
          }
          if (!someoneMountedRemoved) {
            notificationListRef.value.splice(index, 1);
          }
        }
        notificationListRef.value.push(notificationReactive);
        return notificationReactive;
      }
      const apis = ["info", "success", "warning", "error"].map((type) => {
        return (options) => create2(Object.assign(Object.assign({}, options), {
          type
        }));
      });
      function handleAfterLeave(key) {
        leavingKeySet.delete(key);
        notificationListRef.value.splice(notificationListRef.value.findIndex((notification) => notification.key === key), 1);
      }
      const themeRef = useTheme("Notification", "-notification", style$t, notificationLight$1, props, mergedClsPrefixRef);
      const api = {
        create: create2,
        info: apis[0],
        success: apis[1],
        warning: apis[2],
        error: apis[3],
        open,
        destroyAll
      };
      const wipTransitionCountRef = vue.ref(0);
      vue.provide(notificationApiInjectionKey, api);
      vue.provide(notificationProviderInjectionKey, {
        props,
        mergedClsPrefixRef,
        mergedThemeRef: themeRef,
        wipTransitionCountRef
      });
      function open(options) {
        return create2(options);
      }
      function destroyAll() {
        Object.values(notificationListRef.value).forEach((notification) => {
          notification.hide();
        });
      }
      return Object.assign({
        mergedClsPrefix: mergedClsPrefixRef,
        notificationList: notificationListRef,
        notificationRefs,
        handleAfterLeave
      }, api);
    },
    render() {
      var _a, _b, _c;
      const {
        placement
      } = this;
      return vue.h(vue.Fragment, null, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a), this.notificationList.length ? vue.h(vue.Teleport, {
        to: (_c = this.to) !== null && _c !== void 0 ? _c : "body"
      }, vue.h(NotificationContainer, {
        class: this.containerClass,
        style: this.containerStyle,
        scrollable: this.scrollable && placement !== "top" && placement !== "bottom",
        placement
      }, {
        default: () => {
          return this.notificationList.map((notification) => {
            return vue.h(NotificationEnvironment, Object.assign({
              ref: (inst) => {
                const refKey = notification.key;
                if (inst === null) {
                  delete this.notificationRefs[refKey];
                } else {
                  this.notificationRefs[refKey] = inst;
                }
              }
            }, omit(notification, ["destroy", "hide", "deactivate"]), {
              internalKey: notification.key,
              onInternalAfterLeave: this.handleAfterLeave,
              keepAliveOnHover: notification.keepAliveOnHover === void 0 ? this.keepAliveOnHover : notification.keepAliveOnHover
            }));
          });
        }
      })) : null);
    }
  });
  function useNotification() {
    const api = vue.inject(notificationApiInjectionKey, null);
    if (api === null) {
      throwError("use-notification", "No outer `n-notification-provider` found.");
    }
    return api;
  }
  const style$s = c$1([cB("page-header-header", `
 margin-bottom: 20px;
 `), cB("page-header", `
 display: flex;
 align-items: center;
 justify-content: space-between;
 line-height: 1.5;
 font-size: var(--n-font-size);
 `, [cE("main", `
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 `), cE("back", `
 display: flex;
 margin-right: 16px;
 font-size: var(--n-back-size);
 cursor: pointer;
 color: var(--n-back-color);
 transition: color .3s var(--n-bezier);
 `, [c$1("&:hover", "color: var(--n-back-color-hover);"), c$1("&:active", "color: var(--n-back-color-pressed);")]), cE("avatar", `
 display: flex;
 margin-right: 12px
 `), cE("title", `
 margin-right: 16px;
 transition: color .3s var(--n-bezier);
 font-size: var(--n-title-font-size);
 font-weight: var(--n-title-font-weight);
 color: var(--n-title-text-color);
 `), cE("subtitle", `
 font-size: 14px;
 transition: color .3s var(--n-bezier);
 color: var(--n-subtitle-text-color);
 `)]), cB("page-header-content", `
 font-size: var(--n-font-size);
 `, [c$1("&:not(:first-child)", "margin-top: 20px;")]), cB("page-header-footer", `
 font-size: var(--n-font-size);
 `, [c$1("&:not(:first-child)", "margin-top: 20px;")])]);
  const pageHeaderProps = Object.assign(Object.assign({}, useTheme.props), {
    title: String,
    subtitle: String,
    extra: String,
    onBack: Function
  });
  const PageHeader = vue.defineComponent({
    name: "PageHeader",
    props: pageHeaderProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        mergedRtlRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("PageHeader", "-page-header", style$s, pageHeaderLight, props, mergedClsPrefixRef);
      const rtlEnabledRef = useRtl("PageHeader", mergedRtlRef, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          self: {
            titleTextColor,
            subtitleTextColor,
            backColor,
            fontSize: fontSize2,
            titleFontSize,
            backSize,
            titleFontWeight,
            backColorHover,
            backColorPressed
          },
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          }
        } = themeRef.value;
        return {
          "--n-title-text-color": titleTextColor,
          "--n-title-font-size": titleFontSize,
          "--n-title-font-weight": titleFontWeight,
          "--n-font-size": fontSize2,
          "--n-back-size": backSize,
          "--n-subtitle-text-color": subtitleTextColor,
          "--n-back-color": backColor,
          "--n-back-color-hover": backColorHover,
          "--n-back-color-pressed": backColorPressed,
          "--n-bezier": cubicBezierEaseInOut2
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("page-header", void 0, cssVarsRef, props) : void 0;
      return {
        rtlEnabled: rtlEnabledRef,
        mergedClsPrefix: mergedClsPrefixRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a;
      const {
        onBack,
        title,
        subtitle,
        extra,
        mergedClsPrefix,
        cssVars,
        $slots
      } = this;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      const {
        title: titleSlot,
        subtitle: subtitleSlot,
        extra: extraSlot,
        default: defaultSlot,
        header: headerSlot,
        avatar: avatarSlot,
        footer: footerSlot,
        back: backSlot
      } = $slots;
      const showBack = onBack;
      const showTitle = title || titleSlot;
      const showSubtitle = subtitle || subtitleSlot;
      const showExtra = extra || extraSlot;
      return vue.h("div", {
        style: cssVars,
        class: [`${mergedClsPrefix}-page-header-wrapper`, this.themeClass, this.rtlEnabled && `${mergedClsPrefix}-page-header-wrapper--rtl`]
      }, headerSlot ? vue.h("div", {
        class: `${mergedClsPrefix}-page-header-header`,
        key: "breadcrumb"
      }, headerSlot()) : null, (showBack || avatarSlot || showTitle || showSubtitle || showExtra) && vue.h("div", {
        class: `${mergedClsPrefix}-page-header`,
        key: "header"
      }, vue.h("div", {
        class: `${mergedClsPrefix}-page-header__main`,
        key: "back"
      }, showBack ? vue.h("div", {
        class: `${mergedClsPrefix}-page-header__back`,
        onClick: onBack
      }, backSlot ? backSlot() : vue.h(NBaseIcon, {
        clsPrefix: mergedClsPrefix
      }, {
        default: () => vue.h(ArrowBackIcon, null)
      })) : null, avatarSlot ? vue.h("div", {
        class: `${mergedClsPrefix}-page-header__avatar`
      }, avatarSlot()) : null, showTitle ? vue.h("div", {
        class: `${mergedClsPrefix}-page-header__title`,
        key: "title"
      }, title || titleSlot()) : null, showSubtitle ? vue.h("div", {
        class: `${mergedClsPrefix}-page-header__subtitle`,
        key: "subtitle"
      }, subtitle || subtitleSlot()) : null), showExtra ? vue.h("div", {
        class: `${mergedClsPrefix}-page-header__extra`
      }, extra || extraSlot()) : null), defaultSlot ? vue.h("div", {
        class: `${mergedClsPrefix}-page-header-content`,
        key: "content"
      }, defaultSlot()) : null, footerSlot ? vue.h("div", {
        class: `${mergedClsPrefix}-page-header-footer`,
        key: "footer"
      }, footerSlot()) : null);
    }
  });
  const popconfirmInjectionKey = createInjectionKey("n-popconfirm");
  const panelProps = {
    positiveText: String,
    negativeText: String,
    showIcon: {
      type: Boolean,
      default: true
    },
    onPositiveClick: {
      type: Function,
      required: true
    },
    onNegativeClick: {
      type: Function,
      required: true
    }
  };
  const panelPropKeys = keysOf(panelProps);
  const PopconfirmPanel = vue.defineComponent({
    name: "NPopconfirmPanel",
    props: panelProps,
    setup(props) {
      const {
        localeRef
      } = useLocale("Popconfirm");
      const {
        inlineThemeDisabled
      } = useConfig();
      const {
        mergedClsPrefixRef,
        mergedThemeRef,
        props: popconfirmProps2
      } = vue.inject(popconfirmInjectionKey);
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            fontSize: fontSize2,
            iconSize,
            iconColor
          }
        } = mergedThemeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-font-size": fontSize2,
          "--n-icon-size": iconSize,
          "--n-icon-color": iconColor
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("popconfirm-panel", void 0, cssVarsRef, popconfirmProps2) : void 0;
      return Object.assign(Object.assign({}, useLocale("Popconfirm")), {
        mergedClsPrefix: mergedClsPrefixRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        localizedPositiveText: vue.computed(() => {
          return props.positiveText || localeRef.value.positiveText;
        }),
        localizedNegativeText: vue.computed(() => {
          return props.negativeText || localeRef.value.negativeText;
        }),
        positiveButtonProps: vue.toRef(popconfirmProps2, "positiveButtonProps"),
        negativeButtonProps: vue.toRef(popconfirmProps2, "negativeButtonProps"),
        handlePositiveClick(e) {
          props.onPositiveClick(e);
        },
        handleNegativeClick(e) {
          props.onNegativeClick(e);
        },
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      });
    },
    render() {
      var _a;
      const {
        mergedClsPrefix,
        showIcon,
        $slots
      } = this;
      const actionContentNode = resolveSlot($slots.action, () => this.negativeText === null && this.positiveText === null ? [] : [this.negativeText !== null && vue.h(NButton, Object.assign({
        size: "small",
        onClick: this.handleNegativeClick
      }, this.negativeButtonProps), {
        default: () => this.localizedNegativeText
      }), this.positiveText !== null && vue.h(NButton, Object.assign({
        size: "small",
        type: "primary",
        onClick: this.handlePositiveClick
      }, this.positiveButtonProps), {
        default: () => this.localizedPositiveText
      })]);
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      return vue.h("div", {
        class: [`${mergedClsPrefix}-popconfirm__panel`, this.themeClass],
        style: this.cssVars
      }, resolveWrappedSlot($slots.default, (children) => showIcon || children ? vue.h("div", {
        class: `${mergedClsPrefix}-popconfirm__body`
      }, showIcon ? vue.h("div", {
        class: `${mergedClsPrefix}-popconfirm__icon`
      }, resolveSlot($slots.icon, () => [vue.h(NBaseIcon, {
        clsPrefix: mergedClsPrefix
      }, {
        default: () => vue.h(WarningIcon, null)
      })])) : null, children) : null), actionContentNode ? vue.h("div", {
        class: [`${mergedClsPrefix}-popconfirm__action`]
      }, actionContentNode) : null);
    }
  });
  const style$r = cB("popconfirm", [cE("body", `
 font-size: var(--n-font-size);
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 position: relative;
 `, [cE("icon", `
 display: flex;
 font-size: var(--n-icon-size);
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 margin: 0 8px 0 0;
 `)]), cE("action", `
 display: flex;
 justify-content: flex-end;
 `, [c$1("&:not(:first-child)", "margin-top: 8px"), cB("button", [c$1("&:not(:last-child)", "margin-right: 8px;")])])]);
  const popconfirmProps = Object.assign(Object.assign(Object.assign({}, useTheme.props), popoverBaseProps), {
    positiveText: String,
    negativeText: String,
    showIcon: {
      type: Boolean,
      default: true
    },
    trigger: {
      type: String,
      default: "click"
    },
    positiveButtonProps: Object,
    negativeButtonProps: Object,
    onPositiveClick: Function,
    onNegativeClick: Function
  });
  const Popconfirm = vue.defineComponent({
    name: "Popconfirm",
    props: popconfirmProps,
    __popover__: true,
    setup(props) {
      const {
        mergedClsPrefixRef
      } = useConfig();
      const themeRef = useTheme("Popconfirm", "-popconfirm", style$r, popconfirmLight$1, props, mergedClsPrefixRef);
      const popoverInstRef = vue.ref(null);
      function handlePositiveClick(e) {
        var _a;
        if (!((_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.getMergedShow()))
          return;
        const {
          onPositiveClick,
          "onUpdate:show": onUpdateShow
        } = props;
        void Promise.resolve(onPositiveClick ? onPositiveClick(e) : true).then((value) => {
          var _a2;
          if (value === false)
            return;
          (_a2 = popoverInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.setShow(false);
          if (onUpdateShow)
            call(onUpdateShow, false);
        });
      }
      function handleNegativeClick(e) {
        var _a;
        if (!((_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.getMergedShow()))
          return;
        const {
          onNegativeClick,
          "onUpdate:show": onUpdateShow
        } = props;
        void Promise.resolve(onNegativeClick ? onNegativeClick(e) : true).then((value) => {
          var _a2;
          if (value === false)
            return;
          (_a2 = popoverInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.setShow(false);
          if (onUpdateShow)
            call(onUpdateShow, false);
        });
      }
      vue.provide(popconfirmInjectionKey, {
        mergedThemeRef: themeRef,
        mergedClsPrefixRef,
        props
      });
      const returned = {
        setShow(value) {
          var _a;
          (_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.setShow(value);
        },
        syncPosition() {
          var _a;
          (_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
        },
        mergedTheme: themeRef,
        popoverInstRef,
        handlePositiveClick,
        handleNegativeClick
      };
      return returned;
    },
    render() {
      const {
        $slots: slots,
        $props: props,
        mergedTheme
      } = this;
      return vue.h(NPopover, omit(props, panelPropKeys, {
        theme: mergedTheme.peers.Popover,
        themeOverrides: mergedTheme.peerOverrides.Popover,
        internalExtraClass: ["popconfirm"],
        ref: "popoverInstRef"
      }), {
        trigger: slots.activator || slots.trigger,
        default: () => {
          const panelProps2 = keep(props, panelPropKeys);
          return vue.h(PopconfirmPanel, Object.assign(Object.assign({}, panelProps2), {
            onPositiveClick: this.handlePositiveClick,
            onNegativeClick: this.handleNegativeClick
          }), slots);
        }
      });
    }
  });
  const style$q = c$1([cB("progress", {
    display: "inline-block"
  }, [cB("progress-icon", `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 `), cM("line", `
 width: 100%;
 display: block;
 `, [cB("progress-content", `
 display: flex;
 align-items: center;
 `, [cB("progress-graph", {
    flex: 1
  })]), cB("progress-custom-content", {
    marginLeft: "14px"
  }), cB("progress-icon", `
 width: 30px;
 padding-left: 14px;
 height: var(--n-icon-size-line);
 line-height: var(--n-icon-size-line);
 font-size: var(--n-icon-size-line);
 `, [cM("as-text", `
 color: var(--n-text-color-line-outer);
 text-align: center;
 width: 40px;
 font-size: var(--n-font-size);
 padding-left: 4px;
 transition: color .3s var(--n-bezier);
 `)])]), cM("circle, dashboard", {
    width: "120px"
  }, [cB("progress-custom-content", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 `), cB("progress-text", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 color: inherit;
 font-size: var(--n-font-size-circle);
 color: var(--n-text-color-circle);
 font-weight: var(--n-font-weight-circle);
 transition: color .3s var(--n-bezier);
 white-space: nowrap;
 `), cB("progress-icon", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 color: var(--n-icon-color);
 font-size: var(--n-icon-size-circle);
 `)]), cM("multiple-circle", `
 width: 200px;
 color: inherit;
 `, [cB("progress-text", `
 font-weight: var(--n-font-weight-circle);
 color: var(--n-text-color-circle);
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `)]), cB("progress-content", {
    position: "relative"
  }), cB("progress-graph", {
    position: "relative"
  }, [cB("progress-graph-circle", [c$1("svg", {
    verticalAlign: "bottom"
  }), cB("progress-graph-circle-fill", `
 stroke: var(--n-fill-color);
 transition:
 opacity .3s var(--n-bezier),
 stroke .3s var(--n-bezier),
 stroke-dasharray .3s var(--n-bezier);
 `, [cM("empty", {
    opacity: 0
  })]), cB("progress-graph-circle-rail", `
 transition: stroke .3s var(--n-bezier);
 overflow: hidden;
 stroke: var(--n-rail-color);
 `)]), cB("progress-graph-line", [cM("indicator-inside", [cB("progress-graph-line-rail", `
 height: 16px;
 line-height: 16px;
 border-radius: 10px;
 `, [cB("progress-graph-line-fill", `
 height: inherit;
 border-radius: 10px;
 `), cB("progress-graph-line-indicator", `
 background: #0000;
 white-space: nowrap;
 text-align: right;
 margin-left: 14px;
 margin-right: 14px;
 height: inherit;
 font-size: 12px;
 color: var(--n-text-color-line-inner);
 transition: color .3s var(--n-bezier);
 `)])]), cM("indicator-inside-label", `
 height: 16px;
 display: flex;
 align-items: center;
 `, [cB("progress-graph-line-rail", `
 flex: 1;
 transition: background-color .3s var(--n-bezier);
 `), cB("progress-graph-line-indicator", `
 background: var(--n-fill-color);
 font-size: 12px;
 transform: translateZ(0);
 display: flex;
 vertical-align: middle;
 height: 16px;
 line-height: 16px;
 padding: 0 10px;
 border-radius: 10px;
 position: absolute;
 white-space: nowrap;
 color: var(--n-text-color-line-inner);
 transition:
 right .2s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `)]), cB("progress-graph-line-rail", `
 position: relative;
 overflow: hidden;
 height: var(--n-rail-height);
 border-radius: 5px;
 background-color: var(--n-rail-color);
 transition: background-color .3s var(--n-bezier);
 `, [cB("progress-graph-line-fill", `
 background: var(--n-fill-color);
 position: relative;
 border-radius: 5px;
 height: inherit;
 width: 100%;
 max-width: 0%;
 transition:
 background-color .3s var(--n-bezier),
 max-width .2s var(--n-bezier);
 `, [cM("processing", [c$1("&::after", `
 content: "";
 background-image: var(--n-line-bg-processing);
 animation: progress-processing-animation 2s var(--n-bezier) infinite;
 `)])])])])])]), c$1("@keyframes progress-processing-animation", `
 0% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 100%;
 opacity: 1;
 }
 66% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 0;
 opacity: 0;
 }
 100% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 0;
 opacity: 0;
 }
 `)]);
  const iconMap$1 = {
    success: vue.h(SuccessIcon, null),
    error: vue.h(ErrorIcon, null),
    warning: vue.h(WarningIcon, null),
    info: vue.h(InfoIcon, null)
  };
  const Line = vue.defineComponent({
    name: "ProgressLine",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      percentage: {
        type: Number,
        default: 0
      },
      railColor: String,
      railStyle: [String, Object],
      fillColor: String,
      status: {
        type: String,
        required: true
      },
      indicatorPlacement: {
        type: String,
        required: true
      },
      indicatorTextColor: String,
      unit: {
        type: String,
        default: "%"
      },
      processing: {
        type: Boolean,
        required: true
      },
      showIndicator: {
        type: Boolean,
        required: true
      },
      height: [String, Number],
      railBorderRadius: [String, Number],
      fillBorderRadius: [String, Number]
    },
    setup(props, {
      slots
    }) {
      const styleHeightRef = vue.computed(() => {
        return formatLength(props.height);
      });
      const styleRailBorderRadiusRef = vue.computed(() => {
        if (props.railBorderRadius !== void 0) {
          return formatLength(props.railBorderRadius);
        }
        if (props.height !== void 0) {
          return formatLength(props.height, {
            c: 0.5
          });
        }
        return "";
      });
      const styleFillBorderRadiusRef = vue.computed(() => {
        if (props.fillBorderRadius !== void 0) {
          return formatLength(props.fillBorderRadius);
        }
        if (props.railBorderRadius !== void 0) {
          return formatLength(props.railBorderRadius);
        }
        if (props.height !== void 0) {
          return formatLength(props.height, {
            c: 0.5
          });
        }
        return "";
      });
      return () => {
        const {
          indicatorPlacement,
          railColor,
          railStyle,
          percentage,
          unit,
          indicatorTextColor,
          status,
          showIndicator,
          fillColor,
          processing,
          clsPrefix
        } = props;
        return vue.h("div", {
          class: `${clsPrefix}-progress-content`,
          role: "none"
        }, vue.h("div", {
          class: `${clsPrefix}-progress-graph`,
          "aria-hidden": true
        }, vue.h("div", {
          class: [`${clsPrefix}-progress-graph-line`, {
            [`${clsPrefix}-progress-graph-line--indicator-${indicatorPlacement}`]: true
          }]
        }, vue.h("div", {
          class: `${clsPrefix}-progress-graph-line-rail`,
          style: [{
            backgroundColor: railColor,
            height: styleHeightRef.value,
            borderRadius: styleRailBorderRadiusRef.value
          }, railStyle]
        }, vue.h("div", {
          class: [`${clsPrefix}-progress-graph-line-fill`, processing && `${clsPrefix}-progress-graph-line-fill--processing`],
          style: {
            maxWidth: `${props.percentage}%`,
            backgroundColor: fillColor,
            height: styleHeightRef.value,
            lineHeight: styleHeightRef.value,
            borderRadius: styleFillBorderRadiusRef.value
          }
        }, indicatorPlacement === "inside" ? vue.h("div", {
          class: `${clsPrefix}-progress-graph-line-indicator`,
          style: {
            color: indicatorTextColor
          }
        }, slots.default ? slots.default() : `${percentage}${unit}`) : null)))), showIndicator && indicatorPlacement === "outside" ? vue.h("div", null, slots.default ? vue.h("div", {
          class: `${clsPrefix}-progress-custom-content`,
          style: {
            color: indicatorTextColor
          },
          role: "none"
        }, slots.default()) : status === "default" ? vue.h("div", {
          role: "none",
          class: `${clsPrefix}-progress-icon ${clsPrefix}-progress-icon--as-text`,
          style: {
            color: indicatorTextColor
          }
        }, percentage, unit) : vue.h("div", {
          class: `${clsPrefix}-progress-icon`,
          "aria-hidden": true
        }, vue.h(NBaseIcon, {
          clsPrefix
        }, {
          default: () => iconMap$1[status]
        }))) : null);
      };
    }
  });
  const iconMap = {
    success: vue.h(SuccessIcon, null),
    error: vue.h(ErrorIcon, null),
    warning: vue.h(WarningIcon, null),
    info: vue.h(InfoIcon, null)
  };
  const Circle = vue.defineComponent({
    name: "ProgressCircle",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      status: {
        type: String,
        required: true
      },
      strokeWidth: {
        type: Number,
        required: true
      },
      fillColor: String,
      railColor: String,
      railStyle: [String, Object],
      percentage: {
        type: Number,
        default: 0
      },
      offsetDegree: {
        type: Number,
        default: 0
      },
      showIndicator: {
        type: Boolean,
        required: true
      },
      indicatorTextColor: String,
      unit: String,
      viewBoxWidth: {
        type: Number,
        required: true
      },
      gapDegree: {
        type: Number,
        required: true
      },
      gapOffsetDegree: {
        type: Number,
        default: 0
      }
    },
    setup(props, {
      slots
    }) {
      function getPathStyles(percent2, offsetDegree, strokeColor) {
        const {
          gapDegree,
          viewBoxWidth,
          strokeWidth
        } = props;
        const radius = 50;
        const beginPositionX = 0;
        const beginPositionY = radius;
        const endPositionX = 0;
        const endPositionY = 2 * radius;
        const centerX = 50 + strokeWidth / 2;
        const pathString = `M ${centerX},${centerX} m ${beginPositionX},${beginPositionY}
      a ${radius},${radius} 0 1 1 ${endPositionX},${-endPositionY}
      a ${radius},${radius} 0 1 1 ${-endPositionX},${endPositionY}`;
        const len2 = Math.PI * 2 * radius;
        const pathStyle = {
          stroke: strokeColor,
          strokeDasharray: `${percent2 / 100 * (len2 - gapDegree)}px ${viewBoxWidth * 8}px`,
          strokeDashoffset: `-${gapDegree / 2}px`,
          transformOrigin: offsetDegree ? "center" : void 0,
          transform: offsetDegree ? `rotate(${offsetDegree}deg)` : void 0
        };
        return {
          pathString,
          pathStyle
        };
      }
      return () => {
        const {
          fillColor,
          railColor,
          strokeWidth,
          offsetDegree,
          status,
          percentage,
          showIndicator,
          indicatorTextColor,
          unit,
          gapOffsetDegree,
          clsPrefix
        } = props;
        const {
          pathString: railPathString,
          pathStyle: railPathStyle
        } = getPathStyles(100, 0, railColor);
        const {
          pathString: fillPathString,
          pathStyle: fillPathStyle
        } = getPathStyles(percentage, offsetDegree, fillColor);
        const viewBoxSize = 100 + strokeWidth;
        return vue.h("div", {
          class: `${clsPrefix}-progress-content`,
          role: "none"
        }, vue.h("div", {
          class: `${clsPrefix}-progress-graph`,
          "aria-hidden": true
        }, vue.h("div", {
          class: `${clsPrefix}-progress-graph-circle`,
          style: {
            transform: gapOffsetDegree ? `rotate(${gapOffsetDegree}deg)` : void 0
          }
        }, vue.h("svg", {
          viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`
        }, vue.h("g", null, vue.h("path", {
          class: `${clsPrefix}-progress-graph-circle-rail`,
          d: railPathString,
          "stroke-width": strokeWidth,
          "stroke-linecap": "round",
          fill: "none",
          style: railPathStyle
        })), vue.h("g", null, vue.h("path", {
          class: [`${clsPrefix}-progress-graph-circle-fill`, percentage === 0 && `${clsPrefix}-progress-graph-circle-fill--empty`],
          d: fillPathString,
          "stroke-width": strokeWidth,
          "stroke-linecap": "round",
          fill: "none",
          style: fillPathStyle
        }))))), showIndicator ? vue.h("div", null, slots.default ? vue.h("div", {
          class: `${clsPrefix}-progress-custom-content`,
          role: "none"
        }, slots.default()) : status !== "default" ? vue.h("div", {
          class: `${clsPrefix}-progress-icon`,
          "aria-hidden": true
        }, vue.h(NBaseIcon, {
          clsPrefix
        }, {
          default: () => iconMap[status]
        })) : vue.h("div", {
          class: `${clsPrefix}-progress-text`,
          style: {
            color: indicatorTextColor
          },
          role: "none"
        }, vue.h("span", {
          class: `${clsPrefix}-progress-text__percentage`
        }, percentage), vue.h("span", {
          class: `${clsPrefix}-progress-text__unit`
        }, unit))) : null);
      };
    }
  });
  function circlePath(r, sw, vw = 100) {
    return `m ${vw / 2} ${vw / 2 - r} a ${r} ${r} 0 1 1 0 ${2 * r} a ${r} ${r} 0 1 1 0 -${2 * r}`;
  }
  const MultipleCircle = vue.defineComponent({
    name: "ProgressMultipleCircle",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      viewBoxWidth: {
        type: Number,
        required: true
      },
      percentage: {
        type: Array,
        default: [0]
      },
      strokeWidth: {
        type: Number,
        required: true
      },
      circleGap: {
        type: Number,
        required: true
      },
      showIndicator: {
        type: Boolean,
        required: true
      },
      fillColor: {
        type: Array,
        default: () => []
      },
      railColor: {
        type: Array,
        default: () => []
      },
      railStyle: {
        type: Array,
        default: () => []
      }
    },
    setup(props, {
      slots
    }) {
      const strokeDasharrayRef = vue.computed(() => {
        const strokeDasharrays = props.percentage.map((v, i) => `${Math.PI * v / 100 * (props.viewBoxWidth / 2 - props.strokeWidth / 2 * (1 + 2 * i) - props.circleGap * i) * 2}, ${props.viewBoxWidth * 8}`);
        return strokeDasharrays;
      });
      return () => {
        const {
          viewBoxWidth,
          strokeWidth,
          circleGap,
          showIndicator,
          fillColor,
          railColor,
          railStyle,
          percentage,
          clsPrefix
        } = props;
        return vue.h("div", {
          class: `${clsPrefix}-progress-content`,
          role: "none"
        }, vue.h("div", {
          class: `${clsPrefix}-progress-graph`,
          "aria-hidden": true
        }, vue.h("div", {
          class: `${clsPrefix}-progress-graph-circle`
        }, vue.h("svg", {
          viewBox: `0 0 ${viewBoxWidth} ${viewBoxWidth}`
        }, percentage.map((p2, index) => {
          return vue.h("g", {
            key: index
          }, vue.h("path", {
            class: `${clsPrefix}-progress-graph-circle-rail`,
            d: circlePath(viewBoxWidth / 2 - strokeWidth / 2 * (1 + 2 * index) - circleGap * index, strokeWidth, viewBoxWidth),
            "stroke-width": strokeWidth,
            "stroke-linecap": "round",
            fill: "none",
            style: [{
              strokeDashoffset: 0,
              stroke: railColor[index]
            }, railStyle[index]]
          }), vue.h("path", {
            class: [`${clsPrefix}-progress-graph-circle-fill`, p2 === 0 && `${clsPrefix}-progress-graph-circle-fill--empty`],
            d: circlePath(viewBoxWidth / 2 - strokeWidth / 2 * (1 + 2 * index) - circleGap * index, strokeWidth, viewBoxWidth),
            "stroke-width": strokeWidth,
            "stroke-linecap": "round",
            fill: "none",
            style: {
              strokeDasharray: strokeDasharrayRef.value[index],
              strokeDashoffset: 0,
              stroke: fillColor[index]
            }
          }));
        })))), showIndicator && slots.default ? vue.h("div", null, vue.h("div", {
          class: `${clsPrefix}-progress-text`
        }, slots.default())) : null);
      };
    }
  });
  const progressProps = Object.assign(Object.assign({}, useTheme.props), {
    processing: Boolean,
    type: {
      type: String,
      default: "line"
    },
    gapDegree: Number,
    gapOffsetDegree: Number,
    status: {
      type: String,
      default: "default"
    },
    railColor: [String, Array],
    railStyle: [String, Array],
    color: [String, Array],
    viewBoxWidth: {
      type: Number,
      default: 100
    },
    strokeWidth: {
      type: Number,
      default: 7
    },
    percentage: [Number, Array],
    unit: {
      type: String,
      default: "%"
    },
    showIndicator: {
      type: Boolean,
      default: true
    },
    indicatorPosition: {
      type: String,
      default: "outside"
    },
    indicatorPlacement: {
      type: String,
      default: "outside"
    },
    indicatorTextColor: String,
    circleGap: {
      type: Number,
      default: 1
    },
    height: Number,
    borderRadius: [String, Number],
    fillBorderRadius: [String, Number],
    offsetDegree: Number
  });
  const NProgress = vue.defineComponent({
    name: "Progress",
    props: progressProps,
    setup(props) {
      const mergedIndicatorPlacementRef = vue.computed(() => {
        return props.indicatorPlacement || props.indicatorPosition;
      });
      const gapDeg = vue.computed(() => {
        if (props.gapDegree || props.gapDegree === 0) {
          return props.gapDegree;
        }
        if (props.type === "dashboard") {
          return 75;
        }
        return void 0;
      });
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Progress", "-progress", style$q, progressLight$1, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          status
        } = props;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            fontSize: fontSize2,
            fontSizeCircle,
            railColor,
            railHeight,
            iconSizeCircle,
            iconSizeLine,
            textColorCircle,
            textColorLineInner,
            textColorLineOuter,
            lineBgProcessing,
            fontWeightCircle,
            [createKey("iconColor", status)]: iconColor,
            [createKey("fillColor", status)]: fillColor
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-fill-color": fillColor,
          "--n-font-size": fontSize2,
          "--n-font-size-circle": fontSizeCircle,
          "--n-font-weight-circle": fontWeightCircle,
          "--n-icon-color": iconColor,
          "--n-icon-size-circle": iconSizeCircle,
          "--n-icon-size-line": iconSizeLine,
          "--n-line-bg-processing": lineBgProcessing,
          "--n-rail-color": railColor,
          "--n-rail-height": railHeight,
          "--n-text-color-circle": textColorCircle,
          "--n-text-color-line-inner": textColorLineInner,
          "--n-text-color-line-outer": textColorLineOuter
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("progress", vue.computed(() => props.status[0]), cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        mergedIndicatorPlacement: mergedIndicatorPlacementRef,
        gapDeg,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      const {
        type,
        cssVars,
        indicatorTextColor,
        showIndicator,
        status,
        railColor,
        railStyle,
        color,
        percentage,
        viewBoxWidth,
        strokeWidth,
        mergedIndicatorPlacement,
        unit,
        borderRadius,
        fillBorderRadius,
        height,
        processing,
        circleGap,
        mergedClsPrefix,
        gapDeg,
        gapOffsetDegree,
        themeClass,
        $slots,
        onRender
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h("div", {
        class: [themeClass, `${mergedClsPrefix}-progress`, `${mergedClsPrefix}-progress--${type}`, `${mergedClsPrefix}-progress--${status}`],
        style: cssVars,
        "aria-valuemax": 100,
        "aria-valuemin": 0,
        "aria-valuenow": percentage,
        role: type === "circle" || type === "line" || type === "dashboard" ? "progressbar" : "none"
      }, type === "circle" || type === "dashboard" ? vue.h(Circle, {
        clsPrefix: mergedClsPrefix,
        status,
        showIndicator,
        indicatorTextColor,
        railColor,
        fillColor: color,
        railStyle,
        offsetDegree: this.offsetDegree,
        percentage,
        viewBoxWidth,
        strokeWidth,
        gapDegree: gapDeg === void 0 ? type === "dashboard" ? 75 : 0 : gapDeg,
        gapOffsetDegree,
        unit
      }, $slots) : type === "line" ? vue.h(Line, {
        clsPrefix: mergedClsPrefix,
        status,
        showIndicator,
        indicatorTextColor,
        railColor,
        fillColor: color,
        railStyle,
        percentage,
        processing,
        indicatorPlacement: mergedIndicatorPlacement,
        unit,
        fillBorderRadius,
        railBorderRadius: borderRadius,
        height
      }, $slots) : type === "multiple-circle" ? vue.h(MultipleCircle, {
        clsPrefix: mergedClsPrefix,
        strokeWidth,
        railColor,
        fillColor: color,
        railStyle,
        viewBoxWidth,
        percentage,
        showIndicator,
        circleGap
      }, $slots) : null);
    }
  });
  function self$3(vars) {
    return {
      borderRadius: vars.borderRadius
    };
  }
  const themeLight$1 = {
    name: "QrCode",
    common: commonLight,
    self: self$3
  };
  const qrcodeLight = themeLight$1;
  const style$p = c$1([cB("qr-code", `
 background: #fff;
 border-radius: var(--n-border-radius);
 display: inline-flex;
 `)]);
  var qrcodegen;
  (function(qrcodegen2) {
    class QrCode2 {
      /* -- Static factory functions (high level) -- */
      // Returns a QR Code representing the given Unicode text string at the given error correction level.
      // As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer
      // Unicode code points (not UTF-16 code units) if the low error correction level is used. The smallest possible
      // QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the
      // ecl argument if it can be done without increasing the version.
      static encodeText(text2, ecl) {
        const segs = qrcodegen2.QrSegment.makeSegments(text2);
        return QrCode2.encodeSegments(segs, ecl);
      }
      // Returns a QR Code representing the given binary data at the given error correction level.
      // This function always encodes using the binary segment mode, not any text mode. The maximum number of
      // bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.
      // The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.
      static encodeBinary(data, ecl) {
        const seg = qrcodegen2.QrSegment.makeBytes(data);
        return QrCode2.encodeSegments([seg], ecl);
      }
      /* -- Static factory functions (mid level) -- */
      // Returns a QR Code representing the given segments with the given encoding parameters.
      // The smallest possible QR Code version within the given range is automatically
      // chosen for the output. Iff boostEcl is true, then the ECC level of the result
      // may be higher than the ecl argument if it can be done without increasing the
      // version. The mask number is either between 0 to 7 (inclusive) to force that
      // mask, or -1 to automatically choose an appropriate mask (which may be slow).
      // This function allows the user to create a custom sequence of segments that switches
      // between modes (such as alphanumeric and byte) to encode text in less space.
      // This is a mid-level API; the high-level API is encodeText() and encodeBinary().
      static encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {
        if (!(QrCode2.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= QrCode2.MAX_VERSION) || mask < -1 || mask > 7) {
          throw new RangeError("Invalid value");
        }
        let version2;
        let dataUsedBits;
        for (version2 = minVersion; ; version2++) {
          const dataCapacityBits2 = QrCode2.getNumDataCodewords(version2, ecl) * 8;
          const usedBits = QrSegment.getTotalBits(segs, version2);
          if (usedBits <= dataCapacityBits2) {
            dataUsedBits = usedBits;
            break;
          }
          if (version2 >= maxVersion) {
            throw new RangeError("Data too long");
          }
        }
        for (const newEcl of [QrCode2.Ecc.MEDIUM, QrCode2.Ecc.QUARTILE, QrCode2.Ecc.HIGH]) {
          if (boostEcl && dataUsedBits <= QrCode2.getNumDataCodewords(version2, newEcl) * 8) {
            ecl = newEcl;
          }
        }
        const bb = [];
        for (const seg of segs) {
          appendBits(seg.mode.modeBits, 4, bb);
          appendBits(seg.numChars, seg.mode.numCharCountBits(version2), bb);
          for (const b of seg.getData()) {
            bb.push(b);
          }
        }
        const dataCapacityBits = QrCode2.getNumDataCodewords(version2, ecl) * 8;
        appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
        appendBits(0, (8 - bb.length % 8) % 8, bb);
        for (let padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17) {
          appendBits(padByte, 8, bb);
        }
        const dataCodewords = [];
        while (dataCodewords.length * 8 < bb.length) {
          dataCodewords.push(0);
        }
        bb.forEach((b, i) => dataCodewords[i >>> 3] |= b << 7 - (i & 7));
        return new QrCode2(version2, ecl, dataCodewords, mask);
      }
      /* -- Constructor (low level) and fields -- */
      // Creates a new QR Code with the given version number,
      // error correction level, data codeword bytes, and mask number.
      // This is a low-level API that most users should not use directly.
      // A mid-level API is the encodeSegments() function.
      constructor(version2, errorCorrectionLevel, dataCodewords, msk) {
        this.version = version2;
        this.errorCorrectionLevel = errorCorrectionLevel;
        this.modules = [];
        this.isFunction = [];
        if (version2 < QrCode2.MIN_VERSION || version2 > QrCode2.MAX_VERSION) {
          throw new RangeError("Version value out of range");
        }
        if (msk < -1 || msk > 7) {
          throw new RangeError("Mask value out of range");
        }
        this.size = version2 * 4 + 17;
        const row = [];
        for (let i = 0; i < this.size; i++) {
          row.push(false);
        }
        for (let i = 0; i < this.size; i++) {
          this.modules.push(row.slice());
          this.isFunction.push(row.slice());
        }
        this.drawFunctionPatterns();
        const allCodewords = this.addEccAndInterleave(dataCodewords);
        this.drawCodewords(allCodewords);
        if (msk === -1) {
          let minPenalty = 1e9;
          for (let i = 0; i < 8; i++) {
            this.applyMask(i);
            this.drawFormatBits(i);
            const penalty = this.getPenaltyScore();
            if (penalty < minPenalty) {
              msk = i;
              minPenalty = penalty;
            }
            this.applyMask(i);
          }
        }
        this.mask = msk;
        this.applyMask(msk);
        this.drawFormatBits(msk);
        this.isFunction = [];
      }
      /* -- Accessor methods -- */
      // Returns the color of the module (pixel) at the given coordinates, which is false
      // for light or true for dark. The top left corner has the coordinates (x=0, y=0).
      // If the given coordinates are out of bounds, then false (light) is returned.
      getModule(x, y) {
        return x >= 0 && x < this.size && y >= 0 && y < this.size && this.modules[y][x];
      }
      // Modified to expose modules for easy access
      getModules() {
        return this.modules;
      }
      /* -- Private helper methods for constructor: Drawing function modules -- */
      // Reads this object's version field, and draws and marks all function modules.
      drawFunctionPatterns() {
        for (let i = 0; i < this.size; i++) {
          this.setFunctionModule(6, i, i % 2 === 0);
          this.setFunctionModule(i, 6, i % 2 === 0);
        }
        this.drawFinderPattern(3, 3);
        this.drawFinderPattern(this.size - 4, 3);
        this.drawFinderPattern(3, this.size - 4);
        const alignPatPos = this.getAlignmentPatternPositions();
        const numAlign = alignPatPos.length;
        for (let i = 0; i < numAlign; i++) {
          for (let j = 0; j < numAlign; j++) {
            if (!(i === 0 && j === 0 || i === 0 && j === numAlign - 1 || i === numAlign - 1 && j === 0)) {
              this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);
            }
          }
        }
        this.drawFormatBits(0);
        this.drawVersion();
      }
      // Draws two copies of the format bits (with its own error correction code)
      // based on the given mask and this object's error correction level field.
      drawFormatBits(mask) {
        const data = this.errorCorrectionLevel.formatBits << 3 | mask;
        let rem = data;
        for (let i = 0; i < 10; i++) {
          rem = rem << 1 ^ (rem >>> 9) * 1335;
        }
        const bits = (data << 10 | rem) ^ 21522;
        for (let i = 0; i <= 5; i++) {
          this.setFunctionModule(8, i, getBit(bits, i));
        }
        this.setFunctionModule(8, 7, getBit(bits, 6));
        this.setFunctionModule(8, 8, getBit(bits, 7));
        this.setFunctionModule(7, 8, getBit(bits, 8));
        for (let i = 9; i < 15; i++) {
          this.setFunctionModule(14 - i, 8, getBit(bits, i));
        }
        for (let i = 0; i < 8; i++) {
          this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));
        }
        for (let i = 8; i < 15; i++) {
          this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));
        }
        this.setFunctionModule(8, this.size - 8, true);
      }
      // Draws two copies of the version bits (with its own error correction code),
      // based on this object's version field, iff 7 <= version <= 40.
      drawVersion() {
        if (this.version < 7) {
          return;
        }
        let rem = this.version;
        for (let i = 0; i < 12; i++) {
          rem = rem << 1 ^ (rem >>> 11) * 7973;
        }
        const bits = this.version << 12 | rem;
        for (let i = 0; i < 18; i++) {
          const color = getBit(bits, i);
          const a2 = this.size - 11 + i % 3;
          const b = Math.floor(i / 3);
          this.setFunctionModule(a2, b, color);
          this.setFunctionModule(b, a2, color);
        }
      }
      // Draws a 9*9 finder pattern including the border separator,
      // with the center module at (x, y). Modules can be out of bounds.
      drawFinderPattern(x, y) {
        for (let dy = -4; dy <= 4; dy++) {
          for (let dx = -4; dx <= 4; dx++) {
            const dist = Math.max(Math.abs(dx), Math.abs(dy));
            const xx = x + dx;
            const yy = y + dy;
            if (xx >= 0 && xx < this.size && yy >= 0 && yy < this.size) {
              this.setFunctionModule(xx, yy, dist !== 2 && dist !== 4);
            }
          }
        }
      }
      // Draws a 5*5 alignment pattern, with the center module
      // at (x, y). All modules must be in bounds.
      drawAlignmentPattern(x, y) {
        for (let dy = -2; dy <= 2; dy++) {
          for (let dx = -2; dx <= 2; dx++) {
            this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) !== 1);
          }
        }
      }
      // Sets the color of a module and marks it as a function module.
      // Only used by the constructor. Coordinates must be in bounds.
      setFunctionModule(x, y, isDark) {
        this.modules[y][x] = isDark;
        this.isFunction[y][x] = true;
      }
      /* -- Private helper methods for constructor: Codewords and masking -- */
      // Returns a new byte string representing the given data with the appropriate error correction
      // codewords appended to it, based on this object's version and error correction level.
      addEccAndInterleave(data) {
        const ver = this.version;
        const ecl = this.errorCorrectionLevel;
        if (data.length !== QrCode2.getNumDataCodewords(ver, ecl)) {
          throw new RangeError("Invalid argument");
        }
        const numBlocks = QrCode2.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
        const blockEccLen = QrCode2.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];
        const rawCodewords = Math.floor(QrCode2.getNumRawDataModules(ver) / 8);
        const numShortBlocks = numBlocks - rawCodewords % numBlocks;
        const shortBlockLen = Math.floor(rawCodewords / numBlocks);
        const blocks = [];
        const rsDiv = QrCode2.reedSolomonComputeDivisor(blockEccLen);
        for (let i = 0, k = 0; i < numBlocks; i++) {
          const dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
          k += dat.length;
          const ecc = QrCode2.reedSolomonComputeRemainder(dat, rsDiv);
          if (i < numShortBlocks) {
            dat.push(0);
          }
          blocks.push(dat.concat(ecc));
        }
        const result = [];
        for (let i = 0; i < blocks[0].length; i++) {
          blocks.forEach((block, j) => {
            if (i !== shortBlockLen - blockEccLen || j >= numShortBlocks) {
              result.push(block[i]);
            }
          });
        }
        return result;
      }
      // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
      // data area of this QR Code. Function modules need to be marked off before this is called.
      drawCodewords(data) {
        if (data.length !== Math.floor(QrCode2.getNumRawDataModules(this.version) / 8)) {
          throw new RangeError("Invalid argument");
        }
        let i = 0;
        for (let right = this.size - 1; right >= 1; right -= 2) {
          if (right === 6) {
            right = 5;
          }
          for (let vert = 0; vert < this.size; vert++) {
            for (let j = 0; j < 2; j++) {
              const x = right - j;
              const upward = (right + 1 & 2) === 0;
              const y = upward ? this.size - 1 - vert : vert;
              if (!this.isFunction[y][x] && i < data.length * 8) {
                this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));
                i++;
              }
            }
          }
        }
      }
      // XORs the codeword modules in this QR Code with the given mask pattern.
      // The function modules must be marked and the codeword bits must be drawn
      // before masking. Due to the arithmetic of XOR, calling applyMask() with
      // the same mask value a second time will undo the mask. A final well-formed
      // QR Code needs exactly one (not zero, two, etc.) mask applied.
      applyMask(mask) {
        if (mask < 0 || mask > 7) {
          throw new RangeError("Mask value out of range");
        }
        for (let y = 0; y < this.size; y++) {
          for (let x = 0; x < this.size; x++) {
            let invert;
            switch (mask) {
              case 0:
                invert = (x + y) % 2 === 0;
                break;
              case 1:
                invert = y % 2 === 0;
                break;
              case 2:
                invert = x % 3 === 0;
                break;
              case 3:
                invert = (x + y) % 3 === 0;
                break;
              case 4:
                invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 === 0;
                break;
              case 5:
                invert = x * y % 2 + x * y % 3 === 0;
                break;
              case 6:
                invert = (x * y % 2 + x * y % 3) % 2 === 0;
                break;
              case 7:
                invert = ((x + y) % 2 + x * y % 3) % 2 === 0;
                break;
              default:
                throw new Error("Unreachable");
            }
            if (!this.isFunction[y][x] && invert) {
              this.modules[y][x] = !this.modules[y][x];
            }
          }
        }
      }
      // Calculates and returns the penalty score based on state of this QR Code's current modules.
      // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
      getPenaltyScore() {
        let result = 0;
        for (let y = 0; y < this.size; y++) {
          let runColor = false;
          let runX = 0;
          const runHistory = [0, 0, 0, 0, 0, 0, 0];
          for (let x = 0; x < this.size; x++) {
            if (this.modules[y][x] === runColor) {
              runX++;
              if (runX === 5) {
                result += QrCode2.PENALTY_N1;
              } else if (runX > 5) {
                result++;
              }
            } else {
              this.finderPenaltyAddHistory(runX, runHistory);
              if (!runColor) {
                result += this.finderPenaltyCountPatterns(runHistory) * QrCode2.PENALTY_N3;
              }
              runColor = this.modules[y][x];
              runX = 1;
            }
          }
          result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * QrCode2.PENALTY_N3;
        }
        for (let x = 0; x < this.size; x++) {
          let runColor = false;
          let runY = 0;
          const runHistory = [0, 0, 0, 0, 0, 0, 0];
          for (let y = 0; y < this.size; y++) {
            if (this.modules[y][x] === runColor) {
              runY++;
              if (runY === 5) {
                result += QrCode2.PENALTY_N1;
              } else if (runY > 5) {
                result++;
              }
            } else {
              this.finderPenaltyAddHistory(runY, runHistory);
              if (!runColor) {
                result += this.finderPenaltyCountPatterns(runHistory) * QrCode2.PENALTY_N3;
              }
              runColor = this.modules[y][x];
              runY = 1;
            }
          }
          result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * QrCode2.PENALTY_N3;
        }
        for (let y = 0; y < this.size - 1; y++) {
          for (let x = 0; x < this.size - 1; x++) {
            const color = this.modules[y][x];
            if (color === this.modules[y][x + 1] && color === this.modules[y + 1][x] && color === this.modules[y + 1][x + 1]) {
              result += QrCode2.PENALTY_N2;
            }
          }
        }
        let dark = 0;
        for (const row of this.modules) {
          dark = row.reduce((sum, color) => sum + (color ? 1 : 0), dark);
        }
        const total = this.size * this.size;
        const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
        result += k * QrCode2.PENALTY_N4;
        return result;
      }
      /* -- Private helper functions -- */
      // Returns an ascending list of positions of alignment patterns for this version number.
      // Each position is in the range [0,177), and are used on both the x and y axes.
      // This could be implemented as lookup table of 40 variable-length lists of integers.
      getAlignmentPatternPositions() {
        if (this.version === 1) {
          return [];
        } else {
          const numAlign = Math.floor(this.version / 7) + 2;
          const step = this.version === 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
          const result = [6];
          for (let pos = this.size - 7; result.length < numAlign; pos -= step) {
            result.splice(1, 0, pos);
          }
          return result;
        }
      }
      // Returns the number of data bits that can be stored in a QR Code of the given version number, after
      // all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.
      // The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.
      static getNumRawDataModules(ver) {
        if (ver < QrCode2.MIN_VERSION || ver > QrCode2.MAX_VERSION) {
          throw new RangeError("Version number out of range");
        }
        let result = (16 * ver + 128) * ver + 64;
        if (ver >= 2) {
          const numAlign = Math.floor(ver / 7) + 2;
          result -= (25 * numAlign - 10) * numAlign - 55;
          if (ver >= 7) {
            result -= 36;
          }
        }
        return result;
      }
      // Returns the number of 8-bit data (i.e. not error correction) codewords contained in any
      // QR Code of the given version number and error correction level, with remainder bits discarded.
      // This stateless pure function could be implemented as a (40*4)-cell lookup table.
      static getNumDataCodewords(ver, ecl) {
        return Math.floor(QrCode2.getNumRawDataModules(ver) / 8) - QrCode2.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * QrCode2.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
      }
      // Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be
      // implemented as a lookup table over all possible parameter values, instead of as an algorithm.
      static reedSolomonComputeDivisor(degree) {
        if (degree < 1 || degree > 255) {
          throw new RangeError("Degree out of range");
        }
        const result = [];
        for (let i = 0; i < degree - 1; i++) {
          result.push(0);
        }
        result.push(1);
        let root2 = 1;
        for (let i = 0; i < degree; i++) {
          for (let j = 0; j < result.length; j++) {
            result[j] = QrCode2.reedSolomonMultiply(result[j], root2);
            if (j + 1 < result.length) {
              result[j] ^= result[j + 1];
            }
          }
          root2 = QrCode2.reedSolomonMultiply(root2, 2);
        }
        return result;
      }
      // Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.
      static reedSolomonComputeRemainder(data, divisor) {
        const result = divisor.map((_) => 0);
        for (const b of data) {
          const factor = b ^ result.shift();
          result.push(0);
          divisor.forEach((coef, i) => result[i] ^= QrCode2.reedSolomonMultiply(coef, factor));
        }
        return result;
      }
      // Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result
      // are unsigned 8-bit integers. This could be implemented as a lookup table of 256*256 entries of uint8.
      static reedSolomonMultiply(x, y) {
        if (x >>> 8 !== 0 || y >>> 8 !== 0) {
          throw new RangeError("Byte out of range");
        }
        let z = 0;
        for (let i = 7; i >= 0; i--) {
          z = z << 1 ^ (z >>> 7) * 285;
          z ^= (y >>> i & 1) * x;
        }
        return z;
      }
      // Can only be called immediately after a light run is added, and
      // returns either 0, 1, or 2. A helper function for getPenaltyScore().
      finderPenaltyCountPatterns(runHistory) {
        const n = runHistory[1];
        const core = n > 0 && runHistory[2] === n && runHistory[3] === n * 3 && runHistory[4] === n && runHistory[5] === n;
        return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);
      }
      // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().
      finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {
        if (currentRunColor) {
          this.finderPenaltyAddHistory(currentRunLength, runHistory);
          currentRunLength = 0;
        }
        currentRunLength += this.size;
        this.finderPenaltyAddHistory(currentRunLength, runHistory);
        return this.finderPenaltyCountPatterns(runHistory);
      }
      // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().
      finderPenaltyAddHistory(currentRunLength, runHistory) {
        if (runHistory[0] === 0) {
          currentRunLength += this.size;
        }
        runHistory.pop();
        runHistory.unshift(currentRunLength);
      }
    }
    QrCode2.MIN_VERSION = 1;
    QrCode2.MAX_VERSION = 40;
    QrCode2.PENALTY_N1 = 3;
    QrCode2.PENALTY_N2 = 3;
    QrCode2.PENALTY_N3 = 40;
    QrCode2.PENALTY_N4 = 10;
    QrCode2.ECC_CODEWORDS_PER_BLOCK = [
      // Version: (note that index 0 is for padding, and is set to an illegal value)
      // 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
      [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
      // Low
      [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
      // Medium
      [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
      // Quartile
      [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
      // High
    ];
    QrCode2.NUM_ERROR_CORRECTION_BLOCKS = [
      // Version: (note that index 0 is for padding, and is set to an illegal value)
      // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
      [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
      // Low
      [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
      // Medium
      [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
      // Quartile
      [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
      // High
    ];
    qrcodegen2.QrCode = QrCode2;
    function appendBits(val, len2, bb) {
      if (len2 < 0 || len2 > 31 || val >>> len2 !== 0) {
        throw new RangeError("Value out of range");
      }
      for (let i = len2 - 1; i >= 0; i--) {
        bb.push(val >>> i & 1);
      }
    }
    function getBit(x, i) {
      return (x >>> i & 1) !== 0;
    }
    class QrSegment {
      /* -- Static factory functions (mid level) -- */
      // Returns a segment representing the given binary data encoded in
      // byte mode. All input byte arrays are acceptable. Any text string
      // can be converted to UTF-8 bytes and encoded as a byte mode segment.
      static makeBytes(data) {
        const bb = [];
        for (const b of data) {
          appendBits(b, 8, bb);
        }
        return new QrSegment(QrSegment.Mode.BYTE, data.length, bb);
      }
      // Returns a segment representing the given string of decimal digits encoded in numeric mode.
      static makeNumeric(digits) {
        if (!QrSegment.isNumeric(digits)) {
          throw new RangeError("String contains non-numeric characters");
        }
        const bb = [];
        for (let i = 0; i < digits.length; ) {
          const n = Math.min(digits.length - i, 3);
          appendBits(Number.parseInt(digits.substr(i, n), 10), n * 3 + 1, bb);
          i += n;
        }
        return new QrSegment(QrSegment.Mode.NUMERIC, digits.length, bb);
      }
      // Returns a segment representing the given text string encoded in alphanumeric mode.
      // The characters allowed are: 0 to 9, A to Z (uppercase only), space,
      // dollar, percent, asterisk, plus, hyphen, period, slash, colon.
      static makeAlphanumeric(text2) {
        if (!QrSegment.isAlphanumeric(text2)) {
          throw new RangeError("String contains unencodable characters in alphanumeric mode");
        }
        const bb = [];
        let i;
        for (i = 0; i + 2 <= text2.length; i += 2) {
          let temp = QrSegment.ALPHANUMERIC_CHARSET.indexOf(text2.charAt(i)) * 45;
          temp += QrSegment.ALPHANUMERIC_CHARSET.indexOf(text2.charAt(i + 1));
          appendBits(temp, 11, bb);
        }
        if (i < text2.length) {
          appendBits(QrSegment.ALPHANUMERIC_CHARSET.indexOf(text2.charAt(i)), 6, bb);
        }
        return new QrSegment(QrSegment.Mode.ALPHANUMERIC, text2.length, bb);
      }
      // Returns a new mutable list of zero or more segments to represent the given Unicode text string.
      // The result may use various segment modes and switch modes to optimize the length of the bit stream.
      static makeSegments(text2) {
        if (text2 === "") {
          return [];
        } else if (QrSegment.isNumeric(text2)) {
          return [QrSegment.makeNumeric(text2)];
        } else if (QrSegment.isAlphanumeric(text2)) {
          return [QrSegment.makeAlphanumeric(text2)];
        } else {
          return [QrSegment.makeBytes(QrSegment.toUtf8ByteArray(text2))];
        }
      }
      // Returns a segment representing an Extended Channel Interpretation
      // (ECI) designator with the given assignment value.
      static makeEci(assignVal) {
        const bb = [];
        if (assignVal < 0) {
          throw new RangeError("ECI assignment value out of range");
        } else if (assignVal < 1 << 7) {
          appendBits(assignVal, 8, bb);
        } else if (assignVal < 1 << 14) {
          appendBits(2, 2, bb);
          appendBits(assignVal, 14, bb);
        } else if (assignVal < 1e6) {
          appendBits(6, 3, bb);
          appendBits(assignVal, 21, bb);
        } else {
          throw new RangeError("ECI assignment value out of range");
        }
        return new QrSegment(QrSegment.Mode.ECI, 0, bb);
      }
      // Tests whether the given string can be encoded as a segment in numeric mode.
      // A string is encodable iff each character is in the range 0 to 9.
      static isNumeric(text2) {
        return QrSegment.NUMERIC_REGEX.test(text2);
      }
      // Tests whether the given string can be encoded as a segment in alphanumeric mode.
      // A string is encodable iff each character is in the following set: 0 to 9, A to Z
      // (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.
      static isAlphanumeric(text2) {
        return QrSegment.ALPHANUMERIC_REGEX.test(text2);
      }
      /* -- Constructor (low level) and fields -- */
      // Creates a new QR Code segment with the given attributes and data.
      // The character count (numChars) must agree with the mode and the bit buffer length,
      // but the constraint isn't checked. The given bit buffer is cloned and stored.
      constructor(mode, numChars, bitData) {
        this.mode = mode;
        this.numChars = numChars;
        this.bitData = bitData;
        if (numChars < 0) {
          throw new RangeError("Invalid argument");
        }
        this.bitData = bitData.slice();
      }
      /* -- Methods -- */
      // Returns a new copy of the data bits of this segment.
      getData() {
        return this.bitData.slice();
      }
      // (Package-private) Calculates and returns the number of bits needed to encode the given segments at
      // the given version. The result is infinity if a segment has too many characters to fit its length field.
      static getTotalBits(segs, version2) {
        let result = 0;
        for (const seg of segs) {
          const ccbits = seg.mode.numCharCountBits(version2);
          if (seg.numChars >= 1 << ccbits) {
            return Infinity;
          }
          result += 4 + ccbits + seg.bitData.length;
        }
        return result;
      }
      // Returns a new array of bytes representing the given string encoded in UTF-8.
      static toUtf8ByteArray(str) {
        str = encodeURI(str);
        const result = [];
        for (let i = 0; i < str.length; i++) {
          if (str.charAt(i) !== "%") {
            result.push(str.charCodeAt(i));
          } else {
            result.push(Number.parseInt(str.substr(i + 1, 2), 16));
            i += 2;
          }
        }
        return result;
      }
    }
    QrSegment.NUMERIC_REGEX = /^[0-9]*$/;
    QrSegment.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+./:-]*$/;
    QrSegment.ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
    qrcodegen2.QrSegment = QrSegment;
  })(qrcodegen || (qrcodegen = {}));
  (function(qrcodegen2) {
    (function(QrCode2) {
      class Ecc {
        /* -- Constructor and fields -- */
        constructor(ordinal, formatBits) {
          this.ordinal = ordinal;
          this.formatBits = formatBits;
        }
      }
      Ecc.LOW = new Ecc(0, 1);
      Ecc.MEDIUM = new Ecc(1, 0);
      Ecc.QUARTILE = new Ecc(2, 3);
      Ecc.HIGH = new Ecc(3, 2);
      QrCode2.Ecc = Ecc;
    })(qrcodegen2.QrCode || (qrcodegen2.QrCode = {}));
  })(qrcodegen || (qrcodegen = {}));
  (function(qrcodegen2) {
    (function(QrSegment) {
      class Mode {
        /* -- Constructor and fields -- */
        constructor(modeBits, numBitsCharCount) {
          this.modeBits = modeBits;
          this.numBitsCharCount = numBitsCharCount;
        }
        /* -- Method -- */
        // (Package-private) Returns the bit width of the character count field for a segment in
        // this mode in a QR Code at the given version number. The result is in the range [0, 16].
        numCharCountBits(ver) {
          return this.numBitsCharCount[Math.floor((ver + 7) / 17)];
        }
      }
      Mode.NUMERIC = new Mode(1, [10, 12, 14]);
      Mode.ALPHANUMERIC = new Mode(2, [9, 11, 13]);
      Mode.BYTE = new Mode(4, [8, 16, 16]);
      Mode.KANJI = new Mode(8, [8, 10, 12]);
      Mode.ECI = new Mode(7, [0, 0, 0]);
      QrSegment.Mode = Mode;
    })(qrcodegen2.QrSegment || (qrcodegen2.QrSegment = {}));
  })(qrcodegen || (qrcodegen = {}));
  const qrcodegen$1 = qrcodegen;
  const ERROR_CORRECTION_LEVEL = {
    L: qrcodegen$1.QrCode.Ecc.LOW,
    M: qrcodegen$1.QrCode.Ecc.MEDIUM,
    Q: qrcodegen$1.QrCode.Ecc.QUARTILE,
    H: qrcodegen$1.QrCode.Ecc.HIGH
  };
  const qrCodeProps = Object.assign(Object.assign({}, useTheme.props), {
    value: String,
    color: {
      type: String,
      default: "#000"
    },
    backgroundColor: {
      type: String,
      default: "#FFF"
    },
    iconSrc: String,
    iconSize: {
      type: Number,
      default: 40
    },
    iconBackgroundColor: {
      type: String,
      default: "#FFF"
    },
    iconBorderRadius: {
      type: Number,
      default: 4
    },
    size: {
      type: Number,
      default: 100
    },
    padding: {
      type: [Number, String],
      default: 12
    },
    errorCorrectionLevel: {
      type: String,
      default: "M"
    },
    type: {
      type: String,
      default: "canvas"
    }
  });
  const UPSCALE_RATIO = 2;
  const QrCode = vue.defineComponent({
    name: "QrCode",
    props: qrCodeProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("QrCode", "-qr-code", style$p, qrcodeLight, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        return {
          "--n-border-radius": themeRef.value.self.borderRadius
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("qr-code", void 0, cssVarsRef, props) : void 0;
      const canvasRef = vue.ref();
      const qr = vue.computed(() => {
        var _a;
        const errorCorrectionLevel = ERROR_CORRECTION_LEVEL[props.errorCorrectionLevel];
        return qrcodegen$1.QrCode.encodeText((_a = props.value) !== null && _a !== void 0 ? _a : "-", errorCorrectionLevel);
      });
      vue.onMounted(() => {
        const imageLoadedTrigger = vue.ref(0);
        let loadedIcon = null;
        vue.watchEffect(() => {
          if (props.type === "svg")
            return;
          void imageLoadedTrigger.value;
          drawCanvas(qr.value, props.size, props.color, props.backgroundColor, loadedIcon ? {
            icon: loadedIcon,
            iconBorderRadius: props.iconBorderRadius,
            iconSize: props.iconSize,
            iconBackgroundColor: props.iconBackgroundColor
          } : null);
        });
        vue.watchEffect(() => {
          if (props.type === "svg")
            return;
          const {
            iconSrc
          } = props;
          if (iconSrc) {
            let aborted = false;
            const img = new Image();
            img.src = iconSrc;
            img.onload = () => {
              if (aborted)
                return;
              loadedIcon = img;
              imageLoadedTrigger.value++;
            };
            return () => {
              aborted = true;
            };
          }
        });
      });
      function drawCanvas(qr2, size2, foregroundColor, backgroundColor, iconConfig) {
        const canvas = canvasRef.value;
        if (!canvas)
          return;
        const canvasWidth = size2 * UPSCALE_RATIO;
        const width = qr2.size;
        const scale = canvasWidth / width;
        canvas.width = canvasWidth;
        canvas.height = canvasWidth;
        const ctx2 = canvas.getContext("2d");
        if (!ctx2)
          return;
        ctx2.clearRect(0, 0, canvas.width, canvas.height);
        for (let y = 0; y < qr2.size; y++) {
          for (let x = 0; x < qr2.size; x++) {
            ctx2.fillStyle = qr2.getModule(x, y) ? foregroundColor : backgroundColor;
            const startX = Math.floor(x * scale);
            const endX = Math.ceil((x + 1) * scale);
            const startY = Math.floor(y * scale);
            const endY = Math.ceil((y + 1) * scale);
            ctx2.fillRect(startX, startY, endX - startX, endY - startY);
          }
        }
        if (iconConfig) {
          const {
            icon,
            iconBackgroundColor,
            iconBorderRadius,
            iconSize
          } = iconConfig;
          const finalIconSize = iconSize * UPSCALE_RATIO;
          const centerX = (canvas.width - finalIconSize) / 2;
          const centerY = (canvas.height - finalIconSize) / 2;
          ctx2.fillStyle = iconBackgroundColor;
          ctx2.beginPath();
          ctx2.roundRect(centerX, centerY, finalIconSize, finalIconSize, iconBorderRadius * UPSCALE_RATIO);
          ctx2.fill();
          const aspectRatio = icon.width / icon.height;
          const scaledWidth = aspectRatio >= 1 ? finalIconSize : finalIconSize * aspectRatio;
          const scaledHeight = aspectRatio <= 1 ? finalIconSize : finalIconSize / aspectRatio;
          const left = centerX + (finalIconSize - scaledWidth) / 2;
          const top = centerY + (finalIconSize - scaledHeight) / 2;
          ctx2.drawImage(icon, left, top, scaledWidth, scaledHeight);
        }
      }
      function generatePath(modules, margin = 0) {
        const ops = [];
        modules.forEach((row, y) => {
          let start = null;
          row.forEach((cell, x) => {
            if (!cell && start !== null) {
              ops.push(`M${start + margin} ${y + margin}h${x - start}v1H${start + margin}z`);
              start = null;
              return;
            }
            if (x === row.length - 1) {
              if (!cell) {
                return;
              }
              if (start === null) {
                ops.push(`M${x + margin},${y + margin} h1v1H${x + margin}z`);
              } else {
                ops.push(`M${start + margin},${y + margin} h${x + 1 - start}v1H${start + margin}z`);
              }
              return;
            }
            if (cell && start === null) {
              start = x;
            }
          });
        });
        return ops.join("");
      }
      function svgInfo(qr2, size2, iconConfig) {
        const cells = qr2.getModules();
        const numCells = cells.length;
        const cellsToDraw = cells;
        let svgInnerHtml = "";
        const path1Html = `<path fill="transparent" d="M0,0 h${numCells}v${numCells}H0z" shape-rendering="crispEdges"></path>`;
        const path2Html = `<path fill="${props.color}" d="${generatePath(cellsToDraw, 0)}" shape-rendering="crispEdges"></path>`;
        let iconHtml = "";
        if (iconConfig) {
          const {
            iconSrc,
            iconSize
          } = iconConfig;
          const DEFAULT_IMG_SCALE = 0.1;
          const defaultSize = Math.floor(size2 * DEFAULT_IMG_SCALE);
          const scale = numCells / size2;
          const h = (iconSize || defaultSize) * scale;
          const w = (iconSize || defaultSize) * scale;
          const x = cells.length / 2 - w / 2;
          const y = cells.length / 2 - h / 2;
          iconHtml += `<image href="${iconSrc}" width="${w}" height="${h}" x="${x}" y="${y}" preserveAspectRatio="none"></image>`;
        }
        svgInnerHtml += path1Html;
        svgInnerHtml += path2Html;
        svgInnerHtml += iconHtml;
        return {
          innerHtml: svgInnerHtml,
          numCells
        };
      }
      const svgInfoRef = vue.computed(() => svgInfo(qr.value, props.size, props.iconSrc ? {
        iconSrc: props.iconSrc,
        iconBorderRadius: props.iconBorderRadius,
        iconSize: props.iconSize,
        iconBackgroundColor: props.iconBackgroundColor
      } : null));
      return {
        canvasRef,
        mergedClsPrefix: mergedClsPrefixRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        svgInfo: svgInfoRef
      };
    },
    render() {
      const {
        mergedClsPrefix,
        backgroundColor,
        padding,
        cssVars,
        themeClass,
        size: size2,
        type
      } = this;
      return vue.h("div", {
        class: [`${mergedClsPrefix}-qr-code`, themeClass],
        style: Object.assign({
          padding: typeof padding === "number" ? `${padding}px` : padding,
          backgroundColor,
          width: `${size2}px`,
          height: `${size2}px`
        }, cssVars)
      }, type === "canvas" ? vue.h("canvas", {
        ref: "canvasRef",
        style: {
          width: `${size2}px`,
          height: `${size2}px`
        }
      }) : vue.h("svg", {
        height: size2,
        width: size2,
        viewBox: `0 0 ${this.svgInfo.numCells} ${this.svgInfo.numCells}`,
        role: "img",
        innerHTML: this.svgInfo.innerHtml
      }));
    }
  });
  const StarIcon = vue.h("svg", {
    viewBox: "0 0 512 512"
  }, vue.h("path", {
    d: "M394 480a16 16 0 01-9.39-3L256 383.76 127.39 477a16 16 0 01-24.55-18.08L153 310.35 23 221.2a16 16 0 019-29.2h160.38l48.4-148.95a16 16 0 0130.44 0l48.4 149H480a16 16 0 019.05 29.2L359 310.35l50.13 148.53A16 16 0 01394 480z"
  }));
  const style$o = cB("rate", {
    display: "inline-flex",
    flexWrap: "nowrap"
  }, [c$1("&:hover", [cE("item", `
 transition:
 transform .1s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), cE("item", `
 position: relative;
 display: flex;
 transition:
 transform .1s var(--n-bezier),
 color .3s var(--n-bezier);
 transform: scale(1);
 font-size: var(--n-item-size);
 color: var(--n-item-color);
 `, [c$1("&:not(:first-child)", `
 margin-left: 6px;
 `), cM("active", `
 color: var(--n-item-color-active);
 `)]), cNotM("readonly", `
 cursor: pointer;
 `, [cE("item", [c$1("&:hover", `
 transform: scale(1.05);
 `), c$1("&:active", `
 transform: scale(0.96);
 `)])]), cE("half", `
 display: flex;
 transition: inherit;
 position: absolute;
 top: 0;
 left: 0;
 bottom: 0;
 width: 50%;
 overflow: hidden;
 color: rgba(255, 255, 255, 0);
 `, [cM("active", `
 color: var(--n-item-color-active);
 `)])]);
  const rateProps = Object.assign(Object.assign({}, useTheme.props), {
    allowHalf: Boolean,
    count: {
      type: Number,
      default: 5
    },
    value: Number,
    defaultValue: {
      type: Number,
      default: null
    },
    readonly: Boolean,
    size: {
      type: [String, Number],
      default: "medium"
    },
    clearable: Boolean,
    color: String,
    onClear: Function,
    "onUpdate:value": [Function, Array],
    onUpdateValue: [Function, Array]
  });
  const Rate = vue.defineComponent({
    name: "Rate",
    props: rateProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Rate", "-rate", style$o, rateLight, props, mergedClsPrefixRef);
      const controlledValueRef = vue.toRef(props, "value");
      const uncontrolledValueRef = vue.ref(props.defaultValue);
      const hoverIndexRef = vue.ref(null);
      const formItem = useFormItem(props);
      const mergedValue = useMergedState(controlledValueRef, uncontrolledValueRef);
      function doUpdateValue(value) {
        const {
          "onUpdate:value": _onUpdateValue,
          onUpdateValue
        } = props;
        const {
          nTriggerFormChange,
          nTriggerFormInput
        } = formItem;
        if (_onUpdateValue) {
          call(_onUpdateValue, value);
        }
        if (onUpdateValue) {
          call(onUpdateValue, value);
        }
        uncontrolledValueRef.value = value;
        nTriggerFormChange();
        nTriggerFormInput();
      }
      function getDerivedValue(index, e) {
        if (props.allowHalf) {
          if (e.offsetX >= Math.floor(e.currentTarget.offsetWidth / 2)) {
            return index + 1;
          } else {
            return index + 0.5;
          }
        } else {
          return index + 1;
        }
      }
      let cleared = false;
      function handleMouseMove(index, e) {
        if (cleared)
          return;
        hoverIndexRef.value = getDerivedValue(index, e);
      }
      function handleMouseLeave() {
        hoverIndexRef.value = null;
      }
      function handleClick2(index, e) {
        var _a;
        const {
          clearable
        } = props;
        const derivedValue = getDerivedValue(index, e);
        if (clearable && derivedValue === mergedValue.value) {
          cleared = true;
          (_a = props.onClear) === null || _a === void 0 ? void 0 : _a.call(props);
          hoverIndexRef.value = null;
          doUpdateValue(null);
        } else {
          doUpdateValue(derivedValue);
        }
      }
      function handleMouseEnterSomeStar() {
        cleared = false;
      }
      const mergedSizeRef = vue.computed(() => {
        const {
          size: size2
        } = props;
        const {
          self: self2
        } = themeRef.value;
        if (typeof size2 === "number") {
          return `${size2}px`;
        } else {
          return self2[createKey("size", size2)];
        }
      });
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: self2
        } = themeRef.value;
        const {
          itemColor,
          itemColorActive
        } = self2;
        const {
          color
        } = props;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-item-color": itemColor,
          "--n-item-color-active": color || itemColorActive,
          "--n-item-size": mergedSizeRef.value
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("rate", vue.computed(() => {
        const size2 = mergedSizeRef.value;
        const {
          color
        } = props;
        let hash = "";
        if (size2) {
          hash += size2[0];
        }
        if (color) {
          hash += color2Class(color);
        }
        return hash;
      }), cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        mergedValue,
        hoverIndex: hoverIndexRef,
        handleMouseMove,
        handleClick: handleClick2,
        handleMouseLeave,
        handleMouseEnterSomeStar,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      const {
        readonly,
        hoverIndex,
        mergedValue,
        mergedClsPrefix,
        onRender,
        $slots: {
          default: defaultSlot
        }
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h("div", {
        class: [`${mergedClsPrefix}-rate`, {
          [`${mergedClsPrefix}-rate--readonly`]: readonly
        }, this.themeClass],
        style: this.cssVars,
        onMouseleave: this.handleMouseLeave
      }, vue.renderList(this.count, (_, index) => {
        const icon = defaultSlot ? defaultSlot({
          index
        }) : vue.h(NBaseIcon, {
          clsPrefix: mergedClsPrefix
        }, {
          default: () => StarIcon
        });
        const entireStarActive = hoverIndex !== null ? index + 1 <= hoverIndex : index + 1 <= (mergedValue || 0);
        return vue.h("div", {
          key: index,
          class: [`${mergedClsPrefix}-rate__item`, entireStarActive && `${mergedClsPrefix}-rate__item--active`],
          onClick: readonly ? void 0 : (e) => {
            this.handleClick(index, e);
          },
          onMouseenter: this.handleMouseEnterSomeStar,
          onMousemove: readonly ? void 0 : (e) => {
            this.handleMouseMove(index, e);
          }
        }, icon, this.allowHalf ? vue.h("div", {
          class: [`${mergedClsPrefix}-rate__half`, {
            [`${mergedClsPrefix}-rate__half--active`]: !entireStarActive && hoverIndex !== null ? index + 0.5 <= hoverIndex : index + 0.5 <= (mergedValue || 0)
          }]
        }, icon) : null);
      }));
    }
  });
  const image404 = vue.h("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 36 36"
  }, vue.h("circle", {
    fill: "#FFCB4C",
    cx: "18",
    cy: "17.018",
    r: "17"
  }), vue.h("path", {
    fill: "#65471B",
    d: "M14.524 21.036c-.145-.116-.258-.274-.312-.464-.134-.46.13-.918.59-1.021 4.528-1.021 7.577 1.363 7.706 1.465.384.306.459.845.173 1.205-.286.358-.828.401-1.211.097-.11-.084-2.523-1.923-6.182-1.098-.274.061-.554-.016-.764-.184z"
  }), vue.h("ellipse", {
    fill: "#65471B",
    cx: "13.119",
    cy: "11.174",
    rx: "2.125",
    ry: "2.656"
  }), vue.h("ellipse", {
    fill: "#65471B",
    cx: "24.375",
    cy: "12.236",
    rx: "2.125",
    ry: "2.656"
  }), vue.h("path", {
    fill: "#F19020",
    d: "M17.276 35.149s1.265-.411 1.429-1.352c.173-.972-.624-1.167-.624-1.167s1.041-.208 1.172-1.376c.123-1.101-.861-1.363-.861-1.363s.97-.4 1.016-1.539c.038-.959-.995-1.428-.995-1.428s5.038-1.221 5.556-1.341c.516-.12 1.32-.615 1.069-1.694-.249-1.08-1.204-1.118-1.697-1.003-.494.115-6.744 1.566-8.9 2.068l-1.439.334c-.54.127-.785-.11-.404-.512.508-.536.833-1.129.946-2.113.119-1.035-.232-2.313-.433-2.809-.374-.921-1.005-1.649-1.734-1.899-1.137-.39-1.945.321-1.542 1.561.604 1.854.208 3.375-.833 4.293-2.449 2.157-3.588 3.695-2.83 6.973.828 3.575 4.377 5.876 7.952 5.048l3.152-.681z"
  }), vue.h("path", {
    fill: "#65471B",
    d: "M9.296 6.351c-.164-.088-.303-.224-.391-.399-.216-.428-.04-.927.393-1.112 4.266-1.831 7.699-.043 7.843.034.433.231.608.747.391 1.154-.216.405-.74.546-1.173.318-.123-.063-2.832-1.432-6.278.047-.257.109-.547.085-.785-.042zm12.135 3.75c-.156-.098-.286-.243-.362-.424-.187-.442.023-.927.468-1.084 4.381-1.536 7.685.48 7.823.567.415.26.555.787.312 1.178-.242.39-.776.495-1.191.238-.12-.072-2.727-1.621-6.267-.379-.266.091-.553.046-.783-.096z"
  }));
  const image500 = vue.h("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 36 36"
  }, vue.h("path", {
    fill: "#FFCC4D",
    d: "M36 18c0 9.941-8.059 18-18 18-9.94 0-18-8.059-18-18C0 8.06 8.06 0 18 0c9.941 0 18 8.06 18 18"
  }), vue.h("ellipse", {
    fill: "#664500",
    cx: "18",
    cy: "27",
    rx: "5",
    ry: "6"
  }), vue.h("path", {
    fill: "#664500",
    d: "M5.999 11c-.208 0-.419-.065-.599-.2-.442-.331-.531-.958-.2-1.4C8.462 5.05 12.816 5 13 5c.552 0 1 .448 1 1 0 .551-.445.998-.996 1-.155.002-3.568.086-6.204 3.6-.196.262-.497.4-.801.4zm24.002 0c-.305 0-.604-.138-.801-.4-2.64-3.521-6.061-3.598-6.206-3.6-.55-.006-.994-.456-.991-1.005C22.006 5.444 22.45 5 23 5c.184 0 4.537.05 7.8 4.4.332.442.242 1.069-.2 1.4-.18.135-.39.2-.599.2zm-16.087 4.5l1.793-1.793c.391-.391.391-1.023 0-1.414s-1.023-.391-1.414 0L12.5 14.086l-1.793-1.793c-.391-.391-1.023-.391-1.414 0s-.391 1.023 0 1.414l1.793 1.793-1.793 1.793c-.391.391-.391 1.023 0 1.414.195.195.451.293.707.293s.512-.098.707-.293l1.793-1.793 1.793 1.793c.195.195.451.293.707.293s.512-.098.707-.293c.391-.391.391-1.023 0-1.414L13.914 15.5zm11 0l1.793-1.793c.391-.391.391-1.023 0-1.414s-1.023-.391-1.414 0L23.5 14.086l-1.793-1.793c-.391-.391-1.023-.391-1.414 0s-.391 1.023 0 1.414l1.793 1.793-1.793 1.793c-.391.391-.391 1.023 0 1.414.195.195.451.293.707.293s.512-.098.707-.293l1.793-1.793 1.793 1.793c.195.195.451.293.707.293s.512-.098.707-.293c.391-.391.391-1.023 0-1.414L24.914 15.5z"
  }));
  const image418 = vue.h("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 36 36"
  }, vue.h("ellipse", {
    fill: "#292F33",
    cx: "18",
    cy: "26",
    rx: "18",
    ry: "10"
  }), vue.h("ellipse", {
    fill: "#66757F",
    cx: "18",
    cy: "24",
    rx: "18",
    ry: "10"
  }), vue.h("path", {
    fill: "#E1E8ED",
    d: "M18 31C3.042 31 1 16 1 12h34c0 2-1.958 19-17 19z"
  }), vue.h("path", {
    fill: "#77B255",
    d: "M35 12.056c0 5.216-7.611 9.444-17 9.444S1 17.271 1 12.056C1 6.84 8.611 3.611 18 3.611s17 3.229 17 8.445z"
  }), vue.h("ellipse", {
    fill: "#A6D388",
    cx: "18",
    cy: "13",
    rx: "15",
    ry: "7"
  }), vue.h("path", {
    d: "M21 17c-.256 0-.512-.098-.707-.293-2.337-2.337-2.376-4.885-.125-8.262.739-1.109.9-2.246.478-3.377-.461-1.236-1.438-1.996-1.731-2.077-.553 0-.958-.443-.958-.996 0-.552.491-.995 1.043-.995.997 0 2.395 1.153 3.183 2.625 1.034 1.933.91 4.039-.351 5.929-1.961 2.942-1.531 4.332-.125 5.738.391.391.391 1.023 0 1.414-.195.196-.451.294-.707.294zm-6-2c-.256 0-.512-.098-.707-.293-2.337-2.337-2.376-4.885-.125-8.262.727-1.091.893-2.083.494-2.947-.444-.961-1.431-1.469-1.684-1.499-.552 0-.989-.447-.989-1 0-.552.458-1 1.011-1 .997 0 2.585.974 3.36 2.423.481.899 1.052 2.761-.528 5.131-1.961 2.942-1.531 4.332-.125 5.738.391.391.391 1.023 0 1.414-.195.197-.451.295-.707.295z",
    fill: "#5C913B"
  }));
  const image403 = vue.h("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 36 36"
  }, vue.h("path", {
    fill: "#EF9645",
    d: "M15.5 2.965c1.381 0 2.5 1.119 2.5 2.5v.005L20.5.465c1.381 0 2.5 1.119 2.5 2.5V4.25l2.5-1.535c1.381 0 2.5 1.119 2.5 2.5V8.75L29 18H15.458L15.5 2.965z"
  }), vue.h("path", {
    fill: "#FFDC5D",
    d: "M4.625 16.219c1.381-.611 3.354.208 4.75 2.188.917 1.3 1.187 3.151 2.391 3.344.46.073 1.234-.313 1.234-1.397V4.5s0-2 2-2 2 2 2 2v11.633c0-.029 1-.064 1-.082V2s0-2 2-2 2 2 2 2v14.053c0 .017 1 .041 1 .069V4.25s0-2 2-2 2 2 2 2v12.638c0 .118 1 .251 1 .398V8.75s0-2 2-2 2 2 2 2V24c0 6.627-5.373 12-12 12-4.775 0-8.06-2.598-9.896-5.292C8.547 28.423 8.096 26.051 8 25.334c0 0-.123-1.479-1.156-2.865-1.469-1.969-2.5-3.156-3.125-3.866-.317-.359-.625-1.707.906-2.384z"
  }));
  const style$n = cB("result", `
 color: var(--n-text-color);
 line-height: var(--n-line-height);
 font-size: var(--n-font-size);
 transition:
 color .3s var(--n-bezier);
`, [cB("result-icon", `
 display: flex;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `, [cE("status-image", `
 font-size: var(--n-icon-size);
 width: 1em;
 height: 1em;
 `), cB("base-icon", `
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)]), cB("result-content", {
    marginTop: "24px"
  }), cB("result-footer", `
 margin-top: 24px;
 text-align: center;
 `), cB("result-header", [cE("title", `
 margin-top: 16px;
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 text-align: center;
 color: var(--n-title-text-color);
 font-size: var(--n-title-font-size);
 `), cE("description", `
 margin-top: 4px;
 text-align: center;
 font-size: var(--n-font-size);
 `)])]);
  const iconRenderMap = {
    403: () => image403,
    404: () => image404,
    418: () => image418,
    500: () => image500,
    info: () => vue.h(InfoIcon, null),
    success: () => vue.h(SuccessIcon, null),
    warning: () => vue.h(WarningIcon, null),
    error: () => vue.h(ErrorIcon, null)
  };
  const resultProps = Object.assign(Object.assign({}, useTheme.props), {
    size: {
      type: String,
      default: "medium"
    },
    status: {
      type: String,
      default: "info"
    },
    title: String,
    description: String
  });
  const Result = vue.defineComponent({
    name: "Result",
    props: resultProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Result", "-result", style$n, resultLight$1, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          size: size2,
          status
        } = props;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            textColor,
            lineHeight: lineHeight2,
            titleTextColor,
            titleFontWeight,
            [createKey("iconColor", status)]: iconColor,
            [createKey("fontSize", size2)]: fontSize2,
            [createKey("titleFontSize", size2)]: titleFontSize,
            [createKey("iconSize", size2)]: iconSize
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-font-size": fontSize2,
          "--n-icon-size": iconSize,
          "--n-line-height": lineHeight2,
          "--n-text-color": textColor,
          "--n-title-font-size": titleFontSize,
          "--n-title-font-weight": titleFontWeight,
          "--n-title-text-color": titleTextColor,
          "--n-icon-color": iconColor || ""
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("result", vue.computed(() => {
        const {
          size: size2,
          status
        } = props;
        let hash = "";
        if (size2) {
          hash += size2[0];
        }
        if (status) {
          hash += status[0];
        }
        return hash;
      }), cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a;
      const {
        status,
        $slots,
        mergedClsPrefix,
        onRender
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h("div", {
        class: [`${mergedClsPrefix}-result`, this.themeClass],
        style: this.cssVars
      }, vue.h("div", {
        class: `${mergedClsPrefix}-result-icon`
      }, ((_a = $slots.icon) === null || _a === void 0 ? void 0 : _a.call($slots)) || vue.h(NBaseIcon, {
        clsPrefix: mergedClsPrefix
      }, {
        default: () => iconRenderMap[status]()
      })), vue.h("div", {
        class: `${mergedClsPrefix}-result-header`
      }, this.title ? vue.h("div", {
        class: `${mergedClsPrefix}-result-header__title`
      }, this.title) : null, this.description ? vue.h("div", {
        class: `${mergedClsPrefix}-result-header__description`
      }, this.description) : null), $slots.default && vue.h("div", {
        class: `${mergedClsPrefix}-result-content`
      }, $slots), $slots.footer && vue.h("div", {
        class: `${mergedClsPrefix}-result-footer`
      }, $slots.footer()));
    }
  });
  const scrollbarProps = Object.assign(Object.assign({}, useTheme.props), {
    trigger: String,
    xScrollable: Boolean,
    onScroll: Function,
    contentClass: String,
    contentStyle: [Object, String],
    size: Number,
    yPlacement: {
      type: String,
      default: "right"
    },
    xPlacement: {
      type: String,
      default: "bottom"
    }
  });
  const Scrollbar = vue.defineComponent({
    name: "Scrollbar",
    props: scrollbarProps,
    setup() {
      const scrollbarInstRef = vue.ref(null);
      const exposedMethods = {
        scrollTo: (...args) => {
          var _a;
          (_a = scrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(args[0], args[1]);
        },
        scrollBy: (...args) => {
          var _a;
          (_a = scrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollBy(args[0], args[1]);
        }
      };
      return Object.assign(Object.assign({}, exposedMethods), {
        scrollbarInstRef
      });
    },
    render() {
      return vue.h(NScrollbar, Object.assign({
        ref: "scrollbarInstRef"
      }, this.$props), this.$slots);
    }
  });
  const Scrollbar$1 = Scrollbar;
  function self$2(vars) {
    const {
      heightSmall,
      heightMedium,
      heightLarge,
      borderRadius
    } = vars;
    return {
      color: "#eee",
      colorEnd: "#ddd",
      borderRadius,
      heightSmall,
      heightMedium,
      heightLarge
    };
  }
  const skeletonLight = {
    name: "Skeleton",
    common: commonLight,
    self: self$2
  };
  const style$m = c$1([cB("skeleton", `
 height: 1em;
 width: 100%;
 transition:
 --n-color-start .3s var(--n-bezier),
 --n-color-end .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 animation: 2s skeleton-loading infinite cubic-bezier(0.36, 0, 0.64, 1);
 background-color: var(--n-color-start);
 `), c$1("@keyframes skeleton-loading", `
 0% {
 background: var(--n-color-start);
 }
 40% {
 background: var(--n-color-end);
 }
 80% {
 background: var(--n-color-start);
 }
 100% {
 background: var(--n-color-start);
 }
 `)]);
  const skeletonProps = Object.assign(Object.assign({}, useTheme.props), {
    text: Boolean,
    round: Boolean,
    circle: Boolean,
    height: [String, Number],
    width: [String, Number],
    size: String,
    repeat: {
      type: Number,
      default: 1
    },
    animated: {
      type: Boolean,
      default: true
    },
    sharp: {
      type: Boolean,
      default: true
    }
  });
  const Skeleton = vue.defineComponent({
    name: "Skeleton",
    inheritAttrs: false,
    props: skeletonProps,
    setup(props) {
      useHoudini();
      const {
        mergedClsPrefixRef
      } = useConfig(props);
      const themeRef = useTheme("Skeleton", "-skeleton", style$m, skeletonLight, props, mergedClsPrefixRef);
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        style: vue.computed(() => {
          var _a, _b;
          const theme = themeRef.value;
          const {
            common: {
              cubicBezierEaseInOut: cubicBezierEaseInOut2
            }
          } = theme;
          const selfThemeVars = theme.self;
          const {
            color,
            colorEnd,
            borderRadius
          } = selfThemeVars;
          let sizeHeight;
          const {
            circle,
            sharp,
            round: round2,
            width,
            height,
            size: size2,
            text: text2,
            animated
          } = props;
          if (size2 !== void 0) {
            sizeHeight = selfThemeVars[createKey("height", size2)];
          }
          const mergedWidth = circle ? (_a = width !== null && width !== void 0 ? width : height) !== null && _a !== void 0 ? _a : sizeHeight : width;
          const mergedHeight = (_b = circle ? width !== null && width !== void 0 ? width : height : height) !== null && _b !== void 0 ? _b : sizeHeight;
          return {
            display: text2 ? "inline-block" : "",
            verticalAlign: text2 ? "-0.125em" : "",
            borderRadius: circle ? "50%" : round2 ? "4096px" : sharp ? "" : borderRadius,
            width: typeof mergedWidth === "number" ? pxfy(mergedWidth) : mergedWidth,
            height: typeof mergedHeight === "number" ? pxfy(mergedHeight) : mergedHeight,
            animation: !animated ? "none" : "",
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-color-start": color,
            "--n-color-end": colorEnd
          };
        })
      };
    },
    render() {
      const {
        repeat: repeatProp,
        style: style2,
        mergedClsPrefix,
        $attrs
      } = this;
      const child = vue.h("div", vue.mergeProps({
        class: `${mergedClsPrefix}-skeleton`,
        style: style2
      }, $attrs));
      if (repeatProp > 1) {
        return vue.h(vue.Fragment, null, repeat(repeatProp, null).map((_) => [child, "\n"]));
      }
      return child;
    }
  });
  function isTouchEvent(e) {
    return window.TouchEvent && e instanceof window.TouchEvent;
  }
  function useRefs() {
    const refs = /* @__PURE__ */ new Map();
    const setRefs = (index) => (el) => {
      refs.set(index, el);
    };
    vue.onBeforeUpdate(() => {
      refs.clear();
    });
    return [refs, setRefs];
  }
  const style$l = c$1([cB("slider", `
 display: block;
 padding: calc((var(--n-handle-size) - var(--n-rail-height)) / 2) 0;
 position: relative;
 z-index: 0;
 width: 100%;
 cursor: pointer;
 user-select: none;
 -webkit-user-select: none;
 `, [cM("reverse", [cB("slider-handles", [cB("slider-handle-wrapper", `
 transform: translate(50%, -50%);
 `)]), cB("slider-dots", [cB("slider-dot", `
 transform: translateX(50%, -50%);
 `)]), cM("vertical", [cB("slider-handles", [cB("slider-handle-wrapper", `
 transform: translate(-50%, -50%);
 `)]), cB("slider-marks", [cB("slider-mark", `
 transform: translateY(calc(-50% + var(--n-dot-height) / 2));
 `)]), cB("slider-dots", [cB("slider-dot", `
 transform: translateX(-50%) translateY(0);
 `)])])]), cM("vertical", `
 box-sizing: content-box;
 padding: 0 calc((var(--n-handle-size) - var(--n-rail-height)) / 2);
 width: var(--n-rail-width-vertical);
 height: 100%;
 `, [cB("slider-handles", `
 top: calc(var(--n-handle-size) / 2);
 right: 0;
 bottom: calc(var(--n-handle-size) / 2);
 left: 0;
 `, [cB("slider-handle-wrapper", `
 top: unset;
 left: 50%;
 transform: translate(-50%, 50%);
 `)]), cB("slider-rail", `
 height: 100%;
 `, [cE("fill", `
 top: unset;
 right: 0;
 bottom: unset;
 left: 0;
 `)]), cM("with-mark", `
 width: var(--n-rail-width-vertical);
 margin: 0 32px 0 8px;
 `), cB("slider-marks", `
 top: calc(var(--n-handle-size) / 2);
 right: unset;
 bottom: calc(var(--n-handle-size) / 2);
 left: 22px;
 font-size: var(--n-mark-font-size);
 `, [cB("slider-mark", `
 transform: translateY(50%);
 white-space: nowrap;
 `)]), cB("slider-dots", `
 top: calc(var(--n-handle-size) / 2);
 right: unset;
 bottom: calc(var(--n-handle-size) / 2);
 left: 50%;
 `, [cB("slider-dot", `
 transform: translateX(-50%) translateY(50%);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 opacity: var(--n-opacity-disabled);
 `, [cB("slider-handle", `
 cursor: not-allowed;
 `)]), cM("with-mark", `
 width: 100%;
 margin: 8px 0 32px 0;
 `), c$1("&:hover", [cB("slider-rail", {
    backgroundColor: "var(--n-rail-color-hover)"
  }, [cE("fill", {
    backgroundColor: "var(--n-fill-color-hover)"
  })]), cB("slider-handle", {
    boxShadow: "var(--n-handle-box-shadow-hover)"
  })]), cM("active", [cB("slider-rail", {
    backgroundColor: "var(--n-rail-color-hover)"
  }, [cE("fill", {
    backgroundColor: "var(--n-fill-color-hover)"
  })]), cB("slider-handle", {
    boxShadow: "var(--n-handle-box-shadow-hover)"
  })]), cB("slider-marks", `
 position: absolute;
 top: 18px;
 left: calc(var(--n-handle-size) / 2);
 right: calc(var(--n-handle-size) / 2);
 `, [cB("slider-mark", `
 position: absolute;
 transform: translateX(-50%);
 white-space: nowrap;
 `)]), cB("slider-rail", `
 width: 100%;
 position: relative;
 height: var(--n-rail-height);
 background-color: var(--n-rail-color);
 transition: background-color .3s var(--n-bezier);
 border-radius: calc(var(--n-rail-height) / 2);
 `, [cE("fill", `
 position: absolute;
 top: 0;
 bottom: 0;
 border-radius: calc(var(--n-rail-height) / 2);
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-fill-color);
 `)]), cB("slider-handles", `
 position: absolute;
 top: 0;
 right: calc(var(--n-handle-size) / 2);
 bottom: 0;
 left: calc(var(--n-handle-size) / 2);
 `, [cB("slider-handle-wrapper", `
 outline: none;
 position: absolute;
 top: 50%;
 transform: translate(-50%, -50%);
 cursor: pointer;
 display: flex;
 `, [cB("slider-handle", `
 height: var(--n-handle-size);
 width: var(--n-handle-size);
 border-radius: 50%;
 overflow: hidden;
 transition: box-shadow .2s var(--n-bezier), background-color .3s var(--n-bezier);
 background-color: var(--n-handle-color);
 box-shadow: var(--n-handle-box-shadow);
 `, [c$1("&:hover", `
 box-shadow: var(--n-handle-box-shadow-hover);
 `)]), c$1("&:focus", [cB("slider-handle", `
 box-shadow: var(--n-handle-box-shadow-focus);
 `, [c$1("&:hover", `
 box-shadow: var(--n-handle-box-shadow-active);
 `)])])])]), cB("slider-dots", `
 position: absolute;
 top: 50%;
 left: calc(var(--n-handle-size) / 2);
 right: calc(var(--n-handle-size) / 2);
 `, [cM("transition-disabled", [cB("slider-dot", "transition: none;")]), cB("slider-dot", `
 transition:
 border-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 position: absolute;
 transform: translate(-50%, -50%);
 height: var(--n-dot-height);
 width: var(--n-dot-width);
 border-radius: var(--n-dot-border-radius);
 overflow: hidden;
 box-sizing: border-box;
 border: var(--n-dot-border);
 background-color: var(--n-dot-color);
 `, [cM("active", "border: var(--n-dot-border-active);")])])]), cB("slider-handle-indicator", `
 font-size: var(--n-font-size);
 padding: 6px 10px;
 border-radius: var(--n-indicator-border-radius);
 color: var(--n-indicator-text-color);
 background-color: var(--n-indicator-color);
 box-shadow: var(--n-indicator-box-shadow);
 `, [fadeInScaleUpTransition()]), cB("slider-handle-indicator", `
 font-size: var(--n-font-size);
 padding: 6px 10px;
 border-radius: var(--n-indicator-border-radius);
 color: var(--n-indicator-text-color);
 background-color: var(--n-indicator-color);
 box-shadow: var(--n-indicator-box-shadow);
 `, [cM("top", `
 margin-bottom: 12px;
 `), cM("right", `
 margin-left: 12px;
 `), cM("bottom", `
 margin-top: 12px;
 `), cM("left", `
 margin-right: 12px;
 `), fadeInScaleUpTransition()]), insideModal(cB("slider", [cB("slider-dot", "background-color: var(--n-dot-color-modal);")])), insidePopover(cB("slider", [cB("slider-dot", "background-color: var(--n-dot-color-popover);")]))]);
  const eventButtonLeft = 0;
  const sliderProps = Object.assign(Object.assign({}, useTheme.props), {
    to: useAdjustedTo.propTo,
    defaultValue: {
      type: [Number, Array],
      default: 0
    },
    marks: Object,
    disabled: {
      type: Boolean,
      default: void 0
    },
    formatTooltip: Function,
    keyboard: {
      type: Boolean,
      default: true
    },
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    step: {
      type: [Number, String],
      default: 1
    },
    range: Boolean,
    value: [Number, Array],
    placement: String,
    showTooltip: {
      type: Boolean,
      default: void 0
    },
    tooltip: {
      type: Boolean,
      default: true
    },
    vertical: Boolean,
    reverse: Boolean,
    "onUpdate:value": [Function, Array],
    onUpdateValue: [Function, Array],
    onDragstart: [Function],
    onDragend: [Function]
  });
  const Slider = vue.defineComponent({
    name: "Slider",
    props: sliderProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        namespaceRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Slider", "-slider", style$l, sliderLight$1, props, mergedClsPrefixRef);
      const handleRailRef = vue.ref(null);
      const [handleRefs, setHandleRefs] = useRefs();
      const [followerRefs, setFollowerRefs] = useRefs();
      const followerEnabledIndexSetRef = vue.ref(/* @__PURE__ */ new Set());
      const formItem = useFormItem(props);
      const {
        mergedDisabledRef
      } = formItem;
      const precisionRef = vue.computed(() => {
        const {
          step
        } = props;
        if (Number(step) <= 0 || step === "mark")
          return 0;
        const stepString = step.toString();
        let precision = 0;
        if (stepString.includes(".")) {
          precision = stepString.length - stepString.indexOf(".") - 1;
        }
        return precision;
      });
      const uncontrolledValueRef = vue.ref(props.defaultValue);
      const controlledValueRef = vue.toRef(props, "value");
      const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
      const arrifiedValueRef = vue.computed(() => {
        const {
          value: mergedValue
        } = mergedValueRef;
        return (props.range ? mergedValue : [mergedValue]).map(clampValue2);
      });
      const handleCountExceeds2Ref = vue.computed(() => arrifiedValueRef.value.length > 2);
      const mergedPlacementRef = vue.computed(() => {
        return props.placement === void 0 ? props.vertical ? "right" : "top" : props.placement;
      });
      const markValuesRef = vue.computed(() => {
        const {
          marks
        } = props;
        return marks ? Object.keys(marks).map(Number.parseFloat) : null;
      });
      const activeIndexRef = vue.ref(-1);
      const previousIndexRef = vue.ref(-1);
      const hoverIndexRef = vue.ref(-1);
      const draggingRef = vue.ref(false);
      const dotTransitionDisabledRef = vue.ref(false);
      const styleDirectionRef = vue.computed(() => {
        const {
          vertical,
          reverse
        } = props;
        const left = reverse ? "right" : "left";
        const bottom = reverse ? "top" : "bottom";
        return vertical ? bottom : left;
      });
      const fillStyleRef = vue.computed(() => {
        if (handleCountExceeds2Ref.value)
          return;
        const values = arrifiedValueRef.value;
        const start = valueToPercentage(props.range ? Math.min(...values) : props.min);
        const end = valueToPercentage(props.range ? Math.max(...values) : values[0]);
        const {
          value: styleDirection
        } = styleDirectionRef;
        return props.vertical ? {
          [styleDirection]: `${start}%`,
          height: `${end - start}%`
        } : {
          [styleDirection]: `${start}%`,
          width: `${end - start}%`
        };
      });
      const markInfosRef = vue.computed(() => {
        const mergedMarks = [];
        const {
          marks
        } = props;
        if (marks) {
          const orderValues = arrifiedValueRef.value.slice();
          orderValues.sort((a2, b) => a2 - b);
          const {
            value: styleDirection
          } = styleDirectionRef;
          const {
            value: handleCountExceeds2
          } = handleCountExceeds2Ref;
          const {
            range: range2
          } = props;
          const isActive = handleCountExceeds2 ? () => false : (num) => range2 ? num >= orderValues[0] && num <= orderValues[orderValues.length - 1] : num <= orderValues[0];
          for (const key of Object.keys(marks)) {
            const num = Number(key);
            mergedMarks.push({
              active: isActive(num),
              key: num,
              label: marks[key],
              style: {
                [styleDirection]: `${valueToPercentage(num)}%`
              }
            });
          }
        }
        return mergedMarks;
      });
      function getHandleStyle(value, index) {
        const percentage = valueToPercentage(value);
        const {
          value: styleDirection
        } = styleDirectionRef;
        return {
          [styleDirection]: `${percentage}%`,
          zIndex: index === activeIndexRef.value ? 1 : 0
        };
      }
      function isShowTooltip(index) {
        return props.showTooltip || hoverIndexRef.value === index || activeIndexRef.value === index && draggingRef.value;
      }
      function shouldKeepTooltipTransition(index) {
        if (!draggingRef.value)
          return true;
        return !(activeIndexRef.value === index && previousIndexRef.value === index);
      }
      function focusActiveHandle(index) {
        var _a;
        if (~index) {
          activeIndexRef.value = index;
          (_a = handleRefs.get(index)) === null || _a === void 0 ? void 0 : _a.focus();
        }
      }
      function syncPosition() {
        followerRefs.forEach((inst, index) => {
          if (isShowTooltip(index))
            inst.syncPosition();
        });
      }
      function doUpdateValue(value) {
        const {
          "onUpdate:value": _onUpdateValue,
          onUpdateValue
        } = props;
        const {
          nTriggerFormInput,
          nTriggerFormChange
        } = formItem;
        if (onUpdateValue)
          call(onUpdateValue, value);
        if (_onUpdateValue)
          call(_onUpdateValue, value);
        uncontrolledValueRef.value = value;
        nTriggerFormInput();
        nTriggerFormChange();
      }
      function dispatchValueUpdate(value) {
        const {
          range: range2
        } = props;
        if (range2) {
          if (Array.isArray(value)) {
            const {
              value: oldValues
            } = arrifiedValueRef;
            if (value.join() !== oldValues.join()) {
              doUpdateValue(value);
            }
          }
        } else if (!Array.isArray(value)) {
          const oldValue = arrifiedValueRef.value[0];
          if (oldValue !== value) {
            doUpdateValue(value);
          }
        }
      }
      function doDispatchValue(value, index) {
        if (props.range) {
          const values = arrifiedValueRef.value.slice();
          values.splice(index, 1, value);
          dispatchValueUpdate(values);
        } else {
          dispatchValueUpdate(value);
        }
      }
      function sanitizeValue(value, currentValue, stepBuffer) {
        const stepping = stepBuffer !== void 0;
        if (!stepBuffer) {
          stepBuffer = value - currentValue > 0 ? 1 : -1;
        }
        const markValues = markValuesRef.value || [];
        const {
          step
        } = props;
        if (step === "mark") {
          const closestMark2 = getClosestMark(value, markValues.concat(currentValue), stepping ? stepBuffer : void 0);
          return closestMark2 ? closestMark2.value : currentValue;
        }
        if (step <= 0)
          return currentValue;
        const {
          value: precision
        } = precisionRef;
        let closestMark;
        if (stepping) {
          const currentStep = Number((currentValue / step).toFixed(precision));
          const actualStep = Math.floor(currentStep);
          const leftStep = currentStep > actualStep ? actualStep : actualStep - 1;
          const rightStep = currentStep < actualStep ? actualStep : actualStep + 1;
          closestMark = getClosestMark(currentValue, [Number((leftStep * step).toFixed(precision)), Number((rightStep * step).toFixed(precision)), ...markValues], stepBuffer);
        } else {
          const roundValue = getRoundValue(value);
          closestMark = getClosestMark(value, [...markValues, roundValue]);
        }
        return closestMark ? clampValue2(closestMark.value) : currentValue;
      }
      function clampValue2(value) {
        return Math.min(props.max, Math.max(props.min, value));
      }
      function valueToPercentage(value) {
        const {
          max,
          min
        } = props;
        return (value - min) / (max - min) * 100;
      }
      function percentageToValue(percentage) {
        const {
          max,
          min
        } = props;
        return min + (max - min) * percentage;
      }
      function getRoundValue(value) {
        const {
          step,
          min
        } = props;
        if (Number(step) <= 0 || step === "mark")
          return value;
        const newValue = Math.round((value - min) / step) * step + min;
        return Number(newValue.toFixed(precisionRef.value));
      }
      function getClosestMark(currentValue, markValues = markValuesRef.value, buffer) {
        if (!(markValues === null || markValues === void 0 ? void 0 : markValues.length))
          return null;
        let closestMark = null;
        let index = -1;
        while (++index < markValues.length) {
          const diff = markValues[index] - currentValue;
          const distance = Math.abs(diff);
          if (
            // find marks in the same direction
            (buffer === void 0 || diff * buffer > 0) && (closestMark === null || distance < closestMark.distance)
          ) {
            closestMark = {
              index,
              distance,
              value: markValues[index]
            };
          }
        }
        return closestMark;
      }
      function getPointValue(event) {
        const railEl = handleRailRef.value;
        if (!railEl)
          return;
        const touchEvent = isTouchEvent(event) ? event.touches[0] : event;
        const railRect = railEl.getBoundingClientRect();
        let percentage;
        if (props.vertical) {
          percentage = (railRect.bottom - touchEvent.clientY) / railRect.height;
        } else {
          percentage = (touchEvent.clientX - railRect.left) / railRect.width;
        }
        if (props.reverse) {
          percentage = 1 - percentage;
        }
        return percentageToValue(percentage);
      }
      function handleRailKeyDown(e) {
        if (mergedDisabledRef.value || !props.keyboard)
          return;
        const {
          vertical,
          reverse
        } = props;
        switch (e.key) {
          case "ArrowUp":
            e.preventDefault();
            handleStepValue(vertical && reverse ? -1 : 1);
            break;
          case "ArrowRight":
            e.preventDefault();
            handleStepValue(!vertical && reverse ? -1 : 1);
            break;
          case "ArrowDown":
            e.preventDefault();
            handleStepValue(vertical && reverse ? 1 : -1);
            break;
          case "ArrowLeft":
            e.preventDefault();
            handleStepValue(!vertical && reverse ? 1 : -1);
            break;
        }
      }
      function handleStepValue(ratio) {
        const activeIndex = activeIndexRef.value;
        if (activeIndex === -1)
          return;
        const {
          step
        } = props;
        const currentValue = arrifiedValueRef.value[activeIndex];
        const nextValue = Number(step) <= 0 || step === "mark" ? currentValue : currentValue + step * ratio;
        doDispatchValue(
          // Avoid the number of value does not change when `step` is null
          sanitizeValue(nextValue, currentValue, ratio > 0 ? 1 : -1),
          activeIndex
        );
      }
      function handleRailMouseDown(event) {
        var _a, _b;
        if (mergedDisabledRef.value)
          return;
        if (!isTouchEvent(event) && event.button !== eventButtonLeft) {
          return;
        }
        const pointValue = getPointValue(event);
        if (pointValue === void 0)
          return;
        const values = arrifiedValueRef.value.slice();
        const activeIndex = props.range ? (_b = (_a = getClosestMark(pointValue, values)) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : -1 : 0;
        if (activeIndex !== -1) {
          event.preventDefault();
          focusActiveHandle(activeIndex);
          startDragging();
          doDispatchValue(sanitizeValue(pointValue, arrifiedValueRef.value[activeIndex]), activeIndex);
        }
      }
      function startDragging() {
        if (!draggingRef.value) {
          draggingRef.value = true;
          if (props.onDragstart)
            call(props.onDragstart);
          on("touchend", document, handleMouseUp);
          on("mouseup", document, handleMouseUp);
          on("touchmove", document, handleMouseMove);
          on("mousemove", document, handleMouseMove);
        }
      }
      function stopDragging() {
        if (draggingRef.value) {
          draggingRef.value = false;
          if (props.onDragend)
            call(props.onDragend);
          off("touchend", document, handleMouseUp);
          off("mouseup", document, handleMouseUp);
          off("touchmove", document, handleMouseMove);
          off("mousemove", document, handleMouseMove);
        }
      }
      function handleMouseMove(event) {
        const {
          value: activeIndex
        } = activeIndexRef;
        if (!draggingRef.value || activeIndex === -1) {
          stopDragging();
          return;
        }
        const pointValue = getPointValue(event);
        if (pointValue === void 0)
          return;
        doDispatchValue(sanitizeValue(pointValue, arrifiedValueRef.value[activeIndex]), activeIndex);
      }
      function handleMouseUp() {
        stopDragging();
      }
      function handleHandleFocus(index) {
        activeIndexRef.value = index;
        if (!mergedDisabledRef.value) {
          hoverIndexRef.value = index;
        }
      }
      function handleHandleBlur(index) {
        if (activeIndexRef.value === index) {
          activeIndexRef.value = -1;
          stopDragging();
        }
        if (hoverIndexRef.value === index) {
          hoverIndexRef.value = -1;
        }
      }
      function handleHandleMouseEnter(index) {
        hoverIndexRef.value = index;
      }
      function handleHandleMouseLeave(index) {
        if (hoverIndexRef.value === index) {
          hoverIndexRef.value = -1;
        }
      }
      vue.watch(activeIndexRef, (_, previous) => void vue.nextTick(() => previousIndexRef.value = previous));
      vue.watch(mergedValueRef, () => {
        if (props.marks) {
          if (dotTransitionDisabledRef.value)
            return;
          dotTransitionDisabledRef.value = true;
          void vue.nextTick(() => {
            dotTransitionDisabledRef.value = false;
          });
        }
        void vue.nextTick(syncPosition);
      });
      vue.onBeforeUnmount(() => {
        stopDragging();
      });
      const cssVarsRef = vue.computed(() => {
        const {
          self: {
            markFontSize,
            railColor,
            railColorHover,
            fillColor,
            fillColorHover,
            handleColor,
            opacityDisabled,
            dotColor,
            dotColorModal,
            handleBoxShadow,
            handleBoxShadowHover,
            handleBoxShadowActive,
            handleBoxShadowFocus,
            dotBorder,
            dotBoxShadow,
            railHeight,
            railWidthVertical,
            handleSize,
            dotHeight,
            dotWidth,
            dotBorderRadius,
            fontSize: fontSize2,
            dotBorderActive,
            dotColorPopover
          },
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-dot-border": dotBorder,
          "--n-dot-border-active": dotBorderActive,
          "--n-dot-border-radius": dotBorderRadius,
          "--n-dot-box-shadow": dotBoxShadow,
          "--n-dot-color": dotColor,
          "--n-dot-color-modal": dotColorModal,
          "--n-dot-color-popover": dotColorPopover,
          "--n-dot-height": dotHeight,
          "--n-dot-width": dotWidth,
          "--n-fill-color": fillColor,
          "--n-fill-color-hover": fillColorHover,
          "--n-font-size": fontSize2,
          "--n-handle-box-shadow": handleBoxShadow,
          "--n-handle-box-shadow-active": handleBoxShadowActive,
          "--n-handle-box-shadow-focus": handleBoxShadowFocus,
          "--n-handle-box-shadow-hover": handleBoxShadowHover,
          "--n-handle-color": handleColor,
          "--n-handle-size": handleSize,
          "--n-opacity-disabled": opacityDisabled,
          "--n-rail-color": railColor,
          "--n-rail-color-hover": railColorHover,
          "--n-rail-height": railHeight,
          "--n-rail-width-vertical": railWidthVertical,
          "--n-mark-font-size": markFontSize
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("slider", void 0, cssVarsRef, props) : void 0;
      const indicatorCssVarsRef = vue.computed(() => {
        const {
          self: {
            fontSize: fontSize2,
            indicatorColor,
            indicatorBoxShadow,
            indicatorTextColor,
            indicatorBorderRadius
          }
        } = themeRef.value;
        return {
          "--n-font-size": fontSize2,
          "--n-indicator-border-radius": indicatorBorderRadius,
          "--n-indicator-box-shadow": indicatorBoxShadow,
          "--n-indicator-color": indicatorColor,
          "--n-indicator-text-color": indicatorTextColor
        };
      });
      const indicatorThemeClassHandle = inlineThemeDisabled ? useThemeClass("slider-indicator", void 0, indicatorCssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        namespace: namespaceRef,
        uncontrolledValue: uncontrolledValueRef,
        mergedValue: mergedValueRef,
        mergedDisabled: mergedDisabledRef,
        mergedPlacement: mergedPlacementRef,
        isMounted: isMounted(),
        adjustedTo: useAdjustedTo(props),
        dotTransitionDisabled: dotTransitionDisabledRef,
        markInfos: markInfosRef,
        isShowTooltip,
        shouldKeepTooltipTransition,
        handleRailRef,
        setHandleRefs,
        setFollowerRefs,
        fillStyle: fillStyleRef,
        getHandleStyle,
        activeIndex: activeIndexRef,
        arrifiedValues: arrifiedValueRef,
        followerEnabledIndexSet: followerEnabledIndexSetRef,
        handleRailMouseDown,
        handleHandleFocus,
        handleHandleBlur,
        handleHandleMouseEnter,
        handleHandleMouseLeave,
        handleRailKeyDown,
        indicatorCssVars: inlineThemeDisabled ? void 0 : indicatorCssVarsRef,
        indicatorThemeClass: indicatorThemeClassHandle === null || indicatorThemeClassHandle === void 0 ? void 0 : indicatorThemeClassHandle.themeClass,
        indicatorOnRender: indicatorThemeClassHandle === null || indicatorThemeClassHandle === void 0 ? void 0 : indicatorThemeClassHandle.onRender,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a;
      const {
        mergedClsPrefix,
        themeClass,
        formatTooltip
      } = this;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      return vue.h("div", {
        class: [`${mergedClsPrefix}-slider`, themeClass, {
          [`${mergedClsPrefix}-slider--disabled`]: this.mergedDisabled,
          [`${mergedClsPrefix}-slider--active`]: this.activeIndex !== -1,
          [`${mergedClsPrefix}-slider--with-mark`]: this.marks,
          [`${mergedClsPrefix}-slider--vertical`]: this.vertical,
          [`${mergedClsPrefix}-slider--reverse`]: this.reverse
        }],
        style: this.cssVars,
        onKeydown: this.handleRailKeyDown,
        onMousedown: this.handleRailMouseDown,
        onTouchstart: this.handleRailMouseDown
      }, vue.h("div", {
        class: `${mergedClsPrefix}-slider-rail`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-slider-rail__fill`,
        style: this.fillStyle
      }), this.marks ? vue.h("div", {
        class: [`${mergedClsPrefix}-slider-dots`, this.dotTransitionDisabled && `${mergedClsPrefix}-slider-dots--transition-disabled`]
      }, this.markInfos.map((mark) => vue.h("div", {
        key: mark.key,
        class: [`${mergedClsPrefix}-slider-dot`, {
          [`${mergedClsPrefix}-slider-dot--active`]: mark.active
        }],
        style: mark.style
      }))) : null, vue.h("div", {
        ref: "handleRailRef",
        class: `${mergedClsPrefix}-slider-handles`
      }, this.arrifiedValues.map((value, index) => {
        const showTooltip = this.isShowTooltip(index);
        return vue.h(VBinder, null, {
          default: () => [vue.h(VTarget, null, {
            default: () => vue.h("div", {
              ref: this.setHandleRefs(index),
              class: `${mergedClsPrefix}-slider-handle-wrapper`,
              tabindex: this.mergedDisabled ? -1 : 0,
              role: "slider",
              "aria-valuenow": value,
              "aria-valuemin": this.min,
              "aria-valuemax": this.max,
              "aria-orientation": this.vertical ? "vertical" : "horizontal",
              "aria-disabled": this.disabled,
              style: this.getHandleStyle(value, index),
              onFocus: () => {
                this.handleHandleFocus(index);
              },
              onBlur: () => {
                this.handleHandleBlur(index);
              },
              onMouseenter: () => {
                this.handleHandleMouseEnter(index);
              },
              onMouseleave: () => {
                this.handleHandleMouseLeave(index);
              }
            }, resolveSlot(this.$slots.thumb, () => [vue.h("div", {
              class: `${mergedClsPrefix}-slider-handle`
            })]))
          }), this.tooltip && vue.h(VFollower, {
            ref: this.setFollowerRefs(index),
            show: showTooltip,
            to: this.adjustedTo,
            enabled: this.showTooltip && !this.range || this.followerEnabledIndexSet.has(index),
            teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey,
            placement: this.mergedPlacement,
            containerClass: this.namespace
          }, {
            default: () => vue.h(vue.Transition, {
              name: "fade-in-scale-up-transition",
              appear: this.isMounted,
              css: this.shouldKeepTooltipTransition(index),
              onEnter: () => {
                this.followerEnabledIndexSet.add(index);
              },
              onAfterLeave: () => {
                this.followerEnabledIndexSet.delete(index);
              }
            }, {
              default: () => {
                var _a2;
                if (showTooltip) {
                  (_a2 = this.indicatorOnRender) === null || _a2 === void 0 ? void 0 : _a2.call(this);
                  return vue.h("div", {
                    class: [`${mergedClsPrefix}-slider-handle-indicator`, this.indicatorThemeClass, `${mergedClsPrefix}-slider-handle-indicator--${this.mergedPlacement}`],
                    style: this.indicatorCssVars
                  }, typeof formatTooltip === "function" ? formatTooltip(value) : value);
                }
                return null;
              }
            })
          })]
        });
      })), this.marks ? vue.h("div", {
        class: `${mergedClsPrefix}-slider-marks`
      }, this.markInfos.map((mark) => vue.h("div", {
        key: mark.key,
        class: `${mergedClsPrefix}-slider-mark`,
        style: mark.style
      }, typeof mark.label === "function" ? mark.label() : mark.label))) : null));
    }
  });
  const style$k = c$1([c$1("@keyframes spin-rotate", `
 from {
 transform: rotate(0);
 }
 to {
 transform: rotate(360deg);
 }
 `), cB("spin-container", `
 position: relative;
 `, [cB("spin-body", `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [fadeInTransition()])]), cB("spin-body", `
 display: inline-flex;
 align-items: center;
 justify-content: center;
 flex-direction: column;
 `), cB("spin", `
 display: inline-flex;
 height: var(--n-size);
 width: var(--n-size);
 font-size: var(--n-size);
 color: var(--n-color);
 `, [cM("rotate", `
 animation: spin-rotate 2s linear infinite;
 `)]), cB("spin-description", `
 display: inline-block;
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 margin-top: 8px;
 `), cB("spin-content", `
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 pointer-events: all;
 `, [cM("spinning", `
 user-select: none;
 -webkit-user-select: none;
 pointer-events: none;
 opacity: var(--n-opacity-spinning);
 `)])]);
  const STROKE_WIDTH = {
    small: 20,
    medium: 18,
    large: 16
  };
  const spinProps = Object.assign(Object.assign({}, useTheme.props), {
    contentClass: String,
    contentStyle: [Object, String],
    description: String,
    stroke: String,
    size: {
      type: [String, Number],
      default: "medium"
    },
    show: {
      type: Boolean,
      default: true
    },
    strokeWidth: Number,
    rotate: {
      type: Boolean,
      default: true
    },
    spinning: {
      type: Boolean,
      validator: () => {
        return true;
      },
      default: void 0
    },
    delay: Number
  });
  const Spin = vue.defineComponent({
    name: "Spin",
    props: spinProps,
    setup(props) {
      {
        vue.watchEffect(() => {
          if (props.spinning !== void 0) {
            warnOnce("spin", "`spinning` is deprecated, please use `show` instead.");
          }
        });
      }
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Spin", "-spin", style$k, spinLight$1, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          size: spinSize
        } = props;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: self2
        } = themeRef.value;
        const {
          opacitySpinning,
          color,
          textColor
        } = self2;
        const size2 = typeof spinSize === "number" ? pxfy(spinSize) : self2[createKey("size", spinSize)];
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-opacity-spinning": opacitySpinning,
          "--n-size": size2,
          "--n-color": color,
          "--n-text-color": textColor
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("spin", vue.computed(() => {
        const {
          size: size2
        } = props;
        return typeof size2 === "number" ? String(size2) : size2[0];
      }), cssVarsRef, props) : void 0;
      const compitableShow = useCompitable(props, ["spinning", "show"]);
      const activeRef = vue.ref(false);
      vue.watchEffect((onCleanup) => {
        let timerId;
        if (compitableShow.value) {
          const {
            delay
          } = props;
          if (delay) {
            timerId = window.setTimeout(() => {
              activeRef.value = true;
            }, delay);
            onCleanup(() => {
              clearTimeout(timerId);
            });
            return;
          }
        }
        activeRef.value = compitableShow.value;
      });
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        active: activeRef,
        mergedStrokeWidth: vue.computed(() => {
          const {
            strokeWidth
          } = props;
          if (strokeWidth !== void 0)
            return strokeWidth;
          const {
            size: size2
          } = props;
          return STROKE_WIDTH[typeof size2 === "number" ? "medium" : size2];
        }),
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a, _b;
      const {
        $slots,
        mergedClsPrefix,
        description
      } = this;
      const rotate = $slots.icon && this.rotate;
      const descriptionNode = (description || $slots.description) && vue.h("div", {
        class: `${mergedClsPrefix}-spin-description`
      }, description || ((_a = $slots.description) === null || _a === void 0 ? void 0 : _a.call($slots)));
      const icon = $slots.icon ? vue.h("div", {
        class: [`${mergedClsPrefix}-spin-body`, this.themeClass]
      }, vue.h("div", {
        class: [`${mergedClsPrefix}-spin`, rotate && `${mergedClsPrefix}-spin--rotate`],
        style: $slots.default ? "" : this.cssVars
      }, $slots.icon()), descriptionNode) : vue.h("div", {
        class: [`${mergedClsPrefix}-spin-body`, this.themeClass]
      }, vue.h(NBaseLoading, {
        clsPrefix: mergedClsPrefix,
        style: $slots.default ? "" : this.cssVars,
        stroke: this.stroke,
        "stroke-width": this.mergedStrokeWidth,
        class: `${mergedClsPrefix}-spin`
      }), descriptionNode);
      (_b = this.onRender) === null || _b === void 0 ? void 0 : _b.call(this);
      return $slots.default ? vue.h("div", {
        class: [`${mergedClsPrefix}-spin-container`, this.themeClass],
        style: this.cssVars
      }, vue.h("div", {
        class: [`${mergedClsPrefix}-spin-content`, this.active && `${mergedClsPrefix}-spin-content--spinning`, this.contentClass],
        style: this.contentStyle
      }, $slots), vue.h(vue.Transition, {
        name: "fade-in-transition"
      }, {
        default: () => this.active ? icon : null
      })) : icon;
    }
  });
  function self$1(vars) {
    const {
      primaryColorHover,
      borderColor
    } = vars;
    return {
      resizableTriggerColorHover: primaryColorHover,
      resizableTriggerColor: borderColor
    };
  }
  const themeLight = {
    name: "Split",
    common: commonLight,
    self: self$1
  };
  const splitLight = themeLight;
  const style$j = cB("split", `
 display: flex;
 width: 100%;
 height: 100%;
`, [cM("horizontal", `
 flex-direction: row;
 `), cM("vertical", `
 flex-direction: column;
 `), cB("split-pane-1", `
 overflow: hidden;
 `), cB("split-pane-2", `
 overflow: hidden;
 flex: 1;
 `), cE("resize-trigger", `
 background-color: var(--n-resize-trigger-color);
 transition: background-color .3s var(--n-bezier);
 `, [cM("hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `), c$1("&:hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `)])]);
  const splitProps = Object.assign(Object.assign({}, useTheme.props), {
    direction: {
      type: String,
      default: "horizontal"
    },
    resizeTriggerSize: {
      type: Number,
      default: 3
    },
    disabled: Boolean,
    defaultSize: {
      type: [String, Number],
      default: 0.5
    },
    "onUpdate:size": [Function, Array],
    onUpdateSize: [Function, Array],
    size: [String, Number],
    min: {
      type: [String, Number],
      default: 0
    },
    max: {
      type: [String, Number],
      default: 1
    },
    pane1Class: String,
    pane1Style: [Object, String],
    pane2Class: String,
    pane2Style: [Object, String],
    onDragStart: Function,
    onDragMove: Function,
    onDragEnd: Function,
    watchProps: Array
  });
  const Split = vue.defineComponent({
    name: "Split",
    props: splitProps,
    setup(props) {
      var _a;
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Split", "-split", style$j, splitLight, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            resizableTriggerColor,
            resizableTriggerColorHover
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-resize-trigger-color": resizableTriggerColor,
          "--n-resize-trigger-color-hover": resizableTriggerColorHover
        };
      });
      const resizeTriggerElRef = vue.ref(null);
      const isDraggingRef = vue.ref(false);
      const controlledSizeRef = vue.toRef(props, "size");
      const uncontrolledSizeRef = vue.ref(props.defaultSize);
      if ((_a = props.watchProps) === null || _a === void 0 ? void 0 : _a.includes("defaultSize")) {
        vue.watchEffect(() => uncontrolledSizeRef.value = props.defaultSize);
      }
      const doUpdateSize = (size2) => {
        const _onUpdateSize = props["onUpdate:size"];
        if (props.onUpdateSize)
          call(props.onUpdateSize, size2);
        if (_onUpdateSize)
          call(_onUpdateSize, size2);
        uncontrolledSizeRef.value = size2;
      };
      const mergedSizeRef = useMergedState(controlledSizeRef, uncontrolledSizeRef);
      const firstPaneStyle = vue.computed(() => {
        const sizeValue = mergedSizeRef.value;
        if (typeof sizeValue === "string") {
          return {
            flex: `0 0 ${sizeValue}`
          };
        } else if (typeof sizeValue === "number") {
          const size2 = sizeValue * 100;
          return {
            flex: `0 0 calc(${size2}% - ${props.resizeTriggerSize * size2 / 100}px)`
          };
        }
      });
      const resizeTriggerStyle = vue.computed(() => {
        return props.direction === "horizontal" ? {
          width: `${props.resizeTriggerSize}px`,
          height: "100%"
        } : {
          width: "100%",
          height: `${props.resizeTriggerSize}px`
        };
      });
      const resizeTriggerWrapperStyle = vue.computed(() => {
        const horizontal = props.direction === "horizontal";
        return {
          width: horizontal ? `${props.resizeTriggerSize}px` : "",
          height: horizontal ? "" : `${props.resizeTriggerSize}px`,
          cursor: props.direction === "horizontal" ? "col-resize" : "row-resize"
        };
      });
      let offset = 0;
      const handleMouseDown = (e) => {
        e.preventDefault();
        isDraggingRef.value = true;
        if (props.onDragStart)
          props.onDragStart(e);
        const mouseMoveEvent = "mousemove";
        const mouseUpEvent = "mouseup";
        const onMouseMove = (e2) => {
          updateSize(e2);
          if (props.onDragMove)
            props.onDragMove(e2);
        };
        const onMouseUp = () => {
          off(mouseMoveEvent, document, onMouseMove);
          off(mouseUpEvent, document, onMouseUp);
          isDraggingRef.value = false;
          if (props.onDragEnd)
            props.onDragEnd(e);
          document.body.style.cursor = "";
        };
        document.body.style.cursor = resizeTriggerWrapperStyle.value.cursor;
        on(mouseMoveEvent, document, onMouseMove);
        on(mouseUpEvent, document, onMouseUp);
        const resizeTriggerEl = resizeTriggerElRef.value;
        if (resizeTriggerEl) {
          const elRect = resizeTriggerEl.getBoundingClientRect();
          if (props.direction === "horizontal") {
            offset = e.clientX - elRect.left;
          } else {
            offset = elRect.top - e.clientY;
          }
        }
        updateSize(e);
      };
      function updateSize(event) {
        var _a2, _b;
        const containerRect = (_b = (_a2 = resizeTriggerElRef.value) === null || _a2 === void 0 ? void 0 : _a2.parentElement) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect();
        if (!containerRect)
          return;
        const {
          direction
        } = props;
        const containerUsableWidth = containerRect.width - props.resizeTriggerSize;
        const containerUsableHeight = containerRect.height - props.resizeTriggerSize;
        const containerUsableSize = direction === "horizontal" ? containerUsableWidth : containerUsableHeight;
        const newPxSize = direction === "horizontal" ? event.clientX - containerRect.left - offset : event.clientY - containerRect.top + offset;
        const {
          min,
          max
        } = props;
        const pxMin = typeof min === "string" ? depx(min) : min * containerUsableSize;
        const pxMax = typeof max === "string" ? depx(max) : max * containerUsableSize;
        let nextPxSize = newPxSize;
        nextPxSize = Math.max(nextPxSize, pxMin);
        nextPxSize = Math.min(nextPxSize, pxMax, containerUsableSize);
        if (typeof mergedSizeRef.value === "string") {
          doUpdateSize(`${nextPxSize}px`);
        } else {
          doUpdateSize(nextPxSize / containerUsableSize);
        }
      }
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("split", void 0, cssVarsRef, props) : void 0;
      return {
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        resizeTriggerElRef,
        isDragging: isDraggingRef,
        mergedClsPrefix: mergedClsPrefixRef,
        resizeTriggerWrapperStyle,
        resizeTriggerStyle,
        handleMouseDown,
        firstPaneStyle
      };
    },
    render() {
      var _a, _b, _c, _d, _e;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      return vue.h("div", {
        class: [`${this.mergedClsPrefix}-split`, `${this.mergedClsPrefix}-split--${this.direction}`, this.themeClass],
        style: this.cssVars
      }, vue.h("div", {
        class: [`${this.mergedClsPrefix}-split-pane-1`, this.pane1Class],
        style: [this.firstPaneStyle, this.pane1Style]
      }, (_c = (_b = this.$slots)[1]) === null || _c === void 0 ? void 0 : _c.call(_b)), !this.disabled && vue.h("div", {
        ref: "resizeTriggerElRef",
        class: `${this.mergedClsPrefix}-split__resize-trigger-wrapper`,
        style: this.resizeTriggerWrapperStyle,
        onMousedown: this.handleMouseDown
      }, resolveSlot(this.$slots["resize-trigger"], () => [vue.h("div", {
        style: this.resizeTriggerStyle,
        class: [`${this.mergedClsPrefix}-split__resize-trigger`, this.isDragging && `${this.mergedClsPrefix}-split__resize-trigger--hover`]
      })])), vue.h("div", {
        class: [`${this.mergedClsPrefix}-split-pane-2`, this.pane2Class],
        style: this.pane2Style
      }, (_e = (_d = this.$slots)[2]) === null || _e === void 0 ? void 0 : _e.call(_d)));
    }
  });
  const style$i = cB("statistic", [cE("label", `
 font-weight: var(--n-label-font-weight);
 transition: .3s color var(--n-bezier);
 font-size: var(--n-label-font-size);
 color: var(--n-label-text-color);
 `), cB("statistic-value", `
 margin-top: 4px;
 font-weight: var(--n-value-font-weight);
 `, [cE("prefix", `
 margin: 0 4px 0 0;
 font-size: var(--n-value-font-size);
 transition: .3s color var(--n-bezier);
 color: var(--n-value-prefix-text-color);
 `, [cB("icon", {
    verticalAlign: "-0.125em"
  })]), cE("content", `
 font-size: var(--n-value-font-size);
 transition: .3s color var(--n-bezier);
 color: var(--n-value-text-color);
 `), cE("suffix", `
 margin: 0 0 0 4px;
 font-size: var(--n-value-font-size);
 transition: .3s color var(--n-bezier);
 color: var(--n-value-suffix-text-color);
 `, [cB("icon", {
    verticalAlign: "-0.125em"
  })])])]);
  const statisticProps = Object.assign(Object.assign({}, useTheme.props), {
    tabularNums: Boolean,
    label: String,
    value: [String, Number]
  });
  const Statistic = vue.defineComponent({
    name: "Statistic",
    props: statisticProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled,
        mergedRtlRef
      } = useConfig(props);
      const themeRef = useTheme("Statistic", "-statistic", style$i, statisticLight$1, props, mergedClsPrefixRef);
      const rtlEnabledRef = useRtl("Statistic", mergedRtlRef, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          self: {
            labelFontWeight,
            valueFontSize,
            valueFontWeight,
            valuePrefixTextColor,
            labelTextColor,
            valueSuffixTextColor,
            valueTextColor,
            labelFontSize
          },
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-label-font-size": labelFontSize,
          "--n-label-font-weight": labelFontWeight,
          "--n-label-text-color": labelTextColor,
          "--n-value-font-weight": valueFontWeight,
          "--n-value-font-size": valueFontSize,
          "--n-value-prefix-text-color": valuePrefixTextColor,
          "--n-value-suffix-text-color": valueSuffixTextColor,
          "--n-value-text-color": valueTextColor
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("statistic", void 0, cssVarsRef, props) : void 0;
      return {
        rtlEnabled: rtlEnabledRef,
        mergedClsPrefix: mergedClsPrefixRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a;
      const {
        mergedClsPrefix,
        $slots: {
          default: defaultSlot,
          label: labelSlot,
          prefix: prefixSlot,
          suffix: suffixSlot
        }
      } = this;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      return vue.h("div", {
        class: [`${mergedClsPrefix}-statistic`, this.themeClass, this.rtlEnabled && `${mergedClsPrefix}-statistic--rtl`],
        style: this.cssVars
      }, resolveWrappedSlot(labelSlot, (children) => vue.h("div", {
        class: `${mergedClsPrefix}-statistic__label`
      }, this.label || children)), vue.h("div", {
        class: `${mergedClsPrefix}-statistic-value`,
        style: {
          fontVariantNumeric: this.tabularNums ? "tabular-nums" : ""
        }
      }, resolveWrappedSlot(prefixSlot, (children) => children && vue.h("span", {
        class: `${mergedClsPrefix}-statistic-value__prefix`
      }, children)), this.value !== void 0 ? vue.h("span", {
        class: `${mergedClsPrefix}-statistic-value__content`
      }, this.value) : resolveWrappedSlot(defaultSlot, (children) => children && vue.h("span", {
        class: `${mergedClsPrefix}-statistic-value__content`
      }, children)), resolveWrappedSlot(suffixSlot, (children) => children && vue.h("span", {
        class: `${mergedClsPrefix}-statistic-value__suffix`
      }, children))));
    }
  });
  const style$h = cB("steps", `
 width: 100%;
 display: flex;
`, [cB("step", `
 position: relative;
 display: flex;
 flex: 1;
 `, [cM("disabled", "cursor: not-allowed"), cM("clickable", `
 cursor: pointer;
 `), c$1("&:last-child", [cB("step-splitor", "display: none;")])]), cB("step-splitor", `
 background-color: var(--n-splitor-color);
 margin-top: calc(var(--n-step-header-font-size) / 2);
 height: 1px;
 flex: 1;
 align-self: flex-start;
 margin-left: 12px;
 margin-right: 12px;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), cB("step-content", "flex: 1;", [cB("step-content-header", `
 color: var(--n-header-text-color);
 margin-top: calc(var(--n-indicator-size) / 2 - var(--n-step-header-font-size) / 2);
 line-height: var(--n-step-header-font-size);
 font-size: var(--n-step-header-font-size);
 position: relative;
 display: flex;
 font-weight: var(--n-step-header-font-weight);
 margin-left: 9px;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [cE("title", `
 white-space: nowrap;
 flex: 0;
 `)]), cE("description", `
 color: var(--n-description-text-color);
 margin-top: 12px;
 margin-left: 9px;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `)]), cB("step-indicator", `
 background-color: var(--n-indicator-color);
 box-shadow: 0 0 0 1px var(--n-indicator-border-color);
 height: var(--n-indicator-size);
 width: var(--n-indicator-size);
 border-radius: 50%;
 display: flex;
 align-items: center;
 justify-content: center;
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `, [cB("step-indicator-slot", `
 position: relative;
 width: var(--n-indicator-icon-size);
 height: var(--n-indicator-icon-size);
 font-size: var(--n-indicator-icon-size);
 line-height: var(--n-indicator-icon-size);
 `, [cE("index", `
 display: inline-block;
 text-align: center;
 position: absolute;
 left: 0;
 top: 0;
 white-space: nowrap;
 font-size: var(--n-indicator-index-font-size);
 width: var(--n-indicator-icon-size);
 height: var(--n-indicator-icon-size);
 line-height: var(--n-indicator-icon-size);
 color: var(--n-indicator-text-color);
 transition: color .3s var(--n-bezier);
 `, [iconSwitchTransition()]), cB("icon", `
 color: var(--n-indicator-text-color);
 transition: color .3s var(--n-bezier);
 `, [iconSwitchTransition()]), cB("base-icon", `
 color: var(--n-indicator-text-color);
 transition: color .3s var(--n-bezier);
 `, [iconSwitchTransition()])])]), cM("vertical", "flex-direction: column;", [cNotM("show-description", [c$1(">", [cB("step", "padding-bottom: 8px;")])]), c$1(">", [cB("step", "margin-bottom: 16px;", [c$1("&:last-child", "margin-bottom: 0;"), c$1(">", [cB("step-indicator", [c$1(">", [cB("step-splitor", `
 position: absolute;
 bottom: -8px;
 width: 1px;
 margin: 0 !important;
 left: calc(var(--n-indicator-size) / 2);
 height: calc(100% - var(--n-indicator-size));
 `)])]), cB("step-content", [cE("description", "margin-top: 8px;")])])])])])]);
  function stepWithIndex(step, i) {
    if (typeof step !== "object" || step === null || Array.isArray(step)) {
      return null;
    }
    if (!step.props)
      step.props = {};
    step.props.internalIndex = i + 1;
    return step;
  }
  function stepsWithIndex(steps) {
    return steps.map((step, i) => stepWithIndex(step, i));
  }
  const stepsProps = Object.assign(Object.assign({}, useTheme.props), {
    current: Number,
    status: {
      type: String,
      default: "process"
    },
    size: {
      type: String,
      default: "medium"
    },
    vertical: Boolean,
    "onUpdate:current": [Function, Array],
    onUpdateCurrent: [Function, Array]
  });
  const stepsInjectionKey = createInjectionKey("n-steps");
  const Steps = vue.defineComponent({
    name: "Steps",
    props: stepsProps,
    setup(props, {
      slots
    }) {
      const {
        mergedClsPrefixRef,
        mergedRtlRef
      } = useConfig(props);
      const rtlEnabledRef = useRtl("Steps", mergedRtlRef, mergedClsPrefixRef);
      const themeRef = useTheme("Steps", "-steps", style$h, stepsLight$1, props, mergedClsPrefixRef);
      vue.provide(stepsInjectionKey, {
        props,
        mergedThemeRef: themeRef,
        mergedClsPrefixRef,
        stepsSlots: slots
      });
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        rtlEnabled: rtlEnabledRef
      };
    },
    render() {
      const {
        mergedClsPrefix
      } = this;
      return vue.h("div", {
        class: [`${mergedClsPrefix}-steps`, this.rtlEnabled && `${mergedClsPrefix}-steps--rtl`, this.vertical && `${mergedClsPrefix}-steps--vertical`]
      }, stepsWithIndex(flatten$3(getSlot$1(this))));
    }
  });
  const stepProps = {
    status: String,
    title: String,
    description: String,
    disabled: Boolean,
    // index will be filled by parent steps, not user
    internalIndex: {
      type: Number,
      default: 0
    }
  };
  const Step = vue.defineComponent({
    name: "Step",
    props: stepProps,
    setup(props) {
      const NSteps = vue.inject(stepsInjectionKey, null);
      if (!NSteps)
        throwError("step", "`n-step` must be placed inside `n-steps`.");
      const {
        inlineThemeDisabled
      } = useConfig();
      const {
        props: stepsProps2,
        mergedThemeRef,
        mergedClsPrefixRef,
        stepsSlots
      } = NSteps;
      const verticalRef = vue.computed(() => {
        return stepsProps2.vertical;
      });
      const mergedStatusRef = vue.computed(() => {
        const {
          status
        } = props;
        if (status) {
          return status;
        } else {
          const {
            internalIndex
          } = props;
          const {
            current
          } = stepsProps2;
          if (current === void 0)
            return "process";
          if (internalIndex < current) {
            return "finish";
          } else if (internalIndex === current) {
            return stepsProps2.status || "process";
          } else if (internalIndex > current) {
            return "wait";
          }
        }
        return "process";
      });
      const cssVarsRef = vue.computed(() => {
        const {
          value: status
        } = mergedStatusRef;
        const {
          size: size2
        } = stepsProps2;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            stepHeaderFontWeight,
            [createKey("stepHeaderFontSize", size2)]: stepHeaderFontSize,
            [createKey("indicatorIndexFontSize", size2)]: indicatorIndexFontSize,
            [createKey("indicatorSize", size2)]: indicatorSize,
            [createKey("indicatorIconSize", size2)]: indicatorIconSize,
            [createKey("indicatorTextColor", status)]: indicatorTextColor,
            [createKey("indicatorBorderColor", status)]: indicatorBorderColor,
            [createKey("headerTextColor", status)]: headerTextColor,
            [createKey("splitorColor", status)]: splitorColor,
            [createKey("indicatorColor", status)]: indicatorColor,
            [createKey("descriptionTextColor", status)]: descriptionTextColor
          }
        } = mergedThemeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-description-text-color": descriptionTextColor,
          "--n-header-text-color": headerTextColor,
          "--n-indicator-border-color": indicatorBorderColor,
          "--n-indicator-color": indicatorColor,
          "--n-indicator-icon-size": indicatorIconSize,
          "--n-indicator-index-font-size": indicatorIndexFontSize,
          "--n-indicator-size": indicatorSize,
          "--n-indicator-text-color": indicatorTextColor,
          "--n-splitor-color": splitorColor,
          "--n-step-header-font-size": stepHeaderFontSize,
          "--n-step-header-font-weight": stepHeaderFontWeight
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("step", vue.computed(() => {
        const {
          value: status
        } = mergedStatusRef;
        const {
          size: size2
        } = stepsProps2;
        return `${status[0]}${size2[0]}`;
      }), cssVarsRef, stepsProps2) : void 0;
      const handleStepClick = vue.computed(() => {
        if (props.disabled)
          return void 0;
        const {
          onUpdateCurrent,
          "onUpdate:current": _onUpdateCurrent
        } = stepsProps2;
        return onUpdateCurrent || _onUpdateCurrent ? () => {
          if (onUpdateCurrent) {
            call(onUpdateCurrent, props.internalIndex);
          }
          if (_onUpdateCurrent) {
            call(_onUpdateCurrent, props.internalIndex);
          }
        } : void 0;
      });
      return {
        stepsSlots,
        mergedClsPrefix: mergedClsPrefixRef,
        vertical: verticalRef,
        mergedStatus: mergedStatusRef,
        handleStepClick,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      const {
        mergedClsPrefix,
        onRender,
        handleStepClick,
        disabled
      } = this;
      const descriptionNode = resolveWrappedSlot(this.$slots.default, (children) => {
        const mergedDescription = children || this.description;
        if (mergedDescription) {
          return vue.h("div", {
            class: `${mergedClsPrefix}-step-content__description`
          }, mergedDescription);
        }
        return null;
      });
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h("div", {
        class: [`${mergedClsPrefix}-step`, disabled && `${mergedClsPrefix}-step--disabled`, !disabled && handleStepClick && `${mergedClsPrefix}-step--clickable`, this.themeClass, descriptionNode && `${mergedClsPrefix}-step--show-description`, `${mergedClsPrefix}-step--${this.mergedStatus}-status`],
        style: this.cssVars,
        onClick: handleStepClick
      }, vue.h("div", {
        class: `${mergedClsPrefix}-step-indicator`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-step-indicator-slot`
      }, vue.h(NIconSwitchTransition, null, {
        default: () => {
          return resolveWrappedSlot(this.$slots.icon, (icon) => {
            const {
              mergedStatus,
              stepsSlots
            } = this;
            return !(mergedStatus === "finish" || mergedStatus === "error") ? icon || vue.h("div", {
              key: this.internalIndex,
              class: `${mergedClsPrefix}-step-indicator-slot__index`
            }, this.internalIndex) : mergedStatus === "finish" ? vue.h(NBaseIcon, {
              clsPrefix: mergedClsPrefix,
              key: "finish"
            }, {
              default: () => resolveSlot(stepsSlots["finish-icon"], () => [vue.h(FinishedIcon, null)])
            }) : mergedStatus === "error" ? vue.h(NBaseIcon, {
              clsPrefix: mergedClsPrefix,
              key: "error"
            }, {
              default: () => resolveSlot(stepsSlots["error-icon"], () => [vue.h(ErrorIcon$1, null)])
            }) : null;
          });
        }
      })), this.vertical ? vue.h("div", {
        class: `${mergedClsPrefix}-step-splitor`
      }) : null), vue.h("div", {
        class: `${mergedClsPrefix}-step-content`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-step-content-header`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-step-content-header__title`
      }, resolveSlot(this.$slots.title, () => [this.title])), !this.vertical ? vue.h("div", {
        class: `${mergedClsPrefix}-step-splitor`
      }) : null), descriptionNode));
    }
  });
  const style$g = cB("switch", `
 height: var(--n-height);
 min-width: var(--n-width);
 vertical-align: middle;
 user-select: none;
 -webkit-user-select: none;
 display: inline-flex;
 outline: none;
 justify-content: center;
 align-items: center;
`, [cE("children-placeholder", `
 height: var(--n-rail-height);
 display: flex;
 flex-direction: column;
 overflow: hidden;
 pointer-events: none;
 visibility: hidden;
 `), cE("rail-placeholder", `
 display: flex;
 flex-wrap: none;
 `), cE("button-placeholder", `
 width: calc(1.75 * var(--n-rail-height));
 height: var(--n-rail-height);
 `), cB("base-loading", `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 font-size: calc(var(--n-button-width) - 4px);
 color: var(--n-loading-color);
 transition: color .3s var(--n-bezier);
 `, [iconSwitchTransition({
    left: "50%",
    top: "50%",
    originalTransform: "translateX(-50%) translateY(-50%)"
  })]), cE("checked, unchecked", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 box-sizing: border-box;
 position: absolute;
 white-space: nowrap;
 top: 0;
 bottom: 0;
 display: flex;
 align-items: center;
 line-height: 1;
 `), cE("checked", `
 right: 0;
 padding-right: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), cE("unchecked", `
 left: 0;
 justify-content: flex-end;
 padding-left: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), c$1("&:focus", [cE("rail", `
 box-shadow: var(--n-box-shadow-focus);
 `)]), cM("round", [cE("rail", "border-radius: calc(var(--n-rail-height) / 2);", [cE("button", "border-radius: calc(var(--n-button-height) / 2);")])]), cNotM("disabled", [cNotM("icon", [cM("rubber-band", [cM("pressed", [cE("rail", [cE("button", "max-width: var(--n-button-width-pressed);")])]), cE("rail", [c$1("&:active", [cE("button", "max-width: var(--n-button-width-pressed);")])]), cM("active", [cM("pressed", [cE("rail", [cE("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])]), cE("rail", [c$1("&:active", [cE("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])])])])])]), cM("active", [cE("rail", [cE("button", "left: calc(100% - var(--n-button-width) - var(--n-offset))")])]), cE("rail", `
 overflow: hidden;
 height: var(--n-rail-height);
 min-width: var(--n-rail-width);
 border-radius: var(--n-rail-border-radius);
 cursor: pointer;
 position: relative;
 transition:
 opacity .3s var(--n-bezier),
 background .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-rail-color);
 `, [cE("button-icon", `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 font-size: calc(var(--n-button-height) - 4px);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 line-height: 1;
 `, [iconSwitchTransition()]), cE("button", `
 align-items: center; 
 top: var(--n-offset);
 left: var(--n-offset);
 height: var(--n-button-height);
 width: var(--n-button-width-pressed);
 max-width: var(--n-button-width);
 border-radius: var(--n-button-border-radius);
 background-color: var(--n-button-color);
 box-shadow: var(--n-button-box-shadow);
 box-sizing: border-box;
 cursor: inherit;
 content: "";
 position: absolute;
 transition:
 background-color .3s var(--n-bezier),
 left .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 max-width .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `)]), cM("active", [cE("rail", "background-color: var(--n-rail-color-active);")]), cM("loading", [cE("rail", `
 cursor: wait;
 `)]), cM("disabled", [cE("rail", `
 cursor: not-allowed;
 opacity: .5;
 `)])]);
  const switchProps = Object.assign(Object.assign({}, useTheme.props), {
    size: {
      type: String,
      default: "medium"
    },
    value: {
      type: [String, Number, Boolean],
      default: void 0
    },
    loading: Boolean,
    defaultValue: {
      type: [String, Number, Boolean],
      default: false
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    round: {
      type: Boolean,
      default: true
    },
    "onUpdate:value": [Function, Array],
    onUpdateValue: [Function, Array],
    checkedValue: {
      type: [String, Number, Boolean],
      default: true
    },
    uncheckedValue: {
      type: [String, Number, Boolean],
      default: false
    },
    railStyle: Function,
    rubberBand: {
      type: Boolean,
      default: true
    },
    /** @deprecated */
    onChange: [Function, Array]
  });
  let supportCssMax;
  const Switch = vue.defineComponent({
    name: "Switch",
    props: switchProps,
    setup(props) {
      {
        vue.watchEffect(() => {
          if (props.onChange) {
            warnOnce("switch", "`on-change` is deprecated, please use `on-update:value` instead.");
          }
        });
      }
      if (supportCssMax === void 0) {
        if (typeof CSS !== "undefined") {
          if (typeof CSS.supports !== "undefined") {
            supportCssMax = CSS.supports("width", "max(1px)");
          } else {
            supportCssMax = false;
          }
        } else {
          supportCssMax = true;
        }
      }
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Switch", "-switch", style$g, switchLight$1, props, mergedClsPrefixRef);
      const formItem = useFormItem(props);
      const {
        mergedSizeRef,
        mergedDisabledRef
      } = formItem;
      const uncontrolledValueRef = vue.ref(props.defaultValue);
      const controlledValueRef = vue.toRef(props, "value");
      const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
      const checkedRef = vue.computed(() => {
        return mergedValueRef.value === props.checkedValue;
      });
      const pressedRef = vue.ref(false);
      const focusedRef = vue.ref(false);
      const mergedRailStyleRef = vue.computed(() => {
        const {
          railStyle
        } = props;
        if (!railStyle)
          return void 0;
        return railStyle({
          focused: focusedRef.value,
          checked: checkedRef.value
        });
      });
      function doUpdateValue(value) {
        const {
          "onUpdate:value": _onUpdateValue,
          onChange,
          onUpdateValue
        } = props;
        const {
          nTriggerFormInput,
          nTriggerFormChange
        } = formItem;
        if (_onUpdateValue)
          call(_onUpdateValue, value);
        if (onUpdateValue)
          call(onUpdateValue, value);
        if (onChange)
          call(onChange, value);
        uncontrolledValueRef.value = value;
        nTriggerFormInput();
        nTriggerFormChange();
      }
      function doFocus() {
        const {
          nTriggerFormFocus
        } = formItem;
        nTriggerFormFocus();
      }
      function doBlur() {
        const {
          nTriggerFormBlur
        } = formItem;
        nTriggerFormBlur();
      }
      function handleClick2() {
        if (props.loading || mergedDisabledRef.value)
          return;
        if (mergedValueRef.value !== props.checkedValue) {
          doUpdateValue(props.checkedValue);
        } else {
          doUpdateValue(props.uncheckedValue);
        }
      }
      function handleFocus() {
        focusedRef.value = true;
        doFocus();
      }
      function handleBlur() {
        focusedRef.value = false;
        doBlur();
        pressedRef.value = false;
      }
      function handleKeyup(e) {
        if (props.loading || mergedDisabledRef.value)
          return;
        if (e.key === " ") {
          if (mergedValueRef.value !== props.checkedValue) {
            doUpdateValue(props.checkedValue);
          } else {
            doUpdateValue(props.uncheckedValue);
          }
          pressedRef.value = false;
        }
      }
      function handleKeydown(e) {
        if (props.loading || mergedDisabledRef.value)
          return;
        if (e.key === " ") {
          e.preventDefault();
          pressedRef.value = true;
        }
      }
      const cssVarsRef = vue.computed(() => {
        const {
          value: size2
        } = mergedSizeRef;
        const {
          self: {
            opacityDisabled,
            railColor,
            railColorActive,
            buttonBoxShadow,
            buttonColor,
            boxShadowFocus,
            loadingColor,
            textColor,
            iconColor,
            [createKey("buttonHeight", size2)]: buttonHeight,
            [createKey("buttonWidth", size2)]: buttonWidth,
            [createKey("buttonWidthPressed", size2)]: buttonWidthPressed,
            [createKey("railHeight", size2)]: railHeight,
            [createKey("railWidth", size2)]: railWidth,
            [createKey("railBorderRadius", size2)]: railBorderRadius,
            [createKey("buttonBorderRadius", size2)]: buttonBorderRadius
          },
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          }
        } = themeRef.value;
        let offset;
        let height;
        let width;
        if (supportCssMax) {
          offset = `calc((${railHeight} - ${buttonHeight}) / 2)`;
          height = `max(${railHeight}, ${buttonHeight})`;
          width = `max(${railWidth}, calc(${railWidth} + ${buttonHeight} - ${railHeight}))`;
        } else {
          offset = pxfy((depx(railHeight) - depx(buttonHeight)) / 2);
          height = pxfy(Math.max(depx(railHeight), depx(buttonHeight)));
          width = depx(railHeight) > depx(buttonHeight) ? railWidth : pxfy(depx(railWidth) + depx(buttonHeight) - depx(railHeight));
        }
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-button-border-radius": buttonBorderRadius,
          "--n-button-box-shadow": buttonBoxShadow,
          "--n-button-color": buttonColor,
          "--n-button-width": buttonWidth,
          "--n-button-width-pressed": buttonWidthPressed,
          "--n-button-height": buttonHeight,
          "--n-height": height,
          "--n-offset": offset,
          "--n-opacity-disabled": opacityDisabled,
          "--n-rail-border-radius": railBorderRadius,
          "--n-rail-color": railColor,
          "--n-rail-color-active": railColorActive,
          "--n-rail-height": railHeight,
          "--n-rail-width": railWidth,
          "--n-width": width,
          "--n-box-shadow-focus": boxShadowFocus,
          "--n-loading-color": loadingColor,
          "--n-text-color": textColor,
          "--n-icon-color": iconColor
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("switch", vue.computed(() => {
        return mergedSizeRef.value[0];
      }), cssVarsRef, props) : void 0;
      return {
        handleClick: handleClick2,
        handleBlur,
        handleFocus,
        handleKeyup,
        handleKeydown,
        mergedRailStyle: mergedRailStyleRef,
        pressed: pressedRef,
        mergedClsPrefix: mergedClsPrefixRef,
        mergedValue: mergedValueRef,
        checked: checkedRef,
        mergedDisabled: mergedDisabledRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      const {
        mergedClsPrefix,
        mergedDisabled,
        checked,
        mergedRailStyle,
        onRender,
        $slots
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      const {
        checked: checkedSlot,
        unchecked: uncheckedSlot,
        icon: iconSlot,
        "checked-icon": checkedIconSlot,
        "unchecked-icon": uncheckedIconSlot
      } = $slots;
      const hasIcon = !(isSlotEmpty(iconSlot) && isSlotEmpty(checkedIconSlot) && isSlotEmpty(uncheckedIconSlot));
      return vue.h("div", {
        role: "switch",
        "aria-checked": checked,
        class: [`${mergedClsPrefix}-switch`, this.themeClass, hasIcon && `${mergedClsPrefix}-switch--icon`, checked && `${mergedClsPrefix}-switch--active`, mergedDisabled && `${mergedClsPrefix}-switch--disabled`, this.round && `${mergedClsPrefix}-switch--round`, this.loading && `${mergedClsPrefix}-switch--loading`, this.pressed && `${mergedClsPrefix}-switch--pressed`, this.rubberBand && `${mergedClsPrefix}-switch--rubber-band`],
        tabindex: !this.mergedDisabled ? 0 : void 0,
        style: this.cssVars,
        onClick: this.handleClick,
        onFocus: this.handleFocus,
        onBlur: this.handleBlur,
        onKeyup: this.handleKeyup,
        onKeydown: this.handleKeydown
      }, vue.h("div", {
        class: `${mergedClsPrefix}-switch__rail`,
        "aria-hidden": "true",
        style: mergedRailStyle
      }, resolveWrappedSlot(checkedSlot, (checkedSlotChildren) => resolveWrappedSlot(uncheckedSlot, (uncheckedSlotChildren) => {
        if (checkedSlotChildren || uncheckedSlotChildren) {
          return vue.h("div", {
            "aria-hidden": true,
            class: `${mergedClsPrefix}-switch__children-placeholder`
          }, vue.h("div", {
            class: `${mergedClsPrefix}-switch__rail-placeholder`
          }, vue.h("div", {
            class: `${mergedClsPrefix}-switch__button-placeholder`
          }), checkedSlotChildren), vue.h("div", {
            class: `${mergedClsPrefix}-switch__rail-placeholder`
          }, vue.h("div", {
            class: `${mergedClsPrefix}-switch__button-placeholder`
          }), uncheckedSlotChildren));
        }
        return null;
      })), vue.h("div", {
        class: `${mergedClsPrefix}-switch__button`
      }, resolveWrappedSlot(iconSlot, (icon) => resolveWrappedSlot(checkedIconSlot, (checkedIcon) => resolveWrappedSlot(uncheckedIconSlot, (uncheckedIcon) => {
        return vue.h(NIconSwitchTransition, null, {
          default: () => this.loading ? vue.h(NBaseLoading, {
            key: "loading",
            clsPrefix: mergedClsPrefix,
            strokeWidth: 20
          }) : this.checked && (checkedIcon || icon) ? vue.h("div", {
            class: `${mergedClsPrefix}-switch__button-icon`,
            key: checkedIcon ? "checked-icon" : "icon"
          }, checkedIcon || icon) : !this.checked && (uncheckedIcon || icon) ? vue.h("div", {
            class: `${mergedClsPrefix}-switch__button-icon`,
            key: uncheckedIcon ? "unchecked-icon" : "icon"
          }, uncheckedIcon || icon) : null
        });
      }))), resolveWrappedSlot(checkedSlot, (children) => children && vue.h("div", {
        key: "checked",
        class: `${mergedClsPrefix}-switch__checked`
      }, children)), resolveWrappedSlot(uncheckedSlot, (children) => children && vue.h("div", {
        key: "unchecked",
        class: `${mergedClsPrefix}-switch__unchecked`
      }, children)))));
    }
  });
  const style$f = c$1([cB("table", `
 font-size: var(--n-font-size);
 font-variant-numeric: tabular-nums;
 line-height: var(--n-line-height);
 width: 100%;
 border-radius: var(--n-border-radius) var(--n-border-radius) 0 0;
 text-align: left;
 border-collapse: separate;
 border-spacing: 0;
 overflow: hidden;
 background-color: var(--n-td-color);
 border-color: var(--n-merged-border-color);
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 --n-merged-border-color: var(--n-border-color);
 `, [c$1("th", `
 white-space: nowrap;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 text-align: inherit;
 padding: var(--n-th-padding);
 vertical-align: inherit;
 text-transform: none;
 border: 0px solid var(--n-merged-border-color);
 font-weight: var(--n-th-font-weight);
 color: var(--n-th-text-color);
 background-color: var(--n-th-color);
 border-bottom: 1px solid var(--n-merged-border-color);
 border-right: 1px solid var(--n-merged-border-color);
 `, [c$1("&:last-child", `
 border-right: 0px solid var(--n-merged-border-color);
 `)]), c$1("td", `
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 padding: var(--n-td-padding);
 color: var(--n-td-text-color);
 background-color: var(--n-td-color);
 border: 0px solid var(--n-merged-border-color);
 border-right: 1px solid var(--n-merged-border-color);
 border-bottom: 1px solid var(--n-merged-border-color);
 `, [c$1("&:last-child", `
 border-right: 0px solid var(--n-merged-border-color);
 `)]), cM("bordered", `
 border: 1px solid var(--n-merged-border-color);
 border-radius: var(--n-border-radius);
 `, [c$1("tr", [c$1("&:last-child", [c$1("td", `
 border-bottom: 0 solid var(--n-merged-border-color);
 `)])])]), cM("single-line", [c$1("th", `
 border-right: 0px solid var(--n-merged-border-color);
 `), c$1("td", `
 border-right: 0px solid var(--n-merged-border-color);
 `)]), cM("single-column", [c$1("tr", [c$1("&:not(:last-child)", [c$1("td", `
 border-bottom: 0px solid var(--n-merged-border-color);
 `)])])]), cM("striped", [c$1("tr:nth-of-type(even)", [c$1("td", "background-color: var(--n-td-color-striped)")])]), cNotM("bottom-bordered", [c$1("tr", [c$1("&:last-child", [c$1("td", `
 border-bottom: 0px solid var(--n-merged-border-color);
 `)])])])]), insideModal(cB("table", `
 background-color: var(--n-td-color-modal);
 --n-merged-border-color: var(--n-border-color-modal);
 `, [c$1("th", `
 background-color: var(--n-th-color-modal);
 `), c$1("td", `
 background-color: var(--n-td-color-modal);
 `)])), insidePopover(cB("table", `
 background-color: var(--n-td-color-popover);
 --n-merged-border-color: var(--n-border-color-popover);
 `, [c$1("th", `
 background-color: var(--n-th-color-popover);
 `), c$1("td", `
 background-color: var(--n-td-color-popover);
 `)]))]);
  const tableProps = Object.assign(Object.assign({}, useTheme.props), {
    bordered: {
      type: Boolean,
      default: true
    },
    bottomBordered: {
      type: Boolean,
      default: true
    },
    singleLine: {
      type: Boolean,
      default: true
    },
    striped: Boolean,
    singleColumn: Boolean,
    size: {
      type: String,
      default: "medium"
    }
  });
  const Table = vue.defineComponent({
    name: "Table",
    props: tableProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled,
        mergedRtlRef
      } = useConfig(props);
      const themeRef = useTheme("Table", "-table", style$f, tableLight$1, props, mergedClsPrefixRef);
      const rtlEnabledRef = useRtl("Table", mergedRtlRef, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          size: size2
        } = props;
        const {
          self: {
            borderColor,
            tdColor,
            tdColorModal,
            tdColorPopover,
            thColor,
            thColorModal,
            thColorPopover,
            thTextColor,
            tdTextColor,
            borderRadius,
            thFontWeight,
            lineHeight: lineHeight2,
            borderColorModal,
            borderColorPopover,
            tdColorStriped,
            tdColorStripedModal,
            tdColorStripedPopover,
            [createKey("fontSize", size2)]: fontSize2,
            [createKey("tdPadding", size2)]: tdPadding,
            [createKey("thPadding", size2)]: thPadding
          },
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-td-color": tdColor,
          "--n-td-color-modal": tdColorModal,
          "--n-td-color-popover": tdColorPopover,
          "--n-td-text-color": tdTextColor,
          "--n-border-color": borderColor,
          "--n-border-color-modal": borderColorModal,
          "--n-border-color-popover": borderColorPopover,
          "--n-border-radius": borderRadius,
          "--n-font-size": fontSize2,
          "--n-th-color": thColor,
          "--n-th-color-modal": thColorModal,
          "--n-th-color-popover": thColorPopover,
          "--n-th-font-weight": thFontWeight,
          "--n-th-text-color": thTextColor,
          "--n-line-height": lineHeight2,
          "--n-td-padding": tdPadding,
          "--n-th-padding": thPadding,
          "--n-td-color-striped": tdColorStriped,
          "--n-td-color-striped-modal": tdColorStripedModal,
          "--n-td-color-striped-popover": tdColorStripedPopover
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("table", vue.computed(() => {
        return props.size[0];
      }), cssVarsRef, props) : void 0;
      return {
        rtlEnabled: rtlEnabledRef,
        mergedClsPrefix: mergedClsPrefixRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a;
      const {
        mergedClsPrefix
      } = this;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      return vue.h("table", {
        class: [`${mergedClsPrefix}-table`, this.themeClass, {
          [`${mergedClsPrefix}-table--rtl`]: this.rtlEnabled,
          [`${mergedClsPrefix}-table--bottom-bordered`]: this.bottomBordered,
          [`${mergedClsPrefix}-table--bordered`]: this.bordered,
          [`${mergedClsPrefix}-table--single-line`]: this.singleLine,
          [`${mergedClsPrefix}-table--single-column`]: this.singleColumn,
          [`${mergedClsPrefix}-table--striped`]: this.striped
        }],
        style: this.cssVars
      }, this.$slots);
    }
  });
  const Th = vue.defineComponent({
    name: "Th",
    render() {
      return vue.h("th", null, this.$slots);
    }
  });
  const Tr = vue.defineComponent({
    name: "Tr",
    render() {
      return vue.h("tr", null, this.$slots);
    }
  });
  const Td = vue.defineComponent({
    name: "Td",
    render() {
      return vue.h("td", null, this.$slots);
    }
  });
  const Thead = vue.defineComponent({
    name: "Thead",
    render() {
      return vue.h("thead", null, this.$slots);
    }
  });
  const Tbody = vue.defineComponent({
    name: "Tbody",
    render() {
      return vue.h("tbody", null, this.$slots);
    }
  });
  const tabsInjectionKey = createInjectionKey("n-tabs");
  const tabPaneProps = {
    tab: [String, Number, Object, Function],
    name: {
      type: [String, Number],
      required: true
    },
    disabled: Boolean,
    displayDirective: {
      type: String,
      default: "if"
    },
    closable: {
      type: Boolean,
      default: void 0
    },
    tabProps: Object,
    /** @deprecated */
    label: [String, Number, Object, Function]
  };
  const TabPane = vue.defineComponent({
    __TAB_PANE__: true,
    name: "TabPane",
    alias: ["TabPanel"],
    props: tabPaneProps,
    setup(props) {
      {
        vue.watchEffect(() => {
          if (props.label !== void 0) {
            warnOnce("tab-pane", "`label` is deprecated, please use `tab` instead.");
          }
        });
      }
      const NTab = vue.inject(tabsInjectionKey, null);
      if (!NTab) {
        throwError("tab-pane", "`n-tab-pane` must be placed inside `n-tabs`.");
      }
      return {
        style: NTab.paneStyleRef,
        class: NTab.paneClassRef,
        mergedClsPrefix: NTab.mergedClsPrefixRef
      };
    },
    render() {
      return vue.h("div", {
        class: [`${this.mergedClsPrefix}-tab-pane`, this.class],
        style: this.style
      }, this.$slots);
    }
  });
  const tabProps = Object.assign({
    internalLeftPadded: Boolean,
    internalAddable: Boolean,
    internalCreatedByPane: Boolean
  }, omit(tabPaneProps, ["displayDirective"]));
  const Tab = vue.defineComponent({
    __TAB__: true,
    inheritAttrs: false,
    name: "Tab",
    props: tabProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        valueRef,
        typeRef,
        closableRef,
        tabStyleRef,
        addTabStyleRef,
        tabClassRef,
        addTabClassRef,
        tabChangeIdRef,
        onBeforeLeaveRef,
        triggerRef,
        handleAdd,
        activateTab,
        handleClose
      } = vue.inject(tabsInjectionKey);
      return {
        trigger: triggerRef,
        mergedClosable: vue.computed(() => {
          if (props.internalAddable)
            return false;
          const {
            closable
          } = props;
          if (closable === void 0)
            return closableRef.value;
          return closable;
        }),
        style: tabStyleRef,
        addStyle: addTabStyleRef,
        tabClass: tabClassRef,
        addTabClass: addTabClassRef,
        clsPrefix: mergedClsPrefixRef,
        value: valueRef,
        type: typeRef,
        handleClose(e) {
          e.stopPropagation();
          if (props.disabled)
            return;
          handleClose(props.name);
        },
        activateTab() {
          if (props.disabled)
            return;
          if (props.internalAddable) {
            handleAdd();
            return;
          }
          const {
            name: nameProp
          } = props;
          const id = ++tabChangeIdRef.id;
          if (nameProp !== valueRef.value) {
            const {
              value: onBeforeLeave
            } = onBeforeLeaveRef;
            if (!onBeforeLeave) {
              activateTab(nameProp);
            } else {
              void Promise.resolve(onBeforeLeave(props.name, valueRef.value)).then((allowLeave) => {
                if (allowLeave && tabChangeIdRef.id === id) {
                  activateTab(nameProp);
                }
              });
            }
          }
        }
      };
    },
    render() {
      const {
        internalAddable,
        clsPrefix,
        name,
        disabled,
        label,
        tab,
        value,
        mergedClosable,
        trigger: trigger2,
        $slots: {
          default: defaultSlot
        }
      } = this;
      const mergedTab = label !== null && label !== void 0 ? label : tab;
      return vue.h("div", {
        class: `${clsPrefix}-tabs-tab-wrapper`
      }, this.internalLeftPadded ? vue.h("div", {
        class: `${clsPrefix}-tabs-tab-pad`
      }) : null, vue.h("div", Object.assign({
        key: name,
        "data-name": name,
        "data-disabled": disabled ? true : void 0
      }, vue.mergeProps({
        class: [`${clsPrefix}-tabs-tab`, value === name && `${clsPrefix}-tabs-tab--active`, disabled && `${clsPrefix}-tabs-tab--disabled`, mergedClosable && `${clsPrefix}-tabs-tab--closable`, internalAddable && `${clsPrefix}-tabs-tab--addable`, internalAddable ? this.addTabClass : this.tabClass],
        onClick: trigger2 === "click" ? this.activateTab : void 0,
        onMouseenter: trigger2 === "hover" ? this.activateTab : void 0,
        style: internalAddable ? this.addStyle : this.style
      }, this.internalCreatedByPane ? this.tabProps || {} : this.$attrs)), vue.h("span", {
        class: `${clsPrefix}-tabs-tab__label`
      }, internalAddable ? vue.h(vue.Fragment, null, vue.h("div", {
        class: `${clsPrefix}-tabs-tab__height-placeholder`
      }, " "), vue.h(NBaseIcon, {
        clsPrefix
      }, {
        default: () => vue.h(AddIcon, null)
      })) : defaultSlot ? defaultSlot() : typeof mergedTab === "object" ? mergedTab : render$1(mergedTab !== null && mergedTab !== void 0 ? mergedTab : name)), mergedClosable && this.type === "card" ? vue.h(NBaseClose, {
        clsPrefix,
        class: `${clsPrefix}-tabs-tab__close`,
        onClick: this.handleClose,
        disabled
      }) : null));
    }
  });
  const style$e = cB("tabs", `
 box-sizing: border-box;
 width: 100%;
 display: flex;
 flex-direction: column;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
`, [cM("segment-type", [cB("tabs-rail", [c$1("&.transition-disabled", [cB("tabs-capsule", `
 transition: none;
 `)])])]), cM("top", [cB("tab-pane", `
 padding: var(--n-pane-padding-top) var(--n-pane-padding-right) var(--n-pane-padding-bottom) var(--n-pane-padding-left);
 `)]), cM("left", [cB("tab-pane", `
 padding: var(--n-pane-padding-right) var(--n-pane-padding-bottom) var(--n-pane-padding-left) var(--n-pane-padding-top);
 `)]), cM("left, right", `
 flex-direction: row;
 `, [cB("tabs-bar", `
 width: 2px;
 right: 0;
 transition:
 top .2s var(--n-bezier),
 max-height .2s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), cB("tabs-tab", `
 padding: var(--n-tab-padding-vertical); 
 `)]), cM("right", `
 flex-direction: row-reverse;
 `, [cB("tab-pane", `
 padding: var(--n-pane-padding-left) var(--n-pane-padding-top) var(--n-pane-padding-right) var(--n-pane-padding-bottom);
 `), cB("tabs-bar", `
 left: 0;
 `)]), cM("bottom", `
 flex-direction: column-reverse;
 justify-content: flex-end;
 `, [cB("tab-pane", `
 padding: var(--n-pane-padding-bottom) var(--n-pane-padding-right) var(--n-pane-padding-top) var(--n-pane-padding-left);
 `), cB("tabs-bar", `
 top: 0;
 `)]), cB("tabs-rail", `
 position: relative;
 padding: 3px;
 border-radius: var(--n-tab-border-radius);
 width: 100%;
 background-color: var(--n-color-segment);
 transition: background-color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 `, [cB("tabs-capsule", `
 border-radius: var(--n-tab-border-radius);
 position: absolute;
 pointer-events: none;
 background-color: var(--n-tab-color-segment);
 box-shadow: 0 1px 3px 0 rgba(0, 0, 0, .08);
 transition: transform 0.3s var(--n-bezier);
 `), cB("tabs-tab-wrapper", `
 flex-basis: 0;
 flex-grow: 1;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [cB("tabs-tab", `
 overflow: hidden;
 border-radius: var(--n-tab-border-radius);
 width: 100%;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [cM("active", `
 font-weight: var(--n-font-weight-strong);
 color: var(--n-tab-text-color-active);
 `), c$1("&:hover", `
 color: var(--n-tab-text-color-hover);
 `)])])]), cM("flex", [cB("tabs-nav", `
 width: 100%;
 position: relative;
 `, [cB("tabs-wrapper", `
 width: 100%;
 `, [cB("tabs-tab", `
 margin-right: 0;
 `)])])]), cB("tabs-nav", `
 box-sizing: border-box;
 line-height: 1.5;
 display: flex;
 transition: border-color .3s var(--n-bezier);
 `, [cE("prefix, suffix", `
 display: flex;
 align-items: center;
 `), cE("prefix", "padding-right: 16px;"), cE("suffix", "padding-left: 16px;")]), cM("top, bottom", [cB("tabs-nav-scroll-wrapper", [c$1("&::before", `
 top: 0;
 bottom: 0;
 left: 0;
 width: 20px;
 `), c$1("&::after", `
 top: 0;
 bottom: 0;
 right: 0;
 width: 20px;
 `), cM("shadow-start", [c$1("&::before", `
 box-shadow: inset 10px 0 8px -8px rgba(0, 0, 0, .12);
 `)]), cM("shadow-end", [c$1("&::after", `
 box-shadow: inset -10px 0 8px -8px rgba(0, 0, 0, .12);
 `)])])]), cM("left, right", [cB("tabs-nav-scroll-content", `
 flex-direction: column;
 `), cB("tabs-nav-scroll-wrapper", [c$1("&::before", `
 top: 0;
 left: 0;
 right: 0;
 height: 20px;
 `), c$1("&::after", `
 bottom: 0;
 left: 0;
 right: 0;
 height: 20px;
 `), cM("shadow-start", [c$1("&::before", `
 box-shadow: inset 0 10px 8px -8px rgba(0, 0, 0, .12);
 `)]), cM("shadow-end", [c$1("&::after", `
 box-shadow: inset 0 -10px 8px -8px rgba(0, 0, 0, .12);
 `)])])]), cB("tabs-nav-scroll-wrapper", `
 flex: 1;
 position: relative;
 overflow: hidden;
 `, [cB("tabs-nav-y-scroll", `
 height: 100%;
 width: 100%;
 overflow-y: auto; 
 scrollbar-width: none;
 `, [c$1("&::-webkit-scrollbar", `
 width: 0;
 height: 0;
 `)]), c$1("&::before, &::after", `
 transition: box-shadow .3s var(--n-bezier);
 pointer-events: none;
 content: "";
 position: absolute;
 z-index: 1;
 `)]), cB("tabs-nav-scroll-content", `
 display: flex;
 position: relative;
 min-width: 100%;
 min-height: 100%;
 width: fit-content;
 box-sizing: border-box;
 `), cB("tabs-wrapper", `
 display: inline-flex;
 flex-wrap: nowrap;
 position: relative;
 `), cB("tabs-tab-wrapper", `
 display: flex;
 flex-wrap: nowrap;
 flex-shrink: 0;
 flex-grow: 0;
 `), cB("tabs-tab", `
 cursor: pointer;
 white-space: nowrap;
 flex-wrap: nowrap;
 display: inline-flex;
 align-items: center;
 color: var(--n-tab-text-color);
 font-size: var(--n-tab-font-size);
 background-clip: padding-box;
 padding: var(--n-tab-padding);
 transition:
 box-shadow .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cM("disabled", {
    cursor: "not-allowed"
  }), cE("close", `
 margin-left: 6px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), cE("label", `
 display: flex;
 align-items: center;
 z-index: 1;
 `)]), cB("tabs-bar", `
 position: absolute;
 bottom: 0;
 height: 2px;
 border-radius: 1px;
 background-color: var(--n-bar-color);
 transition:
 left .2s var(--n-bezier),
 max-width .2s var(--n-bezier),
 opacity .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [c$1("&.transition-disabled", `
 transition: none;
 `), cM("disabled", `
 background-color: var(--n-tab-text-color-disabled)
 `)]), cB("tabs-pane-wrapper", `
 position: relative;
 overflow: hidden;
 transition: max-height .2s var(--n-bezier);
 `), cB("tab-pane", `
 color: var(--n-pane-text-color);
 width: 100%;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .2s var(--n-bezier);
 left: 0;
 right: 0;
 top: 0;
 `, [c$1("&.next-transition-leave-active, &.prev-transition-leave-active, &.next-transition-enter-active, &.prev-transition-enter-active", `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 transform .2s var(--n-bezier),
 opacity .2s var(--n-bezier);
 `), c$1("&.next-transition-leave-active, &.prev-transition-leave-active", `
 position: absolute;
 `), c$1("&.next-transition-enter-from, &.prev-transition-leave-to", `
 transform: translateX(32px);
 opacity: 0;
 `), c$1("&.next-transition-leave-to, &.prev-transition-enter-from", `
 transform: translateX(-32px);
 opacity: 0;
 `), c$1("&.next-transition-leave-from, &.next-transition-enter-to, &.prev-transition-leave-from, &.prev-transition-enter-to", `
 transform: translateX(0);
 opacity: 1;
 `)]), cB("tabs-tab-pad", `
 box-sizing: border-box;
 width: var(--n-tab-gap);
 flex-grow: 0;
 flex-shrink: 0;
 `), cM("line-type, bar-type", [cB("tabs-tab", `
 font-weight: var(--n-tab-font-weight);
 box-sizing: border-box;
 vertical-align: bottom;
 `, [c$1("&:hover", {
    color: "var(--n-tab-text-color-hover)"
  }), cM("active", `
 color: var(--n-tab-text-color-active);
 font-weight: var(--n-tab-font-weight-active);
 `), cM("disabled", {
    color: "var(--n-tab-text-color-disabled)"
  })])]), cB("tabs-nav", [cM("line-type", [cM("top", [cE("prefix, suffix", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), cB("tabs-nav-scroll-content", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), cB("tabs-bar", `
 bottom: -1px;
 `)]), cM("left", [cE("prefix, suffix", `
 border-right: 1px solid var(--n-tab-border-color);
 `), cB("tabs-nav-scroll-content", `
 border-right: 1px solid var(--n-tab-border-color);
 `), cB("tabs-bar", `
 right: -1px;
 `)]), cM("right", [cE("prefix, suffix", `
 border-left: 1px solid var(--n-tab-border-color);
 `), cB("tabs-nav-scroll-content", `
 border-left: 1px solid var(--n-tab-border-color);
 `), cB("tabs-bar", `
 left: -1px;
 `)]), cM("bottom", [cE("prefix, suffix", `
 border-top: 1px solid var(--n-tab-border-color);
 `), cB("tabs-nav-scroll-content", `
 border-top: 1px solid var(--n-tab-border-color);
 `), cB("tabs-bar", `
 top: -1px;
 `)]), cE("prefix, suffix", `
 transition: border-color .3s var(--n-bezier);
 `), cB("tabs-nav-scroll-content", `
 transition: border-color .3s var(--n-bezier);
 `), cB("tabs-bar", `
 border-radius: 0;
 `)]), cM("card-type", [cE("prefix, suffix", `
 transition: border-color .3s var(--n-bezier);
 `), cB("tabs-pad", `
 flex-grow: 1;
 transition: border-color .3s var(--n-bezier);
 `), cB("tabs-tab-pad", `
 transition: border-color .3s var(--n-bezier);
 `), cB("tabs-tab", `
 font-weight: var(--n-tab-font-weight);
 border: 1px solid var(--n-tab-border-color);
 background-color: var(--n-tab-color);
 box-sizing: border-box;
 position: relative;
 vertical-align: bottom;
 display: flex;
 justify-content: space-between;
 font-size: var(--n-tab-font-size);
 color: var(--n-tab-text-color);
 `, [cM("addable", `
 padding-left: 8px;
 padding-right: 8px;
 font-size: 16px;
 justify-content: center;
 `, [cE("height-placeholder", `
 width: 0;
 font-size: var(--n-tab-font-size);
 `), cNotM("disabled", [c$1("&:hover", `
 color: var(--n-tab-text-color-hover);
 `)])]), cM("closable", "padding-right: 8px;"), cM("active", `
 background-color: #0000;
 font-weight: var(--n-tab-font-weight-active);
 color: var(--n-tab-text-color-active);
 `), cM("disabled", "color: var(--n-tab-text-color-disabled);")])]), cM("left, right", `
 flex-direction: column; 
 `, [cE("prefix, suffix", `
 padding: var(--n-tab-padding-vertical);
 `), cB("tabs-wrapper", `
 flex-direction: column;
 `), cB("tabs-tab-wrapper", `
 flex-direction: column;
 `, [cB("tabs-tab-pad", `
 height: var(--n-tab-gap-vertical);
 width: 100%;
 `)])]), cM("top", [cM("card-type", [cB("tabs-scroll-padding", "border-bottom: 1px solid var(--n-tab-border-color);"), cE("prefix, suffix", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), cB("tabs-tab", `
 border-top-left-radius: var(--n-tab-border-radius);
 border-top-right-radius: var(--n-tab-border-radius);
 `, [cM("active", `
 border-bottom: 1px solid #0000;
 `)]), cB("tabs-tab-pad", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), cB("tabs-pad", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `)])]), cM("left", [cM("card-type", [cB("tabs-scroll-padding", "border-right: 1px solid var(--n-tab-border-color);"), cE("prefix, suffix", `
 border-right: 1px solid var(--n-tab-border-color);
 `), cB("tabs-tab", `
 border-top-left-radius: var(--n-tab-border-radius);
 border-bottom-left-radius: var(--n-tab-border-radius);
 `, [cM("active", `
 border-right: 1px solid #0000;
 `)]), cB("tabs-tab-pad", `
 border-right: 1px solid var(--n-tab-border-color);
 `), cB("tabs-pad", `
 border-right: 1px solid var(--n-tab-border-color);
 `)])]), cM("right", [cM("card-type", [cB("tabs-scroll-padding", "border-left: 1px solid var(--n-tab-border-color);"), cE("prefix, suffix", `
 border-left: 1px solid var(--n-tab-border-color);
 `), cB("tabs-tab", `
 border-top-right-radius: var(--n-tab-border-radius);
 border-bottom-right-radius: var(--n-tab-border-radius);
 `, [cM("active", `
 border-left: 1px solid #0000;
 `)]), cB("tabs-tab-pad", `
 border-left: 1px solid var(--n-tab-border-color);
 `), cB("tabs-pad", `
 border-left: 1px solid var(--n-tab-border-color);
 `)])]), cM("bottom", [cM("card-type", [cB("tabs-scroll-padding", "border-top: 1px solid var(--n-tab-border-color);"), cE("prefix, suffix", `
 border-top: 1px solid var(--n-tab-border-color);
 `), cB("tabs-tab", `
 border-bottom-left-radius: var(--n-tab-border-radius);
 border-bottom-right-radius: var(--n-tab-border-radius);
 `, [cM("active", `
 border-top: 1px solid #0000;
 `)]), cB("tabs-tab-pad", `
 border-top: 1px solid var(--n-tab-border-color);
 `), cB("tabs-pad", `
 border-top: 1px solid var(--n-tab-border-color);
 `)])])])]);
  const tabsProps = Object.assign(Object.assign({}, useTheme.props), {
    value: [String, Number],
    defaultValue: [String, Number],
    trigger: {
      type: String,
      default: "click"
    },
    type: {
      type: String,
      default: "bar"
    },
    closable: Boolean,
    justifyContent: String,
    size: {
      type: String,
      default: "medium"
    },
    placement: {
      type: String,
      default: "top"
    },
    tabStyle: [String, Object],
    tabClass: String,
    addTabStyle: [String, Object],
    addTabClass: String,
    barWidth: Number,
    paneClass: String,
    paneStyle: [String, Object],
    paneWrapperClass: String,
    paneWrapperStyle: [String, Object],
    addable: [Boolean, Object],
    tabsPadding: {
      type: Number,
      default: 0
    },
    animated: Boolean,
    onBeforeLeave: Function,
    onAdd: Function,
    "onUpdate:value": [Function, Array],
    onUpdateValue: [Function, Array],
    onClose: [Function, Array],
    // deprecated
    labelSize: String,
    activeName: [String, Number],
    onActiveNameChange: [Function, Array]
  });
  const Tabs = vue.defineComponent({
    name: "Tabs",
    props: tabsProps,
    setup(props, {
      slots
    }) {
      var _a, _b, _c, _d;
      {
        vue.watchEffect(() => {
          if (props.labelSize !== void 0) {
            warnOnce("tabs", "`label-size` is deprecated, please use `size` instead.");
          }
          if (props.activeName !== void 0) {
            warnOnce("tabs", "`active-name` is deprecated, please use `value` instead.");
          }
          if (props.onActiveNameChange !== void 0) {
            warnOnce("tabs", "`on-active-name-change` is deprecated, please use `on-update:value` instead.");
          }
        });
      }
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Tabs", "-tabs", style$e, tabsLight$1, props, mergedClsPrefixRef);
      const tabsElRef = vue.ref(null);
      const barElRef = vue.ref(null);
      const scrollWrapperElRef = vue.ref(null);
      const addTabInstRef = vue.ref(null);
      const xScrollInstRef = vue.ref(null);
      const yScrollElRef = vue.ref(null);
      const startReachedRef = vue.ref(true);
      const endReachedRef = vue.ref(true);
      const compitableSizeRef = useCompitable(props, ["labelSize", "size"]);
      const compitableValueRef = useCompitable(props, ["activeName", "value"]);
      const uncontrolledValueRef = vue.ref((_b = (_a = compitableValueRef.value) !== null && _a !== void 0 ? _a : props.defaultValue) !== null && _b !== void 0 ? _b : slots.default ? (_d = (_c = flatten$3(slots.default())[0]) === null || _c === void 0 ? void 0 : _c.props) === null || _d === void 0 ? void 0 : _d.name : null);
      const mergedValueRef = useMergedState(compitableValueRef, uncontrolledValueRef);
      const tabChangeIdRef = {
        id: 0
      };
      const tabWrapperStyleRef = vue.computed(() => {
        if (!props.justifyContent || props.type === "card")
          return void 0;
        return {
          display: "flex",
          justifyContent: props.justifyContent
        };
      });
      vue.watch(mergedValueRef, () => {
        tabChangeIdRef.id = 0;
        updateCurrentBarStyle();
        updateCurrentScrollPosition();
      });
      function getCurrentEl() {
        var _a2;
        const {
          value
        } = mergedValueRef;
        if (value === null)
          return null;
        const tabEl = (_a2 = tabsElRef.value) === null || _a2 === void 0 ? void 0 : _a2.querySelector(`[data-name="${value}"]`);
        return tabEl;
      }
      function updateBarStyle(tabEl) {
        if (props.type === "card")
          return;
        const {
          value: barEl
        } = barElRef;
        if (!barEl)
          return;
        const barIsHide = barEl.style.opacity === "0";
        if (tabEl) {
          const disabledClassName = `${mergedClsPrefixRef.value}-tabs-bar--disabled`;
          const {
            barWidth,
            placement
          } = props;
          if (tabEl.dataset.disabled === "true") {
            barEl.classList.add(disabledClassName);
          } else {
            barEl.classList.remove(disabledClassName);
          }
          if (["top", "bottom"].includes(placement)) {
            clearBarStyle(["top", "maxHeight", "height"]);
            if (typeof barWidth === "number" && tabEl.offsetWidth >= barWidth) {
              const offsetDiffLeft = Math.floor((tabEl.offsetWidth - barWidth) / 2) + tabEl.offsetLeft;
              barEl.style.left = `${offsetDiffLeft}px`;
              barEl.style.maxWidth = `${barWidth}px`;
            } else {
              barEl.style.left = `${tabEl.offsetLeft}px`;
              barEl.style.maxWidth = `${tabEl.offsetWidth}px`;
            }
            barEl.style.width = "8192px";
            if (barIsHide) {
              barEl.style.transition = "none";
            }
            void barEl.offsetWidth;
            if (barIsHide) {
              barEl.style.transition = "";
              barEl.style.opacity = "1";
            }
          } else {
            clearBarStyle(["left", "maxWidth", "width"]);
            if (typeof barWidth === "number" && tabEl.offsetHeight >= barWidth) {
              const offsetDiffTop = Math.floor((tabEl.offsetHeight - barWidth) / 2) + tabEl.offsetTop;
              barEl.style.top = `${offsetDiffTop}px`;
              barEl.style.maxHeight = `${barWidth}px`;
            } else {
              barEl.style.top = `${tabEl.offsetTop}px`;
              barEl.style.maxHeight = `${tabEl.offsetHeight}px`;
            }
            barEl.style.height = "8192px";
            if (barIsHide) {
              barEl.style.transition = "none";
            }
            void barEl.offsetHeight;
            if (barIsHide) {
              barEl.style.transition = "";
              barEl.style.opacity = "1";
            }
          }
        }
      }
      function hideBarStyle() {
        if (props.type === "card")
          return;
        const {
          value: barEl
        } = barElRef;
        if (!barEl)
          return;
        barEl.style.opacity = "0";
      }
      function clearBarStyle(styleProps) {
        const {
          value: barEl
        } = barElRef;
        if (!barEl)
          return;
        for (const prop of styleProps) {
          barEl.style[prop] = "";
        }
      }
      function updateCurrentBarStyle() {
        if (props.type === "card")
          return;
        const tabEl = getCurrentEl();
        if (tabEl) {
          updateBarStyle(tabEl);
        } else {
          hideBarStyle();
        }
      }
      function updateCurrentScrollPosition() {
        var _a2;
        const scrollWrapperEl = (_a2 = xScrollInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.$el;
        if (!scrollWrapperEl)
          return;
        const tabEl = getCurrentEl();
        if (!tabEl)
          return;
        const {
          scrollLeft: scrollWrapperElScrollLeft,
          offsetWidth: scrollWrapperElOffsetWidth
        } = scrollWrapperEl;
        const {
          offsetLeft: tabElOffsetLeft,
          offsetWidth: tabElOffsetWidth
        } = tabEl;
        if (scrollWrapperElScrollLeft > tabElOffsetLeft) {
          scrollWrapperEl.scrollTo({
            top: 0,
            left: tabElOffsetLeft,
            behavior: "smooth"
          });
        } else if (tabElOffsetLeft + tabElOffsetWidth > scrollWrapperElScrollLeft + scrollWrapperElOffsetWidth) {
          scrollWrapperEl.scrollTo({
            top: 0,
            left: tabElOffsetLeft + tabElOffsetWidth - scrollWrapperElOffsetWidth,
            behavior: "smooth"
          });
        }
      }
      const tabsPaneWrapperRef = vue.ref(null);
      let fromHeight = 0;
      let hangingTransition = null;
      function onAnimationBeforeLeave(el) {
        const tabsPaneWrapperEl = tabsPaneWrapperRef.value;
        if (tabsPaneWrapperEl) {
          fromHeight = el.getBoundingClientRect().height;
          const fromHeightPx = `${fromHeight}px`;
          const applyFromStyle = () => {
            tabsPaneWrapperEl.style.height = fromHeightPx;
            tabsPaneWrapperEl.style.maxHeight = fromHeightPx;
          };
          if (!hangingTransition) {
            hangingTransition = applyFromStyle;
          } else {
            applyFromStyle();
            hangingTransition();
            hangingTransition = null;
          }
        }
      }
      function onAnimationEnter(el) {
        const tabsPaneWrapperEl = tabsPaneWrapperRef.value;
        if (tabsPaneWrapperEl) {
          const targetHeight = el.getBoundingClientRect().height;
          const applyTargetStyle = () => {
            void document.body.offsetHeight;
            tabsPaneWrapperEl.style.maxHeight = `${targetHeight}px`;
            tabsPaneWrapperEl.style.height = `${Math.max(fromHeight, targetHeight)}px`;
          };
          if (!hangingTransition) {
            hangingTransition = applyTargetStyle;
          } else {
            hangingTransition();
            hangingTransition = null;
            applyTargetStyle();
          }
        }
      }
      function onAnimationAfterEnter() {
        const tabsPaneWrapperEl = tabsPaneWrapperRef.value;
        if (tabsPaneWrapperEl) {
          tabsPaneWrapperEl.style.maxHeight = "";
          tabsPaneWrapperEl.style.height = "";
          const {
            paneWrapperStyle
          } = props;
          if (typeof paneWrapperStyle === "string") {
            tabsPaneWrapperEl.style.cssText = paneWrapperStyle;
          } else if (paneWrapperStyle) {
            const {
              maxHeight,
              height
            } = paneWrapperStyle;
            if (maxHeight !== void 0) {
              tabsPaneWrapperEl.style.maxHeight = maxHeight;
            }
            if (height !== void 0) {
              tabsPaneWrapperEl.style.height = height;
            }
          }
        }
      }
      const renderNameListRef = {
        value: []
      };
      const animationDirectionRef = vue.ref("next");
      function activateTab(panelName) {
        const currentValue = mergedValueRef.value;
        let dir = "next";
        for (const name of renderNameListRef.value) {
          if (name === currentValue) {
            break;
          }
          if (name === panelName) {
            dir = "prev";
            break;
          }
        }
        animationDirectionRef.value = dir;
        doUpdateValue(panelName);
      }
      function doUpdateValue(panelName) {
        const {
          onActiveNameChange,
          onUpdateValue,
          "onUpdate:value": _onUpdateValue
        } = props;
        if (onActiveNameChange) {
          call(onActiveNameChange, panelName);
        }
        if (onUpdateValue)
          call(onUpdateValue, panelName);
        if (_onUpdateValue)
          call(_onUpdateValue, panelName);
        uncontrolledValueRef.value = panelName;
      }
      function handleClose(panelName) {
        const {
          onClose
        } = props;
        if (onClose)
          call(onClose, panelName);
      }
      function updateBarPositionInstantly() {
        const {
          value: barEl
        } = barElRef;
        if (!barEl)
          return;
        const disableTransitionClassName = "transition-disabled";
        barEl.classList.add(disableTransitionClassName);
        updateCurrentBarStyle();
        barEl.classList.remove(disableTransitionClassName);
      }
      const segmentCapsuleElRef = vue.ref(null);
      function updateSegmentPosition({
        transitionDisabled
      }) {
        const tabsEl = tabsElRef.value;
        if (!tabsEl)
          return;
        if (transitionDisabled)
          tabsEl.classList.add("transition-disabled");
        const activeTabEl = getCurrentEl();
        if (activeTabEl && segmentCapsuleElRef.value) {
          segmentCapsuleElRef.value.style.width = `${activeTabEl.offsetWidth}px`;
          segmentCapsuleElRef.value.style.height = `${activeTabEl.offsetHeight}px`;
          segmentCapsuleElRef.value.style.transform = `translateX(${activeTabEl.offsetLeft - depx(getComputedStyle(tabsEl).paddingLeft)}px)`;
          if (transitionDisabled) {
            void segmentCapsuleElRef.value.offsetWidth;
          }
        }
        if (transitionDisabled) {
          tabsEl.classList.remove("transition-disabled");
        }
      }
      vue.watch([mergedValueRef], () => {
        if (props.type === "segment") {
          void vue.nextTick(() => {
            updateSegmentPosition({
              transitionDisabled: false
            });
          });
        }
      });
      vue.onMounted(() => {
        if (props.type === "segment") {
          updateSegmentPosition({
            transitionDisabled: true
          });
        }
      });
      let memorizedWidth = 0;
      function _handleNavResize(entry) {
        var _b2;
        if (entry.contentRect.width === 0 && entry.contentRect.height === 0) {
          return;
        }
        if (memorizedWidth === entry.contentRect.width) {
          return;
        }
        memorizedWidth = entry.contentRect.width;
        const {
          type
        } = props;
        if (type === "line" || type === "bar") {
          {
            updateBarPositionInstantly();
          }
        }
        if (type !== "segment") {
          const {
            placement
          } = props;
          deriveScrollShadow((placement === "top" || placement === "bottom" ? (_b2 = xScrollInstRef.value) === null || _b2 === void 0 ? void 0 : _b2.$el : yScrollElRef.value) || null);
        }
      }
      const handleNavResize = throttle(_handleNavResize, 64);
      vue.watch([() => props.justifyContent, () => props.size], () => {
        void vue.nextTick(() => {
          const {
            type
          } = props;
          if (type === "line" || type === "bar") {
            updateBarPositionInstantly();
          }
        });
      });
      const addTabFixedRef = vue.ref(false);
      function _handleTabsResize(entry) {
        var _a2;
        const {
          target,
          contentRect: {
            width,
            height
          }
        } = entry;
        const containerWidth = target.parentElement.parentElement.offsetWidth;
        const containerHeight = target.parentElement.parentElement.offsetHeight;
        const {
          placement
        } = props;
        if (!addTabFixedRef.value) {
          if (placement === "top" || placement === "bottom") {
            if (containerWidth < width) {
              addTabFixedRef.value = true;
            }
          } else {
            if (containerHeight < height) {
              addTabFixedRef.value = true;
            }
          }
        } else {
          const {
            value: addTabInst
          } = addTabInstRef;
          if (!addTabInst)
            return;
          if (placement === "top" || placement === "bottom") {
            if (containerWidth - width > addTabInst.$el.offsetWidth) {
              addTabFixedRef.value = false;
            }
          } else {
            if (containerHeight - height > addTabInst.$el.offsetHeight) {
              addTabFixedRef.value = false;
            }
          }
        }
        deriveScrollShadow(((_a2 = xScrollInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.$el) || null);
      }
      const handleTabsResize = throttle(_handleTabsResize, 64);
      function handleAdd() {
        const {
          onAdd
        } = props;
        if (onAdd)
          onAdd();
        void vue.nextTick(() => {
          const currentEl = getCurrentEl();
          const {
            value: xScrollInst
          } = xScrollInstRef;
          if (!currentEl || !xScrollInst)
            return;
          xScrollInst.scrollTo({
            left: currentEl.offsetLeft,
            top: 0,
            behavior: "smooth"
          });
        });
      }
      function deriveScrollShadow(el) {
        if (!el)
          return;
        const {
          placement
        } = props;
        if (placement === "top" || placement === "bottom") {
          const {
            scrollLeft,
            scrollWidth,
            offsetWidth
          } = el;
          startReachedRef.value = scrollLeft <= 0;
          endReachedRef.value = scrollLeft + offsetWidth >= scrollWidth;
        } else {
          const {
            scrollTop,
            scrollHeight,
            offsetHeight
          } = el;
          startReachedRef.value = scrollTop <= 0;
          endReachedRef.value = scrollTop + offsetHeight >= scrollHeight;
        }
      }
      const handleScroll = throttle((e) => {
        deriveScrollShadow(e.target);
      }, 64);
      vue.provide(tabsInjectionKey, {
        triggerRef: vue.toRef(props, "trigger"),
        tabStyleRef: vue.toRef(props, "tabStyle"),
        tabClassRef: vue.toRef(props, "tabClass"),
        addTabStyleRef: vue.toRef(props, "addTabStyle"),
        addTabClassRef: vue.toRef(props, "addTabClass"),
        paneClassRef: vue.toRef(props, "paneClass"),
        paneStyleRef: vue.toRef(props, "paneStyle"),
        mergedClsPrefixRef,
        typeRef: vue.toRef(props, "type"),
        closableRef: vue.toRef(props, "closable"),
        valueRef: mergedValueRef,
        tabChangeIdRef,
        onBeforeLeaveRef: vue.toRef(props, "onBeforeLeave"),
        activateTab,
        handleClose,
        handleAdd
      });
      onFontsReady(() => {
        updateCurrentBarStyle();
        updateCurrentScrollPosition();
      });
      vue.watchEffect(() => {
        const {
          value: el
        } = scrollWrapperElRef;
        if (!el)
          return;
        const {
          value: clsPrefix
        } = mergedClsPrefixRef;
        const shadowStartClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-start`;
        const shadowEndClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-end`;
        if (startReachedRef.value) {
          el.classList.remove(shadowStartClass);
        } else {
          el.classList.add(shadowStartClass);
        }
        if (endReachedRef.value) {
          el.classList.remove(shadowEndClass);
        } else {
          el.classList.add(shadowEndClass);
        }
      });
      const exposedMethods = {
        syncBarPosition: () => {
          updateCurrentBarStyle();
        }
      };
      const handleSegmentResize = () => {
        updateSegmentPosition({
          transitionDisabled: true
        });
      };
      const cssVarsRef = vue.computed(() => {
        const {
          value: size2
        } = compitableSizeRef;
        const {
          type
        } = props;
        const typeSuffix = {
          card: "Card",
          bar: "Bar",
          line: "Line",
          segment: "Segment"
        }[type];
        const sizeType = `${size2}${typeSuffix}`;
        const {
          self: {
            barColor,
            closeIconColor,
            closeIconColorHover,
            closeIconColorPressed,
            tabColor,
            tabBorderColor,
            paneTextColor,
            tabFontWeight,
            tabBorderRadius,
            tabFontWeightActive,
            colorSegment,
            fontWeightStrong,
            tabColorSegment,
            closeSize,
            closeIconSize,
            closeColorHover,
            closeColorPressed,
            closeBorderRadius,
            [createKey("panePadding", size2)]: panePadding,
            [createKey("tabPadding", sizeType)]: tabPadding,
            [createKey("tabPaddingVertical", sizeType)]: tabPaddingVertical,
            [createKey("tabGap", sizeType)]: tabGap,
            [createKey("tabGap", `${sizeType}Vertical`)]: tabGapVertical,
            [createKey("tabTextColor", type)]: tabTextColor,
            [createKey("tabTextColorActive", type)]: tabTextColorActive,
            [createKey("tabTextColorHover", type)]: tabTextColorHover,
            [createKey("tabTextColorDisabled", type)]: tabTextColorDisabled,
            [createKey("tabFontSize", size2)]: tabFontSize
          },
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-color-segment": colorSegment,
          "--n-bar-color": barColor,
          "--n-tab-font-size": tabFontSize,
          "--n-tab-text-color": tabTextColor,
          "--n-tab-text-color-active": tabTextColorActive,
          "--n-tab-text-color-disabled": tabTextColorDisabled,
          "--n-tab-text-color-hover": tabTextColorHover,
          "--n-pane-text-color": paneTextColor,
          "--n-tab-border-color": tabBorderColor,
          "--n-tab-border-radius": tabBorderRadius,
          "--n-close-size": closeSize,
          "--n-close-icon-size": closeIconSize,
          "--n-close-color-hover": closeColorHover,
          "--n-close-color-pressed": closeColorPressed,
          "--n-close-border-radius": closeBorderRadius,
          "--n-close-icon-color": closeIconColor,
          "--n-close-icon-color-hover": closeIconColorHover,
          "--n-close-icon-color-pressed": closeIconColorPressed,
          "--n-tab-color": tabColor,
          "--n-tab-font-weight": tabFontWeight,
          "--n-tab-font-weight-active": tabFontWeightActive,
          "--n-tab-padding": tabPadding,
          "--n-tab-padding-vertical": tabPaddingVertical,
          "--n-tab-gap": tabGap,
          "--n-tab-gap-vertical": tabGapVertical,
          "--n-pane-padding-left": getMargin(panePadding, "left"),
          "--n-pane-padding-right": getMargin(panePadding, "right"),
          "--n-pane-padding-top": getMargin(panePadding, "top"),
          "--n-pane-padding-bottom": getMargin(panePadding, "bottom"),
          "--n-font-weight-strong": fontWeightStrong,
          "--n-tab-color-segment": tabColorSegment
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("tabs", vue.computed(() => {
        return `${compitableSizeRef.value[0]}${props.type[0]}`;
      }), cssVarsRef, props) : void 0;
      return Object.assign({
        mergedClsPrefix: mergedClsPrefixRef,
        mergedValue: mergedValueRef,
        renderedNames: /* @__PURE__ */ new Set(),
        segmentCapsuleElRef,
        tabsPaneWrapperRef,
        tabsElRef,
        barElRef,
        addTabInstRef,
        xScrollInstRef,
        scrollWrapperElRef,
        addTabFixed: addTabFixedRef,
        tabWrapperStyle: tabWrapperStyleRef,
        handleNavResize,
        mergedSize: compitableSizeRef,
        handleScroll,
        handleTabsResize,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        animationDirection: animationDirectionRef,
        renderNameListRef,
        yScrollElRef,
        handleSegmentResize,
        onAnimationBeforeLeave,
        onAnimationEnter,
        onAnimationAfterEnter,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      }, exposedMethods);
    },
    render() {
      const {
        mergedClsPrefix,
        type,
        placement,
        addTabFixed,
        addable,
        mergedSize,
        renderNameListRef,
        onRender,
        paneWrapperClass,
        paneWrapperStyle,
        $slots: {
          default: defaultSlot,
          prefix: prefixSlot,
          suffix: suffixSlot
        }
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      const tabPaneChildren = defaultSlot ? flatten$3(defaultSlot()).filter((v) => {
        return v.type.__TAB_PANE__ === true;
      }) : [];
      const tabChildren = defaultSlot ? flatten$3(defaultSlot()).filter((v) => {
        return v.type.__TAB__ === true;
      }) : [];
      const showPane = !tabChildren.length;
      const isCard = type === "card";
      const isSegment = type === "segment";
      const mergedJustifyContent = !isCard && !isSegment && this.justifyContent;
      renderNameListRef.value = [];
      const scrollContent = () => {
        const tabs = vue.h("div", {
          style: this.tabWrapperStyle,
          class: `${mergedClsPrefix}-tabs-wrapper`
        }, mergedJustifyContent ? null : vue.h("div", {
          class: `${mergedClsPrefix}-tabs-scroll-padding`,
          style: placement === "top" || placement === "bottom" ? {
            width: `${this.tabsPadding}px`
          } : {
            height: `${this.tabsPadding}px`
          }
        }), showPane ? tabPaneChildren.map((tabPaneVNode, index) => {
          renderNameListRef.value.push(tabPaneVNode.props.name);
          return justifyTabDynamicProps(vue.h(Tab, Object.assign({}, tabPaneVNode.props, {
            internalCreatedByPane: true,
            internalLeftPadded: index !== 0 && (!mergedJustifyContent || mergedJustifyContent === "center" || mergedJustifyContent === "start" || mergedJustifyContent === "end")
          }), tabPaneVNode.children ? {
            default: tabPaneVNode.children.tab
          } : void 0));
        }) : tabChildren.map((tabVNode, index) => {
          renderNameListRef.value.push(tabVNode.props.name);
          if (index !== 0 && !mergedJustifyContent) {
            return justifyTabDynamicProps(createLeftPaddedTabVNode(tabVNode));
          } else {
            return justifyTabDynamicProps(tabVNode);
          }
        }), !addTabFixed && addable && isCard ? createAddTag(addable, (showPane ? tabPaneChildren.length : tabChildren.length) !== 0) : null, mergedJustifyContent ? null : vue.h("div", {
          class: `${mergedClsPrefix}-tabs-scroll-padding`,
          style: {
            width: `${this.tabsPadding}px`
          }
        }));
        return vue.h("div", {
          ref: "tabsElRef",
          class: `${mergedClsPrefix}-tabs-nav-scroll-content`
        }, isCard && addable ? vue.h(VResizeObserver, {
          onResize: this.handleTabsResize
        }, {
          default: () => tabs
        }) : tabs, isCard ? vue.h("div", {
          class: `${mergedClsPrefix}-tabs-pad`
        }) : null, isCard ? null : vue.h("div", {
          ref: "barElRef",
          class: `${mergedClsPrefix}-tabs-bar`
        }));
      };
      const resolvedPlacement = isSegment ? "top" : placement;
      return vue.h("div", {
        class: [`${mergedClsPrefix}-tabs`, this.themeClass, `${mergedClsPrefix}-tabs--${type}-type`, `${mergedClsPrefix}-tabs--${mergedSize}-size`, mergedJustifyContent && `${mergedClsPrefix}-tabs--flex`, `${mergedClsPrefix}-tabs--${resolvedPlacement}`],
        style: this.cssVars
      }, vue.h("div", {
        class: [
          // the class should be applied here since it's possible
          // to make tabs nested in tabs, style may influence each
          // other. adding a class will make it easy to write the
          // style.
          `${mergedClsPrefix}-tabs-nav--${type}-type`,
          `${mergedClsPrefix}-tabs-nav--${resolvedPlacement}`,
          `${mergedClsPrefix}-tabs-nav`
        ]
      }, resolveWrappedSlot(prefixSlot, (children) => children && vue.h("div", {
        class: `${mergedClsPrefix}-tabs-nav__prefix`
      }, children)), isSegment ? vue.h(VResizeObserver, {
        onResize: this.handleSegmentResize
      }, {
        default: () => vue.h("div", {
          class: `${mergedClsPrefix}-tabs-rail`,
          ref: "tabsElRef"
        }, vue.h("div", {
          class: `${mergedClsPrefix}-tabs-capsule`,
          ref: "segmentCapsuleElRef"
        }, vue.h("div", {
          class: `${mergedClsPrefix}-tabs-wrapper`
        }, vue.h("div", {
          class: `${mergedClsPrefix}-tabs-tab`
        }))), showPane ? tabPaneChildren.map((tabPaneVNode, index) => {
          renderNameListRef.value.push(tabPaneVNode.props.name);
          return vue.h(Tab, Object.assign({}, tabPaneVNode.props, {
            internalCreatedByPane: true,
            internalLeftPadded: index !== 0
          }), tabPaneVNode.children ? {
            default: tabPaneVNode.children.tab
          } : void 0);
        }) : tabChildren.map((tabVNode, index) => {
          renderNameListRef.value.push(tabVNode.props.name);
          if (index === 0) {
            return tabVNode;
          } else {
            return createLeftPaddedTabVNode(tabVNode);
          }
        }))
      }) : vue.h(VResizeObserver, {
        onResize: this.handleNavResize
      }, {
        default: () => vue.h("div", {
          class: `${mergedClsPrefix}-tabs-nav-scroll-wrapper`,
          ref: "scrollWrapperElRef"
        }, ["top", "bottom"].includes(resolvedPlacement) ? vue.h(VXScroll, {
          ref: "xScrollInstRef",
          onScroll: this.handleScroll
        }, {
          default: scrollContent
        }) : vue.h("div", {
          class: `${mergedClsPrefix}-tabs-nav-y-scroll`,
          onScroll: this.handleScroll,
          ref: "yScrollElRef"
        }, scrollContent()))
      }), addTabFixed && addable && isCard ? createAddTag(addable, true) : null, resolveWrappedSlot(suffixSlot, (children) => children && vue.h("div", {
        class: `${mergedClsPrefix}-tabs-nav__suffix`
      }, children))), showPane && (this.animated && (resolvedPlacement === "top" || resolvedPlacement === "bottom") ? vue.h("div", {
        ref: "tabsPaneWrapperRef",
        style: paneWrapperStyle,
        class: [`${mergedClsPrefix}-tabs-pane-wrapper`, paneWrapperClass]
      }, filterMapTabPanes(tabPaneChildren, this.mergedValue, this.renderedNames, this.onAnimationBeforeLeave, this.onAnimationEnter, this.onAnimationAfterEnter, this.animationDirection)) : filterMapTabPanes(tabPaneChildren, this.mergedValue, this.renderedNames)));
    }
  });
  function filterMapTabPanes(tabPaneVNodes, value, renderedNames, onBeforeLeave, onEnter, onAfterEnter, animationDirection) {
    const children = [];
    tabPaneVNodes.forEach((vNode) => {
      const {
        name,
        displayDirective,
        "display-directive": _displayDirective
      } = vNode.props;
      const matchDisplayDirective = (directive) => displayDirective === directive || _displayDirective === directive;
      const show = value === name;
      if (vNode.key !== void 0) {
        vNode.key = name;
      }
      if (show || matchDisplayDirective("show") || matchDisplayDirective("show:lazy") && renderedNames.has(name)) {
        if (!renderedNames.has(name)) {
          renderedNames.add(name);
        }
        const useVShow = !matchDisplayDirective("if");
        children.push(useVShow ? vue.withDirectives(vNode, [[vue.vShow, show]]) : vNode);
      }
    });
    if (!animationDirection) {
      return children;
    }
    return vue.h(vue.TransitionGroup, {
      name: `${animationDirection}-transition`,
      onBeforeLeave,
      onEnter,
      onAfterEnter
    }, {
      default: () => children
    });
  }
  function createAddTag(addable, internalLeftPadded) {
    return vue.h(Tab, {
      ref: "addTabInstRef",
      key: "__addable",
      name: "__addable",
      internalCreatedByPane: true,
      internalAddable: true,
      internalLeftPadded,
      disabled: typeof addable === "object" && addable.disabled
    });
  }
  function createLeftPaddedTabVNode(tabVNode) {
    const modifiedVNode = vue.cloneVNode(tabVNode);
    if (modifiedVNode.props) {
      modifiedVNode.props.internalLeftPadded = true;
    } else {
      modifiedVNode.props = {
        internalLeftPadded: true
      };
    }
    return modifiedVNode;
  }
  function justifyTabDynamicProps(tabVNode) {
    if (Array.isArray(tabVNode.dynamicProps)) {
      if (!tabVNode.dynamicProps.includes("internalLeftPadded")) {
        tabVNode.dynamicProps.push("internalLeftPadded");
      }
    } else {
      tabVNode.dynamicProps = ["internalLeftPadded"];
    }
    return tabVNode;
  }
  const style$d = cB("thing", `
 display: flex;
 transition: color .3s var(--n-bezier);
 font-size: var(--n-font-size);
 color: var(--n-text-color);
`, [cB("thing-avatar", `
 margin-right: 12px;
 margin-top: 2px;
 `), cB("thing-avatar-header-wrapper", `
 display: flex;
 flex-wrap: nowrap;
 `, [cB("thing-header-wrapper", `
 flex: 1;
 `)]), cB("thing-main", `
 flex-grow: 1;
 `, [cB("thing-header", `
 display: flex;
 margin-bottom: 4px;
 justify-content: space-between;
 align-items: center;
 `, [cE("title", `
 font-size: 16px;
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 color: var(--n-title-text-color);
 `)]), cE("description", [c$1("&:not(:last-child)", `
 margin-bottom: 4px;
 `)]), cE("content", [c$1("&:not(:first-child)", `
 margin-top: 12px;
 `)]), cE("footer", [c$1("&:not(:first-child)", `
 margin-top: 12px;
 `)]), cE("action", [c$1("&:not(:first-child)", `
 margin-top: 12px;
 `)])])]);
  const thingProps = Object.assign(Object.assign({}, useTheme.props), {
    title: String,
    titleExtra: String,
    description: String,
    descriptionClass: String,
    descriptionStyle: [String, Object],
    content: String,
    contentClass: String,
    contentStyle: [String, Object],
    contentIndented: Boolean
  });
  const Thing = vue.defineComponent({
    name: "Thing",
    props: thingProps,
    setup(props, {
      slots
    }) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled,
        mergedRtlRef
      } = useConfig(props);
      const themeRef = useTheme("Thing", "-thing", style$d, thingLight$1, props, mergedClsPrefixRef);
      const rtlEnabledRef = useRtl("Thing", mergedRtlRef, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          self: {
            titleTextColor,
            textColor,
            titleFontWeight,
            fontSize: fontSize2
          },
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-font-size": fontSize2,
          "--n-text-color": textColor,
          "--n-title-font-weight": titleFontWeight,
          "--n-title-text-color": titleTextColor
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("thing", void 0, cssVarsRef, props) : void 0;
      return () => {
        var _a;
        const {
          value: mergedClsPrefix
        } = mergedClsPrefixRef;
        const rtlEnabled = rtlEnabledRef ? rtlEnabledRef.value : false;
        (_a = themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender) === null || _a === void 0 ? void 0 : _a.call(themeClassHandle);
        return vue.h("div", {
          class: [`${mergedClsPrefix}-thing`, themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, rtlEnabled && `${mergedClsPrefix}-thing--rtl`],
          style: inlineThemeDisabled ? void 0 : cssVarsRef.value
        }, slots.avatar && props.contentIndented ? vue.h("div", {
          class: `${mergedClsPrefix}-thing-avatar`
        }, slots.avatar()) : null, vue.h("div", {
          class: `${mergedClsPrefix}-thing-main`
        }, !props.contentIndented && (slots.header || props.title || slots["header-extra"] || props.titleExtra || slots.avatar) ? vue.h("div", {
          class: `${mergedClsPrefix}-thing-avatar-header-wrapper`
        }, slots.avatar ? vue.h("div", {
          class: `${mergedClsPrefix}-thing-avatar`
        }, slots.avatar()) : null, slots.header || props.title || slots["header-extra"] || props.titleExtra ? vue.h("div", {
          class: `${mergedClsPrefix}-thing-header-wrapper`
        }, vue.h("div", {
          class: `${mergedClsPrefix}-thing-header`
        }, slots.header || props.title ? vue.h("div", {
          class: `${mergedClsPrefix}-thing-header__title`
        }, slots.header ? slots.header() : props.title) : null, slots["header-extra"] || props.titleExtra ? vue.h("div", {
          class: `${mergedClsPrefix}-thing-header__extra`
        }, slots["header-extra"] ? slots["header-extra"]() : props.titleExtra) : null), slots.description || props.description ? vue.h("div", {
          class: [`${mergedClsPrefix}-thing-main__description`, props.descriptionClass],
          style: props.descriptionStyle
        }, slots.description ? slots.description() : props.description) : null) : null) : vue.h(vue.Fragment, null, slots.header || props.title || slots["header-extra"] || props.titleExtra ? vue.h("div", {
          class: `${mergedClsPrefix}-thing-header`
        }, slots.header || props.title ? vue.h("div", {
          class: `${mergedClsPrefix}-thing-header__title`
        }, slots.header ? slots.header() : props.title) : null, slots["header-extra"] || props.titleExtra ? vue.h("div", {
          class: `${mergedClsPrefix}-thing-header__extra`
        }, slots["header-extra"] ? slots["header-extra"]() : props.titleExtra) : null) : null, slots.description || props.description ? vue.h("div", {
          class: [`${mergedClsPrefix}-thing-main__description`, props.descriptionClass],
          style: props.descriptionStyle
        }, slots.description ? slots.description() : props.description) : null), slots.default || props.content ? vue.h("div", {
          class: [`${mergedClsPrefix}-thing-main__content`, props.contentClass],
          style: props.contentStyle
        }, slots.default ? slots.default() : props.content) : null, slots.footer ? vue.h("div", {
          class: `${mergedClsPrefix}-thing-main__footer`
        }, slots.footer()) : null, slots.action ? vue.h("div", {
          class: `${mergedClsPrefix}-thing-main__action`
        }, slots.action()) : null));
      };
    }
  });
  const timeProps = {
    time: {
      type: [Number, Date],
      default: void 0
      // For unix or non unix mode, it should be different default value
    },
    type: {
      type: String,
      default: "datetime"
    },
    to: {
      type: [Number, Date],
      default: void 0
      // the same as `time` prop
    },
    unix: Boolean,
    format: String,
    text: Boolean,
    timeZone: String
  };
  const Time = vue.defineComponent({
    name: "Time",
    props: timeProps,
    setup(props) {
      const now2 = Date.now();
      const {
        localeRef,
        dateLocaleRef
      } = useLocale("Time");
      const mergedFormatRef = vue.computed(() => {
        const {
          timeZone
        } = props;
        if (timeZone) {
          return (time2, _format, options) => {
            return formatInTimeZone(time2, timeZone, _format, options);
          };
        }
        return format$3;
      });
      const dateFnsOptionsRef = vue.computed(() => {
        return {
          locale: dateLocaleRef.value.locale
        };
      });
      const mergedTimeRef = vue.computed(() => {
        const {
          time: time2
        } = props;
        if (props.unix) {
          if (time2 === void 0)
            return now2;
          return fromUnixTime(typeof time2 === "number" ? time2 : time2.valueOf());
        }
        return time2 !== null && time2 !== void 0 ? time2 : now2;
      });
      const mergedToRef = vue.computed(() => {
        const {
          to
        } = props;
        if (props.unix) {
          if (to === void 0)
            return now2;
          return fromUnixTime(typeof to === "number" ? to : to.valueOf());
        }
        return to !== null && to !== void 0 ? to : now2;
      });
      const renderedTimeRef = vue.computed(() => {
        if (props.format) {
          return mergedFormatRef.value(mergedTimeRef.value, props.format, dateFnsOptionsRef.value);
        } else if (props.type === "date") {
          return mergedFormatRef.value(mergedTimeRef.value, localeRef.value.dateFormat, dateFnsOptionsRef.value);
        } else if (props.type === "datetime") {
          return mergedFormatRef.value(mergedTimeRef.value, localeRef.value.dateTimeFormat, dateFnsOptionsRef.value);
        } else {
          return formatDistanceStrict(mergedTimeRef.value, mergedToRef.value, {
            addSuffix: true,
            locale: dateLocaleRef.value.locale
          });
        }
      });
      return {
        renderedTime: renderedTimeRef
      };
    },
    render() {
      return this.text ? vue.createTextVNode(this.renderedTime) : vue.h("time", [this.renderedTime]);
    }
  });
  const lineHeight = 1.25;
  const style$c = cB("timeline", `
 position: relative;
 width: 100%;
 display: flex;
 flex-direction: column;
 line-height: ${lineHeight};
`, [cM("horizontal", `
 flex-direction: row;
 `, [c$1(">", [cB("timeline-item", `
 flex-shrink: 0;
 padding-right: 40px;
 `, [cM("dashed-line-type", [c$1(">", [cB("timeline-item-timeline", [cE("line", `
 background-image: linear-gradient(90deg, var(--n-color-start), var(--n-color-start) 50%, transparent 50%, transparent 100%);
 background-size: 10px 1px;
 `)])])]), c$1(">", [cB("timeline-item-content", `
 margin-top: calc(var(--n-icon-size) + 12px);
 `, [c$1(">", [cE("meta", `
 margin-top: 6px;
 margin-bottom: unset;
 `)])]), cB("timeline-item-timeline", `
 width: 100%;
 height: calc(var(--n-icon-size) + 12px);
 `, [cE("line", `
 left: var(--n-icon-size);
 top: calc(var(--n-icon-size) / 2 - 1px);
 right: 0px;
 width: unset;
 height: 2px;
 `)])])])])]), cM("right-placement", [cB("timeline-item", [cB("timeline-item-content", `
 text-align: right;
 margin-right: calc(var(--n-icon-size) + 12px);
 `), cB("timeline-item-timeline", `
 width: var(--n-icon-size);
 right: 0;
 `)])]), cM("left-placement", [cB("timeline-item", [cB("timeline-item-content", `
 margin-left: calc(var(--n-icon-size) + 12px);
 `), cB("timeline-item-timeline", `
 left: 0;
 `)])]), cB("timeline-item", `
 position: relative;
 `, [c$1("&:last-child", [cB("timeline-item-timeline", [cE("line", `
 display: none;
 `)]), cB("timeline-item-content", [cE("meta", `
 margin-bottom: 0;
 `)])]), cB("timeline-item-content", [cE("title", `
 margin: var(--n-title-margin);
 font-size: var(--n-title-font-size);
 transition: color .3s var(--n-bezier);
 font-weight: var(--n-title-font-weight);
 color: var(--n-title-text-color);
 `), cE("content", `
 transition: color .3s var(--n-bezier);
 font-size: var(--n-content-font-size);
 color: var(--n-content-text-color);
 `), cE("meta", `
 transition: color .3s var(--n-bezier);
 font-size: 12px;
 margin-top: 6px;
 margin-bottom: 20px;
 color: var(--n-meta-text-color);
 `)]), cM("dashed-line-type", [cB("timeline-item-timeline", [cE("line", `
 --n-color-start: var(--n-line-color);
 transition: --n-color-start .3s var(--n-bezier);
 background-color: transparent;
 background-image: linear-gradient(180deg, var(--n-color-start), var(--n-color-start) 50%, transparent 50%, transparent 100%);
 background-size: 1px 10px;
 `)])]), cB("timeline-item-timeline", `
 width: calc(var(--n-icon-size) + 12px);
 position: absolute;
 top: calc(var(--n-title-font-size) * ${lineHeight} / 2 - var(--n-icon-size) / 2);
 height: 100%;
 `, [cE("circle", `
 border: var(--n-circle-border);
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 width: var(--n-icon-size);
 height: var(--n-icon-size);
 border-radius: var(--n-icon-size);
 box-sizing: border-box;
 `), cE("icon", `
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 display: flex;
 align-items: center;
 justify-content: center;
 `), cE("line", `
 transition: background-color .3s var(--n-bezier);
 position: absolute;
 top: var(--n-icon-size);
 left: calc(var(--n-icon-size) / 2 - 1px);
 bottom: 0px;
 width: 2px;
 background-color: var(--n-line-color);
 `)])])]);
  const timelineProps = Object.assign(Object.assign({}, useTheme.props), {
    horizontal: Boolean,
    itemPlacement: {
      type: String,
      default: "left"
    },
    size: {
      type: String,
      default: "medium"
    },
    iconSize: Number
  });
  const timelineInjectionKey = createInjectionKey("n-timeline");
  const Timeline = vue.defineComponent({
    name: "Timeline",
    props: timelineProps,
    setup(props, {
      slots
    }) {
      const {
        mergedClsPrefixRef
      } = useConfig(props);
      const themeRef = useTheme("Timeline", "-timeline", style$c, timelineLight$1, props, mergedClsPrefixRef);
      vue.provide(timelineInjectionKey, {
        props,
        mergedThemeRef: themeRef,
        mergedClsPrefixRef
      });
      return () => {
        const {
          value: mergedClsPrefix
        } = mergedClsPrefixRef;
        return vue.h("div", {
          class: [`${mergedClsPrefix}-timeline`, props.horizontal && `${mergedClsPrefix}-timeline--horizontal`, `${mergedClsPrefix}-timeline--${props.size}-size`, !props.horizontal && `${mergedClsPrefix}-timeline--${props.itemPlacement}-placement`]
        }, slots);
      };
    }
  });
  const timelineItemProps = {
    time: [String, Number],
    title: String,
    content: String,
    color: String,
    lineType: {
      type: String,
      default: "default"
    },
    type: {
      type: String,
      default: "default"
    }
  };
  const TimelineItem = vue.defineComponent({
    name: "TimelineItem",
    props: timelineItemProps,
    setup(props) {
      const NTimeline = vue.inject(timelineInjectionKey);
      if (!NTimeline) {
        throwError("timeline-item", "`n-timeline-item` must be placed inside `n-timeline`.");
      }
      useHoudini();
      const {
        inlineThemeDisabled
      } = useConfig();
      const cssVarsRef = vue.computed(() => {
        const {
          props: {
            size: size2,
            iconSize: iconSizeProp
          },
          mergedThemeRef
        } = NTimeline;
        const {
          type
        } = props;
        const {
          self: {
            titleTextColor,
            contentTextColor,
            metaTextColor,
            lineColor,
            titleFontWeight,
            contentFontSize,
            [createKey("iconSize", size2)]: iconSize,
            [createKey("titleMargin", size2)]: titleMargin,
            [createKey("titleFontSize", size2)]: titleFontSize,
            [createKey("circleBorder", type)]: circleBorder,
            [createKey("iconColor", type)]: iconColor
          },
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          }
        } = mergedThemeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-circle-border": circleBorder,
          "--n-icon-color": iconColor,
          "--n-content-font-size": contentFontSize,
          "--n-content-text-color": contentTextColor,
          "--n-line-color": lineColor,
          "--n-meta-text-color": metaTextColor,
          "--n-title-font-size": titleFontSize,
          "--n-title-font-weight": titleFontWeight,
          "--n-title-margin": titleMargin,
          "--n-title-text-color": titleTextColor,
          "--n-icon-size": formatLength(iconSizeProp) || iconSize
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("timeline-item", vue.computed(() => {
        const {
          props: {
            size: size2,
            iconSize: iconSizeProp
          }
        } = NTimeline;
        const {
          type
        } = props;
        return `${size2[0]}${iconSizeProp || "a"}${type[0]}`;
      }), cssVarsRef, NTimeline.props) : void 0;
      return {
        mergedClsPrefix: NTimeline.mergedClsPrefixRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      const {
        mergedClsPrefix,
        color,
        onRender,
        $slots
      } = this;
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h("div", {
        class: [`${mergedClsPrefix}-timeline-item`, this.themeClass, `${mergedClsPrefix}-timeline-item--${this.type}-type`, `${mergedClsPrefix}-timeline-item--${this.lineType}-line-type`],
        style: this.cssVars
      }, vue.h("div", {
        class: `${mergedClsPrefix}-timeline-item-timeline`
      }, vue.h("div", {
        class: `${mergedClsPrefix}-timeline-item-timeline__line`
      }), resolveWrappedSlot($slots.icon, (children) => {
        return children ? vue.h("div", {
          class: `${mergedClsPrefix}-timeline-item-timeline__icon`,
          style: {
            color
          }
        }, children) : vue.h("div", {
          class: `${mergedClsPrefix}-timeline-item-timeline__circle`,
          style: {
            borderColor: color
          }
        });
      })), vue.h("div", {
        class: `${mergedClsPrefix}-timeline-item-content`
      }, resolveWrappedSlot($slots.header, (children) => {
        const mergedChildren = children || this.title;
        if (mergedChildren) {
          return vue.h("div", {
            class: `${mergedClsPrefix}-timeline-item-content__title`
          }, children || this.title);
        }
        return null;
      }), vue.h("div", {
        class: `${mergedClsPrefix}-timeline-item-content__content`
      }, resolveSlot($slots.default, () => [this.content])), vue.h("div", {
        class: `${mergedClsPrefix}-timeline-item-content__meta`
      }, resolveSlot($slots.footer, () => [this.time]))));
    }
  });
  const transferInjectionKey = createInjectionKey("n-transfer");
  const NTransferHeader = vue.defineComponent({
    name: "TransferHeader",
    props: {
      size: {
        type: String,
        required: true
      },
      selectAllText: String,
      clearText: String,
      source: Boolean,
      onCheckedAll: Function,
      onClearAll: Function,
      title: [String, Function]
    },
    setup(props) {
      const {
        targetOptionsRef,
        canNotSelectAnythingRef,
        canBeClearedRef,
        allCheckedRef,
        mergedThemeRef,
        disabledRef,
        mergedClsPrefixRef,
        srcOptionsLengthRef
      } = vue.inject(transferInjectionKey);
      const {
        localeRef
      } = useLocale("Transfer");
      return () => {
        const {
          source,
          onClearAll,
          onCheckedAll,
          selectAllText,
          clearText
        } = props;
        const {
          value: mergedTheme
        } = mergedThemeRef;
        const {
          value: mergedClsPrefix
        } = mergedClsPrefixRef;
        const {
          value: locale
        } = localeRef;
        const buttonSize = props.size === "large" ? "small" : "tiny";
        const {
          title
        } = props;
        return vue.h("div", {
          class: `${mergedClsPrefix}-transfer-list-header`
        }, title && vue.h("div", {
          class: `${mergedClsPrefix}-transfer-list-header__title`
        }, typeof title === "function" ? title() : title), source && vue.h(NButton, {
          class: `${mergedClsPrefix}-transfer-list-header__button`,
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          size: buttonSize,
          tertiary: true,
          onClick: allCheckedRef.value ? onClearAll : onCheckedAll,
          disabled: canNotSelectAnythingRef.value || disabledRef.value
        }, {
          default: () => allCheckedRef.value ? clearText || locale.unselectAll : selectAllText || locale.selectAll
        }), !source && canBeClearedRef.value && vue.h(NButton, {
          class: `${mergedClsPrefix}-transfer-list-header__button`,
          theme: mergedTheme.peers.Button,
          themeOverrides: mergedTheme.peerOverrides.Button,
          size: buttonSize,
          tertiary: true,
          onClick: onClearAll,
          disabled: disabledRef.value
        }, {
          default: () => locale.clearAll
        }), vue.h("div", {
          class: `${mergedClsPrefix}-transfer-list-header__extra`
        }, source ? locale.total(srcOptionsLengthRef.value) : locale.selected(targetOptionsRef.value.length)));
      };
    }
  });
  const NTransferListItem = vue.defineComponent({
    name: "NTransferListItem",
    props: {
      source: Boolean,
      label: {
        type: String,
        required: true
      },
      value: {
        type: [String, Number],
        required: true
      },
      disabled: Boolean,
      option: {
        type: Object,
        required: true
      }
    },
    setup(props) {
      const {
        targetValueSetRef,
        mergedClsPrefixRef,
        mergedThemeRef,
        handleItemCheck,
        renderSourceLabelRef,
        renderTargetLabelRef,
        showSelectedRef
      } = vue.inject(transferInjectionKey);
      const checkedRef = useMemo(() => targetValueSetRef.value.has(props.value));
      function handleClick2() {
        if (!props.disabled) {
          handleItemCheck(!checkedRef.value, props.value);
        }
      }
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        mergedTheme: mergedThemeRef,
        checked: checkedRef,
        showSelected: showSelectedRef,
        renderSourceLabel: renderSourceLabelRef,
        renderTargetLabel: renderTargetLabelRef,
        handleClick: handleClick2
      };
    },
    render() {
      const {
        disabled,
        mergedTheme,
        mergedClsPrefix,
        label,
        checked,
        source,
        renderSourceLabel,
        renderTargetLabel
      } = this;
      return vue.h("div", {
        class: [`${mergedClsPrefix}-transfer-list-item`, disabled && `${mergedClsPrefix}-transfer-list-item--disabled`, source ? `${mergedClsPrefix}-transfer-list-item--source` : `${mergedClsPrefix}-transfer-list-item--target`],
        onClick: source ? this.handleClick : void 0
      }, vue.h("div", {
        class: `${mergedClsPrefix}-transfer-list-item__background`
      }), source && this.showSelected && vue.h("div", {
        class: `${mergedClsPrefix}-transfer-list-item__checkbox`
      }, vue.h(NCheckbox, {
        theme: mergedTheme.peers.Checkbox,
        themeOverrides: mergedTheme.peerOverrides.Checkbox,
        disabled,
        checked
      })), vue.h("div", {
        class: `${mergedClsPrefix}-transfer-list-item__label`,
        title: getTitleAttribute(label)
      }, source ? renderSourceLabel ? renderSourceLabel({
        option: this.option
      }) : label : renderTargetLabel ? renderTargetLabel({
        option: this.option
      }) : label), !source && !disabled && vue.h(NBaseClose, {
        focusable: false,
        class: `${mergedClsPrefix}-transfer-list-item__close`,
        clsPrefix: mergedClsPrefix,
        onClick: this.handleClick
      }));
    }
  });
  const NTransferList = vue.defineComponent({
    name: "TransferList",
    props: {
      virtualScroll: {
        type: Boolean,
        required: true
      },
      itemSize: {
        type: Number,
        required: true
      },
      options: {
        type: Array,
        required: true
      },
      disabled: {
        type: Boolean,
        required: true
      },
      source: Boolean
    },
    setup() {
      const {
        mergedThemeRef,
        mergedClsPrefixRef
      } = vue.inject(transferInjectionKey);
      const scrollerInstRef = vue.ref(null);
      const vlInstRef = vue.ref(null);
      function syncVLScroller() {
        var _a;
        (_a = scrollerInstRef.value) === null || _a === void 0 ? void 0 : _a.sync();
      }
      function scrollContainer() {
        const {
          value
        } = vlInstRef;
        if (!value)
          return null;
        const {
          listElRef
        } = value;
        return listElRef;
      }
      function scrollContent() {
        const {
          value
        } = vlInstRef;
        if (!value)
          return null;
        const {
          itemsElRef
        } = value;
        return itemsElRef;
      }
      return {
        mergedTheme: mergedThemeRef,
        mergedClsPrefix: mergedClsPrefixRef,
        scrollerInstRef,
        vlInstRef,
        syncVLScroller,
        scrollContainer,
        scrollContent
      };
    },
    render() {
      const {
        mergedTheme,
        options
      } = this;
      if (options.length === 0) {
        return vue.h(NEmpty, {
          theme: mergedTheme.peers.Empty,
          themeOverrides: mergedTheme.peerOverrides.Empty
        });
      }
      const {
        mergedClsPrefix,
        virtualScroll,
        source,
        disabled,
        syncVLScroller
      } = this;
      return vue.h(NScrollbar, {
        ref: "scrollerInstRef",
        theme: mergedTheme.peers.Scrollbar,
        themeOverrides: mergedTheme.peerOverrides.Scrollbar,
        container: virtualScroll ? this.scrollContainer : void 0,
        content: virtualScroll ? this.scrollContent : void 0
      }, {
        default: () => virtualScroll ? vue.h(VVirtualList, {
          ref: "vlInstRef",
          style: {
            height: "100%"
          },
          class: `${mergedClsPrefix}-transfer-list-content`,
          items: this.options,
          itemSize: this.itemSize,
          showScrollbar: false,
          onResize: syncVLScroller,
          onScroll: syncVLScroller,
          keyField: "value"
        }, {
          default: ({
            item
          }) => {
            const {
              source: source2,
              disabled: disabled2
            } = this;
            return vue.h(NTransferListItem, {
              source: source2,
              key: item.value,
              value: item.value,
              disabled: item.disabled || disabled2,
              label: item.label,
              option: item
            });
          }
        }) : vue.h("div", {
          class: `${mergedClsPrefix}-transfer-list-content`
        }, options.map((option) => vue.h(NTransferListItem, {
          source,
          key: option.value,
          value: option.value,
          disabled: option.disabled || disabled,
          label: option.label,
          option
        })))
      });
    }
  });
  const NTransferFilter = vue.defineComponent({
    name: "TransferFilter",
    props: {
      value: String,
      placeholder: String,
      disabled: Boolean,
      onUpdateValue: {
        type: Function,
        required: true
      }
    },
    setup() {
      const {
        mergedThemeRef,
        mergedClsPrefixRef
      } = vue.inject(transferInjectionKey);
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        mergedTheme: mergedThemeRef
      };
    },
    render() {
      const {
        mergedTheme,
        mergedClsPrefix
      } = this;
      return vue.h("div", {
        class: `${mergedClsPrefix}-transfer-filter`
      }, vue.h(NInput, {
        value: this.value,
        onUpdateValue: this.onUpdateValue,
        disabled: this.disabled,
        placeholder: this.placeholder,
        theme: mergedTheme.peers.Input,
        themeOverrides: mergedTheme.peerOverrides.Input,
        clearable: true,
        size: "small"
      }, {
        "clear-icon-placeholder": () => vue.h(NBaseIcon, {
          clsPrefix: mergedClsPrefix
        }, {
          default: () => vue.h(SearchIcon, null)
        })
      }));
    }
  });
  function useTransferData(props) {
    const uncontrolledValueRef = vue.ref(props.defaultValue);
    const mergedValueRef = useMergedState(vue.toRef(props, "value"), uncontrolledValueRef);
    const optionsMapRef = vue.computed(() => {
      const map2 = /* @__PURE__ */ new Map();
      (props.options || []).forEach((opt) => map2.set(opt.value, opt));
      return map2;
    });
    const targetValueSetRef = vue.computed(() => new Set(mergedValueRef.value || []));
    const targetOptionsRef = vue.computed(() => {
      const optionMap = optionsMapRef.value;
      const targetOptions = [];
      (mergedValueRef.value || []).forEach((v) => {
        const option = optionMap.get(v);
        if (option) {
          targetOptions.push(option);
        }
      });
      return targetOptions;
    });
    const srcPatternRef = vue.ref("");
    const tgtPatternRef = vue.ref("");
    const mergedSrcFilterableRef = vue.computed(() => {
      return props.sourceFilterable || !!props.filterable;
    });
    const filteredSrcOptionsRef = vue.computed(() => {
      const {
        showSelected,
        options,
        filter
      } = props;
      if (!mergedSrcFilterableRef.value) {
        if (showSelected) {
          return options;
        } else {
          return options.filter((option) => !targetValueSetRef.value.has(option.value));
        }
      }
      return options.filter((option) => {
        return filter(srcPatternRef.value, option, "source") && (showSelected || !targetValueSetRef.value.has(option.value));
      });
    });
    const filteredTgtOptionsRef = vue.computed(() => {
      if (!props.targetFilterable)
        return targetOptionsRef.value;
      const {
        filter
      } = props;
      return targetOptionsRef.value.filter((opt) => filter(tgtPatternRef.value, opt, "target"));
    });
    const mergedValueSetRef = vue.computed(() => {
      const {
        value
      } = mergedValueRef;
      if (value === null)
        return /* @__PURE__ */ new Set();
      return new Set(value);
    });
    const valueSetForCheckAllRef = vue.computed(() => {
      const values = new Set(mergedValueSetRef.value);
      filteredSrcOptionsRef.value.forEach((option) => {
        if (!option.disabled && !values.has(option.value)) {
          values.add(option.value);
        }
      });
      return values;
    });
    const valueSetForUncheckAllRef = vue.computed(() => {
      const values = new Set(mergedValueSetRef.value);
      filteredSrcOptionsRef.value.forEach((option) => {
        if (!option.disabled && values.has(option.value)) {
          values.delete(option.value);
        }
      });
      return values;
    });
    const valueSetForClearRef = vue.computed(() => {
      const values = new Set(mergedValueSetRef.value);
      filteredTgtOptionsRef.value.forEach((option) => {
        if (!option.disabled) {
          values.delete(option.value);
        }
      });
      return values;
    });
    const canNotSelectAnythingRef = vue.computed(() => {
      return filteredSrcOptionsRef.value.every((option) => option.disabled);
    });
    const allCheckedRef = vue.computed(() => {
      if (!filteredSrcOptionsRef.value.length) {
        return false;
      }
      const mergedValueSet = mergedValueSetRef.value;
      return filteredSrcOptionsRef.value.every((option) => option.disabled || mergedValueSet.has(option.value));
    });
    const canBeClearedRef = vue.computed(() => {
      return filteredTgtOptionsRef.value.some((option) => !option.disabled);
    });
    function handleSrcFilterUpdateValue(value) {
      srcPatternRef.value = value !== null && value !== void 0 ? value : "";
    }
    function handleTgtFilterUpdateValue(value) {
      tgtPatternRef.value = value !== null && value !== void 0 ? value : "";
    }
    return {
      uncontrolledValueRef,
      mergedValueRef,
      targetValueSetRef,
      valueSetForCheckAllRef,
      valueSetForUncheckAllRef,
      valueSetForClearRef,
      filteredTgtOptionsRef,
      filteredSrcOptionsRef,
      targetOptionsRef,
      canNotSelectAnythingRef,
      canBeClearedRef,
      allCheckedRef,
      srcPatternRef,
      tgtPatternRef,
      mergedSrcFilterableRef,
      handleSrcFilterUpdateValue,
      handleTgtFilterUpdateValue
    };
  }
  const style$b = cB("transfer", `
 width: 100%;
 font-size: var(--n-font-size);
 height: 300px;
 display: flex;
 flex-wrap: nowrap;
 word-break: break-word;
`, [cM("disabled", [cB("transfer-list", [cB("transfer-list-header", [cE("title", `
 color: var(--n-header-text-color-disabled);
 `), cE("extra", `
 color: var(--n-header-extra-text-color-disabled);
 `)])])]), cB("transfer-list", `
 flex: 1;
 min-width: 0;
 height: inherit;
 display: flex;
 flex-direction: column;
 background-clip: padding-box;
 position: relative;
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-list-color);
 `, [cM("source", `
 border-top-left-radius: var(--n-border-radius);
 border-bottom-left-radius: var(--n-border-radius);
 `, [cE("border", "border-right: 1px solid var(--n-divider-color);")]), cM("target", `
 border-top-right-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `, [cE("border", "border-left: none;")]), cE("border", `
 padding: 0 12px;
 border: 1px solid var(--n-border-color);
 transition: border-color .3s var(--n-bezier);
 pointer-events: none;
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `), cB("transfer-list-header", `
 min-height: var(--n-header-height);
 box-sizing: border-box;
 display: flex;
 padding: 12px 12px 10px 12px;
 align-items: center;
 background-clip: padding-box;
 border-radius: inherit;
 border-bottom-left-radius: 0;
 border-bottom-right-radius: 0;
 line-height: 1.5;
 transition:
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [c$1("> *:not(:first-child)", `
 margin-left: 8px;
 `), cE("title", `
 flex: 1;
 min-width: 0;
 line-height: 1.5;
 font-size: var(--n-header-font-size);
 font-weight: var(--n-header-font-weight);
 transition: color .3s var(--n-bezier);
 color: var(--n-header-text-color);
 `), cE("button", `
 position: relative;
 `), cE("extra", `
 transition: color .3s var(--n-bezier);
 font-size: var(--n-extra-font-size);
 margin-right: 0;
 white-space: nowrap;
 color: var(--n-header-extra-text-color);
 `)]), cB("transfer-list-body", `
 flex-basis: 0;
 flex-grow: 1;
 box-sizing: border-box;
 position: relative;
 display: flex;
 flex-direction: column;
 border-radius: inherit;
 border-top-left-radius: 0;
 border-top-right-radius: 0;
 `, [cB("transfer-filter", `
 padding: 4px 12px 8px 12px;
 box-sizing: border-box;
 transition:
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), cB("transfer-list-flex-container", `
 flex: 1;
 position: relative;
 `, [cB("scrollbar", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 height: unset;
 `), cB("empty", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateY(-50%) translateX(-50%);
 `), cB("transfer-list-content", `
 padding: 0;
 margin: 0;
 position: relative;
 `, [cB("transfer-list-item", `
 padding: 0 12px;
 min-height: var(--n-item-height);
 display: flex;
 align-items: center;
 color: var(--n-item-text-color);
 position: relative;
 transition: color .3s var(--n-bezier);
 `, [cE("background", `
 position: absolute;
 left: 4px;
 right: 4px;
 top: 0;
 bottom: 0;
 border-radius: var(--n-border-radius);
 transition: background-color .3s var(--n-bezier);
 `), cE("checkbox", `
 position: relative;
 margin-right: 8px;
 `), cE("close", `
 opacity: 0;
 pointer-events: none;
 position: relative;
 transition:
 opacity .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), cE("label", `
 position: relative;
 min-width: 0;
 flex-grow: 1;
 `), cM("source", "cursor: pointer;"), cM("disabled", `
 cursor: not-allowed;
 color: var(--n-item-text-color-disabled);
 `), cNotM("disabled", [c$1("&:hover", [cE("background", "background-color: var(--n-item-color-pending);"), cE("close", `
 opacity: 1;
 pointer-events: all;
 `)])])])])])])])]);
  const transferProps = Object.assign(Object.assign({}, useTheme.props), {
    value: Array,
    defaultValue: {
      type: Array,
      default: null
    },
    options: {
      type: Array,
      default: () => []
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    virtualScroll: Boolean,
    sourceTitle: [String, Function],
    selectAllText: String,
    clearText: String,
    targetTitle: [String, Function],
    filterable: {
      type: Boolean,
      default: void 0
    },
    sourceFilterable: Boolean,
    targetFilterable: Boolean,
    showSelected: {
      type: Boolean,
      default: true
    },
    sourceFilterPlaceholder: String,
    targetFilterPlaceholder: String,
    filter: {
      type: Function,
      default: (pattern, option) => {
        if (!pattern)
          return true;
        return ~`${option.label}`.toLowerCase().indexOf(`${pattern}`.toLowerCase());
      }
    },
    size: String,
    renderSourceLabel: Function,
    renderTargetLabel: Function,
    renderSourceList: Function,
    renderTargetList: Function,
    "onUpdate:value": [Function, Array],
    onUpdateValue: [Function, Array],
    onChange: [Function, Array]
  });
  const Transfer = vue.defineComponent({
    name: "Transfer",
    props: transferProps,
    setup(props) {
      {
        vue.watchEffect(() => {
          if (props.onChange !== void 0) {
            warnOnce("transfer", "`on-change` is deprecated, please use `on-update:value` instead.");
          }
          if (props.filterable !== void 0) {
            warnOnce("transfer", "`filterable` is deprecated, please use `source-filterable` or `target-filterable` instead.");
          }
        });
      }
      const {
        mergedClsPrefixRef
      } = useConfig(props);
      const themeRef = useTheme("Transfer", "-transfer", style$b, transferLight$2, props, mergedClsPrefixRef);
      const formItem = useFormItem(props);
      const {
        mergedSizeRef,
        mergedDisabledRef
      } = formItem;
      const itemSizeRef = vue.computed(() => {
        const {
          value: size2
        } = mergedSizeRef;
        const {
          self: {
            [createKey("itemHeight", size2)]: itemSize
          }
        } = themeRef.value;
        return depx(itemSize);
      });
      const {
        uncontrolledValueRef,
        mergedValueRef,
        targetValueSetRef,
        valueSetForCheckAllRef,
        valueSetForUncheckAllRef,
        valueSetForClearRef,
        filteredTgtOptionsRef,
        filteredSrcOptionsRef,
        targetOptionsRef,
        canNotSelectAnythingRef,
        canBeClearedRef,
        allCheckedRef,
        srcPatternRef,
        tgtPatternRef,
        mergedSrcFilterableRef,
        handleSrcFilterUpdateValue,
        handleTgtFilterUpdateValue
      } = useTransferData(props);
      function doUpdateValue(value) {
        const {
          onUpdateValue,
          "onUpdate:value": _onUpdateValue,
          onChange
        } = props;
        const {
          nTriggerFormInput,
          nTriggerFormChange
        } = formItem;
        if (onUpdateValue)
          call(onUpdateValue, value);
        if (_onUpdateValue)
          call(_onUpdateValue, value);
        if (onChange)
          call(onChange, value);
        uncontrolledValueRef.value = value;
        nTriggerFormInput();
        nTriggerFormChange();
      }
      function handleSourceCheckAll() {
        doUpdateValue([...valueSetForCheckAllRef.value]);
      }
      function handleSourceUncheckAll() {
        doUpdateValue([...valueSetForUncheckAllRef.value]);
      }
      function handleTargetClearAll() {
        doUpdateValue([...valueSetForClearRef.value]);
      }
      function handleItemCheck(checked, optionValue) {
        if (checked) {
          doUpdateValue((mergedValueRef.value || []).concat(optionValue));
        } else {
          doUpdateValue((mergedValueRef.value || []).filter((v) => v !== optionValue));
        }
      }
      function handleChecked(optionValueList) {
        doUpdateValue(optionValueList);
      }
      vue.provide(transferInjectionKey, {
        targetValueSetRef,
        mergedClsPrefixRef,
        disabledRef: mergedDisabledRef,
        mergedThemeRef: themeRef,
        targetOptionsRef,
        canNotSelectAnythingRef,
        canBeClearedRef,
        allCheckedRef,
        srcOptionsLengthRef: vue.computed(() => props.options.length),
        handleItemCheck,
        renderSourceLabelRef: vue.toRef(props, "renderSourceLabel"),
        renderTargetLabelRef: vue.toRef(props, "renderTargetLabel"),
        showSelectedRef: vue.toRef(props, "showSelected")
      });
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        mergedDisabled: mergedDisabledRef,
        itemSize: itemSizeRef,
        isMounted: isMounted(),
        mergedTheme: themeRef,
        filteredSrcOpts: filteredSrcOptionsRef,
        filteredTgtOpts: filteredTgtOptionsRef,
        srcPattern: srcPatternRef,
        tgtPattern: tgtPatternRef,
        mergedSize: mergedSizeRef,
        mergedSrcFilterable: mergedSrcFilterableRef,
        handleSrcFilterUpdateValue,
        handleTgtFilterUpdateValue,
        handleSourceCheckAll,
        handleSourceUncheckAll,
        handleTargetClearAll,
        handleItemCheck,
        handleChecked,
        cssVars: vue.computed(() => {
          const {
            value: size2
          } = mergedSizeRef;
          const {
            common: {
              cubicBezierEaseInOut: cubicBezierEaseInOut2
            },
            self: {
              borderRadius,
              borderColor,
              listColor,
              titleTextColor,
              titleTextColorDisabled,
              extraTextColor,
              itemTextColor,
              itemColorPending,
              itemTextColorDisabled,
              titleFontWeight,
              closeColorHover,
              closeColorPressed,
              closeIconColor,
              closeIconColorHover,
              closeIconColorPressed,
              closeIconSize,
              closeSize,
              dividerColor,
              extraTextColorDisabled,
              [createKey("extraFontSize", size2)]: extraFontSize,
              [createKey("fontSize", size2)]: fontSize2,
              [createKey("titleFontSize", size2)]: titleFontSize,
              [createKey("itemHeight", size2)]: itemHeight,
              [createKey("headerHeight", size2)]: headerHeight
            }
          } = themeRef.value;
          return {
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-border-color": borderColor,
            "--n-border-radius": borderRadius,
            "--n-extra-font-size": extraFontSize,
            "--n-font-size": fontSize2,
            "--n-header-font-size": titleFontSize,
            "--n-header-extra-text-color": extraTextColor,
            "--n-header-extra-text-color-disabled": extraTextColorDisabled,
            "--n-header-font-weight": titleFontWeight,
            "--n-header-text-color": titleTextColor,
            "--n-header-text-color-disabled": titleTextColorDisabled,
            "--n-item-color-pending": itemColorPending,
            "--n-item-height": itemHeight,
            "--n-item-text-color": itemTextColor,
            "--n-item-text-color-disabled": itemTextColorDisabled,
            "--n-list-color": listColor,
            "--n-header-height": headerHeight,
            "--n-close-size": closeSize,
            "--n-close-icon-size": closeIconSize,
            "--n-close-color-hover": closeColorHover,
            "--n-close-color-pressed": closeColorPressed,
            "--n-close-icon-color": closeIconColor,
            "--n-close-icon-color-hover": closeIconColorHover,
            "--n-close-icon-color-pressed": closeIconColorPressed,
            "--n-divider-color": dividerColor
          };
        })
      };
    },
    render() {
      const {
        mergedClsPrefix,
        renderSourceList,
        renderTargetList,
        mergedTheme,
        mergedSrcFilterable,
        targetFilterable
      } = this;
      return vue.h("div", {
        class: [`${mergedClsPrefix}-transfer`, this.mergedDisabled && `${mergedClsPrefix}-transfer--disabled`],
        style: this.cssVars
      }, vue.h("div", {
        class: `${mergedClsPrefix}-transfer-list ${mergedClsPrefix}-transfer-list--source`
      }, vue.h(NTransferHeader, {
        source: true,
        selectAllText: this.selectAllText,
        clearText: this.clearText,
        title: this.sourceTitle,
        onCheckedAll: this.handleSourceCheckAll,
        onClearAll: this.handleSourceUncheckAll,
        size: this.mergedSize
      }), vue.h("div", {
        class: `${mergedClsPrefix}-transfer-list-body`
      }, mergedSrcFilterable ? vue.h(NTransferFilter, {
        onUpdateValue: this.handleSrcFilterUpdateValue,
        value: this.srcPattern,
        disabled: this.mergedDisabled,
        placeholder: this.sourceFilterPlaceholder
      }) : null, vue.h("div", {
        class: `${mergedClsPrefix}-transfer-list-flex-container`
      }, renderSourceList ? vue.h(NScrollbar, {
        theme: mergedTheme.peers.Scrollbar,
        themeOverrides: mergedTheme.peerOverrides.Scrollbar
      }, {
        default: () => renderSourceList({
          onCheck: this.handleChecked,
          checkedOptions: this.filteredTgtOpts,
          pattern: this.srcPattern
        })
      }) : vue.h(NTransferList, {
        source: true,
        options: this.filteredSrcOpts,
        disabled: this.mergedDisabled,
        virtualScroll: this.virtualScroll,
        itemSize: this.itemSize
      }))), vue.h("div", {
        class: `${mergedClsPrefix}-transfer-list__border`
      })), vue.h("div", {
        class: `${mergedClsPrefix}-transfer-list ${mergedClsPrefix}-transfer-list--target`
      }, vue.h(NTransferHeader, {
        onClearAll: this.handleTargetClearAll,
        size: this.mergedSize,
        title: this.targetTitle
      }), vue.h("div", {
        class: `${mergedClsPrefix}-transfer-list-body`
      }, targetFilterable ? vue.h(NTransferFilter, {
        onUpdateValue: this.handleTgtFilterUpdateValue,
        value: this.tgtPattern,
        disabled: this.mergedDisabled,
        placeholder: this.sourceFilterPlaceholder
      }) : null, vue.h("div", {
        class: `${mergedClsPrefix}-transfer-list-flex-container`
      }, renderTargetList ? vue.h(NScrollbar, {
        theme: mergedTheme.peers.Scrollbar,
        themeOverrides: mergedTheme.peerOverrides.Scrollbar
      }, {
        default: () => renderTargetList({
          onCheck: this.handleChecked,
          checkedOptions: this.filteredTgtOpts,
          pattern: this.tgtPattern
        })
      }) : vue.h(NTransferList, {
        options: this.filteredTgtOpts,
        disabled: this.mergedDisabled,
        virtualScroll: this.virtualScroll,
        itemSize: this.itemSize
      }))), vue.h("div", {
        class: `${mergedClsPrefix}-transfer-list__border`
      })));
    }
  });
  const treeSelectInjectionKey = createInjectionKey("n-tree-select");
  const treeInjectionKey = createInjectionKey("n-tree");
  const NTreeNodeSwitcher = vue.defineComponent({
    name: "NTreeSwitcher",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      indent: {
        type: Number,
        required: true
      },
      expanded: Boolean,
      selected: Boolean,
      hide: Boolean,
      loading: Boolean,
      onClick: Function,
      tmNode: {
        type: Object,
        required: true
      }
    },
    setup(props) {
      const {
        renderSwitcherIconRef
      } = vue.inject(treeInjectionKey, null);
      return () => {
        const {
          clsPrefix,
          expanded,
          hide,
          indent,
          onClick
        } = props;
        return vue.h("span", {
          "data-switcher": true,
          class: [`${clsPrefix}-tree-node-switcher`, expanded && `${clsPrefix}-tree-node-switcher--expanded`, hide && `${clsPrefix}-tree-node-switcher--hide`],
          style: {
            width: `${indent}px`
          },
          onClick
        }, vue.h("div", {
          class: `${clsPrefix}-tree-node-switcher__icon`
        }, vue.h(NIconSwitchTransition, null, {
          default: () => {
            if (props.loading) {
              return vue.h(NBaseLoading, {
                clsPrefix,
                key: "loading",
                radius: 85,
                strokeWidth: 20
              });
            }
            const {
              value: renderSwitcherIcon
            } = renderSwitcherIconRef;
            return renderSwitcherIcon ? renderSwitcherIcon({
              expanded: props.expanded,
              selected: props.selected,
              option: props.tmNode.rawNode
            }) : vue.h(NBaseIcon, {
              clsPrefix,
              key: "switcher"
            }, {
              default: () => vue.h(SwitcherIcon, null)
            });
          }
        })));
      };
    }
  });
  const NTreeNodeCheckbox = vue.defineComponent({
    name: "NTreeNodeCheckbox",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      indent: {
        type: Number,
        required: true
      },
      right: Boolean,
      focusable: Boolean,
      disabled: Boolean,
      checked: Boolean,
      indeterminate: Boolean,
      onCheck: Function
    },
    setup(props) {
      const NTree2 = vue.inject(treeInjectionKey);
      function doCheck(value) {
        const {
          onCheck
        } = props;
        if (onCheck) {
          onCheck(value);
        }
      }
      function handleUpdateValue(value) {
        doCheck(value);
      }
      return {
        handleUpdateValue,
        mergedTheme: NTree2.mergedThemeRef
      };
    },
    render() {
      const {
        clsPrefix,
        mergedTheme,
        checked,
        indeterminate,
        disabled,
        focusable,
        indent,
        handleUpdateValue
      } = this;
      return vue.h("span", {
        class: [`${clsPrefix}-tree-node-checkbox`, this.right && `${clsPrefix}-tree-node-checkbox--right`],
        style: {
          width: `${indent}px`
        },
        "data-checkbox": true
      }, vue.h(NCheckbox, {
        focusable,
        disabled,
        theme: mergedTheme.peers.Checkbox,
        themeOverrides: mergedTheme.peerOverrides.Checkbox,
        checked,
        indeterminate,
        onUpdateChecked: handleUpdateValue
      }));
    }
  });
  const NTreeNodeContent = vue.defineComponent({
    name: "TreeNodeContent",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      disabled: Boolean,
      checked: Boolean,
      selected: Boolean,
      onClick: Function,
      onDragstart: Function,
      tmNode: {
        type: Object,
        required: true
      },
      nodeProps: Object
    },
    setup(props) {
      const {
        renderLabelRef,
        renderPrefixRef,
        renderSuffixRef,
        labelFieldRef
      } = vue.inject(treeInjectionKey);
      const selfRef = vue.ref(null);
      function doClick(e) {
        const {
          onClick
        } = props;
        if (onClick)
          onClick(e);
      }
      function handleClick2(e) {
        doClick(e);
      }
      return {
        selfRef,
        renderLabel: renderLabelRef,
        renderPrefix: renderPrefixRef,
        renderSuffix: renderSuffixRef,
        labelField: labelFieldRef,
        handleClick: handleClick2
      };
    },
    render() {
      const {
        clsPrefix,
        labelField,
        nodeProps,
        checked = false,
        selected = false,
        renderLabel,
        renderPrefix,
        renderSuffix,
        handleClick: handleClick2,
        onDragstart,
        tmNode: {
          rawNode,
          rawNode: {
            prefix: prefix2,
            suffix: suffix2,
            [labelField]: label
          }
        }
      } = this;
      return vue.h("span", Object.assign({}, nodeProps, {
        ref: "selfRef",
        class: [`${clsPrefix}-tree-node-content`, nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps.class],
        onClick: handleClick2,
        draggable: onDragstart === void 0 ? void 0 : true,
        onDragstart
      }), renderPrefix || prefix2 ? vue.h("div", {
        class: `${clsPrefix}-tree-node-content__prefix`
      }, renderPrefix ? renderPrefix({
        option: rawNode,
        selected,
        checked
      }) : render$1(prefix2)) : null, vue.h("div", {
        class: `${clsPrefix}-tree-node-content__text`
      }, renderLabel ? renderLabel({
        option: rawNode,
        selected,
        checked
      }) : render$1(label)), renderSuffix || suffix2 ? vue.h("div", {
        class: `${clsPrefix}-tree-node-content__suffix`
      }, renderSuffix ? renderSuffix({
        option: rawNode,
        selected,
        checked
      }) : render$1(suffix2)) : null);
    }
  });
  function renderDropMark({
    position,
    offsetLevel,
    indent,
    el
  }) {
    const style2 = {
      position: "absolute",
      boxSizing: "border-box",
      right: 0
    };
    if (position === "inside") {
      style2.left = 0;
      style2.top = 0;
      style2.bottom = 0;
      style2.borderRadius = "inherit";
      style2.boxShadow = "inset 0 0 0 2px var(--n-drop-mark-color)";
    } else {
      const cssPosition = position === "before" ? "top" : "bottom";
      style2[cssPosition] = 0;
      style2.left = `${el.offsetLeft + 6 - offsetLevel * indent}px`;
      style2.height = "2px";
      style2.backgroundColor = "var(--n-drop-mark-color)";
      style2.transformOrigin = cssPosition;
      style2.borderRadius = "1px";
      style2.transform = position === "before" ? "translateY(-4px)" : "translateY(4px)";
    }
    return vue.h("div", {
      style: style2
    });
  }
  function defaultAllowDrop({
    dropPosition,
    node
  }) {
    if (node.isLeaf === false)
      return true;
    if (node.children) {
      return true;
    }
    return dropPosition !== "inside";
  }
  function useMergedCheckStrategy(props) {
    return vue.computed(() => props.leafOnly ? "child" : props.checkStrategy);
  }
  function isNodeDisabled(node, disabledField) {
    return !!node.rawNode[disabledField];
  }
  function traverse(nodes, childrenField, callback, callbackAfter) {
    nodes === null || nodes === void 0 ? void 0 : nodes.forEach((node) => {
      callback(node);
      traverse(node[childrenField], childrenField, callback, callbackAfter);
      callbackAfter(node);
    });
  }
  function keysWithFilter(nodes, pattern, keyField, childrenField, filter) {
    const keys2 = /* @__PURE__ */ new Set();
    const highlightKeySet = /* @__PURE__ */ new Set();
    const path = [];
    traverse(nodes, childrenField, (node) => {
      path.push(node);
      if (filter(pattern, node)) {
        highlightKeySet.add(node[keyField]);
        for (let i = path.length - 2; i >= 0; --i) {
          if (!keys2.has(path[i][keyField])) {
            keys2.add(path[i][keyField]);
          } else {
            return;
          }
        }
      }
    }, () => {
      path.pop();
    });
    return {
      expandedKeys: Array.from(keys2),
      highlightKeySet
    };
  }
  if (isBrowser$2 && Image) {
    const emptyImage = new Image();
    emptyImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
  }
  function filterTree(tree, filter, pattern, keyField, childrenField) {
    const visitedTailKeys = /* @__PURE__ */ new Set();
    const visitedNonTailKeys = /* @__PURE__ */ new Set();
    const highlightKeySet = /* @__PURE__ */ new Set();
    const expandedKeys = [];
    const filteredTree = [];
    const path = [];
    function visit(t) {
      t.forEach((n) => {
        path.push(n);
        if (filter(pattern, n)) {
          visitedTailKeys.add(n[keyField]);
          highlightKeySet.add(n[keyField]);
          for (let i = path.length - 2; i >= 0; --i) {
            const key = path[i][keyField];
            if (!visitedNonTailKeys.has(key)) {
              visitedNonTailKeys.add(key);
              if (visitedTailKeys.has(key)) {
                visitedTailKeys.delete(key);
              }
            } else {
              break;
            }
          }
        }
        const children = n[childrenField];
        if (children) {
          visit(children);
        }
        path.pop();
      });
    }
    visit(tree);
    function build(t, sibs) {
      t.forEach((n) => {
        const key = n[keyField];
        const isVisitedTail = visitedTailKeys.has(key);
        const isVisitedNonTail = visitedNonTailKeys.has(key);
        if (!isVisitedTail && !isVisitedNonTail)
          return;
        const children = n[childrenField];
        if (children) {
          if (isVisitedTail) {
            sibs.push(n);
          } else {
            expandedKeys.push(key);
            const clonedNode = Object.assign(Object.assign({}, n), {
              [childrenField]: []
            });
            sibs.push(clonedNode);
            build(children, clonedNode[childrenField]);
          }
        } else {
          sibs.push(n);
        }
      });
    }
    build(tree, filteredTree);
    return {
      filteredTree,
      highlightKeySet,
      expandedKeys
    };
  }
  function treeGetClickTarget(e) {
    if (happensIn(e, "checkbox")) {
      return "checkbox";
    } else if (happensIn(e, "switcher")) {
      return "switcher";
    } else {
      return "node";
    }
  }
  const TreeNode = vue.defineComponent({
    name: "TreeNode",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      tmNode: {
        type: Object,
        required: true
      }
    },
    setup(props) {
      const NTree2 = vue.inject(treeInjectionKey);
      const {
        droppingNodeParentRef,
        droppingMouseNodeRef,
        draggingNodeRef,
        droppingPositionRef,
        droppingOffsetLevelRef,
        nodePropsRef,
        indentRef,
        blockLineRef,
        checkboxPlacementRef,
        checkOnClickRef,
        disabledFieldRef,
        showLineRef,
        renderSwitcherIconRef,
        overrideDefaultNodeClickBehaviorRef
      } = NTree2;
      const checkboxDisabledRef = useMemo(() => !!props.tmNode.rawNode.checkboxDisabled);
      const nodeIsDisabledRef = useMemo(() => {
        return isNodeDisabled(props.tmNode, disabledFieldRef.value);
      });
      const disabledRef = useMemo(() => NTree2.disabledRef.value || nodeIsDisabledRef.value);
      const resolvedNodePropsRef = vue.computed(() => {
        const {
          value: nodeProps
        } = nodePropsRef;
        if (!nodeProps)
          return void 0;
        return nodeProps({
          option: props.tmNode.rawNode
        });
      });
      const contentInstRef = vue.ref(null);
      const contentElRef = {
        value: null
      };
      vue.onMounted(() => {
        contentElRef.value = contentInstRef.value.$el;
      });
      function handleSwitcherClick() {
        const callback = () => {
          const {
            tmNode
          } = props;
          if (!tmNode.isLeaf && !tmNode.shallowLoaded) {
            if (!NTree2.loadingKeysRef.value.has(tmNode.key)) {
              NTree2.loadingKeysRef.value.add(tmNode.key);
            } else {
              return;
            }
            const {
              onLoadRef: {
                value: onLoad
              }
            } = NTree2;
            if (onLoad) {
              void onLoad(tmNode.rawNode).then((value) => {
                if (value !== false) {
                  NTree2.handleSwitcherClick(tmNode);
                }
              }).finally(() => {
                NTree2.loadingKeysRef.value.delete(tmNode.key);
              });
            }
          } else {
            NTree2.handleSwitcherClick(tmNode);
          }
        };
        if (renderSwitcherIconRef.value) {
          setTimeout(callback, 0);
        } else {
          callback();
        }
      }
      const selectableRef = useMemo(() => !nodeIsDisabledRef.value && NTree2.selectableRef.value && (NTree2.internalTreeSelect ? NTree2.mergedCheckStrategyRef.value !== "child" || NTree2.multipleRef.value && NTree2.cascadeRef.value || props.tmNode.isLeaf : true));
      const checkableRef = useMemo(() => NTree2.checkableRef.value && (NTree2.cascadeRef.value || NTree2.mergedCheckStrategyRef.value !== "child" || props.tmNode.isLeaf));
      const checkedRef = useMemo(() => NTree2.displayedCheckedKeysRef.value.includes(props.tmNode.key));
      const mergedCheckOnClickRef = useMemo(() => {
        const {
          value: checkable
        } = checkableRef;
        if (!checkable)
          return false;
        const {
          value: checkOnClick
        } = checkOnClickRef;
        const {
          tmNode
        } = props;
        if (typeof checkOnClick === "boolean") {
          return !tmNode.disabled && checkOnClick;
        }
        return checkOnClick(props.tmNode.rawNode);
      });
      function _handleClick(e) {
        const {
          value: expandOnClick
        } = NTree2.expandOnClickRef;
        const {
          value: selectable
        } = selectableRef;
        const {
          value: mergedCheckOnClick
        } = mergedCheckOnClickRef;
        if (!selectable && !expandOnClick && !mergedCheckOnClick)
          return;
        if (happensIn(e, "checkbox") || happensIn(e, "switcher"))
          return;
        const {
          tmNode
        } = props;
        if (selectable) {
          NTree2.handleSelect(tmNode);
        }
        if (expandOnClick && !tmNode.isLeaf) {
          handleSwitcherClick();
        }
        if (mergedCheckOnClick) {
          handleCheck(!checkedRef.value);
        }
      }
      function handleNodeClick(e) {
        var _a, _b;
        if (happensIn(e, "checkbox") || happensIn(e, "switcher"))
          return;
        if (!disabledRef.value) {
          const overrideDefaultNodeClickBehavior = overrideDefaultNodeClickBehaviorRef.value;
          let shouldOverride = false;
          if (overrideDefaultNodeClickBehavior) {
            switch (overrideDefaultNodeClickBehavior({
              option: props.tmNode.rawNode
            })) {
              case "toggleCheck":
                shouldOverride = true;
                handleCheck(!checkedRef.value);
                break;
              case "toggleSelect":
                shouldOverride = true;
                NTree2.handleSelect(props.tmNode);
                break;
              case "toggleExpand":
                shouldOverride = true;
                handleSwitcherClick();
                shouldOverride = true;
                break;
              case "none":
                shouldOverride = true;
                shouldOverride = true;
                return;
            }
          }
          if (!shouldOverride) {
            _handleClick(e);
          }
        }
        (_b = (_a = resolvedNodePropsRef.value) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e);
      }
      function handleContentClick(e) {
        if (blockLineRef.value)
          return;
        handleNodeClick(e);
      }
      function handleLineClick(e) {
        if (!blockLineRef.value)
          return;
        handleNodeClick(e);
      }
      function handleCheck(checked) {
        NTree2.handleCheck(props.tmNode, checked);
      }
      function handleDragStart(e) {
        NTree2.handleDragStart({
          event: e,
          node: props.tmNode
        });
      }
      function handleDragEnter(e) {
        if (e.currentTarget !== e.target) {
          return;
        }
        NTree2.handleDragEnter({
          event: e,
          node: props.tmNode
        });
      }
      function handleDragOver(e) {
        e.preventDefault();
        NTree2.handleDragOver({
          event: e,
          node: props.tmNode
        });
      }
      function handleDragEnd(e) {
        NTree2.handleDragEnd({
          event: e,
          node: props.tmNode
        });
      }
      function handleDragLeave(e) {
        if (e.currentTarget !== e.target) {
          return;
        }
        NTree2.handleDragLeave({
          event: e,
          node: props.tmNode
        });
      }
      function handleDrop(e) {
        e.preventDefault();
        if (droppingPositionRef.value !== null) {
          NTree2.handleDrop({
            event: e,
            node: props.tmNode,
            dropPosition: droppingPositionRef.value
          });
        }
      }
      const indentNodes = vue.computed(() => {
        const {
          clsPrefix
        } = props;
        const {
          value: indent
        } = indentRef;
        if (showLineRef.value) {
          const indentNodes2 = [];
          let cursor = props.tmNode.parent;
          while (cursor) {
            if (cursor.isLastChild) {
              indentNodes2.push(vue.h("div", {
                class: `${clsPrefix}-tree-node-indent`
              }, vue.h("div", {
                style: {
                  width: `${indent}px`
                }
              })));
            } else {
              indentNodes2.push(vue.h("div", {
                class: [`${clsPrefix}-tree-node-indent`, `${clsPrefix}-tree-node-indent--show-line`]
              }, vue.h("div", {
                style: {
                  width: `${indent}px`
                }
              })));
            }
            cursor = cursor.parent;
          }
          return indentNodes2.reverse();
        } else {
          return repeat(props.tmNode.level, vue.h("div", {
            class: `${props.clsPrefix}-tree-node-indent`
          }, vue.h("div", {
            style: {
              width: `${indent}px`
            }
          })));
        }
      });
      return {
        showDropMark: useMemo(() => {
          const {
            value: draggingNode
          } = draggingNodeRef;
          if (!draggingNode)
            return;
          const {
            value: droppingPosition
          } = droppingPositionRef;
          if (!droppingPosition)
            return;
          const {
            value: droppingMouseNode
          } = droppingMouseNodeRef;
          if (!droppingMouseNode) {
            return;
          }
          const {
            tmNode
          } = props;
          if (tmNode.key === droppingMouseNode.key)
            return true;
          return false;
        }),
        showDropMarkAsParent: useMemo(() => {
          const {
            value: droppingNodeParent
          } = droppingNodeParentRef;
          if (!droppingNodeParent)
            return false;
          const {
            tmNode
          } = props;
          const {
            value: droppingPosition
          } = droppingPositionRef;
          if (droppingPosition === "before" || droppingPosition === "after") {
            return droppingNodeParent.key === tmNode.key;
          }
          return false;
        }),
        pending: useMemo(() => NTree2.pendingNodeKeyRef.value === props.tmNode.key),
        loading: useMemo(() => NTree2.loadingKeysRef.value.has(props.tmNode.key)),
        highlight: useMemo(() => {
          var _a;
          return (_a = NTree2.highlightKeySetRef.value) === null || _a === void 0 ? void 0 : _a.has(props.tmNode.key);
        }),
        checked: checkedRef,
        indeterminate: useMemo(() => NTree2.displayedIndeterminateKeysRef.value.includes(props.tmNode.key)),
        selected: useMemo(() => NTree2.mergedSelectedKeysRef.value.includes(props.tmNode.key)),
        expanded: useMemo(() => NTree2.mergedExpandedKeysRef.value.includes(props.tmNode.key)),
        disabled: disabledRef,
        checkable: checkableRef,
        mergedCheckOnClick: mergedCheckOnClickRef,
        checkboxDisabled: checkboxDisabledRef,
        selectable: selectableRef,
        expandOnClick: NTree2.expandOnClickRef,
        internalScrollable: NTree2.internalScrollableRef,
        draggable: NTree2.draggableRef,
        blockLine: blockLineRef,
        nodeProps: resolvedNodePropsRef,
        checkboxFocusable: NTree2.internalCheckboxFocusableRef,
        droppingPosition: droppingPositionRef,
        droppingOffsetLevel: droppingOffsetLevelRef,
        indent: indentRef,
        checkboxPlacement: checkboxPlacementRef,
        showLine: showLineRef,
        contentInstRef,
        contentElRef,
        indentNodes,
        handleCheck,
        handleDrop,
        handleDragStart,
        handleDragEnter,
        handleDragOver,
        handleDragEnd,
        handleDragLeave,
        handleLineClick,
        handleContentClick,
        handleSwitcherClick
      };
    },
    render() {
      const {
        tmNode,
        clsPrefix,
        checkable,
        expandOnClick,
        selectable,
        selected,
        checked,
        highlight,
        draggable,
        blockLine,
        indent,
        indentNodes,
        disabled,
        pending,
        internalScrollable,
        nodeProps,
        checkboxPlacement
      } = this;
      const dragEventHandlers = draggable && !disabled ? {
        onDragenter: this.handleDragEnter,
        onDragleave: this.handleDragLeave,
        onDragend: this.handleDragEnd,
        onDrop: this.handleDrop,
        onDragover: this.handleDragOver
      } : void 0;
      const dataKey = internalScrollable ? createDataKey(tmNode.key) : void 0;
      const checkboxOnRight = checkboxPlacement === "right";
      const checkboxNode = checkable ? vue.h(NTreeNodeCheckbox, {
        indent,
        right: checkboxOnRight,
        focusable: this.checkboxFocusable,
        disabled: disabled || this.checkboxDisabled,
        clsPrefix,
        checked: this.checked,
        indeterminate: this.indeterminate,
        onCheck: this.handleCheck
      }) : null;
      return vue.h("div", Object.assign({
        class: `${clsPrefix}-tree-node-wrapper`
      }, dragEventHandlers), vue.h("div", Object.assign({}, blockLine ? nodeProps : void 0, {
        class: [`${clsPrefix}-tree-node`, {
          [`${clsPrefix}-tree-node--selected`]: selected,
          [`${clsPrefix}-tree-node--checkable`]: checkable,
          [`${clsPrefix}-tree-node--highlight`]: highlight,
          [`${clsPrefix}-tree-node--pending`]: pending,
          [`${clsPrefix}-tree-node--disabled`]: disabled,
          [`${clsPrefix}-tree-node--selectable`]: selectable,
          [`${clsPrefix}-tree-node--clickable`]: selectable || expandOnClick || this.mergedCheckOnClick
        }, nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps.class],
        "data-key": dataKey,
        draggable: draggable && blockLine,
        onClick: this.handleLineClick,
        onDragstart: draggable && blockLine && !disabled ? this.handleDragStart : void 0
      }), indentNodes, tmNode.isLeaf && this.showLine ? vue.h("div", {
        class: [`${clsPrefix}-tree-node-indent`, `${clsPrefix}-tree-node-indent--show-line`, tmNode.isLeaf && `${clsPrefix}-tree-node-indent--is-leaf`, tmNode.isLastChild && `${clsPrefix}-tree-node-indent--last-child`]
      }, vue.h("div", {
        style: {
          width: `${indent}px`
        }
      })) : vue.h(NTreeNodeSwitcher, {
        clsPrefix,
        expanded: this.expanded,
        selected,
        loading: this.loading,
        hide: tmNode.isLeaf,
        tmNode: this.tmNode,
        indent,
        onClick: this.handleSwitcherClick
      }), !checkboxOnRight ? checkboxNode : null, vue.h(NTreeNodeContent, {
        ref: "contentInstRef",
        clsPrefix,
        checked,
        selected,
        onClick: this.handleContentClick,
        nodeProps: blockLine ? void 0 : nodeProps,
        onDragstart: draggable && !blockLine && !disabled ? this.handleDragStart : void 0,
        tmNode
      }), draggable ? this.showDropMark ? renderDropMark({
        el: this.contentElRef.value,
        position: this.droppingPosition,
        offsetLevel: this.droppingOffsetLevel,
        indent
      }) : this.showDropMarkAsParent ? renderDropMark({
        el: this.contentElRef.value,
        position: "inside",
        offsetLevel: this.droppingOffsetLevel,
        indent
      }) : null : null, checkboxOnRight ? checkboxNode : null));
    }
  });
  const NTreeNode = TreeNode;
  function useKeyboard({
    props,
    fNodesRef,
    mergedExpandedKeysRef,
    mergedSelectedKeysRef,
    mergedCheckedKeysRef,
    handleCheck,
    handleSelect,
    handleSwitcherClick
  }) {
    const {
      value: mergedSelectedKeys
    } = mergedSelectedKeysRef;
    const treeSelectInjection = vue.inject(treeSelectInjectionKey, null);
    const pendingNodeKeyRef = treeSelectInjection ? treeSelectInjection.pendingNodeKeyRef : vue.ref(mergedSelectedKeys.length ? mergedSelectedKeys[mergedSelectedKeys.length - 1] : null);
    function handleKeydown(e) {
      var _a;
      if (!props.keyboard)
        return {
          enterBehavior: null
        };
      const {
        value: pendingNodeKey
      } = pendingNodeKeyRef;
      let enterBehavior = null;
      if (pendingNodeKey === null) {
        if (e.key === "ArrowDown" || e.key === "ArrowUp") {
          e.preventDefault();
        }
        if (["ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"].includes(e.key)) {
          if (pendingNodeKey === null) {
            const {
              value: fNodes
            } = fNodesRef;
            let fIndex = 0;
            while (fIndex < fNodes.length) {
              if (!fNodes[fIndex].disabled) {
                pendingNodeKeyRef.value = fNodes[fIndex].key;
                break;
              }
              fIndex += 1;
            }
          }
        }
      } else {
        const {
          value: fNodes
        } = fNodesRef;
        let fIndex = fNodes.findIndex((tmNode) => tmNode.key === pendingNodeKey);
        if (!~fIndex)
          return {
            enterBehavior: null
          };
        if (e.key === "Enter") {
          const tmNode = fNodes[fIndex];
          enterBehavior = ((_a = props.overrideDefaultNodeClickBehavior) === null || _a === void 0 ? void 0 : _a.call(props, {
            option: tmNode.rawNode
          })) || null;
          switch (enterBehavior) {
            case "toggleCheck":
              handleCheck(tmNode, !mergedCheckedKeysRef.value.includes(tmNode.key));
              break;
            case "toggleSelect":
              handleSelect(tmNode);
              break;
            case "toggleExpand":
              handleSwitcherClick(tmNode);
              break;
            case "none":
              break;
            case "default":
            default:
              enterBehavior = "default";
              handleSelect(tmNode);
          }
        } else if (e.key === "ArrowDown") {
          e.preventDefault();
          fIndex += 1;
          while (fIndex < fNodes.length) {
            if (!fNodes[fIndex].disabled) {
              pendingNodeKeyRef.value = fNodes[fIndex].key;
              break;
            }
            fIndex += 1;
          }
        } else if (e.key === "ArrowUp") {
          e.preventDefault();
          fIndex -= 1;
          while (fIndex >= 0) {
            if (!fNodes[fIndex].disabled) {
              pendingNodeKeyRef.value = fNodes[fIndex].key;
              break;
            }
            fIndex -= 1;
          }
        } else if (e.key === "ArrowLeft") {
          const pendingNode = fNodes[fIndex];
          if (pendingNode.isLeaf || !mergedExpandedKeysRef.value.includes(pendingNodeKey)) {
            const parentTmNode = pendingNode.getParent();
            if (parentTmNode) {
              pendingNodeKeyRef.value = parentTmNode.key;
            }
          } else {
            handleSwitcherClick(pendingNode);
          }
        } else if (e.key === "ArrowRight") {
          const pendingNode = fNodes[fIndex];
          if (pendingNode.isLeaf)
            return {
              enterBehavior: null
            };
          if (!mergedExpandedKeysRef.value.includes(pendingNodeKey)) {
            handleSwitcherClick(pendingNode);
          } else {
            fIndex += 1;
            while (fIndex < fNodes.length) {
              if (!fNodes[fIndex].disabled) {
                pendingNodeKeyRef.value = fNodes[fIndex].key;
                break;
              }
              fIndex += 1;
            }
          }
        }
      }
      return {
        enterBehavior
      };
    }
    return {
      pendingNodeKeyRef,
      handleKeydown
    };
  }
  const MotionWrapper = vue.defineComponent({
    name: "TreeMotionWrapper",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      height: Number,
      nodes: {
        type: Array,
        required: true
      },
      mode: {
        type: String,
        required: true
      },
      onAfterEnter: {
        type: Function,
        required: true
      }
    },
    render() {
      const {
        clsPrefix
      } = this;
      return vue.h(NFadeInExpandTransition, {
        onAfterEnter: this.onAfterEnter,
        appear: true,
        reverse: this.mode === "collapse"
      }, {
        default: () => vue.h("div", {
          class: [`${clsPrefix}-tree-motion-wrapper`, `${clsPrefix}-tree-motion-wrapper--${this.mode}`],
          style: {
            height: pxfy(this.height)
          }
        }, this.nodes.map((node) => vue.h(NTreeNode, {
          clsPrefix,
          tmNode: node
        })))
      });
    }
  });
  const iconSwitchTransitionNode = iconSwitchTransition();
  const style$a = cB("tree", `
 font-size: var(--n-font-size);
 outline: none;
`, [c$1("ul, li", `
 margin: 0;
 padding: 0;
 list-style: none;
 `), c$1(">", [cB("tree-node", [c$1("&:first-child", "margin-top: 0;")])]), cB("tree-motion-wrapper", [cM("expand", [fadeInHeightExpandTransition({
    duration: "0.2s"
  })]), cM("collapse", [fadeInHeightExpandTransition({
    duration: "0.2s",
    reverse: true
  })])]), cB("tree-node-wrapper", `
 box-sizing: border-box;
 padding: var(--n-node-wrapper-padding);
 `), cB("tree-node", `
 transform: translate3d(0,0,0);
 position: relative;
 display: flex;
 border-radius: var(--n-node-border-radius);
 transition: background-color .3s var(--n-bezier);
 `, [cM("highlight", [cB("tree-node-content", [cE("text", "border-bottom-color: var(--n-node-text-color-disabled);")])]), cM("disabled", [cB("tree-node-content", `
 color: var(--n-node-text-color-disabled);
 cursor: not-allowed;
 `)]), cNotM("disabled", [cM("clickable", [cB("tree-node-content", `
 cursor: pointer;
 `)])])]), cM("block-node", [cB("tree-node-content", `
 flex: 1;
 min-width: 0;
 `)]), cNotM("block-line", [cB("tree-node", [cNotM("disabled", [cB("tree-node-content", [c$1("&:hover", "background: var(--n-node-color-hover);")]), cM("selectable", [cB("tree-node-content", [c$1("&:active", "background: var(--n-node-color-pressed);")])]), cM("pending", [cB("tree-node-content", `
 background: var(--n-node-color-hover);
 `)]), cM("selected", [cB("tree-node-content", "background: var(--n-node-color-active);")])]), cM("selected", [cB("tree-node-content", "background: var(--n-node-color-active);")])])]), cM("block-line", [cB("tree-node", [cNotM("disabled", [c$1("&:hover", "background: var(--n-node-color-hover);"), cM("pending", `
 background: var(--n-node-color-hover);
 `), cM("selectable", [cNotM("selected", [c$1("&:active", "background: var(--n-node-color-pressed);")])]), cM("selected", "background: var(--n-node-color-active);")]), cM("selected", "background: var(--n-node-color-active);"), cM("disabled", `
 cursor: not-allowed;
 `)])]), cB("tree-node-indent", `
 flex-grow: 0;
 flex-shrink: 0;
 `, [cM("show-line", "position: relative", [c$1("&::before", `
 position: absolute;
 left: 50%;
 border-left: 1px solid var(--n-line-color);
 transition: border-color .3s var(--n-bezier);
 transform: translate(-50%);
 content: "";
 top: var(--n-line-offset-top);
 bottom: var(--n-line-offset-bottom);
 `), cM("last-child", [c$1("&::before", `
 bottom: 50%;
 `)]), cM("is-leaf", [c$1("&::after", `
 position: absolute;
 content: "";
 left: calc(50% + 0.5px);
 right: 0;
 bottom: 50%;
 transition: border-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-line-color);
 `)])]), cNotM("show-line", "height: 0;")]), cB("tree-node-switcher", `
 cursor: pointer;
 display: inline-flex;
 flex-shrink: 0;
 height: var(--n-node-content-height);
 align-items: center;
 justify-content: center;
 transition: transform .15s var(--n-bezier);
 vertical-align: bottom;
 `, [cE("icon", `
 position: relative;
 height: 14px;
 width: 14px;
 display: flex;
 color: var(--n-arrow-color);
 transition: color .3s var(--n-bezier);
 font-size: 14px;
 `, [cB("icon", [iconSwitchTransitionNode]), cB("base-loading", `
 color: var(--n-loading-color);
 position: absolute;
 left: 0;
 top: 0;
 right: 0;
 bottom: 0;
 `, [iconSwitchTransitionNode]), cB("base-icon", [iconSwitchTransitionNode])]), cM("hide", "visibility: hidden;"), cM("expanded", "transform: rotate(90deg);")]), cB("tree-node-checkbox", `
 display: inline-flex;
 height: var(--n-node-content-height);
 vertical-align: bottom;
 align-items: center;
 justify-content: center;
 `), cB("tree-node-content", `
 user-select: none;
 position: relative;
 display: inline-flex;
 align-items: center;
 min-height: var(--n-node-content-height);
 box-sizing: border-box;
 line-height: var(--n-line-height);
 vertical-align: bottom;
 padding: 0 6px 0 4px;
 cursor: default;
 border-radius: var(--n-node-border-radius);
 color: var(--n-node-text-color);
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [c$1("&:last-child", "margin-bottom: 0;"), cE("prefix", `
 display: inline-flex;
 margin-right: 8px;
 `), cE("text", `
 border-bottom: 1px solid #0000;
 transition: border-color .3s var(--n-bezier);
 flex-grow: 1;
 max-width: 100%;
 `), cE("suffix", `
 display: inline-flex;
 `)]), cE("empty", "margin: auto;")]);
  var __awaiter$3 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function createTreeMateOptions(keyField, childrenField, disabledField, getChildren) {
    const settledGetChildren = getChildren || ((node) => {
      return node[childrenField];
    });
    return {
      getIsGroup() {
        return false;
      },
      getKey(node) {
        return node[keyField];
      },
      getChildren: settledGetChildren,
      getDisabled(node) {
        return !!(node[disabledField] || node.checkboxDisabled);
      }
    };
  }
  const treeSharedProps = {
    allowCheckingNotLoaded: Boolean,
    filter: Function,
    defaultExpandAll: Boolean,
    expandedKeys: Array,
    keyField: {
      type: String,
      default: "key"
    },
    labelField: {
      type: String,
      default: "label"
    },
    childrenField: {
      type: String,
      default: "children"
    },
    disabledField: {
      type: String,
      default: "disabled"
    },
    defaultExpandedKeys: {
      type: Array,
      default: () => []
    },
    indeterminateKeys: Array,
    renderSwitcherIcon: Function,
    onUpdateIndeterminateKeys: [Function, Array],
    "onUpdate:indeterminateKeys": [Function, Array],
    onUpdateExpandedKeys: [Function, Array],
    "onUpdate:expandedKeys": [Function, Array],
    overrideDefaultNodeClickBehavior: Function
  };
  const treeProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), {
    accordion: Boolean,
    showIrrelevantNodes: {
      type: Boolean,
      default: true
    },
    data: {
      type: Array,
      default: () => []
    },
    expandOnDragenter: {
      type: Boolean,
      default: true
    },
    expandOnClick: Boolean,
    checkOnClick: {
      type: [Boolean, Function],
      default: false
    },
    cancelable: {
      type: Boolean,
      default: true
    },
    checkable: Boolean,
    draggable: Boolean,
    blockNode: Boolean,
    blockLine: Boolean,
    showLine: Boolean,
    disabled: Boolean,
    checkedKeys: Array,
    defaultCheckedKeys: {
      type: Array,
      default: () => []
    },
    selectedKeys: Array,
    defaultSelectedKeys: {
      type: Array,
      default: () => []
    },
    multiple: Boolean,
    pattern: {
      type: String,
      default: ""
    },
    onLoad: Function,
    cascade: Boolean,
    selectable: {
      type: Boolean,
      default: true
    },
    scrollbarProps: Object,
    indent: {
      type: Number,
      default: 24
    },
    allowDrop: {
      type: Function,
      default: defaultAllowDrop
    },
    animated: {
      type: Boolean,
      default: true
    },
    checkboxPlacement: {
      type: String,
      default: "left"
    },
    virtualScroll: Boolean,
    watchProps: Array,
    renderLabel: Function,
    renderPrefix: Function,
    renderSuffix: Function,
    nodeProps: Function,
    keyboard: {
      type: Boolean,
      default: true
    },
    getChildren: Function,
    onDragenter: [Function, Array],
    onDragleave: [Function, Array],
    onDragend: [Function, Array],
    onDragstart: [Function, Array],
    onDragover: [Function, Array],
    onDrop: [Function, Array],
    onUpdateCheckedKeys: [Function, Array],
    "onUpdate:checkedKeys": [Function, Array],
    onUpdateSelectedKeys: [Function, Array],
    "onUpdate:selectedKeys": [Function, Array]
  }), treeSharedProps), {
    // internal props for tree-select
    internalTreeSelect: Boolean,
    internalScrollable: Boolean,
    internalScrollablePadding: String,
    // use it to display
    internalRenderEmpty: Function,
    internalHighlightKeySet: Object,
    internalUnifySelectCheck: Boolean,
    internalCheckboxFocusable: {
      type: Boolean,
      default: true
    },
    internalFocusable: {
      // Make tree-select take over keyboard operations
      type: Boolean,
      default: true
    },
    checkStrategy: {
      type: String,
      default: "all"
    },
    /**
     * @deprecated
     */
    leafOnly: Boolean
  });
  const NTree = vue.defineComponent({
    name: "Tree",
    props: treeProps,
    setup(props) {
      {
        vue.watchEffect(() => {
          if (props.leafOnly) {
            warnOnce("tree", '`leaf-only` is deprecated, please use `check-strategy="child"` instead');
          }
        });
      }
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled,
        mergedRtlRef
      } = useConfig(props);
      const rtlEnabledRef = useRtl("Tree", mergedRtlRef, mergedClsPrefixRef);
      const themeRef = useTheme("Tree", "-tree", style$a, treeLight$1, props, mergedClsPrefixRef);
      const selfElRef = vue.ref(null);
      const scrollbarInstRef = vue.ref(null);
      const virtualListInstRef = vue.ref(null);
      function getScrollContainer() {
        var _a;
        return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.listElRef;
      }
      function getScrollContent() {
        var _a;
        return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.itemsElRef;
      }
      const mergedFilterRef = vue.computed(() => {
        const {
          filter
        } = props;
        if (filter)
          return filter;
        const {
          labelField
        } = props;
        return (pattern, node) => {
          if (!pattern.length)
            return true;
          const label = node[labelField];
          if (typeof label === "string") {
            return label.toLowerCase().includes(pattern.toLowerCase());
          }
          return false;
        };
      });
      const filteredTreeInfoRef = vue.computed(() => {
        const {
          pattern
        } = props;
        if (!pattern) {
          return {
            filteredTree: props.data,
            highlightKeySet: null,
            expandedKeys: void 0
          };
        }
        if (!pattern.length || !mergedFilterRef.value) {
          return {
            filteredTree: props.data,
            highlightKeySet: null,
            expandedKeys: void 0
          };
        }
        return filterTree(props.data, mergedFilterRef.value, pattern, props.keyField, props.childrenField);
      });
      const displayTreeMateRef = vue.computed(() => createTreeMate(props.showIrrelevantNodes ? props.data : filteredTreeInfoRef.value.filteredTree, createTreeMateOptions(props.keyField, props.childrenField, props.disabledField, props.getChildren)));
      const treeSelectInjection = vue.inject(treeSelectInjectionKey, null);
      const dataTreeMateRef = props.internalTreeSelect ? treeSelectInjection.dataTreeMate : vue.computed(() => props.showIrrelevantNodes ? displayTreeMateRef.value : createTreeMate(props.data, createTreeMateOptions(props.keyField, props.childrenField, props.disabledField, props.getChildren)));
      const {
        watchProps
      } = props;
      const uncontrolledCheckedKeysRef = vue.ref([]);
      if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes("defaultCheckedKeys")) {
        vue.watchEffect(() => {
          uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;
        });
      } else {
        uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;
      }
      const controlledCheckedKeysRef = vue.toRef(props, "checkedKeys");
      const mergedCheckedKeysRef = useMergedState(controlledCheckedKeysRef, uncontrolledCheckedKeysRef);
      const checkedStatusRef = vue.computed(() => {
        const value = dataTreeMateRef.value.getCheckedKeys(mergedCheckedKeysRef.value, {
          cascade: props.cascade,
          allowNotLoaded: props.allowCheckingNotLoaded
        });
        return value;
      });
      const mergedCheckStrategyRef = useMergedCheckStrategy(props);
      const displayedCheckedKeysRef = vue.computed(() => {
        return checkedStatusRef.value.checkedKeys;
      });
      const displayedIndeterminateKeysRef = vue.computed(() => {
        const {
          indeterminateKeys
        } = props;
        if (indeterminateKeys !== void 0)
          return indeterminateKeys;
        return checkedStatusRef.value.indeterminateKeys;
      });
      const uncontrolledSelectedKeysRef = vue.ref([]);
      if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes("defaultSelectedKeys")) {
        vue.watchEffect(() => {
          uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;
        });
      } else {
        uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;
      }
      const controlledSelectedKeysRef = vue.toRef(props, "selectedKeys");
      const mergedSelectedKeysRef = useMergedState(controlledSelectedKeysRef, uncontrolledSelectedKeysRef);
      const uncontrolledExpandedKeysRef = vue.ref([]);
      const initUncontrolledExpandedKeys = (keys2) => {
        uncontrolledExpandedKeysRef.value = props.defaultExpandAll ? dataTreeMateRef.value.getNonLeafKeys() : keys2 === void 0 ? props.defaultExpandedKeys : keys2;
      };
      if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes("defaultExpandedKeys")) {
        vue.watchEffect(() => {
          initUncontrolledExpandedKeys(void 0);
        });
      } else {
        vue.watchEffect(() => {
          initUncontrolledExpandedKeys(props.defaultExpandedKeys);
        });
      }
      const controlledExpandedKeysRef = vue.toRef(props, "expandedKeys");
      const mergedExpandedKeysRef = useMergedState(controlledExpandedKeysRef, uncontrolledExpandedKeysRef);
      const fNodesRef = vue.computed(() => displayTreeMateRef.value.getFlattenedNodes(mergedExpandedKeysRef.value));
      const {
        pendingNodeKeyRef,
        handleKeydown
      } = useKeyboard({
        props,
        mergedCheckedKeysRef,
        mergedSelectedKeysRef,
        fNodesRef,
        mergedExpandedKeysRef,
        handleCheck,
        handleSelect,
        handleSwitcherClick
      });
      let expandTimerId = null;
      let nodeKeyToBeExpanded = null;
      const uncontrolledHighlightKeySetRef = vue.ref(/* @__PURE__ */ new Set());
      const controlledHighlightKeySetRef = vue.computed(() => {
        return props.internalHighlightKeySet || filteredTreeInfoRef.value.highlightKeySet;
      });
      const mergedHighlightKeySetRef = useMergedState(controlledHighlightKeySetRef, uncontrolledHighlightKeySetRef);
      const loadingKeysRef = vue.ref(/* @__PURE__ */ new Set());
      const expandedNonLoadingKeysRef = vue.computed(() => {
        return mergedExpandedKeysRef.value.filter((key) => !loadingKeysRef.value.has(key));
      });
      let dragStartX = 0;
      const draggingNodeRef = vue.ref(null);
      const droppingNodeRef = vue.ref(null);
      const droppingMouseNodeRef = vue.ref(null);
      const droppingPositionRef = vue.ref(null);
      const droppingOffsetLevelRef = vue.ref(0);
      const droppingNodeParentRef = vue.computed(() => {
        const {
          value: droppingNode
        } = droppingNodeRef;
        if (!droppingNode)
          return null;
        return droppingNode.parent;
      });
      let isDataReset = false;
      vue.watch(vue.toRef(props, "data"), () => {
        isDataReset = true;
        void vue.nextTick(() => {
          isDataReset = false;
        });
        loadingKeysRef.value.clear();
        pendingNodeKeyRef.value = null;
        resetDndState();
      }, {
        deep: false
      });
      let expandAnimationDisabled = false;
      const disableExpandAnimationForOneTick = () => {
        expandAnimationDisabled = true;
        void vue.nextTick(() => {
          expandAnimationDisabled = false;
        });
      };
      let memoizedExpandedKeys;
      vue.watch(vue.toRef(props, "pattern"), (value, oldValue) => {
        if (props.showIrrelevantNodes) {
          memoizedExpandedKeys = void 0;
          if (value) {
            const {
              expandedKeys: expandedKeysAfterChange,
              highlightKeySet
            } = keysWithFilter(props.data, props.pattern, props.keyField, props.childrenField, mergedFilterRef.value);
            uncontrolledHighlightKeySetRef.value = highlightKeySet;
            disableExpandAnimationForOneTick();
            doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange), {
              node: null,
              action: "filter"
            });
          } else {
            uncontrolledHighlightKeySetRef.value = /* @__PURE__ */ new Set();
          }
        } else {
          if (!value.length) {
            if (memoizedExpandedKeys !== void 0) {
              disableExpandAnimationForOneTick();
              doUpdateExpandedKeys(memoizedExpandedKeys, getOptionsByKeys(memoizedExpandedKeys), {
                node: null,
                action: "filter"
              });
            }
          } else {
            if (!oldValue.length) {
              memoizedExpandedKeys = mergedExpandedKeysRef.value;
            }
            const {
              expandedKeys
            } = filteredTreeInfoRef.value;
            if (expandedKeys !== void 0) {
              disableExpandAnimationForOneTick();
              doUpdateExpandedKeys(expandedKeys, getOptionsByKeys(expandedKeys), {
                node: null,
                action: "filter"
              });
            }
          }
        }
      });
      function triggerLoading(node) {
        return __awaiter$3(this, void 0, void 0, function* () {
          const {
            onLoad
          } = props;
          if (!onLoad) {
            {
              warn$2("tree", "There is unloaded node in data but props.onLoad is not specified.");
            }
            yield Promise.resolve();
            return;
          }
          const {
            value: loadingKeys
          } = loadingKeysRef;
          if (!loadingKeys.has(node.key)) {
            loadingKeys.add(node.key);
            try {
              const loadResult = yield onLoad(node.rawNode);
              if (loadResult === false) {
                resetDragExpandState();
              }
            } catch (loadError) {
              console.error(loadError);
              resetDragExpandState();
            }
            loadingKeys.delete(node.key);
          }
        });
      }
      vue.watchEffect(() => {
        var _a;
        const {
          value: displayTreeMate
        } = displayTreeMateRef;
        if (!displayTreeMate)
          return;
        const {
          getNode
        } = displayTreeMate;
        (_a = mergedExpandedKeysRef.value) === null || _a === void 0 ? void 0 : _a.forEach((key) => {
          const node = getNode(key);
          if (node && !node.shallowLoaded) {
            void triggerLoading(node);
          }
        });
      });
      const aipRef = vue.ref(false);
      const afNodesRef = vue.ref([]);
      vue.watch(expandedNonLoadingKeysRef, (value, prevValue) => {
        if (!props.animated || expandAnimationDisabled) {
          void vue.nextTick(syncScrollbar);
          return;
        }
        if (isDataReset) {
          return;
        }
        const nodeHeight = depx(themeRef.value.self.nodeHeight);
        const prevVSet = new Set(prevValue);
        let addedKey = null;
        let removedKey = null;
        for (const expandedKey of value) {
          if (!prevVSet.has(expandedKey)) {
            if (addedKey !== null)
              return;
            addedKey = expandedKey;
          }
        }
        const currentVSet = new Set(value);
        for (const expandedKey of prevValue) {
          if (!currentVSet.has(expandedKey)) {
            if (removedKey !== null)
              return;
            removedKey = expandedKey;
          }
        }
        if (addedKey === null && removedKey === null) {
          return;
        }
        const {
          virtualScroll
        } = props;
        const viewportHeight = (virtualScroll ? virtualListInstRef.value.listElRef : selfElRef.value).offsetHeight;
        const viewportItemCount = Math.ceil(viewportHeight / nodeHeight) + 1;
        let baseExpandedKeys;
        if (addedKey !== null) {
          baseExpandedKeys = prevValue;
        }
        if (removedKey !== null) {
          if (baseExpandedKeys === void 0) {
            baseExpandedKeys = value;
          } else {
            baseExpandedKeys = baseExpandedKeys.filter((key) => key !== removedKey);
          }
        }
        aipRef.value = true;
        afNodesRef.value = displayTreeMateRef.value.getFlattenedNodes(baseExpandedKeys);
        if (addedKey !== null) {
          const expandedNodeIndex = afNodesRef.value.findIndex((node) => node.key === addedKey);
          if (~expandedNodeIndex) {
            const children = afNodesRef.value[expandedNodeIndex].children;
            if (children) {
              const expandedChildren = flatten$1(children, value);
              afNodesRef.value.splice(expandedNodeIndex + 1, 0, {
                __motion: true,
                mode: "expand",
                height: virtualScroll ? expandedChildren.length * nodeHeight : void 0,
                nodes: virtualScroll ? expandedChildren.slice(0, viewportItemCount) : expandedChildren
              });
            }
          }
        }
        if (removedKey !== null) {
          const collapsedNodeIndex = afNodesRef.value.findIndex((node) => node.key === removedKey);
          if (~collapsedNodeIndex) {
            const collapsedNodeChildren = afNodesRef.value[collapsedNodeIndex].children;
            if (!collapsedNodeChildren)
              return;
            aipRef.value = true;
            const collapsedChildren = flatten$1(collapsedNodeChildren, value);
            afNodesRef.value.splice(collapsedNodeIndex + 1, 0, {
              __motion: true,
              mode: "collapse",
              height: virtualScroll ? collapsedChildren.length * nodeHeight : void 0,
              nodes: virtualScroll ? collapsedChildren.slice(0, viewportItemCount) : collapsedChildren
            });
          }
        }
      });
      const getFIndexRef = vue.computed(() => {
        return createIndexGetter(fNodesRef.value);
      });
      const mergedFNodesRef = vue.computed(() => {
        if (aipRef.value)
          return afNodesRef.value;
        else
          return fNodesRef.value;
      });
      function syncScrollbar() {
        const {
          value: scrollbarInst
        } = scrollbarInstRef;
        if (scrollbarInst)
          scrollbarInst.sync();
      }
      function handleAfterEnter() {
        aipRef.value = false;
        if (props.virtualScroll) {
          void vue.nextTick(syncScrollbar);
        }
      }
      function getOptionsByKeys(keys2) {
        const {
          getNode
        } = dataTreeMateRef.value;
        return keys2.map((key) => {
          var _a;
          return ((_a = getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode) || null;
        });
      }
      function doUpdateExpandedKeys(value, option, meta) {
        const {
          "onUpdate:expandedKeys": _onUpdateExpandedKeys,
          onUpdateExpandedKeys
        } = props;
        uncontrolledExpandedKeysRef.value = value;
        if (_onUpdateExpandedKeys) {
          call(_onUpdateExpandedKeys, value, option, meta);
        }
        if (onUpdateExpandedKeys) {
          call(onUpdateExpandedKeys, value, option, meta);
        }
      }
      function doUpdateCheckedKeys(value, option, meta) {
        const {
          "onUpdate:checkedKeys": _onUpdateCheckedKeys,
          onUpdateCheckedKeys
        } = props;
        uncontrolledCheckedKeysRef.value = value;
        if (onUpdateCheckedKeys) {
          call(onUpdateCheckedKeys, value, option, meta);
        }
        if (_onUpdateCheckedKeys) {
          call(_onUpdateCheckedKeys, value, option, meta);
        }
      }
      function doUpdateIndeterminateKeys(value, option) {
        const {
          "onUpdate:indeterminateKeys": _onUpdateIndeterminateKeys,
          onUpdateIndeterminateKeys
        } = props;
        if (_onUpdateIndeterminateKeys) {
          call(_onUpdateIndeterminateKeys, value, option);
        }
        if (onUpdateIndeterminateKeys) {
          call(onUpdateIndeterminateKeys, value, option);
        }
      }
      function doUpdateSelectedKeys(value, option, meta) {
        const {
          "onUpdate:selectedKeys": _onUpdateSelectedKeys,
          onUpdateSelectedKeys
        } = props;
        uncontrolledSelectedKeysRef.value = value;
        if (onUpdateSelectedKeys) {
          call(onUpdateSelectedKeys, value, option, meta);
        }
        if (_onUpdateSelectedKeys) {
          call(_onUpdateSelectedKeys, value, option, meta);
        }
      }
      function doDragEnter(info) {
        const {
          onDragenter
        } = props;
        if (onDragenter)
          call(onDragenter, info);
      }
      function doDragLeave(info) {
        const {
          onDragleave
        } = props;
        if (onDragleave)
          call(onDragleave, info);
      }
      function doDragEnd(info) {
        const {
          onDragend
        } = props;
        if (onDragend)
          call(onDragend, info);
      }
      function doDragStart(info) {
        const {
          onDragstart
        } = props;
        if (onDragstart)
          call(onDragstart, info);
      }
      function doDragOver(info) {
        const {
          onDragover
        } = props;
        if (onDragover)
          call(onDragover, info);
      }
      function doDrop(info) {
        const {
          onDrop
        } = props;
        if (onDrop)
          call(onDrop, info);
      }
      function resetDndState() {
        resetDragState();
        resetDropState();
      }
      function resetDragState() {
        draggingNodeRef.value = null;
      }
      function resetDropState() {
        droppingOffsetLevelRef.value = 0;
        droppingNodeRef.value = null;
        droppingMouseNodeRef.value = null;
        droppingPositionRef.value = null;
        resetDragExpandState();
      }
      function resetDragExpandState() {
        if (expandTimerId) {
          window.clearTimeout(expandTimerId);
          expandTimerId = null;
        }
        nodeKeyToBeExpanded = null;
      }
      function handleCheck(node, checked) {
        if (props.disabled || isNodeDisabled(node, props.disabledField)) {
          return;
        }
        if (props.internalUnifySelectCheck && !props.multiple) {
          handleSelect(node);
          return;
        }
        const checkedAction = checked ? "check" : "uncheck";
        const {
          checkedKeys,
          indeterminateKeys
        } = dataTreeMateRef.value[checkedAction](node.key, displayedCheckedKeysRef.value, {
          cascade: props.cascade,
          checkStrategy: mergedCheckStrategyRef.value,
          allowNotLoaded: props.allowCheckingNotLoaded
        });
        doUpdateCheckedKeys(checkedKeys, getOptionsByKeys(checkedKeys), {
          node: node.rawNode,
          action: checkedAction
        });
        doUpdateIndeterminateKeys(indeterminateKeys, getOptionsByKeys(indeterminateKeys));
      }
      function toggleExpand(node) {
        if (props.disabled)
          return;
        const {
          key
        } = node;
        const {
          value: mergedExpandedKeys
        } = mergedExpandedKeysRef;
        const index = mergedExpandedKeys.findIndex((expandNodeId) => expandNodeId === key);
        if (~index) {
          const expandedKeysAfterChange = Array.from(mergedExpandedKeys);
          expandedKeysAfterChange.splice(index, 1);
          doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange), {
            node: node.rawNode,
            action: "collapse"
          });
        } else {
          const nodeToBeExpanded = displayTreeMateRef.value.getNode(key);
          if (!nodeToBeExpanded || nodeToBeExpanded.isLeaf) {
            return;
          }
          let nextKeys;
          if (props.accordion) {
            const siblingKeySet = new Set(node.siblings.map(({
              key: key2
            }) => key2));
            nextKeys = mergedExpandedKeys.filter((expandedKey) => {
              return !siblingKeySet.has(expandedKey);
            });
            nextKeys.push(key);
          } else {
            nextKeys = mergedExpandedKeys.concat(key);
          }
          doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys), {
            node: node.rawNode,
            action: "expand"
          });
        }
      }
      function handleSwitcherClick(node) {
        if (props.disabled || aipRef.value)
          return;
        toggleExpand(node);
      }
      function handleSelect(node) {
        if (props.disabled || !props.selectable) {
          return;
        }
        pendingNodeKeyRef.value = node.key;
        if (props.internalUnifySelectCheck) {
          const {
            value: {
              checkedKeys,
              indeterminateKeys
            }
          } = checkedStatusRef;
          if (props.multiple) {
            handleCheck(node, !(checkedKeys.includes(node.key) || indeterminateKeys.includes(node.key)));
          } else {
            doUpdateCheckedKeys([node.key], getOptionsByKeys([node.key]), {
              node: node.rawNode,
              action: "check"
            });
          }
        }
        if (props.multiple) {
          const selectedKeys = Array.from(mergedSelectedKeysRef.value);
          const index = selectedKeys.findIndex((key) => key === node.key);
          if (~index) {
            if (props.cancelable) {
              selectedKeys.splice(index, 1);
            }
          } else if (!~index) {
            selectedKeys.push(node.key);
          }
          doUpdateSelectedKeys(selectedKeys, getOptionsByKeys(selectedKeys), {
            node: node.rawNode,
            action: ~index ? "unselect" : "select"
          });
        } else {
          const selectedKeys = mergedSelectedKeysRef.value;
          if (selectedKeys.includes(node.key)) {
            if (props.cancelable) {
              doUpdateSelectedKeys([], [], {
                node: node.rawNode,
                action: "unselect"
              });
            }
          } else {
            doUpdateSelectedKeys([node.key], getOptionsByKeys([node.key]), {
              node: node.rawNode,
              action: "select"
            });
          }
        }
      }
      function expandDragEnterNode(node) {
        if (expandTimerId) {
          window.clearTimeout(expandTimerId);
          expandTimerId = null;
        }
        if (node.isLeaf)
          return;
        nodeKeyToBeExpanded = node.key;
        const expand = () => {
          if (nodeKeyToBeExpanded !== node.key)
            return;
          const {
            value: droppingMouseNode
          } = droppingMouseNodeRef;
          if (droppingMouseNode && droppingMouseNode.key === node.key && !mergedExpandedKeysRef.value.includes(node.key)) {
            const nextKeys = mergedExpandedKeysRef.value.concat(node.key);
            doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys), {
              node: node.rawNode,
              action: "expand"
            });
          }
          expandTimerId = null;
          nodeKeyToBeExpanded = null;
        };
        if (!node.shallowLoaded) {
          expandTimerId = window.setTimeout(() => {
            void triggerLoading(node).then(() => {
              expand();
            });
          }, 1e3);
        } else {
          expandTimerId = window.setTimeout(() => {
            expand();
          }, 1e3);
        }
      }
      function handleDragEnter({
        event,
        node
      }) {
        if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {
          return;
        }
        handleDragOver({
          event,
          node
        }, false);
        doDragEnter({
          event,
          node: node.rawNode
        });
      }
      function handleDragLeave({
        event,
        node
      }) {
        if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {
          return;
        }
        doDragLeave({
          event,
          node: node.rawNode
        });
      }
      function handleDragLeaveTree(e) {
        if (e.target !== e.currentTarget)
          return;
        resetDropState();
      }
      function handleDragEnd({
        event,
        node
      }) {
        resetDndState();
        if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {
          return;
        }
        doDragEnd({
          event,
          node: node.rawNode
        });
      }
      function handleDragStart({
        event,
        node
      }) {
        if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {
          return;
        }
        dragStartX = event.clientX;
        draggingNodeRef.value = node;
        doDragStart({
          event,
          node: node.rawNode
        });
      }
      function handleDragOver({
        event,
        node
      }, emit = true) {
        var _a;
        if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {
          return;
        }
        const {
          value: draggingNode
        } = draggingNodeRef;
        if (!draggingNode)
          return;
        const {
          allowDrop,
          indent
        } = props;
        if (emit)
          doDragOver({
            event,
            node: node.rawNode
          });
        const el = event.currentTarget;
        const {
          height: elOffsetHeight,
          top: elClientTop
        } = el.getBoundingClientRect();
        const eventOffsetY = event.clientY - elClientTop;
        let mousePosition;
        const allowDropInside = allowDrop({
          node: node.rawNode,
          dropPosition: "inside",
          phase: "drag"
        });
        if (allowDropInside) {
          if (eventOffsetY <= 8) {
            mousePosition = "before";
          } else if (eventOffsetY >= elOffsetHeight - 8) {
            mousePosition = "after";
          } else {
            mousePosition = "inside";
          }
        } else {
          if (eventOffsetY <= elOffsetHeight / 2) {
            mousePosition = "before";
          } else {
            mousePosition = "after";
          }
        }
        const {
          value: getFindex
        } = getFIndexRef;
        let finalDropNode;
        let finalDropPosition;
        const hoverNodeFIndex = getFindex(node.key);
        if (hoverNodeFIndex === null) {
          resetDropState();
          return;
        }
        let mouseAtExpandedNonLeafNode = false;
        if (mousePosition === "inside") {
          finalDropNode = node;
          finalDropPosition = "inside";
        } else {
          if (mousePosition === "before") {
            if (node.isFirstChild) {
              finalDropNode = node;
              finalDropPosition = "before";
            } else {
              finalDropNode = fNodesRef.value[hoverNodeFIndex - 1];
              finalDropPosition = "after";
            }
          } else {
            finalDropNode = node;
            finalDropPosition = "after";
          }
        }
        if (!finalDropNode.isLeaf && mergedExpandedKeysRef.value.includes(finalDropNode.key)) {
          mouseAtExpandedNonLeafNode = true;
          if (finalDropPosition === "after") {
            finalDropNode = fNodesRef.value[hoverNodeFIndex + 1];
            if (!finalDropNode) {
              finalDropNode = node;
              finalDropPosition = "inside";
            } else {
              finalDropPosition = "before";
            }
          }
        }
        const droppingMouseNode = finalDropNode;
        droppingMouseNodeRef.value = droppingMouseNode;
        if (!mouseAtExpandedNonLeafNode && draggingNode.isLastChild && draggingNode.key === finalDropNode.key) {
          finalDropPosition = "after";
        }
        if (finalDropPosition === "after") {
          let offset = dragStartX - event.clientX;
          let offsetLevel = 0;
          while (offset >= indent / 2 && finalDropNode.parent !== null && finalDropNode.isLastChild && offsetLevel < 1) {
            offset -= indent;
            offsetLevel += 1;
            finalDropNode = finalDropNode.parent;
          }
          droppingOffsetLevelRef.value = offsetLevel;
        } else {
          droppingOffsetLevelRef.value = 0;
        }
        if (draggingNode.contains(finalDropNode) || finalDropPosition === "inside" && ((_a = draggingNode.parent) === null || _a === void 0 ? void 0 : _a.key) === finalDropNode.key) {
          if (draggingNode.key === droppingMouseNode.key && draggingNode.key === finalDropNode.key)
            ;
          else {
            resetDropState();
            return;
          }
        }
        if (!allowDrop({
          node: finalDropNode.rawNode,
          dropPosition: finalDropPosition,
          phase: "drag"
        })) {
          resetDropState();
          return;
        }
        if (draggingNode.key === finalDropNode.key) {
          resetDragExpandState();
        } else {
          if (nodeKeyToBeExpanded !== finalDropNode.key) {
            if (finalDropPosition === "inside") {
              if (props.expandOnDragenter) {
                expandDragEnterNode(finalDropNode);
                if (!finalDropNode.shallowLoaded && nodeKeyToBeExpanded !== finalDropNode.key) {
                  resetDndState();
                  return;
                }
              } else {
                if (!finalDropNode.shallowLoaded) {
                  resetDndState();
                  return;
                }
              }
            } else {
              resetDragExpandState();
            }
          } else {
            if (finalDropPosition !== "inside") {
              resetDragExpandState();
            }
          }
        }
        droppingPositionRef.value = finalDropPosition;
        droppingNodeRef.value = finalDropNode;
      }
      function handleDrop({
        event,
        node,
        dropPosition
      }) {
        if (!props.draggable || props.disabled || isNodeDisabled(node, props.disabledField)) {
          return;
        }
        const {
          value: draggingNode
        } = draggingNodeRef;
        const {
          value: droppingNode
        } = droppingNodeRef;
        const {
          value: droppingPosition
        } = droppingPositionRef;
        if (!draggingNode || !droppingNode || !droppingPosition) {
          return;
        }
        if (!props.allowDrop({
          node: droppingNode.rawNode,
          dropPosition: droppingPosition,
          phase: "drag"
        })) {
          return;
        }
        if (draggingNode.key === droppingNode.key) {
          return;
        }
        if (droppingPosition === "before") {
          const nextNode = draggingNode.getNext({
            includeDisabled: true
          });
          if (nextNode) {
            if (nextNode.key === droppingNode.key) {
              resetDropState();
              return;
            }
          }
        }
        if (droppingPosition === "after") {
          const prevNode = draggingNode.getPrev({
            includeDisabled: true
          });
          if (prevNode) {
            if (prevNode.key === droppingNode.key) {
              resetDropState();
              return;
            }
          }
        }
        doDrop({
          event,
          node: droppingNode.rawNode,
          dragNode: draggingNode.rawNode,
          dropPosition
        });
        resetDndState();
      }
      function handleScroll() {
        syncScrollbar();
      }
      function handleResize() {
        syncScrollbar();
      }
      function handleFocusout(e) {
        var _a;
        if (props.virtualScroll || props.internalScrollable) {
          const {
            value: scrollbarInst
          } = scrollbarInstRef;
          if ((_a = scrollbarInst === null || scrollbarInst === void 0 ? void 0 : scrollbarInst.containerRef) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) {
            return;
          }
          pendingNodeKeyRef.value = null;
        } else {
          const {
            value: selfEl
          } = selfElRef;
          if (selfEl === null || selfEl === void 0 ? void 0 : selfEl.contains(e.relatedTarget))
            return;
          pendingNodeKeyRef.value = null;
        }
      }
      vue.watch(pendingNodeKeyRef, (value) => {
        var _a, _b;
        if (value === null)
          return;
        if (props.virtualScroll) {
          (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo({
            key: value
          });
        } else if (props.internalScrollable) {
          const {
            value: scrollbarInst
          } = scrollbarInstRef;
          if (scrollbarInst === null)
            return;
          const targetEl = (_b = scrollbarInst.contentRef) === null || _b === void 0 ? void 0 : _b.querySelector(`[data-key="${createDataKey(value)}"]`);
          if (!targetEl)
            return;
          scrollbarInst.scrollTo({
            el: targetEl
          });
        }
      });
      vue.provide(treeInjectionKey, {
        loadingKeysRef,
        highlightKeySetRef: mergedHighlightKeySetRef,
        displayedCheckedKeysRef,
        displayedIndeterminateKeysRef,
        mergedSelectedKeysRef,
        mergedExpandedKeysRef,
        mergedThemeRef: themeRef,
        mergedCheckStrategyRef,
        nodePropsRef: vue.toRef(props, "nodeProps"),
        disabledRef: vue.toRef(props, "disabled"),
        checkableRef: vue.toRef(props, "checkable"),
        selectableRef: vue.toRef(props, "selectable"),
        expandOnClickRef: vue.toRef(props, "expandOnClick"),
        onLoadRef: vue.toRef(props, "onLoad"),
        draggableRef: vue.toRef(props, "draggable"),
        blockLineRef: vue.toRef(props, "blockLine"),
        indentRef: vue.toRef(props, "indent"),
        cascadeRef: vue.toRef(props, "cascade"),
        checkOnClickRef: vue.toRef(props, "checkOnClick"),
        checkboxPlacementRef: props.checkboxPlacement,
        droppingMouseNodeRef,
        droppingNodeParentRef,
        draggingNodeRef,
        droppingPositionRef,
        droppingOffsetLevelRef,
        fNodesRef,
        pendingNodeKeyRef,
        showLineRef: vue.toRef(props, "showLine"),
        disabledFieldRef: vue.toRef(props, "disabledField"),
        internalScrollableRef: vue.toRef(props, "internalScrollable"),
        internalCheckboxFocusableRef: vue.toRef(props, "internalCheckboxFocusable"),
        internalTreeSelect: props.internalTreeSelect,
        renderLabelRef: vue.toRef(props, "renderLabel"),
        renderPrefixRef: vue.toRef(props, "renderPrefix"),
        renderSuffixRef: vue.toRef(props, "renderSuffix"),
        renderSwitcherIconRef: vue.toRef(props, "renderSwitcherIcon"),
        labelFieldRef: vue.toRef(props, "labelField"),
        multipleRef: vue.toRef(props, "multiple"),
        overrideDefaultNodeClickBehaviorRef: vue.toRef(props, "overrideDefaultNodeClickBehavior"),
        handleSwitcherClick,
        handleDragEnd,
        handleDragEnter,
        handleDragLeave,
        handleDragStart,
        handleDrop,
        handleDragOver,
        handleSelect,
        handleCheck
      });
      function scrollTo(options, y) {
        var _a, _b;
        if (typeof options === "number") {
          (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(options, y || 0);
        } else {
          (_b = virtualListInstRef.value) === null || _b === void 0 ? void 0 : _b.scrollTo(options);
        }
      }
      const exposedMethods = {
        handleKeydown,
        scrollTo,
        getCheckedData: () => {
          if (!props.checkable)
            return {
              keys: [],
              options: []
            };
          const {
            checkedKeys
          } = checkedStatusRef.value;
          return {
            keys: checkedKeys,
            options: getOptionsByKeys(checkedKeys)
          };
        },
        getIndeterminateData: () => {
          if (!props.checkable)
            return {
              keys: [],
              options: []
            };
          const {
            indeterminateKeys
          } = checkedStatusRef.value;
          return {
            keys: indeterminateKeys,
            options: getOptionsByKeys(indeterminateKeys)
          };
        }
      };
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            fontSize: fontSize2,
            nodeBorderRadius,
            nodeColorHover,
            nodeColorPressed,
            nodeColorActive,
            arrowColor,
            loadingColor,
            nodeTextColor,
            nodeTextColorDisabled,
            dropMarkColor,
            nodeWrapperPadding,
            nodeHeight,
            lineHeight: lineHeight2,
            lineColor
          }
        } = themeRef.value;
        const lineOffsetTop = getMargin(nodeWrapperPadding, "top");
        const lineOffsetBottom = getMargin(nodeWrapperPadding, "bottom");
        const nodeContentHeight = pxfy(depx(nodeHeight) - depx(lineOffsetTop) - depx(lineOffsetBottom));
        return {
          "--n-arrow-color": arrowColor,
          "--n-loading-color": loadingColor,
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-font-size": fontSize2,
          "--n-node-border-radius": nodeBorderRadius,
          "--n-node-color-active": nodeColorActive,
          "--n-node-color-hover": nodeColorHover,
          "--n-node-color-pressed": nodeColorPressed,
          "--n-node-text-color": nodeTextColor,
          "--n-node-text-color-disabled": nodeTextColorDisabled,
          "--n-drop-mark-color": dropMarkColor,
          "--n-node-wrapper-padding": nodeWrapperPadding,
          "--n-line-offset-top": `-${lineOffsetTop}`,
          "--n-line-offset-bottom": `-${lineOffsetBottom}`,
          "--n-node-content-height": nodeContentHeight,
          "--n-line-height": lineHeight2,
          "--n-line-color": lineColor
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("tree", void 0, cssVarsRef, props) : void 0;
      return Object.assign(Object.assign({}, exposedMethods), {
        mergedClsPrefix: mergedClsPrefixRef,
        mergedTheme: themeRef,
        rtlEnabled: rtlEnabledRef,
        fNodes: mergedFNodesRef,
        aip: aipRef,
        selfElRef,
        virtualListInstRef,
        scrollbarInstRef,
        handleFocusout,
        handleDragLeaveTree,
        handleScroll,
        getScrollContainer,
        getScrollContent,
        handleAfterEnter,
        handleResize,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      });
    },
    render() {
      var _a;
      const {
        fNodes,
        internalRenderEmpty
      } = this;
      if (!fNodes.length && internalRenderEmpty) {
        return internalRenderEmpty();
      }
      const {
        mergedClsPrefix,
        blockNode,
        blockLine,
        draggable,
        disabled,
        internalFocusable,
        checkable,
        handleKeydown,
        rtlEnabled,
        handleFocusout,
        scrollbarProps: scrollbarProps2
      } = this;
      const mergedFocusable = internalFocusable && !disabled;
      const tabindex = mergedFocusable ? "0" : void 0;
      const treeClass = [`${mergedClsPrefix}-tree`, rtlEnabled && `${mergedClsPrefix}-tree--rtl`, checkable && `${mergedClsPrefix}-tree--checkable`, (blockLine || blockNode) && `${mergedClsPrefix}-tree--block-node`, blockLine && `${mergedClsPrefix}-tree--block-line`];
      const createNode = (tmNode) => {
        return "__motion" in tmNode ? vue.h(MotionWrapper, {
          height: tmNode.height,
          nodes: tmNode.nodes,
          clsPrefix: mergedClsPrefix,
          mode: tmNode.mode,
          onAfterEnter: this.handleAfterEnter
        }) : vue.h(NTreeNode, {
          key: tmNode.key,
          tmNode,
          clsPrefix: mergedClsPrefix
        });
      };
      if (this.virtualScroll) {
        const {
          mergedTheme,
          internalScrollablePadding
        } = this;
        const padding = getMargin(internalScrollablePadding || "0");
        return vue.h(XScrollbar, Object.assign({}, scrollbarProps2, {
          ref: "scrollbarInstRef",
          onDragleave: draggable ? this.handleDragLeaveTree : void 0,
          container: this.getScrollContainer,
          content: this.getScrollContent,
          class: treeClass,
          theme: mergedTheme.peers.Scrollbar,
          themeOverrides: mergedTheme.peerOverrides.Scrollbar,
          tabindex,
          onKeydown: mergedFocusable ? handleKeydown : void 0,
          onFocusout: mergedFocusable ? handleFocusout : void 0
        }), {
          default: () => {
            var _a2;
            (_a2 = this.onRender) === null || _a2 === void 0 ? void 0 : _a2.call(this);
            return !fNodes.length ? resolveSlot(this.$slots.empty, () => [vue.h(NEmpty, {
              class: `${mergedClsPrefix}-tree__empty`,
              theme: this.mergedTheme.peers.Empty,
              themeOverrides: this.mergedTheme.peerOverrides.Empty
            })]) : vue.h(VVirtualList, {
              ref: "virtualListInstRef",
              items: this.fNodes,
              itemSize: depx(mergedTheme.self.nodeHeight),
              ignoreItemResize: this.aip,
              paddingTop: padding.top,
              paddingBottom: padding.bottom,
              class: this.themeClass,
              style: [this.cssVars, {
                paddingLeft: padding.left,
                paddingRight: padding.right
              }],
              onScroll: this.handleScroll,
              onResize: this.handleResize,
              showScrollbar: false,
              itemResizable: true
            }, {
              default: ({
                item
              }) => createNode(item)
            });
          }
        });
      }
      const {
        internalScrollable
      } = this;
      treeClass.push(this.themeClass);
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      if (internalScrollable) {
        return vue.h(XScrollbar, Object.assign({}, scrollbarProps2, {
          class: treeClass,
          tabindex,
          onKeydown: mergedFocusable ? handleKeydown : void 0,
          onFocusout: mergedFocusable ? handleFocusout : void 0,
          style: this.cssVars,
          contentStyle: {
            padding: this.internalScrollablePadding
          }
        }), {
          default: () => vue.h("div", {
            onDragleave: draggable ? this.handleDragLeaveTree : void 0,
            ref: "selfElRef"
          }, this.fNodes.map(createNode))
        });
      } else {
        return vue.h("div", {
          class: treeClass,
          tabindex,
          ref: "selfElRef",
          style: this.cssVars,
          onKeydown: mergedFocusable ? handleKeydown : void 0,
          onFocusout: mergedFocusable ? handleFocusout : void 0,
          onDragleave: draggable ? this.handleDragLeaveTree : void 0
        }, !fNodes.length ? resolveSlot(this.$slots.empty, () => [vue.h(NEmpty, {
          class: `${mergedClsPrefix}-tree__empty`,
          theme: this.mergedTheme.peers.Empty,
          themeOverrides: this.mergedTheme.peerOverrides.Empty
        })]) : fNodes.map(createNode));
      }
    }
  });
  function treeOption2SelectOption(tmNode, labelField) {
    const {
      rawNode
    } = tmNode;
    return Object.assign(Object.assign({}, rawNode), {
      label: rawNode[labelField],
      value: tmNode.key
    });
  }
  function treeOption2SelectOptionWithPath(tmNode, path, separator, labelField) {
    const {
      rawNode
    } = tmNode;
    return Object.assign(Object.assign({}, rawNode), {
      value: tmNode.key,
      label: path.map((v) => v.rawNode[labelField]).join(separator)
    });
  }
  const style$9 = c$1([cB("tree-select", `
 z-index: auto;
 outline: none;
 width: 100%;
 position: relative;
 `), cB("tree-select-menu", `
 position: relative;
 overflow: hidden;
 margin: 4px 0;
 transition: box-shadow .3s var(--n-bezier), background-color .3s var(--n-bezier);
 border-radius: var(--n-menu-border-radius);
 box-shadow: var(--n-menu-box-shadow);
 background-color: var(--n-menu-color);
 outline: none;
 `, [cB("tree", "max-height: var(--n-menu-height);"), cE("empty", `
 display: flex;
 padding: 12px 32px;
 flex: 1;
 justify-content: center;
 `), cE("header", `
 padding: var(--n-header-padding);
 transition: 
 color .3s var(--n-bezier);
 border-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-header-divider-color);
 color: var(--n-header-text-color);
 `), cE("action", `
 padding: var(--n-action-padding);
 transition: 
 color .3s var(--n-bezier);
 border-color .3s var(--n-bezier);
 border-top: 1px solid var(--n-action-divider-color);
 color: var(--n-action-text-color);
 `), fadeInScaleUpTransition()])]);
  const treeSelectProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), {
    bordered: {
      type: Boolean,
      default: true
    },
    cascade: Boolean,
    checkable: Boolean,
    clearable: Boolean,
    clearFilterAfterSelect: {
      type: Boolean,
      default: true
    },
    consistentMenuWidth: {
      type: Boolean,
      default: true
    },
    defaultShow: Boolean,
    defaultValue: {
      type: [String, Number, Array],
      default: null
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    filterable: Boolean,
    checkStrategy: {
      type: String,
      default: "all"
    },
    loading: Boolean,
    maxTagCount: [String, Number],
    multiple: Boolean,
    showPath: Boolean,
    separator: {
      type: String,
      default: " / "
    },
    options: {
      type: Array,
      default: () => []
    },
    placeholder: String,
    placement: {
      type: String,
      default: "bottom-start"
    },
    show: {
      type: Boolean,
      default: void 0
    },
    size: String,
    value: [String, Number, Array],
    to: useAdjustedTo.propTo,
    menuProps: Object,
    virtualScroll: {
      type: Boolean,
      default: true
    },
    status: String,
    renderTag: Function,
    ellipsisTagPopoverProps: Object
  }), treeSharedProps), {
    renderLabel: Function,
    renderPrefix: Function,
    renderSuffix: Function,
    nodeProps: Function,
    watchProps: Array,
    getChildren: Function,
    onBlur: Function,
    onFocus: Function,
    onLoad: Function,
    onUpdateShow: [Function, Array],
    onUpdateValue: [Function, Array],
    "onUpdate:value": [Function, Array],
    "onUpdate:show": [Function, Array],
    /**
     * @deprecated
     */
    leafOnly: Boolean
  });
  const TreeSelect = vue.defineComponent({
    name: "TreeSelect",
    props: treeSelectProps,
    setup(props) {
      {
        vue.watchEffect(() => {
          if (props.leafOnly) {
            warnOnce("tree-select", '`leaf-only` is deprecated, please use `check-strategy="child"` instead.');
          }
        });
      }
      const followerInstRef = vue.ref(null);
      const triggerInstRef = vue.ref(null);
      const treeInstRef = vue.ref(null);
      const menuElRef = vue.ref(null);
      const {
        mergedClsPrefixRef,
        namespaceRef,
        inlineThemeDisabled
      } = useConfig(props);
      const {
        localeRef
      } = useLocale("Select");
      const {
        mergedSizeRef,
        mergedDisabledRef,
        mergedStatusRef,
        nTriggerFormBlur,
        nTriggerFormChange,
        nTriggerFormFocus,
        nTriggerFormInput
      } = useFormItem(props);
      const uncontrolledValueRef = vue.ref(props.defaultValue);
      const controlledValueRef = vue.toRef(props, "value");
      const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
      const uncontrolledShowRef = vue.ref(props.defaultShow);
      const controlledShowRef = vue.toRef(props, "show");
      const mergedShowRef = useMergedState(controlledShowRef, uncontrolledShowRef);
      const patternRef = vue.ref("");
      const mergedFilterRef = vue.computed(() => {
        const {
          filter
        } = props;
        if (filter)
          return filter;
        const {
          labelField
        } = props;
        return (pattern, node) => {
          if (!pattern.length)
            return true;
          return node[labelField].toLowerCase().includes(pattern.toLowerCase());
        };
      });
      const dataTreeMateRef = vue.computed(() => createTreeMate(props.options, createTreeMateOptions(props.keyField, props.childrenField, props.disabledField, void 0)));
      const {
        value: initMergedValue
      } = mergedValueRef;
      const pendingNodeKeyRef = vue.ref(props.checkable ? null : Array.isArray(initMergedValue) && initMergedValue.length ? initMergedValue[initMergedValue.length - 1] : null);
      const mergedCascadeRef = vue.computed(() => {
        return props.multiple && props.cascade && props.checkable;
      });
      const uncontrolledExpandedKeysRef = vue.ref(props.defaultExpandAll ? void 0 : props.defaultExpandedKeys || props.expandedKeys);
      const controlledExpandedKeysRef = vue.toRef(props, "expandedKeys");
      const mergedExpandedKeysRef = useMergedState(controlledExpandedKeysRef, uncontrolledExpandedKeysRef);
      const focusedRef = vue.ref(false);
      const mergedPlaceholderRef = vue.computed(() => {
        const {
          placeholder
        } = props;
        if (placeholder !== void 0)
          return placeholder;
        return localeRef.value.placeholder;
      });
      const treeCheckedKeysRef = vue.computed(() => {
        const {
          value: mergedValue
        } = mergedValueRef;
        if (props.multiple) {
          if (Array.isArray(mergedValue))
            return mergedValue;
          else
            return [];
        } else {
          if (mergedValue === null || Array.isArray(mergedValue))
            return [];
          else
            return [mergedValue];
        }
      });
      const treeSelectedKeysRef = vue.computed(() => {
        if (props.checkable)
          return [];
        return treeCheckedKeysRef.value;
      });
      const selectedOptionRef = vue.computed(() => {
        const {
          multiple,
          showPath,
          separator,
          labelField
        } = props;
        if (multiple)
          return null;
        const {
          value: mergedValue
        } = mergedValueRef;
        if (!Array.isArray(mergedValue) && mergedValue !== null) {
          const {
            value: treeMate
          } = dataTreeMateRef;
          const tmNode = treeMate.getNode(mergedValue);
          if (tmNode !== null) {
            return showPath ? treeOption2SelectOptionWithPath(tmNode, treeMate.getPath(mergedValue).treeNodePath, separator, labelField) : treeOption2SelectOption(tmNode, labelField);
          }
        }
        return null;
      });
      const selectedOptionsRef = vue.computed(() => {
        const {
          multiple,
          showPath,
          separator
        } = props;
        if (!multiple)
          return null;
        const {
          value: mergedValue
        } = mergedValueRef;
        if (Array.isArray(mergedValue)) {
          const res = [];
          const {
            value: treeMate
          } = dataTreeMateRef;
          const {
            checkedKeys
          } = treeMate.getCheckedKeys(mergedValue, {
            checkStrategy: props.checkStrategy,
            cascade: mergedCascadeRef.value,
            allowNotLoaded: props.allowCheckingNotLoaded
          });
          const {
            labelField
          } = props;
          checkedKeys.forEach((value) => {
            const tmNode = treeMate.getNode(value);
            if (tmNode !== null) {
              res.push(showPath ? treeOption2SelectOptionWithPath(tmNode, treeMate.getPath(value).treeNodePath, separator, labelField) : treeOption2SelectOption(tmNode, labelField));
            }
          });
          return res;
        }
        return [];
      });
      function focusSelection() {
        var _a;
        (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
      }
      function focusSelectionInput() {
        var _a;
        (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.focusInput();
      }
      function doUpdateShow(value) {
        const {
          onUpdateShow,
          "onUpdate:show": _onUpdateShow
        } = props;
        if (onUpdateShow)
          call(onUpdateShow, value);
        if (_onUpdateShow)
          call(_onUpdateShow, value);
        uncontrolledShowRef.value = value;
      }
      function doUpdateValue(value, option, meta) {
        const {
          onUpdateValue,
          "onUpdate:value": _onUpdateValue
        } = props;
        if (onUpdateValue) {
          call(onUpdateValue, value, option, meta);
        }
        if (_onUpdateValue) {
          call(_onUpdateValue, value, option, meta);
        }
        uncontrolledValueRef.value = value;
        nTriggerFormInput();
        nTriggerFormChange();
      }
      function doUpdateIndeterminateKeys(value, option) {
        const {
          onUpdateIndeterminateKeys,
          "onUpdate:indeterminateKeys": _onUpdateIndeterminateKeys
        } = props;
        if (onUpdateIndeterminateKeys) {
          call(onUpdateIndeterminateKeys, value, option);
        }
        if (_onUpdateIndeterminateKeys) {
          call(_onUpdateIndeterminateKeys, value, option);
        }
      }
      function doUpdateExpandedKeys(keys2, option, meta) {
        const {
          onUpdateExpandedKeys,
          "onUpdate:expandedKeys": _onUpdateExpandedKeys
        } = props;
        if (onUpdateExpandedKeys) {
          call(onUpdateExpandedKeys, keys2, option, meta);
        }
        if (_onUpdateExpandedKeys) {
          call(_onUpdateExpandedKeys, keys2, option, meta);
        }
        uncontrolledExpandedKeysRef.value = keys2;
      }
      function doFocus(e) {
        const {
          onFocus
        } = props;
        if (onFocus)
          onFocus(e);
        nTriggerFormFocus();
      }
      function doBlur(e) {
        closeMenu();
        const {
          onBlur
        } = props;
        if (onBlur)
          onBlur(e);
        nTriggerFormBlur();
      }
      function closeMenu() {
        doUpdateShow(false);
      }
      function openMenu() {
        if (!mergedDisabledRef.value) {
          patternRef.value = "";
          doUpdateShow(true);
          if (props.filterable) {
            focusSelectionInput();
          }
        }
      }
      function handleMenuLeave() {
        patternRef.value = "";
      }
      function handleMenuClickoutside(e) {
        var _a;
        if (mergedShowRef.value) {
          if (!((_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(getPreciseEventTarget(e)))) {
            closeMenu();
          }
        }
      }
      function handleTriggerClick() {
        if (mergedDisabledRef.value)
          return;
        if (!mergedShowRef.value) {
          openMenu();
        } else {
          if (!props.filterable) {
            closeMenu();
          }
        }
      }
      function getOptionsByKeys(keys2) {
        const {
          value: {
            getNode
          }
        } = dataTreeMateRef;
        return keys2.map((key) => {
          var _a;
          return ((_a = getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode) || null;
        });
      }
      function handleUpdateCheckedKeys(keys2, _, meta) {
        const options = getOptionsByKeys(keys2);
        const action = meta.action === "check" ? "select" : "unselect";
        const node = meta.node;
        if (props.multiple) {
          doUpdateValue(keys2, options, {
            node,
            action
          });
          if (props.filterable) {
            focusSelectionInput();
            if (props.clearFilterAfterSelect)
              patternRef.value = "";
          }
        } else {
          if (keys2.length) {
            doUpdateValue(keys2[0], options[0] || null, {
              node,
              action
            });
          } else {
            doUpdateValue(null, null, {
              node,
              action
            });
          }
          closeMenu();
          focusSelection();
        }
      }
      function handleUpdateIndeterminateKeys(keys2) {
        if (props.checkable) {
          doUpdateIndeterminateKeys(keys2, getOptionsByKeys(keys2));
        }
      }
      function handleTriggerFocus(e) {
        var _a;
        if ((_a = menuElRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget))
          return;
        focusedRef.value = true;
        doFocus(e);
      }
      function handleTriggerBlur(e) {
        var _a;
        if ((_a = menuElRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget))
          return;
        focusedRef.value = false;
        doBlur(e);
      }
      function handleMenuFocusin(e) {
        var _a, _b, _c;
        if (((_a = menuElRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) || ((_c = (_b = triggerInstRef.value) === null || _b === void 0 ? void 0 : _b.$el) === null || _c === void 0 ? void 0 : _c.contains(e.relatedTarget))) {
          return;
        }
        focusedRef.value = true;
        doFocus(e);
      }
      function handleMenuFocusout(e) {
        var _a, _b, _c;
        if (((_a = menuElRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) || ((_c = (_b = triggerInstRef.value) === null || _b === void 0 ? void 0 : _b.$el) === null || _c === void 0 ? void 0 : _c.contains(e.relatedTarget))) {
          return;
        }
        focusedRef.value = false;
        doBlur(e);
      }
      function handleClear(e) {
        e.stopPropagation();
        const {
          multiple
        } = props;
        if (!multiple && props.filterable) {
          closeMenu();
        }
        if (multiple) {
          doUpdateValue([], [], {
            node: null,
            action: "clear"
          });
        } else {
          doUpdateValue(null, null, {
            node: null,
            action: "clear"
          });
        }
      }
      function handleDeleteOption(option) {
        const {
          value: mergedValue
        } = mergedValueRef;
        if (Array.isArray(mergedValue)) {
          const {
            value: treeMate
          } = dataTreeMateRef;
          const {
            checkedKeys: checkedKeysValue
          } = treeMate.getCheckedKeys(mergedValue, {
            cascade: mergedCascadeRef.value,
            allowNotLoaded: props.allowCheckingNotLoaded
          });
          const index = checkedKeysValue.findIndex((key) => key === option.value);
          if (~index) {
            const checkedKeyToBeRemoved = checkedKeysValue[index];
            const checkOptionToBeRemoved = getOptionsByKeys([checkedKeyToBeRemoved])[0];
            if (props.checkable) {
              const {
                checkedKeys
              } = treeMate.uncheck(option.value, checkedKeysValue, {
                checkStrategy: props.checkStrategy,
                cascade: mergedCascadeRef.value,
                allowNotLoaded: props.allowCheckingNotLoaded
              });
              doUpdateValue(checkedKeys, getOptionsByKeys(checkedKeys), {
                node: checkOptionToBeRemoved,
                action: "delete"
              });
            } else {
              const nextValue = Array.from(checkedKeysValue);
              nextValue.splice(index, 1);
              doUpdateValue(nextValue, getOptionsByKeys(nextValue), {
                node: checkOptionToBeRemoved,
                action: "delete"
              });
            }
          }
        }
      }
      function handlePatternInput(e) {
        const {
          value
        } = e.target;
        patternRef.value = value;
      }
      function treeHandleKeydown(e) {
        const {
          value: treeInst
        } = treeInstRef;
        if (treeInst) {
          return treeInst.handleKeydown(e);
        }
        return {
          enterBehavior: null
        };
      }
      function handleKeydown(e) {
        if (e.key === "Enter") {
          if (mergedShowRef.value) {
            const {
              enterBehavior
            } = treeHandleKeydown(e);
            if (!props.multiple) {
              switch (enterBehavior) {
                case "default":
                case "toggleSelect":
                  closeMenu();
                  focusSelection();
                  break;
              }
            }
          } else {
            openMenu();
          }
          e.preventDefault();
        } else if (e.key === "Escape") {
          if (mergedShowRef.value) {
            markEventEffectPerformed(e);
            closeMenu();
            focusSelection();
          }
        } else {
          if (mergedShowRef.value) {
            treeHandleKeydown(e);
          } else if (e.key === "ArrowDown") {
            openMenu();
          }
        }
      }
      function handleTabOut() {
        closeMenu();
        focusSelection();
      }
      function handleMenuMousedown(e) {
        if (!happensIn(e, "action") && !happensIn(e, "header"))
          e.preventDefault();
      }
      const selectionRenderTagRef = vue.computed(() => {
        const {
          renderTag
        } = props;
        if (!renderTag)
          return void 0;
        return function selectionRenderTag({
          option,
          handleClose
        }) {
          const {
            value
          } = option;
          if (value !== void 0) {
            const treeOption = dataTreeMateRef.value.getNode(value);
            if (treeOption) {
              return renderTag({
                option: treeOption.rawNode,
                handleClose
              });
            }
          }
          return value;
        };
      });
      vue.provide(treeSelectInjectionKey, {
        pendingNodeKeyRef,
        dataTreeMate: dataTreeMateRef
      });
      function handleTriggerOrMenuResize() {
        var _a;
        if (!mergedShowRef.value)
          return;
        (_a = followerInstRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
      }
      useOnResize(menuElRef, handleTriggerOrMenuResize);
      const mergedCheckStrategyRef = useMergedCheckStrategy(props);
      const exposedCheckedStatusRef = vue.computed(() => {
        if (props.checkable) {
          const mergedValue = mergedValueRef.value;
          if (props.multiple && Array.isArray(mergedValue)) {
            return dataTreeMateRef.value.getCheckedKeys(mergedValue, {
              cascade: props.cascade,
              checkStrategy: mergedCheckStrategyRef.value,
              allowNotLoaded: props.allowCheckingNotLoaded
            });
          } else {
            return {
              checkedKeys: Array.isArray(mergedValue) || mergedValue === null ? [] : [mergedValue],
              indeterminateKeys: []
            };
          }
        }
        return {
          checkedKeys: [],
          indeterminateKeys: []
        };
      });
      const exposedMethods = {
        getCheckedData: () => {
          const {
            checkedKeys
          } = exposedCheckedStatusRef.value;
          return {
            keys: checkedKeys,
            options: getOptionsByKeys(checkedKeys)
          };
        },
        getIndeterminateData: () => {
          const {
            indeterminateKeys
          } = exposedCheckedStatusRef.value;
          return {
            keys: indeterminateKeys,
            options: getOptionsByKeys(indeterminateKeys)
          };
        },
        focus: () => {
          var _a;
          return (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
        },
        focusInput: () => {
          var _a;
          return (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.focusInput();
        },
        blur: () => {
          var _a;
          return (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.blur();
        },
        blurInput: () => {
          var _a;
          return (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.blurInput();
        }
      };
      const themeRef = useTheme("TreeSelect", "-tree-select", style$9, treeSelectLight$1, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            menuBoxShadow,
            menuBorderRadius,
            menuColor,
            menuHeight,
            actionPadding,
            actionDividerColor,
            actionTextColor,
            headerDividerColor,
            headerPadding,
            headerTextColor
          }
        } = themeRef.value;
        return {
          "--n-menu-box-shadow": menuBoxShadow,
          "--n-menu-border-radius": menuBorderRadius,
          "--n-menu-color": menuColor,
          "--n-menu-height": menuHeight,
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-action-padding": actionPadding,
          "--n-action-text-color": actionTextColor,
          "--n-action-divider-color": actionDividerColor,
          "--n-header-padding": headerPadding,
          "--n-header-text-color": headerTextColor,
          "--n-header-divider-color": headerDividerColor
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("tree-select", void 0, cssVarsRef, props) : void 0;
      const menuPaddingRef = vue.computed(() => {
        const {
          self: {
            menuPadding
          }
        } = themeRef.value;
        return menuPadding;
      });
      return Object.assign(Object.assign({}, exposedMethods), {
        menuElRef,
        mergedStatus: mergedStatusRef,
        triggerInstRef,
        followerInstRef,
        treeInstRef,
        mergedClsPrefix: mergedClsPrefixRef,
        mergedValue: mergedValueRef,
        mergedShow: mergedShowRef,
        namespace: namespaceRef,
        adjustedTo: useAdjustedTo(props),
        isMounted: isMounted(),
        focused: focusedRef,
        menuPadding: menuPaddingRef,
        mergedPlaceholder: mergedPlaceholderRef,
        mergedExpandedKeys: mergedExpandedKeysRef,
        treeSelectedKeys: treeSelectedKeysRef,
        treeCheckedKeys: treeCheckedKeysRef,
        mergedSize: mergedSizeRef,
        mergedDisabled: mergedDisabledRef,
        selectedOption: selectedOptionRef,
        selectedOptions: selectedOptionsRef,
        pattern: patternRef,
        pendingNodeKey: pendingNodeKeyRef,
        mergedCascade: mergedCascadeRef,
        mergedFilter: mergedFilterRef,
        selectionRenderTag: selectionRenderTagRef,
        handleTriggerOrMenuResize,
        doUpdateExpandedKeys,
        handleMenuLeave,
        handleTriggerClick,
        handleMenuClickoutside,
        handleUpdateCheckedKeys,
        handleUpdateIndeterminateKeys,
        handleTriggerFocus,
        handleTriggerBlur,
        handleMenuFocusin,
        handleMenuFocusout,
        handleClear,
        handleDeleteOption,
        handlePatternInput,
        handleKeydown,
        handleTabOut,
        handleMenuMousedown,
        mergedTheme: themeRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      });
    },
    render() {
      const {
        mergedTheme,
        mergedClsPrefix,
        $slots
      } = this;
      return vue.h("div", {
        class: `${mergedClsPrefix}-tree-select`
      }, vue.h(VBinder, null, {
        default: () => [vue.h(VTarget, null, {
          default: () => vue.h(NInternalSelection, {
            ref: "triggerInstRef",
            onResize: this.handleTriggerOrMenuResize,
            status: this.mergedStatus,
            focused: this.focused,
            clsPrefix: mergedClsPrefix,
            theme: mergedTheme.peers.InternalSelection,
            themeOverrides: mergedTheme.peerOverrides.InternalSelection,
            ellipsisTagPopoverProps: this.ellipsisTagPopoverProps,
            renderTag: this.selectionRenderTag,
            selectedOption: this.selectedOption,
            selectedOptions: this.selectedOptions,
            size: this.mergedSize,
            bordered: this.bordered,
            placeholder: this.mergedPlaceholder,
            disabled: this.mergedDisabled,
            active: this.mergedShow,
            loading: this.loading,
            multiple: this.multiple,
            maxTagCount: this.maxTagCount,
            showArrow: true,
            filterable: this.filterable,
            clearable: this.clearable,
            pattern: this.pattern,
            onPatternInput: this.handlePatternInput,
            onClear: this.handleClear,
            onClick: this.handleTriggerClick,
            onFocus: this.handleTriggerFocus,
            onBlur: this.handleTriggerBlur,
            onDeleteOption: this.handleDeleteOption,
            onKeydown: this.handleKeydown
          }, {
            arrow: () => {
              var _a, _b;
              return [(_b = (_a = this.$slots).arrow) === null || _b === void 0 ? void 0 : _b.call(_a)];
            }
          })
        }), vue.h(VFollower, {
          ref: "followerInstRef",
          show: this.mergedShow,
          placement: this.placement,
          to: this.adjustedTo,
          teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey,
          containerClass: this.namespace,
          width: this.consistentMenuWidth ? "target" : void 0,
          minWidth: "target"
        }, {
          default: () => vue.h(vue.Transition, {
            name: "fade-in-scale-up-transition",
            appear: this.isMounted,
            onLeave: this.handleMenuLeave
          }, {
            default: () => {
              var _a;
              if (!this.mergedShow)
                return null;
              const {
                mergedClsPrefix: mergedClsPrefix2,
                checkable,
                multiple,
                menuProps: menuProps2,
                options
              } = this;
              (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
              return vue.withDirectives(vue.h("div", Object.assign({}, menuProps2, {
                class: [`${mergedClsPrefix2}-tree-select-menu`, menuProps2 === null || menuProps2 === void 0 ? void 0 : menuProps2.class, this.themeClass],
                ref: "menuElRef",
                style: [(menuProps2 === null || menuProps2 === void 0 ? void 0 : menuProps2.style) || "", this.cssVars],
                tabindex: 0,
                onMousedown: this.handleMenuMousedown,
                onKeydown: this.handleKeydown,
                onFocusin: this.handleMenuFocusin,
                onFocusout: this.handleMenuFocusout
              }), resolveWrappedSlot($slots.header, (children) => {
                return children ? vue.h("div", {
                  class: `${mergedClsPrefix2}-tree-select-menu__header`,
                  "data-header": true
                }, children) : null;
              }), vue.h(NTree, {
                ref: "treeInstRef",
                blockLine: true,
                allowCheckingNotLoaded: this.allowCheckingNotLoaded,
                showIrrelevantNodes: false,
                animated: false,
                pattern: this.pattern,
                getChildren: this.getChildren,
                filter: this.mergedFilter,
                data: options,
                cancelable: multiple,
                labelField: this.labelField,
                keyField: this.keyField,
                disabledField: this.disabledField,
                childrenField: this.childrenField,
                theme: mergedTheme.peers.Tree,
                themeOverrides: mergedTheme.peerOverrides.Tree,
                defaultExpandAll: this.defaultExpandAll,
                defaultExpandedKeys: this.defaultExpandedKeys,
                expandedKeys: this.mergedExpandedKeys,
                checkedKeys: this.treeCheckedKeys,
                selectedKeys: this.treeSelectedKeys,
                checkable,
                checkStrategy: this.checkStrategy,
                cascade: this.mergedCascade,
                leafOnly: this.leafOnly,
                multiple: this.multiple,
                renderLabel: this.renderLabel,
                renderPrefix: this.renderPrefix,
                renderSuffix: this.renderSuffix,
                renderSwitcherIcon: this.renderSwitcherIcon,
                nodeProps: this.nodeProps,
                watchProps: this.watchProps,
                virtualScroll: this.consistentMenuWidth && this.virtualScroll,
                overrideDefaultNodeClickBehavior: this.overrideDefaultNodeClickBehavior,
                internalTreeSelect: true,
                internalUnifySelectCheck: true,
                internalScrollable: true,
                internalScrollablePadding: this.menuPadding,
                internalFocusable: false,
                internalCheckboxFocusable: false,
                internalRenderEmpty: () => vue.h("div", {
                  class: `${mergedClsPrefix2}-tree-select-menu__empty`
                }, resolveSlot($slots.empty, () => [vue.h(NEmpty, {
                  theme: mergedTheme.peers.Empty,
                  themeOverrides: mergedTheme.peerOverrides.Empty
                })])),
                onLoad: this.onLoad,
                onUpdateCheckedKeys: this.handleUpdateCheckedKeys,
                onUpdateIndeterminateKeys: this.handleUpdateIndeterminateKeys,
                onUpdateExpandedKeys: this.doUpdateExpandedKeys
              }), resolveWrappedSlot($slots.action, (children) => {
                return children ? vue.h("div", {
                  class: `${mergedClsPrefix2}-tree-select-menu__action`,
                  "data-action": true
                }, children) : null;
              }), vue.h(FocusDetector, {
                onFocus: this.handleTabOut
              })), [[clickoutside$1, this.handleMenuClickoutside, void 0, {
                capture: true
              }]]);
            }
          })
        })]
      }));
    }
  });
  const style$8 = cB("h", `
 font-size: var(--n-font-size);
 font-weight: var(--n-font-weight);
 margin: var(--n-margin);
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
`, [c$1("&:first-child", {
    marginTop: 0
  }), cM("prefix-bar", {
    position: "relative",
    paddingLeft: "var(--n-prefix-width)"
  }, [cM("align-text", {
    paddingLeft: 0
  }, [c$1("&::before", {
    left: "calc(-1 * var(--n-prefix-width))"
  })]), c$1("&::before", `
 content: "";
 width: var(--n-bar-width);
 border-radius: calc(var(--n-bar-width) / 2);
 transition: background-color .3s var(--n-bezier);
 left: 0;
 top: 0;
 bottom: 0;
 position: absolute;
 `), c$1("&::before", {
    backgroundColor: "var(--n-bar-color)"
  })])]);
  const headerProps = Object.assign(Object.assign({}, useTheme.props), {
    type: {
      type: String,
      default: "default"
    },
    prefix: String,
    alignText: Boolean
  });
  const createHeader = (level) => vue.defineComponent({
    name: `H${level}`,
    props: headerProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Typography", "-h", style$8, typographyLight$1, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          type
        } = props;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            headerFontWeight,
            headerTextColor,
            [createKey("headerPrefixWidth", level)]: prefixWidth,
            [createKey("headerFontSize", level)]: fontSize2,
            [createKey("headerMargin", level)]: margin,
            [createKey("headerBarWidth", level)]: barWidth,
            [createKey("headerBarColor", type)]: barColor
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-font-size": fontSize2,
          "--n-margin": margin,
          "--n-bar-color": barColor,
          "--n-bar-width": barWidth,
          "--n-font-weight": headerFontWeight,
          "--n-text-color": headerTextColor,
          "--n-prefix-width": prefixWidth
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass(`h${level}`, vue.computed(() => props.type[0]), cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a;
      const {
        prefix: prefix2,
        alignText,
        mergedClsPrefix,
        cssVars,
        $slots
      } = this;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      return vue.h(`h${level}`, {
        class: [`${mergedClsPrefix}-h`, `${mergedClsPrefix}-h${level}`, this.themeClass, {
          [`${mergedClsPrefix}-h--prefix-bar`]: prefix2,
          [`${mergedClsPrefix}-h--align-text`]: alignText
        }],
        style: cssVars
      }, $slots);
    }
  });
  const NH1 = createHeader("1");
  const NH2 = createHeader("2");
  const NH3 = createHeader("3");
  const NH4 = createHeader("4");
  const NH5 = createHeader("5");
  const NH6 = createHeader("6");
  const style$7 = cB("a", `
 cursor: pointer;
 transition:
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier);
 text-decoration-color: var(--n-text-color);
 color: var(--n-text-color);
`);
  const aProps = Object.assign({}, useTheme.props);
  const a = vue.defineComponent({
    name: "A",
    props: aProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Typography", "-a", style$7, typographyLight$1, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            aTextColor
          }
        } = themeRef.value;
        return {
          "--n-text-color": aTextColor,
          "--n-bezier": cubicBezierEaseInOut2
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("a", void 0, cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      return vue.h("a", {
        class: [`${this.mergedClsPrefix}-a`, this.themeClass],
        style: this.cssVars
      }, this.$slots);
    }
  });
  const style$6 = cB("p", `
 box-sizing: border-box;
 transition: color .3s var(--n-bezier);
 margin: var(--n-margin);
 font-size: var(--n-font-size);
 line-height: var(--n-line-height);
 color: var(--n-text-color);
`, [c$1("&:first-child", "margin-top: 0;"), c$1("&:last-child", "margin-bottom: 0;")]);
  const pProps = Object.assign(Object.assign({}, useTheme.props), {
    depth: [String, Number]
  });
  const p = vue.defineComponent({
    name: "P",
    props: pProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Typography", "-p", style$6, typographyLight$1, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          depth
        } = props;
        const typeSafeDepth = depth || "1";
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            pFontSize,
            pLineHeight,
            pMargin,
            pTextColor,
            [`pTextColor${typeSafeDepth}Depth`]: depthTextColor
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-font-size": pFontSize,
          "--n-line-height": pLineHeight,
          "--n-margin": pMargin,
          "--n-text-color": depth === void 0 ? pTextColor : depthTextColor
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("p", vue.computed(() => `${props.depth || ""}`), cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      return vue.h("p", {
        class: [`${this.mergedClsPrefix}-p`, this.themeClass],
        style: this.cssVars
      }, this.$slots);
    }
  });
  const style$5 = cB("blockquote", `
 font-size: var(--n-font-size);
 line-height: var(--n-line-height);
 margin: 0;
 margin-top: 12px;
 margin-bottom: 12px;
 box-sizing: border-box;
 padding-left: 12px;
 border-left: 4px solid var(--n-prefix-color);
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
`, [c$1("&:first-child", {
    marginTop: 0
  }), c$1("&:last-child", {
    marginBottom: 0
  }), cM("align-text", {
    marginLeft: "-16px"
  })]);
  const blockquoteProps = Object.assign(Object.assign({}, useTheme.props), {
    alignText: Boolean
  });
  const blockquote = vue.defineComponent({
    name: "Blockquote",
    props: blockquoteProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Typography", "-blockquote", style$5, typographyLight$1, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            blockquoteTextColor,
            blockquotePrefixColor,
            blockquoteLineHeight,
            blockquoteFontSize
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-font-size": blockquoteFontSize,
          "--n-line-height": blockquoteLineHeight,
          "--n-prefix-color": blockquotePrefixColor,
          "--n-text-color": blockquoteTextColor
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("blockquote", void 0, cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a;
      const {
        mergedClsPrefix
      } = this;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      return vue.h("blockquote", {
        class: [`${mergedClsPrefix}-blockquote`, this.themeClass, this.alignText && `${mergedClsPrefix}-blockquote--align-text`],
        style: this.cssVars
      }, this.$slots);
    }
  });
  const style$4 = cB("hr", `
 margin: 12px 0;
 transition: border-color .3s var(--n-bezier);
 border-left: none;
 border-right: none;
 border-bottom: none;
 border-top: 1px solid var(--n-color);
`);
  const hr = vue.defineComponent({
    name: "Hr",
    props: Object.assign({}, useTheme.props),
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Typography", "-hr", style$4, typographyLight$1, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            hrColor
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-color": hrColor
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("hr", void 0, cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      return vue.h("hr", {
        class: [`${this.mergedClsPrefix}-hr`, this.themeClass],
        style: this.cssVars
      });
    }
  });
  const liStyle = c$1("li", {
    transition: "color .3s var(--n-bezier)",
    lineHeight: "var(--n-line-height)",
    margin: "var(--n-li-margin)",
    marginBottom: 0,
    color: "var(--n-text-color)"
  });
  const childStyle = [c$1("&:first-child", `
 margin-top: 0;
 `), c$1("&:last-child", `
 margin-bottom: 0;
 `)];
  const style$3 = c$1([cB("ol", {
    fontSize: "var(--n-font-size)",
    padding: "var(--n-ol-padding)"
  }, [cM("align-text", {
    paddingLeft: 0
  }), liStyle, childStyle]), cB("ul", {
    fontSize: "var(--n-font-size)",
    padding: "var(--n-ul-padding)"
  }, [cM("align-text", {
    paddingLeft: 0
  }), liStyle, childStyle])]);
  const ulProps = Object.assign(Object.assign({}, useTheme.props), {
    alignText: Boolean
  });
  const ul = vue.defineComponent({
    name: "Ul",
    props: ulProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Typography", "-xl", style$3, typographyLight$1, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            olPadding,
            ulPadding,
            liMargin,
            liTextColor,
            liLineHeight,
            liFontSize
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-font-size": liFontSize,
          "--n-line-height": liLineHeight,
          "--n-text-color": liTextColor,
          "--n-li-margin": liMargin,
          "--n-ol-padding": olPadding,
          "--n-ul-padding": ulPadding
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("ul", void 0, cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a;
      const {
        mergedClsPrefix
      } = this;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      return vue.h("ul", {
        class: [`${mergedClsPrefix}-ul`, this.themeClass, this.alignText && `${mergedClsPrefix}-ul--align-text`],
        style: this.cssVars
      }, this.$slots);
    }
  });
  const olProps = Object.assign(Object.assign({}, useTheme.props), {
    alignText: Boolean
  });
  const ol = vue.defineComponent({
    name: "Ol",
    props: olProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Typography", "-xl", style$3, typographyLight$1, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            olPadding,
            ulPadding,
            liMargin,
            liTextColor,
            liLineHeight,
            liFontSize
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-font-size": liFontSize,
          "--n-line-height": liLineHeight,
          "--n-text-color": liTextColor,
          "--n-li-margin": liMargin,
          "--n-ol-padding": olPadding,
          "--n-ul-padding": ulPadding
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("ol", void 0, cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a;
      const {
        mergedClsPrefix
      } = this;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      return vue.h("ol", {
        class: [`${mergedClsPrefix}-ol`, this.themeClass, this.alignText && `${mergedClsPrefix}-ol--align-text`],
        style: this.cssVars
      }, this.$slots);
    }
  });
  const li = vue.defineComponent({
    name: "Li",
    render() {
      return vue.h("li", null, this.$slots);
    }
  });
  const style$2 = cB("text", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
`, [cM("strong", `
 font-weight: var(--n-font-weight-strong);
 `), cM("italic", {
    fontStyle: "italic"
  }), cM("underline", {
    textDecoration: "underline"
  }), cM("code", `
 line-height: 1.4;
 display: inline-block;
 font-family: var(--n-font-famliy-mono);
 transition: 
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 box-sizing: border-box;
 padding: .05em .35em 0 .35em;
 border-radius: var(--n-code-border-radius);
 font-size: .9em;
 color: var(--n-code-text-color);
 background-color: var(--n-code-color);
 border: var(--n-code-border);
 `)]);
  const textProps = Object.assign(Object.assign({}, useTheme.props), {
    code: Boolean,
    type: {
      type: String,
      default: "default"
    },
    delete: Boolean,
    strong: Boolean,
    italic: Boolean,
    underline: Boolean,
    depth: [String, Number],
    tag: String,
    // deprecated
    as: {
      type: String,
      validator: () => {
        {
          warn$2("text", "`as` is deprecated, please use `tag` instead.");
        }
        return true;
      },
      default: void 0
    }
  });
  const text = vue.defineComponent({
    name: "Text",
    props: textProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Typography", "-text", style$2, typographyLight$1, props, mergedClsPrefixRef);
      const cssVarsRef = vue.computed(() => {
        const {
          depth,
          type
        } = props;
        const textColorKey = type === "default" ? depth === void 0 ? "textColor" : `textColor${depth}Depth` : createKey("textColor", type);
        const {
          common: {
            fontWeightStrong,
            fontFamilyMono,
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            codeTextColor,
            codeBorderRadius,
            codeColor,
            codeBorder,
            [textColorKey]: textColor
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-text-color": textColor,
          "--n-font-weight-strong": fontWeightStrong,
          "--n-font-famliy-mono": fontFamilyMono,
          "--n-code-border-radius": codeBorderRadius,
          "--n-code-text-color": codeTextColor,
          "--n-code-color": codeColor,
          "--n-code-border": codeBorder
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("text", vue.computed(() => `${props.type[0]}${props.depth || ""}`), cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        compitableTag: useCompitable(props, ["as", "tag"]),
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a, _b, _c;
      const {
        mergedClsPrefix
      } = this;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      const textClass = [`${mergedClsPrefix}-text`, this.themeClass, {
        [`${mergedClsPrefix}-text--code`]: this.code,
        [`${mergedClsPrefix}-text--delete`]: this.delete,
        [`${mergedClsPrefix}-text--strong`]: this.strong,
        [`${mergedClsPrefix}-text--italic`]: this.italic,
        [`${mergedClsPrefix}-text--underline`]: this.underline
      }];
      const children = (_c = (_b = this.$slots).default) === null || _c === void 0 ? void 0 : _c.call(_b);
      return this.code ? vue.h("code", {
        class: textClass,
        style: this.cssVars
      }, this.delete ? vue.h("del", null, children) : children) : this.delete ? vue.h("del", {
        class: textClass,
        style: this.cssVars
      }, children) : vue.h(this.compitableTag || "span", {
        class: textClass,
        style: this.cssVars
      }, children);
    }
  });
  const uploadInjectionKey = createInjectionKey("n-upload");
  const uploadDraggerKey = "__UPLOAD_DRAGGER__";
  const NUploadDragger = vue.defineComponent({
    name: "UploadDragger",
    [uploadDraggerKey]: true,
    setup(_, {
      slots
    }) {
      const NUpload = vue.inject(uploadInjectionKey, null);
      if (!NUpload) {
        throwError("upload-dragger", "`n-upload-dragger` must be placed inside `n-upload`.");
      }
      return () => {
        const {
          mergedClsPrefixRef: {
            value: mergedClsPrefix
          },
          mergedDisabledRef: {
            value: mergedDisabled
          },
          maxReachedRef: {
            value: maxReached
          }
        } = NUpload;
        return vue.h("div", {
          class: [`${mergedClsPrefix}-upload-dragger`, (mergedDisabled || maxReached) && `${mergedClsPrefix}-upload-dragger--disabled`]
        }, slots);
      };
    }
  });
  var __awaiter$2 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function isImageFileType(type) {
    return type.includes("image/");
  }
  function getExtname(url = "") {
    const temp = url.split("/");
    const filename = temp[temp.length - 1];
    const filenameWithoutSuffix = filename.split(/#|\?/)[0];
    return (/\.[^./\\]*$/.exec(filenameWithoutSuffix) || [""])[0];
  }
  const imageExtensionRegex = /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico)$/i;
  const isImageFile = (file) => {
    if (file.type) {
      return isImageFileType(file.type);
    }
    const fileNameExtension = getExtname(file.name || "");
    if (imageExtensionRegex.test(fileNameExtension)) {
      return true;
    }
    const url = file.thumbnailUrl || file.url || "";
    const urlExtension = getExtname(url);
    if (/^data:image\//.test(url) || imageExtensionRegex.test(urlExtension)) {
      return true;
    }
    return false;
  };
  function createImageDataUrl(file) {
    return __awaiter$2(this, void 0, void 0, function* () {
      return yield new Promise((resolve) => {
        if (!file.type || !isImageFileType(file.type)) {
          resolve("");
          return;
        }
        resolve(window.URL.createObjectURL(file));
      });
    });
  }
  const environmentSupportFile = isBrowser$2 && window.FileReader && window.File;
  function isFileSystemDirectoryEntry(item) {
    return item.isDirectory;
  }
  function isFileSystemFileEntry(item) {
    return item.isFile;
  }
  function getFilesFromEntries(entries, directory) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const fileAndEntries = [];
      function _getFilesFromEntries(entries2) {
        return __awaiter$2(this, void 0, void 0, function* () {
          for (const entry of entries2) {
            if (!entry)
              continue;
            if (directory && isFileSystemDirectoryEntry(entry)) {
              const directoryReader = entry.createReader();
              let allEntries = [];
              let readEntries;
              try {
                do {
                  readEntries = yield new Promise((resolve, reject) => {
                    directoryReader.readEntries(resolve, reject);
                  });
                  allEntries = allEntries.concat(readEntries);
                } while (readEntries.length > 0);
              } catch (e) {
                error("upload", "error happens when handling directory upload", e);
              }
              yield _getFilesFromEntries(allEntries);
            } else if (isFileSystemFileEntry(entry)) {
              try {
                const file = yield new Promise((resolve, reject) => {
                  entry.file(resolve, reject);
                });
                fileAndEntries.push({
                  file,
                  entry,
                  source: "dnd"
                });
              } catch (e) {
                error("upload", "error happens when handling file upload", e);
              }
            }
          }
        });
      }
      yield _getFilesFromEntries(entries);
      return fileAndEntries;
    });
  }
  function createSettledFileInfo(fileInfo) {
    const {
      id,
      name,
      percentage,
      status,
      url,
      file,
      thumbnailUrl,
      type,
      fullPath,
      batchId
    } = fileInfo;
    return {
      id,
      name,
      percentage: percentage !== null && percentage !== void 0 ? percentage : null,
      status,
      url: url !== null && url !== void 0 ? url : null,
      file: file !== null && file !== void 0 ? file : null,
      thumbnailUrl: thumbnailUrl !== null && thumbnailUrl !== void 0 ? thumbnailUrl : null,
      type: type !== null && type !== void 0 ? type : null,
      fullPath: fullPath !== null && fullPath !== void 0 ? fullPath : null,
      batchId: batchId !== null && batchId !== void 0 ? batchId : null
    };
  }
  function matchType(name, mimeType, accept) {
    name = name.toLowerCase();
    mimeType = mimeType.toLocaleLowerCase();
    accept = accept.toLocaleLowerCase();
    const acceptAtoms = accept.split(",").map((acceptAtom) => acceptAtom.trim()).filter(Boolean);
    return acceptAtoms.some((acceptAtom) => {
      if (acceptAtom.startsWith(".")) {
        if (name.endsWith(acceptAtom))
          return true;
      } else if (acceptAtom.includes("/")) {
        const [type, subtype] = mimeType.split("/");
        const [acceptType, acceptSubtype] = acceptAtom.split("/");
        if (acceptType === "*" || type && acceptType && acceptType === type) {
          if (acceptSubtype === "*" || subtype && acceptSubtype && acceptSubtype === subtype) {
            return true;
          }
        }
      } else {
        return true;
      }
      return false;
    });
  }
  const NUploadTrigger = vue.defineComponent({
    name: "UploadTrigger",
    props: {
      abstract: Boolean
    },
    setup(props, {
      slots
    }) {
      const NUpload = vue.inject(uploadInjectionKey, null);
      if (!NUpload) {
        throwError("upload-trigger", "`n-upload-trigger` must be placed inside `n-upload`.");
      }
      const {
        mergedClsPrefixRef,
        mergedDisabledRef,
        maxReachedRef,
        listTypeRef,
        dragOverRef,
        openOpenFileDialog,
        draggerInsideRef,
        handleFileAddition,
        mergedDirectoryDndRef,
        triggerClassRef,
        triggerStyleRef
      } = NUpload;
      const isImageCardTypeRef = vue.computed(() => listTypeRef.value === "image-card");
      function handleTriggerClick() {
        if (mergedDisabledRef.value || maxReachedRef.value)
          return;
        openOpenFileDialog();
      }
      function handleTriggerDragOver(e) {
        e.preventDefault();
        dragOverRef.value = true;
      }
      function handleTriggerDragEnter(e) {
        e.preventDefault();
        dragOverRef.value = true;
      }
      function handleTriggerDragLeave(e) {
        e.preventDefault();
        dragOverRef.value = false;
      }
      function handleTriggerDrop(e) {
        var _a;
        e.preventDefault();
        if (!draggerInsideRef.value || mergedDisabledRef.value || maxReachedRef.value) {
          dragOverRef.value = false;
          return;
        }
        const dataTransferItems = (_a = e.dataTransfer) === null || _a === void 0 ? void 0 : _a.items;
        if (dataTransferItems === null || dataTransferItems === void 0 ? void 0 : dataTransferItems.length) {
          void getFilesFromEntries(Array.from(dataTransferItems).map((item) => item.webkitGetAsEntry()), mergedDirectoryDndRef.value).then((files) => {
            handleFileAddition(files);
          }).finally(() => {
            dragOverRef.value = false;
          });
        } else {
          dragOverRef.value = false;
        }
      }
      return () => {
        var _a;
        const {
          value: mergedClsPrefix
        } = mergedClsPrefixRef;
        return props.abstract ? (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots, {
          handleClick: handleTriggerClick,
          handleDrop: handleTriggerDrop,
          handleDragOver: handleTriggerDragOver,
          handleDragEnter: handleTriggerDragEnter,
          handleDragLeave: handleTriggerDragLeave
        }) : vue.h("div", {
          class: [`${mergedClsPrefix}-upload-trigger`, (mergedDisabledRef.value || maxReachedRef.value) && `${mergedClsPrefix}-upload-trigger--disabled`, isImageCardTypeRef.value && `${mergedClsPrefix}-upload-trigger--image-card`, triggerClassRef.value],
          style: triggerStyleRef.value,
          onClick: handleTriggerClick,
          onDrop: handleTriggerDrop,
          onDragover: handleTriggerDragOver,
          onDragenter: handleTriggerDragEnter,
          onDragleave: handleTriggerDragLeave
        }, isImageCardTypeRef.value ? vue.h(NUploadDragger, null, {
          default: () => resolveSlot(slots.default, () => [vue.h(NBaseIcon, {
            clsPrefix: mergedClsPrefix
          }, {
            default: () => vue.h(AddIcon, null)
          })])
        }) : slots);
      };
    }
  });
  const NUploadProgress = vue.defineComponent({
    name: "UploadProgress",
    props: {
      show: Boolean,
      percentage: {
        type: Number,
        required: true
      },
      status: {
        type: String,
        required: true
      }
    },
    setup() {
      const NUpload = vue.inject(uploadInjectionKey);
      return {
        mergedTheme: NUpload.mergedThemeRef
      };
    },
    render() {
      return vue.h(NFadeInExpandTransition, null, {
        default: () => this.show ? vue.h(NProgress, {
          type: "line",
          showIndicator: false,
          percentage: this.percentage,
          status: this.status,
          height: 2,
          theme: this.mergedTheme.peers.Progress,
          themeOverrides: this.mergedTheme.peerOverrides.Progress
        }) : null
      });
    }
  });
  const imageIcon = vue.h("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 28 28"
  }, vue.h("g", {
    fill: "none"
  }, vue.h("path", {
    d: "M21.75 3A3.25 3.25 0 0 1 25 6.25v15.5A3.25 3.25 0 0 1 21.75 25H6.25A3.25 3.25 0 0 1 3 21.75V6.25A3.25 3.25 0 0 1 6.25 3h15.5zm.583 20.4l-7.807-7.68a.75.75 0 0 0-.968-.07l-.084.07l-7.808 7.68c.183.065.38.1.584.1h15.5c.204 0 .4-.035.583-.1l-7.807-7.68l7.807 7.68zM21.75 4.5H6.25A1.75 1.75 0 0 0 4.5 6.25v15.5c0 .208.036.408.103.593l7.82-7.692a2.25 2.25 0 0 1 3.026-.117l.129.117l7.82 7.692c.066-.185.102-.385.102-.593V6.25a1.75 1.75 0 0 0-1.75-1.75zm-3.25 3a2.5 2.5 0 1 1 0 5a2.5 2.5 0 0 1 0-5zm0 1.5a1 1 0 1 0 0 2a1 1 0 0 0 0-2z",
    fill: "currentColor"
  })));
  const documentIcon = vue.h("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 28 28"
  }, vue.h("g", {
    fill: "none"
  }, vue.h("path", {
    d: "M6.4 2A2.4 2.4 0 0 0 4 4.4v19.2A2.4 2.4 0 0 0 6.4 26h15.2a2.4 2.4 0 0 0 2.4-2.4V11.578c0-.729-.29-1.428-.805-1.944l-6.931-6.931A2.4 2.4 0 0 0 14.567 2H6.4zm-.9 2.4a.9.9 0 0 1 .9-.9H14V10a2 2 0 0 0 2 2h6.5v11.6a.9.9 0 0 1-.9.9H6.4a.9.9 0 0 1-.9-.9V4.4zm16.44 6.1H16a.5.5 0 0 1-.5-.5V4.06l6.44 6.44z",
    fill: "currentColor"
  })));
  var __awaiter$1 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  const buttonThemeOverrides = {
    paddingMedium: "0 3px",
    heightMedium: "24px",
    iconSizeMedium: "18px"
  };
  const NUploadFile = vue.defineComponent({
    name: "UploadFile",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      file: {
        type: Object,
        required: true
      },
      listType: {
        type: String,
        required: true
      },
      index: {
        type: Number,
        required: true
      }
    },
    setup(props) {
      const NUpload = vue.inject(uploadInjectionKey);
      const imageRef = vue.ref(null);
      const thumbnailUrlRef = vue.ref("");
      const progressStatusRef = vue.computed(() => {
        const {
          file
        } = props;
        if (file.status === "finished")
          return "success";
        if (file.status === "error")
          return "error";
        return "info";
      });
      const buttonTypeRef = vue.computed(() => {
        const {
          file
        } = props;
        if (file.status === "error")
          return "error";
        return void 0;
      });
      const showProgressRef = vue.computed(() => {
        const {
          file
        } = props;
        return file.status === "uploading";
      });
      const showCancelButtonRef = vue.computed(() => {
        if (!NUpload.showCancelButtonRef.value)
          return false;
        const {
          file
        } = props;
        return ["uploading", "pending", "error"].includes(file.status);
      });
      const showRemoveButtonRef = vue.computed(() => {
        if (!NUpload.showRemoveButtonRef.value)
          return false;
        const {
          file
        } = props;
        return ["finished"].includes(file.status);
      });
      const showDownloadButtonRef = vue.computed(() => {
        if (!NUpload.showDownloadButtonRef.value)
          return false;
        const {
          file
        } = props;
        return ["finished"].includes(file.status);
      });
      const showRetryButtonRef = vue.computed(() => {
        if (!NUpload.showRetryButtonRef.value)
          return false;
        const {
          file
        } = props;
        return ["error"].includes(file.status);
      });
      const mergedThumbnailUrlRef = useMemo(() => {
        return thumbnailUrlRef.value || props.file.thumbnailUrl || props.file.url;
      });
      const showPreviewButtonRef = vue.computed(() => {
        if (!NUpload.showPreviewButtonRef.value)
          return false;
        const {
          file: {
            status
          },
          listType
        } = props;
        return ["finished"].includes(status) && mergedThumbnailUrlRef.value && listType === "image-card";
      });
      function handleRetryClick() {
        return __awaiter$1(this, void 0, void 0, function* () {
          const onRetry = NUpload.onRetryRef.value;
          if (onRetry) {
            const onRetryReturn = yield onRetry({
              file: props.file
            });
            if (onRetryReturn === false) {
              return;
            }
          }
          NUpload.submit(props.file.id);
        });
      }
      function handleRemoveOrCancelClick(e) {
        e.preventDefault();
        const {
          file
        } = props;
        if (["finished", "pending", "error"].includes(file.status)) {
          handleRemove(file);
        } else if (["uploading"].includes(file.status)) {
          handleAbort(file);
        } else {
          warn$2("upload", "The button clicked type is unknown.");
        }
      }
      function handleDownloadClick(e) {
        e.preventDefault();
        handleDownload(props.file);
      }
      function handleRemove(file) {
        const {
          xhrMap,
          doChange,
          onRemoveRef: {
            value: onRemove
          },
          mergedFileListRef: {
            value: mergedFileList
          }
        } = NUpload;
        void Promise.resolve(onRemove ? onRemove({
          file: Object.assign({}, file),
          fileList: mergedFileList,
          index: props.index
        }) : true).then((result) => {
          if (result === false)
            return;
          const fileAfterChange = Object.assign({}, file, {
            status: "removed"
          });
          xhrMap.delete(file.id);
          doChange(fileAfterChange, void 0, {
            remove: true
          });
        });
      }
      function handleDownload(file) {
        const {
          onDownloadRef: {
            value: onDownload
          }
        } = NUpload;
        void Promise.resolve(onDownload ? onDownload(Object.assign({}, file)) : true).then((res) => {
          if (res !== false) {
            download(file.url, file.name);
          }
        });
      }
      function handleAbort(file) {
        const {
          xhrMap
        } = NUpload;
        const xhr = xhrMap.get(file.id);
        xhr === null || xhr === void 0 ? void 0 : xhr.abort();
        handleRemove(Object.assign({}, file));
      }
      function handlePreviewClick(e) {
        const {
          onPreviewRef: {
            value: onPreview
          }
        } = NUpload;
        if (onPreview) {
          onPreview(props.file, {
            event: e
          });
        } else if (props.listType === "image-card") {
          const {
            value
          } = imageRef;
          if (!value)
            return;
          value.click();
        }
      }
      const deriveFileThumbnailUrl = () => __awaiter$1(this, void 0, void 0, function* () {
        const {
          listType
        } = props;
        if (listType !== "image" && listType !== "image-card") {
          return;
        }
        if (NUpload.shouldUseThumbnailUrlRef.value(props.file)) {
          thumbnailUrlRef.value = yield NUpload.getFileThumbnailUrlResolver(props.file);
        }
      });
      vue.watchEffect(() => {
        void deriveFileThumbnailUrl();
      });
      return {
        mergedTheme: NUpload.mergedThemeRef,
        progressStatus: progressStatusRef,
        buttonType: buttonTypeRef,
        showProgress: showProgressRef,
        disabled: NUpload.mergedDisabledRef,
        showCancelButton: showCancelButtonRef,
        showRemoveButton: showRemoveButtonRef,
        showDownloadButton: showDownloadButtonRef,
        showRetryButton: showRetryButtonRef,
        showPreviewButton: showPreviewButtonRef,
        mergedThumbnailUrl: mergedThumbnailUrlRef,
        shouldUseThumbnailUrl: NUpload.shouldUseThumbnailUrlRef,
        renderIcon: NUpload.renderIconRef,
        imageRef,
        handleRemoveOrCancelClick,
        handleDownloadClick,
        handleRetryClick,
        handlePreviewClick
      };
    },
    render() {
      const {
        clsPrefix,
        mergedTheme,
        listType,
        file,
        renderIcon
      } = this;
      let icon;
      const isImageType = listType === "image";
      const isImageCardType = listType === "image-card";
      if (isImageType || isImageCardType) {
        icon = !this.shouldUseThumbnailUrl(file) || !this.mergedThumbnailUrl ? vue.h("span", {
          class: `${clsPrefix}-upload-file-info__thumbnail`
        }, renderIcon ? renderIcon(file) : isImageFile(file) ? vue.h(NBaseIcon, {
          clsPrefix
        }, {
          default: () => imageIcon
        }) : vue.h(NBaseIcon, {
          clsPrefix
        }, {
          default: () => documentIcon
        })) : vue.h("a", {
          rel: "noopener noreferer",
          target: "_blank",
          href: file.url || void 0,
          class: `${clsPrefix}-upload-file-info__thumbnail`,
          onClick: this.handlePreviewClick
        }, listType === "image-card" ? vue.h(NImage, {
          src: this.mergedThumbnailUrl || void 0,
          previewSrc: file.url || void 0,
          alt: file.name,
          ref: "imageRef"
        }) : vue.h("img", {
          src: this.mergedThumbnailUrl || void 0,
          alt: file.name
        }));
      } else {
        icon = vue.h("span", {
          class: `${clsPrefix}-upload-file-info__thumbnail`
        }, renderIcon ? renderIcon(file) : vue.h(NBaseIcon, {
          clsPrefix
        }, {
          default: () => vue.h(AttachIcon, null)
        }));
      }
      const progress = vue.h(NUploadProgress, {
        show: this.showProgress,
        percentage: file.percentage || 0,
        status: this.progressStatus
      });
      const showName = listType === "text" || listType === "image";
      return vue.h("div", {
        class: [`${clsPrefix}-upload-file`, `${clsPrefix}-upload-file--${this.progressStatus}-status`, file.url && file.status !== "error" && listType !== "image-card" && `${clsPrefix}-upload-file--with-url`, `${clsPrefix}-upload-file--${listType}-type`]
      }, vue.h("div", {
        class: `${clsPrefix}-upload-file-info`
      }, icon, vue.h("div", {
        class: `${clsPrefix}-upload-file-info__name`
      }, showName && (file.url && file.status !== "error" ? vue.h("a", {
        rel: "noopener noreferer",
        target: "_blank",
        href: file.url || void 0,
        onClick: this.handlePreviewClick
      }, file.name) : vue.h("span", {
        onClick: this.handlePreviewClick
      }, file.name)), isImageType && progress), vue.h("div", {
        class: [`${clsPrefix}-upload-file-info__action`, `${clsPrefix}-upload-file-info__action--${listType}-type`]
      }, this.showPreviewButton ? vue.h(NButton, {
        key: "preview",
        quaternary: true,
        type: this.buttonType,
        onClick: this.handlePreviewClick,
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        builtinThemeOverrides: buttonThemeOverrides
      }, {
        icon: () => vue.h(NBaseIcon, {
          clsPrefix
        }, {
          default: () => vue.h(EyeIcon, null)
        })
      }) : null, (this.showRemoveButton || this.showCancelButton) && !this.disabled && vue.h(NButton, {
        key: "cancelOrTrash",
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        quaternary: true,
        builtinThemeOverrides: buttonThemeOverrides,
        type: this.buttonType,
        onClick: this.handleRemoveOrCancelClick
      }, {
        icon: () => vue.h(NIconSwitchTransition, null, {
          default: () => this.showRemoveButton ? vue.h(NBaseIcon, {
            clsPrefix,
            key: "trash"
          }, {
            default: () => vue.h(TrashIcon, null)
          }) : vue.h(NBaseIcon, {
            clsPrefix,
            key: "cancel"
          }, {
            default: () => vue.h(CancelIcon, null)
          })
        })
      }), this.showRetryButton && !this.disabled && vue.h(NButton, {
        key: "retry",
        quaternary: true,
        type: this.buttonType,
        onClick: this.handleRetryClick,
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        builtinThemeOverrides: buttonThemeOverrides
      }, {
        icon: () => vue.h(NBaseIcon, {
          clsPrefix
        }, {
          default: () => vue.h(RetryIcon, null)
        })
      }), this.showDownloadButton ? vue.h(NButton, {
        key: "download",
        quaternary: true,
        type: this.buttonType,
        onClick: this.handleDownloadClick,
        theme: mergedTheme.peers.Button,
        themeOverrides: mergedTheme.peerOverrides.Button,
        builtinThemeOverrides: buttonThemeOverrides
      }, {
        icon: () => vue.h(NBaseIcon, {
          clsPrefix
        }, {
          default: () => vue.h(DownloadIcon, null)
        })
      }) : null)), !isImageType && progress);
    }
  });
  const NUploadFileList = vue.defineComponent({
    name: "UploadFileList",
    setup(_, {
      slots
    }) {
      const NUpload = vue.inject(uploadInjectionKey, null);
      if (!NUpload) {
        throwError("upload-file-list", "`n-upload-file-list` must be placed inside `n-upload`.");
      }
      const {
        abstractRef,
        mergedClsPrefixRef,
        listTypeRef,
        mergedFileListRef,
        fileListClassRef,
        fileListStyleRef,
        cssVarsRef,
        themeClassRef,
        maxReachedRef,
        showTriggerRef,
        imageGroupPropsRef
      } = NUpload;
      const isImageCardTypeRef = vue.computed(() => listTypeRef.value === "image-card");
      const renderFileList = () => mergedFileListRef.value.map((file, index) => vue.h(NUploadFile, {
        clsPrefix: mergedClsPrefixRef.value,
        key: file.id,
        file,
        index,
        listType: listTypeRef.value
      }));
      const renderUploadFileList = () => isImageCardTypeRef.value ? vue.h(NImageGroup, Object.assign({}, imageGroupPropsRef.value), {
        default: renderFileList
      }) : vue.h(NFadeInExpandTransition, {
        group: true
      }, {
        default: renderFileList
      });
      return () => {
        const {
          value: mergedClsPrefix
        } = mergedClsPrefixRef;
        const {
          value: abstract
        } = abstractRef;
        return vue.h("div", {
          class: [`${mergedClsPrefix}-upload-file-list`, isImageCardTypeRef.value && `${mergedClsPrefix}-upload-file-list--grid`, abstract ? themeClassRef === null || themeClassRef === void 0 ? void 0 : themeClassRef.value : void 0, fileListClassRef.value],
          style: [abstract && cssVarsRef ? cssVarsRef.value : "", fileListStyleRef.value]
        }, renderUploadFileList(), showTriggerRef.value && !maxReachedRef.value && isImageCardTypeRef.value && vue.h(NUploadTrigger, null, slots));
      };
    }
  });
  const style$1 = c$1([cB("upload", "width: 100%;", [cM("dragger-inside", [cB("upload-trigger", `
 display: block;
 `)]), cM("drag-over", [cB("upload-dragger", `
 border: var(--n-dragger-border-hover);
 `)])]), cB("upload-dragger", `
 cursor: pointer;
 box-sizing: border-box;
 width: 100%;
 text-align: center;
 border-radius: var(--n-border-radius);
 padding: 24px;
 opacity: 1;
 transition:
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 background-color: var(--n-dragger-color);
 border: var(--n-dragger-border);
 `, [c$1("&:hover", `
 border: var(--n-dragger-border-hover);
 `), cM("disabled", `
 cursor: not-allowed;
 `)]), cB("upload-trigger", `
 display: inline-block;
 box-sizing: border-box;
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 `, [c$1("+", [cB("upload-file-list", "margin-top: 8px;")]), cM("disabled", `
 opacity: var(--n-item-disabled-opacity);
 cursor: not-allowed;
 `), cM("image-card", `
 width: 96px;
 height: 96px;
 `, [cB("base-icon", `
 font-size: 24px;
 `), cB("upload-dragger", `
 padding: 0;
 height: 100%;
 width: 100%;
 display: flex;
 align-items: center;
 justify-content: center;
 `)])]), cB("upload-file-list", `
 line-height: var(--n-line-height);
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 `, [c$1("a, img", "outline: none;"), cM("disabled", `
 opacity: var(--n-item-disabled-opacity);
 cursor: not-allowed;
 `, [cB("upload-file", "cursor: not-allowed;")]), cM("grid", `
 display: grid;
 grid-template-columns: repeat(auto-fill, 96px);
 grid-gap: 8px;
 margin-top: 0;
 `), cB("upload-file", `
 display: block;
 box-sizing: border-box;
 cursor: default;
 padding: 0px 12px 0 6px;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 `, [fadeInHeightExpandTransition(), cB("progress", [fadeInHeightExpandTransition({
    foldPadding: true
  })]), c$1("&:hover", `
 background-color: var(--n-item-color-hover);
 `, [cB("upload-file-info", [cE("action", `
 opacity: 1;
 `)])]), cM("image-type", `
 border-radius: var(--n-border-radius);
 text-decoration: underline;
 text-decoration-color: #0000;
 `, [cB("upload-file-info", `
 padding-top: 0px;
 padding-bottom: 0px;
 width: 100%;
 height: 100%;
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 6px 0;
 `, [cB("progress", `
 padding: 2px 0;
 margin-bottom: 0;
 `), cE("name", `
 padding: 0 8px;
 `), cE("thumbnail", `
 width: 32px;
 height: 32px;
 font-size: 28px;
 display: flex;
 justify-content: center;
 align-items: center;
 `, [c$1("img", `
 width: 100%;
 `)])])]), cM("text-type", [cB("progress", `
 box-sizing: border-box;
 padding-bottom: 6px;
 margin-bottom: 6px;
 `)]), cM("image-card-type", `
 position: relative;
 width: 96px;
 height: 96px;
 border: var(--n-item-border-image-card);
 border-radius: var(--n-border-radius);
 padding: 0;
 display: flex;
 align-items: center;
 justify-content: center;
 transition: border-color .3s var(--n-bezier), background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 overflow: hidden;
 `, [cB("progress", `
 position: absolute;
 left: 8px;
 bottom: 8px;
 right: 8px;
 width: unset;
 `), cB("upload-file-info", `
 padding: 0;
 width: 100%;
 height: 100%;
 `, [cE("thumbnail", `
 width: 100%;
 height: 100%;
 display: flex;
 flex-direction: column;
 align-items: center;
 justify-content: center;
 font-size: 36px;
 `, [c$1("img", `
 width: 100%;
 `)])]), c$1("&::before", `
 position: absolute;
 z-index: 1;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 opacity: 0;
 transition: opacity .2s var(--n-bezier);
 content: "";
 `), c$1("&:hover", [c$1("&::before", "opacity: 1;"), cB("upload-file-info", [cE("thumbnail", "opacity: .12;")])])]), cM("error-status", [c$1("&:hover", `
 background-color: var(--n-item-color-hover-error);
 `), cB("upload-file-info", [cE("name", "color: var(--n-item-text-color-error);"), cE("thumbnail", "color: var(--n-item-text-color-error);")]), cM("image-card-type", `
 border: var(--n-item-border-image-card-error);
 `)]), cM("with-url", `
 cursor: pointer;
 `, [cB("upload-file-info", [cE("name", `
 color: var(--n-item-text-color-success);
 text-decoration-color: var(--n-item-text-color-success);
 `, [c$1("a", `
 text-decoration: underline;
 `)])])]), cB("upload-file-info", `
 position: relative;
 padding-top: 6px;
 padding-bottom: 6px;
 display: flex;
 flex-wrap: nowrap;
 `, [cE("thumbnail", `
 font-size: 18px;
 opacity: 1;
 transition: opacity .2s var(--n-bezier);
 color: var(--n-item-icon-color);
 `, [cB("base-icon", `
 margin-right: 2px;
 vertical-align: middle;
 transition: color .3s var(--n-bezier);
 `)]), cE("action", `
 padding-top: inherit;
 padding-bottom: inherit;
 position: absolute;
 right: 0;
 top: 0;
 bottom: 0;
 width: 80px;
 display: flex;
 align-items: center;
 transition: opacity .2s var(--n-bezier);
 justify-content: flex-end;
 opacity: 0;
 `, [cB("button", [c$1("&:not(:last-child)", {
    marginRight: "4px"
  }), cB("base-icon", [c$1("svg", [iconSwitchTransition()])])]), cM("image-type", `
 position: relative;
 max-width: 80px;
 width: auto;
 `), cM("image-card-type", `
 z-index: 2;
 position: absolute;
 width: 100%;
 height: 100%;
 left: 0;
 right: 0;
 bottom: 0;
 top: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 `)]), cE("name", `
 color: var(--n-item-text-color);
 flex: 1;
 display: flex;
 justify-content: center;
 text-overflow: ellipsis;
 overflow: hidden;
 flex-direction: column;
 text-decoration-color: #0000;
 font-size: var(--n-font-size);
 transition:
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier); 
 `, [c$1("a", `
 color: inherit;
 text-decoration: underline;
 `)])])])]), cB("upload-file-input", `
 display: none;
 width: 0;
 height: 0;
 opacity: 0;
 `)]);
  var __awaiter = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function createXhrHandlers(inst, file, xhr) {
    const {
      doChange,
      xhrMap
    } = inst;
    let percentage = 0;
    function handleXHRError(e) {
      var _a;
      let fileAfterChange = Object.assign({}, file, {
        status: "error",
        percentage
      });
      xhrMap.delete(file.id);
      fileAfterChange = createSettledFileInfo(((_a = inst.onError) === null || _a === void 0 ? void 0 : _a.call(inst, {
        file: fileAfterChange,
        event: e
      })) || fileAfterChange);
      doChange(fileAfterChange, e);
    }
    function handleXHRLoad(e) {
      var _a;
      if (inst.isErrorState) {
        if (inst.isErrorState(xhr)) {
          handleXHRError(e);
          return;
        }
      } else {
        if (xhr.status < 200 || xhr.status >= 300) {
          handleXHRError(e);
          return;
        }
      }
      let fileAfterChange = Object.assign({}, file, {
        status: "finished",
        percentage
      });
      xhrMap.delete(file.id);
      fileAfterChange = createSettledFileInfo(((_a = inst.onFinish) === null || _a === void 0 ? void 0 : _a.call(inst, {
        file: fileAfterChange,
        event: e
      })) || fileAfterChange);
      doChange(fileAfterChange, e);
    }
    return {
      handleXHRLoad,
      handleXHRError,
      handleXHRAbort(e) {
        const fileAfterChange = Object.assign({}, file, {
          status: "removed",
          file: null,
          percentage
        });
        xhrMap.delete(file.id);
        doChange(fileAfterChange, e);
      },
      handleXHRProgress(e) {
        const fileAfterChange = Object.assign({}, file, {
          status: "uploading"
        });
        if (e.lengthComputable) {
          const progress = Math.ceil(e.loaded / e.total * 100);
          fileAfterChange.percentage = progress;
          percentage = progress;
        }
        doChange(fileAfterChange, e);
      }
    };
  }
  function customSubmitImpl(options) {
    const {
      inst,
      file,
      data,
      headers,
      withCredentials,
      action,
      customRequest
    } = options;
    const {
      doChange
    } = options.inst;
    let percentage = 0;
    customRequest({
      file,
      data,
      headers,
      withCredentials,
      action,
      onProgress(event) {
        const fileAfterChange = Object.assign({}, file, {
          status: "uploading"
        });
        const progress = event.percent;
        fileAfterChange.percentage = progress;
        percentage = progress;
        doChange(fileAfterChange);
      },
      onFinish() {
        var _a;
        let fileAfterChange = Object.assign({}, file, {
          status: "finished",
          percentage
        });
        fileAfterChange = createSettledFileInfo(((_a = inst.onFinish) === null || _a === void 0 ? void 0 : _a.call(inst, {
          file: fileAfterChange
        })) || fileAfterChange);
        doChange(fileAfterChange);
      },
      onError() {
        var _a;
        let fileAfterChange = Object.assign({}, file, {
          status: "error",
          percentage
        });
        fileAfterChange = createSettledFileInfo(((_a = inst.onError) === null || _a === void 0 ? void 0 : _a.call(inst, {
          file: fileAfterChange
        })) || fileAfterChange);
        doChange(fileAfterChange);
      }
    });
  }
  function registerHandler(inst, file, request) {
    const handlers = createXhrHandlers(inst, file, request);
    request.onabort = handlers.handleXHRAbort;
    request.onerror = handlers.handleXHRError;
    request.onload = handlers.handleXHRLoad;
    if (request.upload) {
      request.upload.onprogress = handlers.handleXHRProgress;
    }
  }
  function unwrapFunctionValue(data, file) {
    if (typeof data === "function") {
      return data({
        file
      });
    }
    if (data)
      return data;
    return {};
  }
  function setHeaders(request, headers, file) {
    const headersObject = unwrapFunctionValue(headers, file);
    if (!headersObject)
      return;
    Object.keys(headersObject).forEach((key) => {
      request.setRequestHeader(key, headersObject[key]);
    });
  }
  function appendData(formData, data, file) {
    const dataObject = unwrapFunctionValue(data, file);
    if (!dataObject)
      return;
    Object.keys(dataObject).forEach((key) => {
      formData.append(key, dataObject[key]);
    });
  }
  function submitImpl(inst, fieldName, file, {
    method,
    action,
    withCredentials,
    responseType,
    headers,
    data
  }) {
    const request = new XMLHttpRequest();
    request.responseType = responseType;
    inst.xhrMap.set(file.id, request);
    request.withCredentials = withCredentials;
    const formData = new FormData();
    appendData(formData, data, file);
    if (file.file !== null) {
      formData.append(fieldName, file.file);
    }
    registerHandler(inst, file, request);
    if (action !== void 0) {
      request.open(method.toUpperCase(), action);
      setHeaders(request, headers, file);
      request.send(formData);
      const fileAfterChange = Object.assign({}, file, {
        status: "uploading"
      });
      inst.doChange(fileAfterChange);
    }
  }
  const uploadProps = Object.assign(Object.assign({}, useTheme.props), {
    name: {
      type: String,
      default: "file"
    },
    accept: String,
    action: String,
    customRequest: Function,
    directory: Boolean,
    directoryDnd: {
      type: Boolean,
      default: void 0
    },
    method: {
      type: String,
      default: "POST"
    },
    multiple: Boolean,
    showFileList: {
      type: Boolean,
      default: true
    },
    data: [Object, Function],
    headers: [Object, Function],
    withCredentials: Boolean,
    responseType: {
      type: String,
      default: ""
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    onChange: Function,
    onRemove: Function,
    onFinish: Function,
    onError: Function,
    onRetry: Function,
    onBeforeUpload: Function,
    isErrorState: Function,
    /** currently not used */
    onDownload: Function,
    defaultUpload: {
      type: Boolean,
      default: true
    },
    fileList: Array,
    "onUpdate:fileList": [Function, Array],
    onUpdateFileList: [Function, Array],
    fileListClass: String,
    fileListStyle: [String, Object],
    defaultFileList: {
      type: Array,
      default: () => []
    },
    showCancelButton: {
      type: Boolean,
      default: true
    },
    showRemoveButton: {
      type: Boolean,
      default: true
    },
    showDownloadButton: Boolean,
    showRetryButton: {
      type: Boolean,
      default: true
    },
    showPreviewButton: {
      type: Boolean,
      default: true
    },
    listType: {
      type: String,
      default: "text"
    },
    onPreview: Function,
    shouldUseThumbnailUrl: {
      type: Function,
      default: (file) => {
        if (!environmentSupportFile)
          return false;
        return isImageFile(file);
      }
    },
    createThumbnailUrl: Function,
    abstract: Boolean,
    max: Number,
    showTrigger: {
      type: Boolean,
      default: true
    },
    imageGroupProps: Object,
    inputProps: Object,
    triggerClass: String,
    triggerStyle: [String, Object],
    renderIcon: Function
  });
  const Upload = vue.defineComponent({
    name: "Upload",
    props: uploadProps,
    setup(props) {
      if (props.abstract && props.listType === "image-card") {
        throwError("upload", "when the list-type is image-card, abstract is not supported.");
      }
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Upload", "-upload", style$1, uploadLight$1, props, mergedClsPrefixRef);
      const formItem = useFormItem(props);
      const uncontrolledFileListRef = vue.ref(props.defaultFileList);
      const controlledFileListRef = vue.toRef(props, "fileList");
      const inputElRef = vue.ref(null);
      const draggerInsideRef = {
        value: false
      };
      const dragOverRef = vue.ref(false);
      const xhrMap = /* @__PURE__ */ new Map();
      const _mergedFileListRef = useMergedState(controlledFileListRef, uncontrolledFileListRef);
      const mergedFileListRef = vue.computed(() => _mergedFileListRef.value.map(createSettledFileInfo));
      const maxReachedRef = vue.computed(() => {
        const {
          max
        } = props;
        if (max !== void 0) {
          return mergedFileListRef.value.length >= max;
        }
        return false;
      });
      function openOpenFileDialog() {
        var _a;
        (_a = inputElRef.value) === null || _a === void 0 ? void 0 : _a.click();
      }
      function handleFileInputChange(e) {
        const target = e.target;
        handleFileAddition(target.files ? Array.from(target.files).map((file) => ({
          file,
          entry: null,
          source: "input"
        })) : null, e);
        target.value = "";
      }
      function doUpdateFileList(files) {
        const {
          "onUpdate:fileList": _onUpdateFileList,
          onUpdateFileList
        } = props;
        if (_onUpdateFileList)
          call(_onUpdateFileList, files);
        if (onUpdateFileList)
          call(onUpdateFileList, files);
        uncontrolledFileListRef.value = files;
      }
      const mergedMultipleRef = vue.computed(() => props.multiple || props.directory);
      const doChange = (fileAfterChange, event, options = {
        append: false,
        remove: false
      }) => {
        const {
          append,
          remove
        } = options;
        const fileListAfterChange = Array.from(mergedFileListRef.value);
        const fileIndex = fileListAfterChange.findIndex((file) => file.id === fileAfterChange.id);
        if (append || remove || ~fileIndex) {
          if (append) {
            fileListAfterChange.push(fileAfterChange);
          } else if (remove) {
            fileListAfterChange.splice(fileIndex, 1);
          } else {
            fileListAfterChange.splice(fileIndex, 1, fileAfterChange);
          }
          const {
            onChange
          } = props;
          if (onChange) {
            onChange({
              file: fileAfterChange,
              fileList: fileListAfterChange,
              event
            });
          }
          doUpdateFileList(fileListAfterChange);
        } else {
          warn$2("upload", "File has no corresponding id in current file list.");
        }
      };
      function handleFileAddition(fileAndEntries, e) {
        if (!fileAndEntries || fileAndEntries.length === 0)
          return;
        const {
          onBeforeUpload
        } = props;
        fileAndEntries = mergedMultipleRef.value ? fileAndEntries : [fileAndEntries[0]];
        const {
          max,
          accept
        } = props;
        fileAndEntries = fileAndEntries.filter(({
          file,
          source
        }) => {
          if (source === "dnd" && (accept === null || accept === void 0 ? void 0 : accept.trim())) {
            return matchType(file.name, file.type, accept);
          } else {
            return true;
          }
        });
        if (max) {
          fileAndEntries = fileAndEntries.slice(0, max - mergedFileListRef.value.length);
        }
        const batchId = createId();
        void Promise.all(fileAndEntries.map((_a) => __awaiter(this, [_a], void 0, function* ({
          file,
          entry
        }) {
          var _b;
          const fileInfo = {
            id: createId(),
            batchId,
            name: file.name,
            status: "pending",
            percentage: 0,
            file,
            url: null,
            type: file.type,
            thumbnailUrl: null,
            fullPath: (_b = entry === null || entry === void 0 ? void 0 : entry.fullPath) !== null && _b !== void 0 ? _b : `/${file.webkitRelativePath || file.name}`
          };
          if (!onBeforeUpload || (yield onBeforeUpload({
            file: fileInfo,
            fileList: mergedFileListRef.value
          })) !== false) {
            return fileInfo;
          }
          return null;
        }))).then((fileInfos) => __awaiter(this, void 0, void 0, function* () {
          let nextTickChain = Promise.resolve();
          fileInfos.forEach((fileInfo) => {
            nextTickChain = nextTickChain.then(vue.nextTick).then(() => {
              if (fileInfo) {
                doChange(fileInfo, e, {
                  append: true
                });
              }
            });
          });
          yield nextTickChain;
        })).then(() => {
          if (props.defaultUpload) {
            submit();
          }
        });
      }
      function submit(fileId) {
        const {
          method,
          action,
          withCredentials,
          headers,
          data,
          name: fieldName
        } = props;
        const filesToUpload = fileId !== void 0 ? mergedFileListRef.value.filter((file) => file.id === fileId) : mergedFileListRef.value;
        const shouldReupload = fileId !== void 0;
        filesToUpload.forEach((file) => {
          const {
            status
          } = file;
          if (status === "pending" || status === "error" && shouldReupload) {
            if (props.customRequest) {
              customSubmitImpl({
                inst: {
                  doChange,
                  xhrMap,
                  onFinish: props.onFinish,
                  onError: props.onError
                },
                file,
                action,
                withCredentials,
                headers,
                data,
                customRequest: props.customRequest
              });
            } else {
              submitImpl({
                doChange,
                xhrMap,
                onFinish: props.onFinish,
                onError: props.onError,
                isErrorState: props.isErrorState
              }, fieldName, file, {
                method,
                action,
                withCredentials,
                responseType: props.responseType,
                headers,
                data
              });
            }
          }
        });
      }
      function getFileThumbnailUrlResolver(file) {
        var _a;
        if (file.thumbnailUrl)
          return file.thumbnailUrl;
        const {
          createThumbnailUrl
        } = props;
        if (createThumbnailUrl) {
          return (_a = createThumbnailUrl(file.file, file)) !== null && _a !== void 0 ? _a : file.url || "";
        }
        if (file.url) {
          return file.url;
        } else if (file.file) {
          return createImageDataUrl(file.file);
        }
        return "";
      }
      const cssVarsRef = vue.computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            draggerColor,
            draggerBorder,
            draggerBorderHover,
            itemColorHover,
            itemColorHoverError,
            itemTextColorError,
            itemTextColorSuccess,
            itemTextColor,
            itemIconColor,
            itemDisabledOpacity,
            lineHeight: lineHeight2,
            borderRadius,
            fontSize: fontSize2,
            itemBorderImageCardError,
            itemBorderImageCard
          }
        } = themeRef.value;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-border-radius": borderRadius,
          "--n-dragger-border": draggerBorder,
          "--n-dragger-border-hover": draggerBorderHover,
          "--n-dragger-color": draggerColor,
          "--n-font-size": fontSize2,
          "--n-item-color-hover": itemColorHover,
          "--n-item-color-hover-error": itemColorHoverError,
          "--n-item-disabled-opacity": itemDisabledOpacity,
          "--n-item-icon-color": itemIconColor,
          "--n-item-text-color": itemTextColor,
          "--n-item-text-color-error": itemTextColorError,
          "--n-item-text-color-success": itemTextColorSuccess,
          "--n-line-height": lineHeight2,
          "--n-item-border-image-card-error": itemBorderImageCardError,
          "--n-item-border-image-card": itemBorderImageCard
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("upload", void 0, cssVarsRef, props) : void 0;
      vue.provide(uploadInjectionKey, {
        mergedClsPrefixRef,
        mergedThemeRef: themeRef,
        showCancelButtonRef: vue.toRef(props, "showCancelButton"),
        showDownloadButtonRef: vue.toRef(props, "showDownloadButton"),
        showRemoveButtonRef: vue.toRef(props, "showRemoveButton"),
        showRetryButtonRef: vue.toRef(props, "showRetryButton"),
        onRemoveRef: vue.toRef(props, "onRemove"),
        onDownloadRef: vue.toRef(props, "onDownload"),
        mergedFileListRef,
        triggerClassRef: vue.toRef(props, "triggerClass"),
        triggerStyleRef: vue.toRef(props, "triggerStyle"),
        shouldUseThumbnailUrlRef: vue.toRef(props, "shouldUseThumbnailUrl"),
        renderIconRef: vue.toRef(props, "renderIcon"),
        xhrMap,
        submit,
        doChange,
        showPreviewButtonRef: vue.toRef(props, "showPreviewButton"),
        onPreviewRef: vue.toRef(props, "onPreview"),
        getFileThumbnailUrlResolver,
        listTypeRef: vue.toRef(props, "listType"),
        dragOverRef,
        openOpenFileDialog,
        draggerInsideRef,
        handleFileAddition,
        mergedDisabledRef: formItem.mergedDisabledRef,
        maxReachedRef,
        fileListClassRef: vue.toRef(props, "fileListClass"),
        fileListStyleRef: vue.toRef(props, "fileListStyle"),
        abstractRef: vue.toRef(props, "abstract"),
        acceptRef: vue.toRef(props, "accept"),
        cssVarsRef: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClassRef: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
        showTriggerRef: vue.toRef(props, "showTrigger"),
        imageGroupPropsRef: vue.toRef(props, "imageGroupProps"),
        mergedDirectoryDndRef: vue.computed(() => {
          var _a;
          return (_a = props.directoryDnd) !== null && _a !== void 0 ? _a : props.directory;
        }),
        onRetryRef: vue.toRef(props, "onRetry")
      });
      const exposedMethods = {
        clear: () => {
          uncontrolledFileListRef.value = [];
        },
        submit,
        openOpenFileDialog
      };
      return Object.assign({
        mergedClsPrefix: mergedClsPrefixRef,
        draggerInsideRef,
        inputElRef,
        mergedTheme: themeRef,
        dragOver: dragOverRef,
        mergedMultiple: mergedMultipleRef,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
        handleFileInputChange
      }, exposedMethods);
    },
    render() {
      var _a, _b;
      const {
        draggerInsideRef,
        mergedClsPrefix,
        $slots,
        directory,
        onRender
      } = this;
      if ($slots.default && !this.abstract) {
        const firstChild = $slots.default()[0];
        if ((_a = firstChild === null || firstChild === void 0 ? void 0 : firstChild.type) === null || _a === void 0 ? void 0 : _a[uploadDraggerKey]) {
          draggerInsideRef.value = true;
        }
      }
      const inputNode = vue.h("input", Object.assign({}, this.inputProps, {
        ref: "inputElRef",
        type: "file",
        class: `${mergedClsPrefix}-upload-file-input`,
        accept: this.accept,
        multiple: this.mergedMultiple,
        onChange: this.handleFileInputChange,
        // @ts-expect-error // seems vue-tsc will add the prop, so we can't use expect-error
        webkitdirectory: directory || void 0,
        directory: directory || void 0
      }));
      if (this.abstract) {
        return vue.h(vue.Fragment, null, (_b = $slots.default) === null || _b === void 0 ? void 0 : _b.call($slots), vue.h(vue.Teleport, {
          to: "body"
        }, inputNode));
      }
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return vue.h("div", {
        class: [`${mergedClsPrefix}-upload`, draggerInsideRef.value && `${mergedClsPrefix}-upload--dragger-inside`, this.dragOver && `${mergedClsPrefix}-upload--drag-over`, this.themeClass],
        style: this.cssVars
      }, inputNode, this.showTrigger && this.listType !== "image-card" && vue.h(NUploadTrigger, null, $slots), this.showFileList && vue.h(NUploadFileList, null, $slots));
    }
  });
  const virtualListProps = {
    scrollbarProps: Object,
    items: {
      type: Array,
      default: () => []
    },
    itemSize: {
      type: Number,
      required: true
    },
    itemResizable: Boolean,
    itemsStyle: [String, Object],
    visibleItemsTag: {
      type: [String, Object],
      default: "div"
    },
    visibleItemsProps: Object,
    ignoreItemResize: Boolean,
    onScroll: Function,
    onWheel: Function,
    onResize: Function,
    defaultScrollKey: [Number, String],
    defaultScrollIndex: Number,
    keyField: {
      type: String,
      default: "key"
    },
    paddingTop: {
      type: [Number, String],
      default: 0
    },
    paddingBottom: {
      type: [Number, String],
      default: 0
    }
  };
  const VirtualList = vue.defineComponent({
    name: "VirtualList",
    props: virtualListProps,
    setup(props) {
      const scrollbarInstRef = vue.ref(null);
      const virtualListInstRef = vue.ref(null);
      function syncScrollbar() {
        const {
          value: scrollbarInst
        } = scrollbarInstRef;
        if (scrollbarInst)
          scrollbarInst.sync();
      }
      function handleScroll(e) {
        var _a;
        syncScrollbar();
        (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);
      }
      function handleResize(e) {
        var _a;
        syncScrollbar();
        (_a = props.onResize) === null || _a === void 0 ? void 0 : _a.call(props, e);
      }
      function handleWheel(e) {
        var _a;
        (_a = props.onWheel) === null || _a === void 0 ? void 0 : _a.call(props, e);
      }
      function scrollTo(options, y) {
        var _a, _b;
        if (typeof options === "number") {
          (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(options, y !== null && y !== void 0 ? y : 0);
        } else {
          (_b = virtualListInstRef.value) === null || _b === void 0 ? void 0 : _b.scrollTo(options);
        }
      }
      function getScrollContainer() {
        var _a;
        return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.listElRef;
      }
      function getScrollContent() {
        var _a;
        return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.itemsElRef;
      }
      return {
        scrollTo,
        scrollbarInstRef,
        virtualListInstRef,
        getScrollContainer,
        getScrollContent,
        handleScroll,
        handleResize,
        handleWheel
      };
    },
    render() {
      return vue.h(XScrollbar, Object.assign({}, this.scrollbarProps, {
        ref: "scrollbarInstRef",
        container: this.getScrollContainer,
        content: this.getScrollContent
      }), {
        default: () => {
          return vue.h(VVirtualList, {
            ref: "virtualListInstRef",
            showScrollbar: false,
            items: this.items,
            itemSize: this.itemSize,
            itemResizable: this.itemResizable,
            itemsStyle: this.itemsStyle,
            visibleItemsTag: this.visibleItemsTag,
            visibleItemsProps: this.visibleItemsProps,
            ignoreItemResize: this.ignoreItemResize,
            keyField: this.keyField,
            defaultScrollKey: this.defaultScrollKey,
            defaultScrollIndex: this.defaultScrollIndex,
            paddingTop: this.paddingTop,
            paddingBottom: this.paddingBottom,
            onScroll: this.handleScroll,
            onResize: this.handleResize,
            onWheel: this.handleWheel
          }, {
            default: ({
              item,
              index
            }) => {
              var _a, _b;
              return (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a, {
                item,
                index
              });
            }
          });
        }
      });
    }
  });
  const style = c$1([cB("watermark-container", `
 position: relative;
 `, [cNotM("selectable", `
 user-select: none;
 -webkit-user-select: none;
 `), cM("global-rotate", `
 overflow: hidden;
 `), cM("fullscreen", `
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 pointer-events: none;
 position: fixed;
 `)]), cB("watermark", `
 position: absolute;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 pointer-events: none;
 background-repeat: repeat;
 `, [cM("fullscreen", `
 position: fixed;
 `), cM("global-rotate", `
 position: absolute;
 height: max(284vh, 284vw);
 width: max(284vh, 284vw);
 `)])]);
  function getRatio(context) {
    if (!context) {
      return 1;
    }
    const backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
    return (window.devicePixelRatio || 1) / backingStore;
  }
  const watermarkProps = Object.assign(Object.assign({}, useTheme.props), {
    debug: Boolean,
    cross: Boolean,
    fullscreen: Boolean,
    width: {
      type: Number,
      default: 32
    },
    height: {
      type: Number,
      default: 32
    },
    zIndex: {
      type: Number,
      default: 10
    },
    xGap: {
      type: Number,
      default: 0
    },
    yGap: {
      type: Number,
      default: 0
    },
    yOffset: {
      type: Number,
      default: 0
    },
    xOffset: {
      type: Number,
      default: 0
    },
    rotate: {
      type: Number,
      default: 0
    },
    textAlign: {
      type: String,
      default: "left"
    },
    image: String,
    imageOpacity: {
      type: Number,
      default: 1
    },
    imageHeight: Number,
    imageWidth: Number,
    content: String,
    selectable: {
      type: Boolean,
      default: true
    },
    fontSize: {
      type: Number,
      default: 14
    },
    fontFamily: String,
    fontStyle: {
      type: String,
      default: "normal"
    },
    fontVariant: {
      type: String,
      default: ""
    },
    fontWeight: {
      type: Number,
      default: 400
    },
    fontColor: {
      type: String,
      default: "rgba(128, 128, 128, .3)"
    },
    fontStretch: {
      type: String,
      default: ""
    },
    lineHeight: {
      type: Number,
      default: 14
    },
    globalRotate: {
      type: Number,
      default: 0
    }
  });
  const Watermark = vue.defineComponent({
    name: "Watermark",
    props: watermarkProps,
    setup(props, {
      slots
    }) {
      const {
        mergedClsPrefixRef
      } = useConfig(props);
      const themeRef = useTheme("Watermark", "-watermark", style, watermarkLight$1, props, mergedClsPrefixRef);
      const base64UrlRef = vue.ref("");
      const canvas = isBrowser$2 ? document.createElement("canvas") : null;
      const ctx2 = canvas ? canvas.getContext("2d") : null;
      const fontsReadyRef = vue.ref(false);
      onFontsReady(() => fontsReadyRef.value = true);
      vue.watchEffect(() => {
        if (!canvas)
          return;
        void fontsReadyRef.value;
        const ratio = getRatio(ctx2);
        const {
          xGap,
          yGap,
          width,
          height,
          yOffset,
          xOffset,
          rotate,
          image,
          content,
          fontColor,
          fontStyle,
          fontVariant,
          fontStretch,
          fontWeight,
          fontFamily: fontFamily2,
          fontSize: fontSize2,
          lineHeight: lineHeight2,
          debug
        } = props;
        const canvasWidth = (xGap + width) * ratio;
        const canvasHeight = (yGap + height) * ratio;
        const canvasOffsetLeft = xOffset * ratio;
        const canvasOffsetTop = yOffset * ratio;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        if (ctx2) {
          ctx2.translate(0, 0);
          const markWidth = width * ratio;
          const markHeight = height * ratio;
          if (debug) {
            ctx2.strokeStyle = "grey";
            ctx2.strokeRect(0, 0, markWidth, markHeight);
          }
          ctx2.rotate(rotate * (Math.PI / 180));
          if (image) {
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.referrerPolicy = "no-referrer";
            img.src = image;
            img.onload = () => {
              ctx2.globalAlpha = props.imageOpacity;
              const {
                imageWidth,
                imageHeight
              } = props;
              ctx2.drawImage(img, canvasOffsetLeft, canvasOffsetTop, (props.imageWidth || (imageHeight ? img.width * imageHeight / img.height : img.width)) * ratio, (props.imageHeight || (imageWidth ? img.height * imageWidth / img.width : img.height)) * ratio);
              base64UrlRef.value = canvas.toDataURL();
            };
          } else if (content) {
            if (debug) {
              ctx2.strokeStyle = "green";
              ctx2.strokeRect(0, 0, markWidth, markHeight);
            }
            ctx2.font = `${fontStyle} ${fontVariant} ${fontWeight} ${fontStretch} ${fontSize2 * ratio}px/${lineHeight2 * ratio}px ${fontFamily2 || themeRef.value.self.fontFamily}`;
            ctx2.fillStyle = fontColor;
            let maxWidth = 0;
            const {
              textAlign
            } = props;
            content.split("\n").map((line) => {
              const width2 = ctx2.measureText(line).width;
              maxWidth = Math.max(maxWidth, width2);
              return {
                width: width2,
                line
              };
            }).forEach(({
              line,
              width: width2
            }, index) => {
              const alignOffset = textAlign === "left" ? 0 : textAlign === "center" ? (maxWidth - width2) / 2 : maxWidth - width2;
              ctx2.fillText(line, canvasOffsetLeft + alignOffset, canvasOffsetTop + lineHeight2 * ratio * (index + 1));
            });
            base64UrlRef.value = canvas.toDataURL();
          } else if (!content) {
            ctx2.clearRect(0, 0, canvas.width, canvas.height);
            base64UrlRef.value = canvas.toDataURL();
          }
        } else {
          warnOnce("watermark", "Canvas is not supported in the browser.");
        }
      });
      return () => {
        var _a;
        const {
          globalRotate,
          fullscreen,
          zIndex
        } = props;
        const mergedClsPrefix = mergedClsPrefixRef.value;
        const isFullScreenGlobalRotate = globalRotate !== 0 && fullscreen;
        const rotatedImageOffset = "max(142vh, 142vw)";
        const watermarkNode = vue.h("div", {
          class: [`${mergedClsPrefix}-watermark`, globalRotate !== 0 && `${mergedClsPrefix}-watermark--global-rotate`, fullscreen && `${mergedClsPrefix}-watermark--fullscreen`],
          style: {
            transform: globalRotate ? `translateX(-50%) translateY(-50%) rotate(${globalRotate}deg)` : void 0,
            zIndex: isFullScreenGlobalRotate ? void 0 : zIndex,
            backgroundSize: `${props.xGap + props.width}px`,
            backgroundPosition: globalRotate === 0 ? props.cross ? `${props.width / 2}px ${props.height / 2}px, 0 0` : "" : props.cross ? `calc(${rotatedImageOffset} + ${props.width / 2}px) calc(${rotatedImageOffset} + ${props.height / 2}px), ${rotatedImageOffset} ${rotatedImageOffset}` : rotatedImageOffset,
            backgroundImage: props.cross ? `url(${base64UrlRef.value}), url(${base64UrlRef.value})` : `url(${base64UrlRef.value})`
          }
        });
        if (props.fullscreen && !globalRotate)
          return watermarkNode;
        return vue.h("div", {
          class: [`${mergedClsPrefix}-watermark-container`, globalRotate !== 0 && `${mergedClsPrefix}-watermark-container--global-rotate`, fullscreen && `${mergedClsPrefix}-watermark-container--fullscreen`, props.selectable && `${mergedClsPrefix}-watermark-container--selectable`],
          style: {
            zIndex: isFullScreenGlobalRotate ? zIndex : void 0
          }
        }, (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots), watermarkNode);
      };
    }
  });
  const NInjectionExtractor = vue.defineComponent({
    name: "InjectionExtractor",
    props: {
      onSetup: Function
    },
    setup(props, {
      slots
    }) {
      var _a;
      (_a = props.onSetup) === null || _a === void 0 ? void 0 : _a.call(props);
      return () => {
        var _a2;
        return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      };
    }
  });
  const injectionFactoryMap = {
    message: useMessage,
    notification: useNotification,
    loadingBar: useLoadingBar,
    dialog: useDialog,
    modal: useModal
  };
  function createDiscreteApp({
    providersAndProps,
    configProviderProps: configProviderProps2
  }) {
    let app = vue.createApp(App2);
    const extractedApi = {
      app
    };
    function App2() {
      return vue.h(NConfigProvider, vue.unref(configProviderProps2), {
        default: () => providersAndProps.map(({
          type,
          Provider,
          props
        }) => {
          return vue.h(Provider, vue.unref(props), {
            default: () => vue.h(NInjectionExtractor, {
              onSetup: () => extractedApi[type] = injectionFactoryMap[type]()
            })
          });
        })
      });
    }
    let hostEl;
    if (isBrowser$2) {
      hostEl = document.createElement("div");
      document.body.appendChild(hostEl);
      app.mount(hostEl);
    }
    const unmount2 = () => {
      var _a;
      if (app === null || hostEl === null) {
        warn$2("discrete", "unmount call no need because discrete app has been unmounted");
        return;
      }
      app.unmount();
      (_a = hostEl.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(hostEl);
      hostEl = null;
      app = null;
    };
    return Object.assign({
      unmount: unmount2
    }, extractedApi);
  }
  function createDiscreteApi(includes, {
    configProviderProps: configProviderProps2,
    messageProviderProps: messageProviderProps2,
    dialogProviderProps: dialogProviderProps2,
    notificationProviderProps: notificationProviderProps2,
    loadingBarProviderProps: loadingBarProviderProps2,
    modalProviderProps: modalProviderProps2
  } = {}) {
    const providersAndProps = [];
    includes.forEach((type) => {
      switch (type) {
        case "message":
          providersAndProps.push({
            type,
            Provider: NMessageProvider,
            props: messageProviderProps2
          });
          break;
        case "notification":
          providersAndProps.push({
            type,
            Provider: NNotificationProvider,
            props: notificationProviderProps2
          });
          break;
        case "dialog":
          providersAndProps.push({
            type,
            Provider: NDialogProvider,
            props: dialogProviderProps2
          });
          break;
        case "loadingBar":
          providersAndProps.push({
            type,
            Provider: NLoadingBarProvider,
            props: loadingBarProviderProps2
          });
          break;
        case "modal":
          providersAndProps.push({
            type,
            Provider: NModalProvider,
            props: modalProviderProps2
          });
      }
    });
    const discreteApp = createDiscreteApp({
      providersAndProps,
      configProviderProps: configProviderProps2
    });
    return discreteApp;
  }
  const equationProps = {
    value: String,
    katex: Object,
    katexOptions: Object
  };
  const Equation = vue.defineComponent({
    name: "Equation",
    props: equationProps,
    setup(props) {
      const configProviderContext = vue.inject(configProviderInjectionKey);
      const extractedHtmlInfo = vue.computed(() => {
        var _a;
        const outerHtml = ((_a = props.katex || (configProviderContext === null || configProviderContext === void 0 ? void 0 : configProviderContext.mergedKatexRef.value)) === null || _a === void 0 ? void 0 : _a.renderToString(props.value || "", Object.assign({
          throwOnError: false
        }, props.katexOptions))) || "no katex provided";
        const matchResult = outerHtml.match(/^<([a-z]+)[^>]+class="([^"]+)"[^>]*>/);
        const wrapperTag = (matchResult === null || matchResult === void 0 ? void 0 : matchResult[1]) || "span";
        const wrapperClass = matchResult === null || matchResult === void 0 ? void 0 : matchResult[2];
        const innerHtml = outerHtml.replace(/^<[a-z]+[^>]*>/, "").replace(/<\/[a-z]+>$/, "");
        return {
          wrapperTag,
          innerHtml,
          wrapperClass
        };
      });
      return () => {
        const {
          innerHtml,
          wrapperClass,
          wrapperTag
        } = extractedHtmlInfo.value;
        return vue.h(wrapperTag, {
          class: wrapperClass,
          innerHTML: innerHtml
        });
      };
    }
  });
  const components = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    NA: a,
    NAffix,
    NAlert: Alert,
    NAnchor: AnchorAdapter,
    NAnchorLink: Link,
    NAutoComplete: AutoComplete,
    NAvatar,
    NAvatarGroup: AvatarGroup,
    NBackTop: BackTop,
    NBadge: Badge,
    NBlockquote: blockquote,
    NBreadcrumb: Breadcrumb,
    NBreadcrumbItem: BreadcrumbItem,
    NButton,
    NButtonGroup,
    NCalendar: Calendar,
    NCard,
    NCarousel: Carousel,
    NCarouselItem,
    NCascader: Cascader,
    NCheckbox,
    NCheckboxGroup,
    NCode,
    NCol,
    NCollapse,
    NCollapseItem,
    NCollapseTransition: CollapseTransition,
    NColorPicker,
    NConfigProvider,
    NCountdown: Countdown,
    NDataTable: DataTable,
    NDatePicker: DatePicker,
    NDescriptions: Descriptions,
    NDescriptionsItem: DescriptionsItem,
    NDialog,
    NDialogProvider,
    NDivider,
    NDrawer: Drawer,
    NDrawerContent: DrawerContent,
    NDropdown,
    NDynamicInput: DynamicInput,
    NDynamicTags: DynamicTags,
    NEl: NElement,
    NElement,
    NEllipsis,
    NEmpty,
    NEquation: Equation,
    NFlex: Flex,
    NFloatButton: FloatButton,
    NFloatButtonGroup: FloatButtonGroup,
    NForm: Form,
    NFormItem,
    NFormItemCol,
    NFormItemGi: FormItemGridItem,
    NFormItemGridItem: FormItemGridItem,
    NFormItemRow: FormItemRow,
    NGi,
    NGlobalStyle: GlobalStyle,
    NGradientText: GradientText,
    NGrid,
    NGridItem: NGi,
    NH1,
    NH2,
    NH3,
    NH4,
    NH5,
    NH6,
    NHighlight: Highlight,
    NHr: hr,
    NIcon,
    NIconWrapper,
    NImage,
    NImageGroup,
    NInfiniteScroll: InfiniteScroll,
    NInput,
    NInputGroup,
    NInputGroupLabel: InputGroupLabel,
    NInputNumber: InputNumber,
    NLayout: Layout,
    NLayoutContent: LayoutContent,
    NLayoutFooter: LayoutFooter,
    NLayoutHeader: LayoutHeader,
    NLayoutSider: LayoutSider,
    NLegacyTransfer: Transfer$1,
    NLi: li,
    NList: List,
    NListItem: ListItem,
    NLoadingBarProvider,
    NLog: Log,
    NMention: Mention,
    NMenu: Menu,
    NMessageProvider,
    NModal,
    NModalProvider,
    NNotificationProvider,
    NNumberAnimation: NumberAnimation,
    NOl: ol,
    NP: p,
    NPageHeader: PageHeader,
    NPagination,
    NPerformantEllipsis,
    NPopconfirm: Popconfirm,
    NPopover,
    NPopselect,
    NProgress,
    NQrCode: QrCode,
    NRadio,
    NRadioButton: RadioButton,
    NRadioGroup,
    NRate: Rate,
    NResult: Result,
    NRow,
    NScrollbar: Scrollbar$1,
    NSelect,
    NSkeleton: Skeleton,
    NSlider: Slider,
    NSpace,
    NSpin: Spin,
    NSplit: Split,
    NStatistic: Statistic,
    NStep: Step,
    NSteps: Steps,
    NSwitch: Switch,
    NTab: Tab,
    NTabPane: TabPane,
    NTable: Table,
    NTabs: Tabs,
    NTag,
    NTbody: Tbody,
    NTd: Td,
    NText: text,
    NTh: Th,
    NThead: Thead,
    NThing: Thing,
    NTime: Time,
    NTimePicker,
    NTimeline: Timeline,
    NTimelineItem: TimelineItem,
    NTooltip,
    NTr: Tr,
    NTransfer: Transfer,
    NTree,
    NTreeSelect: TreeSelect,
    NUl: ul,
    NUpload: Upload,
    NUploadDragger,
    NUploadFileList,
    NUploadTrigger,
    NVirtualList: VirtualList,
    NWatermark: Watermark,
    NxButton: XButton,
    aProps,
    affixProps,
    alertProps,
    anchorLinkProps,
    anchorProps,
    autoCompleteProps,
    avatarGroupProps,
    avatarProps,
    backTopProps,
    badgeProps,
    blockquoteProps,
    breadcrumbItemProps,
    breadcrumbProps,
    buttonGroupProps,
    buttonProps,
    calendarProps,
    cardProps,
    carouselProps,
    cascaderProps,
    checkboxGroupProps,
    checkboxProps,
    codeProps,
    colProps,
    collapseItemProps,
    collapseProps,
    collapseTransitionProps,
    colorPickerProps,
    configProviderProps,
    countdownProps,
    createDiscreteApi,
    dataTableProps,
    datePickerProps,
    descriptionsItemProps,
    descriptionsProps,
    dialogProps,
    dialogProviderProps,
    dividerProps,
    drawerContentProps,
    drawerProps,
    dropdownProps,
    dynamicInputProps,
    dynamicTagsProps,
    elementProps,
    ellipsisProps,
    emptyProps,
    equationProps,
    flexProps,
    floatButtonGroupProps,
    floatButtonProps,
    formItemGiProps,
    formItemGridItemProps: formItemGiProps,
    formItemProps,
    formProps,
    giProps: gridItemProps,
    gradientTextProps,
    gridItemProps,
    gridProps,
    h1Props: headerProps,
    h2Props: headerProps,
    h3Props: headerProps,
    h4Props: headerProps,
    h5Props: headerProps,
    h6Props: headerProps,
    highlightProps,
    iconProps,
    iconWrapperProps,
    imageGroupProps,
    imageProps,
    infiniteScrollProps,
    inputGroupLabelProps,
    inputGroupProps,
    inputNumberProps,
    inputProps,
    layoutContentProps: layoutProps,
    layoutFooterProps,
    layoutHeaderProps: headerProps$1,
    layoutProps,
    layoutSiderProps,
    legacyTransferProps: transferProps$1,
    listProps,
    loadingBarProviderProps,
    logProps,
    mentionProps,
    menuProps,
    messageProviderProps,
    modalProps,
    modalProviderProps,
    notificationProviderProps,
    numberAnimationProps,
    olProps,
    pProps,
    pageHeaderProps,
    paginationProps,
    popconfirmProps,
    popoverProps,
    popselectProps,
    progressProps,
    qrCodeProps,
    radioButtonProps,
    radioGroupProps,
    radioProps,
    rateProps,
    resultProps,
    rowProps,
    scrollbarProps,
    selectProps,
    skeletonProps,
    sliderProps,
    spaceProps,
    spinProps,
    splitProps,
    statisticProps,
    stepProps,
    stepsProps,
    switchProps,
    tabPaneProps,
    tabProps,
    tableProps,
    tabsProps,
    tagProps,
    textProps,
    thingProps,
    timePickerProps,
    timeProps,
    timelineItemProps,
    timelineProps,
    tooltipProps,
    transferProps,
    treeGetClickTarget,
    treeProps,
    treeSelectProps,
    ulProps,
    uploadProps,
    useDialog,
    useDialogReactiveList,
    useLoadingBar,
    useMessage,
    useModal,
    useModalReactiveList,
    useNotification,
    virtualListProps,
    watermarkProps
  }, Symbol.toStringTag, { value: "Module" }));
  const version = "2.40.1";
  function create({
    componentPrefix = "N",
    components: components2 = []
  } = {}) {
    const installTargets = [];
    function registerComponent(app, name, component) {
      const registered = app.component(componentPrefix + name);
      if (!registered) {
        app.component(componentPrefix + name, component);
      }
    }
    function install(app) {
      if (installTargets.includes(app))
        return;
      installTargets.push(app);
      components2.forEach((component) => {
        const {
          name,
          alias
        } = component;
        registerComponent(app, name, component);
        if (alias) {
          alias.forEach((aliasName) => {
            registerComponent(app, aliasName, component);
          });
        }
      });
    }
    return {
      version,
      componentPrefix,
      install
    };
  }
  const naive = create({
    components: Object.keys(components).map((key) => components[key])
  });
  const naive$1 = naive;
  naive.install;
  function createApp() {
    const app = vue.createVueApp(App);
    app.use(naive$1);
    return {
      app
    };
  }
  const { app: __app__, Vuex: __Vuex__, Pinia: __Pinia__ } = createApp();
  uni.Vuex = __Vuex__;
  uni.Pinia = __Pinia__;
  __app__.provide("__globalStyles", __uniConfig.styles);
  __app__._component.mpType = "app";
  __app__._component.render = () => {
  };
  __app__.mount("#app");
})(Vue);
